{"title":"记SpringBoot拦截器报错getWriter() has already been called for this response","uid":"91927c15e1d4404177918c3eb486f6d5","slug":"BlogRepository/问题记录/记SpringBoot拦截器报错getWriter() has already been called for this response","date":"2022-09-01T02:40:59.000Z","updated":"2023-03-13T19:13:04.973Z","comments":true,"path":"api/articles/BlogRepository/问题记录/记SpringBoot拦截器报错getWriter() has already been called for this response.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-问题\"><a href=\"#1-问题\" class=\"headerlink\" title=\"1. 问题\"></a>1. 问题</h1><p>在拦截器中返回信息时，使用 <code>response.getWriter()</code> 报错 <code>getWriter() has already been called for this response</code>。这里使用的 <code>getWriter()</code>操作的是字符，所以使用 <code>print()</code> 或 <code>write()</code>都可以（<code>print()</code>和 <code>wirte</code>区别见 3）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5783c648cdba4f9ab6a39d8cd5a723c4.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/b9235f0a16004650b50490aa64c94bc1.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/68031d2c12ce43799c051bc06415bb1b.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"2-原因分析\"><a href=\"#2-原因分析\" class=\"headerlink\" title=\"2. 原因分析\"></a>2. 原因分析</h1><p><strong>这里先确定一个前提，上面的拦截器返回的是 true，还会走后面的拦截器或过滤器，假如返回 false 直接结束，则不会有上述问题。</strong> 通过跟踪 <code>getWriter()</code>方法，在类 Response.class 源码中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c2543ce7e2734e7d8fc3ca23a6440c2d.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到在调用 <code>getWriter()</code>方法时，首先会判断 <code>usingOutputStream</code>，如果是 true，就抛出异常，否则设置 <code>usingWriter=true;</code>。所以调用 <code>getWriter()</code>方法后，会导致：<code>usingWriter=true;</code></p>\n<p>同样在类 Response.class 源码中再查看 <code>getOutputStream()</code>的源码</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bb01e80542ce4806adced01bcc304c9a.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看到在调用 <code>getOutputStream()</code>方法时，首先会判断 <code>usingWriter</code>，如果是 true，就抛出异常，否则设置 <code>usingOutputStream=true;</code>。所以调用 <code>getOutputStream()</code>方法后，会导致：<code>usingOutputStream=true;</code></p>\n<p><strong>在这样的设定下，就无法同时使用 <code>getWriter()</code> 和 <code>getOutputStream()</code> 方法，调用其中一个之后必然会使其标记为 true，从而调用另一个方法时会报错</strong></p>\n<p><strong>之所以两者互相排斥，调用一个方法后不能再调用另一方法，因为 <code>getWriter()</code>是字符流，<code>getOutputStream()</code>是字节流，缓存区不可能同时存在两种格式</strong></p>\n<h1 id=\"3-解决\"><a href=\"#3-解决\" class=\"headerlink\" title=\"3. 解决\"></a>3. 解决</h1><p><strong>在所有的 Filter 和 Interceptor 中，要么都使用 <code>getWriter()</code> 方法，要么都使用 <code>getOutputStream()</code> 方法，不能两者都使用</strong></p>\n<p>我这里后面并没有再自定义拦截器或过滤器，推测 SpringBoot 可能默认使用的是 <code>getOutputStream()</code>返回白页等信息，而我并没有 <code>retrun false</code>，同时存在两种格式导致报错。重新修改如下（测试 return false 时下图忘记改成 return true 了，但不影响引出问题）：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e15ebd55054c48e2a4d01639c4232fb4.png\" alt=\"在这里插入图片描述\"></p>\n<p>这里使用的是 <code>print()</code>，会报错 <code>Not an ISO 8859-1 character</code>，因为 Stream 输出的是二进制流，没有对字符进行编码，Stream 只适用于 ISO 8859-1编码的字符。Writer 输出的是文本的信息， 是进行过系统编码后的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20752ec94cdf4801be2e056ca7349ed1.png\" alt=\"在这里插入图片描述\"></p>\n<p>使用 <code>write()</code> ，将数据用字节传输则正常</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0acc7e68cf9c463ebcf90137b44a0b65.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8f96b2ea19284e85a23a403c8923fe9c.png\" alt=\"在这里插入图片描述\"></p>\n","feature":false,"text":"1. 问题在拦截器中返回信息时，使用 response.getWriter() 报错 getWriter() has already been called for this response。这里使用的 getWriter()操作的是字符，所以使用 print() 或 writ...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"问题记录","slug":"问题记录","count":7,"path":"api/categories/问题记录.json"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":4,"path":"api/tags/SpringBoot.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. 问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2. 原因分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">3. 解决</span></a></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"设计模式之美总结（面向对象篇）","uid":"ffaf8c18c9c334b55a0bf75e7c8818f0","slug":"BlogRepository/设计模式/设计模式之美总结（面向对象篇）","date":"2022-10-11T09:02:54.000Z","updated":"2023-03-13T19:13:04.973Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（面向对象篇）.json","keywords":null,"cover":"https://cover.png","text":"1. 代码质量的好坏下面这些几乎涵盖我们所能听到的描述代码质量的所有常用词汇，这些描述方法语义更丰富、更专业、更细化 灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（...","link":"","photos":[],"count_time":{"symbolsCount":"75k","symbolsTime":"1:08"},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"轻量应用服务器使用总结","uid":"6381587c82bf912786d507cd9ab0bca2","slug":"BlogRepository/服务器/轻量应用服务器使用总结","date":"2022-08-14T18:33:49.000Z","updated":"2023-03-13T19:13:04.963Z","comments":true,"path":"api/articles/BlogRepository/服务器/轻量应用服务器使用总结.json","keywords":null,"cover":"https://cover.png","text":"本文使用系统为 CentOS 7.6，服务器为腾讯轻量应用服务器 1. 设置 root 密码初始化实例后，默认 root 是没有密码的，可以登录云服务器自带的 WebShell，通过 sudo passwd root 命令，设置密码 2. 宝塔面板服务器管理软件，支持 Windo...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"服务器","slug":"服务器","count":3,"path":"api/categories/服务器.json"}],"tags":[{"name":"服务器","slug":"服务器","count":4,"path":"api/tags/服务器.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}