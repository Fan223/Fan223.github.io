{"title":"设计模式之美总结（创建型篇）","uid":"b576af472086ff634c008c948f90fb9b","slug":"BlogRepository/设计模式/设计模式之美总结（创建型篇）","date":"2022-11-03T05:58:36.000Z","updated":"2023-03-13T19:13:04.964Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（创建型篇）.json","keywords":null,"cover":"https://cover.png","content":"<p>前三篇见：</p>\n<ul>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/126966428\">设计模式之美总结（面向对象篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127412458\">设计模式之美总结（设计原则篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127573227\">设计模式之美总结（重构篇）_凡 223 的博客</a></strong></li>\n</ul>\n<h1 id=\"1-单例模式（Singleton-Design-Pattern）\"><a href=\"#1-单例模式（Singleton-Design-Pattern）\" class=\"headerlink\" title=\"1. 单例模式（Singleton Design Pattern）\"></a>1. 单例模式（Singleton Design Pattern）</h1><h2 id=\"1-1-为什么要使用单例？\"><a href=\"#1-1-为什么要使用单例？\" class=\"headerlink\" title=\"1.1 为什么要使用单例？\"></a>1.1 为什么要使用单例？</h2><p><strong>单例设计模式（Singleton Design Pattern）</strong> 理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式</p>\n<h3 id=\"1-1-1-处理资源访问冲突\"><a href=\"#1-1-1-处理资源访问冲突\" class=\"headerlink\" title=\"1.1.1 处理资源访问冲突\"></a>1.1.1 处理资源访问冲突</h3><p>如下例，自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Logger &#123;\n    private FileWriter writer;\n    public Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public void log(String message) &#123;\n        writer.write(mesasge);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Logger类的应用示例：\npublic class UserController &#123;\n    private Logger logger &#x3D; new Logger();\n    public void login(String username, String password) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        logger.log(username + &quot; logined!&quot;);\n    &#125;\n&#125;\npublic class OrderController &#123;\n    private Logger logger &#x3D; new Logger();\n    public void create(OrderVo order) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        logger.log(&quot;Created an order: &quot; + order.toString());\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的代码中，可以注意到，所有的日志都写入到同一个文件 <code>/Users/wangzheng/log.txt</code> 中。在 UserController 和 OrderController 中，分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 <code>login()</code> 和 <code>create()</code> 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况</p>\n<p>为什么会出现互相覆盖呢？可以这么类比着理解。在多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了 2，而是只加了 1。同理，这里的 log.txt 文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6aa434e9d6e8431f8e138c9a839af270.png\" alt=\"在这里插入图片描述\"></p>\n<p>那如何来解决这个问题呢？最先想到的就是通过加锁的方式：给 <code>log()</code> 函数加互斥锁（Java 中可以通过 synchronized 的关键字），同一时刻只允许一个线程调用执行 <code>log()</code> 函数。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Logger &#123;\n    private FileWriter writer;\n    public Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public void log(String message) &#123;\n        synchronized(this) &#123;\n            writer.write(mesasge);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>不过，这真的能解决多线程写入日志时互相覆盖的问题吗？答案是否定的。这是因为，这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 <code>log()</code> 函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行 <code>log()</code> 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0e4394810338492aa2dce30506a498e3.png\" alt=\"在这里插入图片描述\"></p>\n<p>还有，给 <code>log()</code> 函数加不加对象级别的锁，其实都没有关系。因为 FileWriter 本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用 <code>write()</code> 函数的时候，再加对象级别的锁实际上是多此一举。因为不同的 Logger 对象不共享 FileWriter 对象，所以，FileWriter 对象级别的锁也解决不了数据写入互相覆盖的问题</p>\n<p>那该怎么解决这个问题呢？实际上，要想解决这个问题也不难，只需要把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 <code>log()</code> 函数，而导致的日志覆盖问题。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Logger &#123;\n    private FileWriter writer;\n    public Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public void log(String message) &#123;\n        synchronized(Logger.class) &#123; &#x2F;&#x2F; 类级别的锁\n            writer.write(mesasge);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂</p>\n<p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）</p>\n<p>将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题</p>\n<p>按照这个设计思路，实现了 Logger 单例类。具体代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Logger &#123;\n    private FileWriter writer;\n    private static final Logger instance &#x3D; new Logger();\n    private Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public static Logger getInstance() &#123;\n        return instance;\n    &#125;\n    public void log(String message) &#123;\n        writer.write(mesasge);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Logger类的应用示例：\npublic class UserController &#123;\n    public void login(String username, String password) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        Logger.getInstance().log(username + &quot; logined!&quot;);\n    &#125;\n&#125;\npublic class OrderController &#123;\n    private Logger logger &#x3D; new Logger();\n    public void create(OrderVo order) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"1-1-2-表示全局唯一类\"><a href=\"#1-1-2-表示全局唯一类\" class=\"headerlink\" title=\"1.1.2 表示全局唯一类\"></a>1.1.2 表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类，比如，配置信息类。在系统中，只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份</p>\n<p>再比如，唯一递增 ID 号码生成器，如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，应该将 ID 生成器类设计为单例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.concurrent.atomic.AtomicLong;\npublic class IdGenerator &#123;\n    &#x2F;&#x2F; AtomicLong是一个Java并发库中提供的一个原子变量类型,\n    &#x2F;&#x2F; 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n    &#x2F;&#x2F; 比如下面会用到的incrementAndGet().\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; IdGenerator使用举例\nlong id &#x3D; IdGenerator.getInstance().getId();</code></pre>\n\n<h2 id=\"1-2-如何实现一个单例？\"><a href=\"#1-2-如何实现一个单例？\" class=\"headerlink\" title=\"1.2 如何实现一个单例？\"></a>1.2 如何实现一个单例？</h2><p>要实现一个单例，需要关注的点无外乎下面几个：</p>\n<ul>\n<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例</li>\n<li>考虑对象创建时的线程安全问题</li>\n<li>考虑是否支持延迟加载</li>\n<li>考虑 <code>getInstance()</code> 性能是否高（是否加锁）</li>\n</ul>\n<h3 id=\"1-1-1-饿汉式\"><a href=\"#1-1-1-饿汉式\" class=\"headerlink\" title=\"1.1.1 饿汉式\"></a>1.1.1 饿汉式</h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中也可以看出这一点。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点</p>\n<p>如果初始化耗时长，那最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题</p>\n<p>如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java 中的 PermGen Space OOM），可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性</p>\n<h3 id=\"1-1-2-懒汉式\"><a href=\"#1-1-2-懒汉式\" class=\"headerlink\" title=\"1.1.2 懒汉式\"></a>1.1.2 懒汉式</h3><p>懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static synchronized IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new IdGenerator();\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>不过懒汉式的缺点也很明显，给 <code>getInstance()</code> 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了</p>\n<h3 id=\"1-1-3-双重检测\"><a href=\"#1-1-3-双重检测\" class=\"headerlink\" title=\"1.1.3 双重检测\"></a>1.1.3 双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式</p>\n<p>在这种实现方式中，只要 instance 被创建之后，即便再调用 <code>getInstance()</code> 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new IdGenerator();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了</p>\n<p>要解决这个问题，需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）</p>\n<h3 id=\"1-1-4-静态内部类\"><a href=\"#1-1-4-静态内部类\" class=\"headerlink\" title=\"1.1.4 静态内部类\"></a>1.1.4 静态内部类</h3><p>再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载，代码实现如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private IdGenerator() &#123;&#125;\n    private static class SingletonHolder&#123;\n        private static final IdGenerator instance &#x3D; new IdGenerator();\n    &#125;\n    public static IdGenerator getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 <code>getInstance()</code> 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载</p>\n<h3 id=\"1-1-5-枚举\"><a href=\"#1-1-5-枚举\" class=\"headerlink\" title=\"1.1.5 枚举\"></a>1.1.5 枚举</h3><p>这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如<br>下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum IdGenerator &#123;\n    INSTANCE;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"1-3-单例存在哪些问题\"><a href=\"#1-3-单例存在哪些问题\" class=\"headerlink\" title=\"1.3 单例存在哪些问题?\"></a>1.3 单例存在哪些问题?</h2><p>尽管单例是一个很常用的设计模式，在实际的开发中，也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用</p>\n<p>大部分情况下，在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，不需要创建对象，直接通过类似 <code>IdGenerator.getInstance().getId()</code> 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题</p>\n<h3 id=\"1-3-1-单例对-OOP-特性的支持不友好\"><a href=\"#1-3-1-单例对-OOP-特性的支持不友好\" class=\"headerlink\" title=\"1.3.1 单例对 OOP 特性的支持不友好\"></a>1.3.1 单例对 OOP 特性的支持不友好</h3><p>OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好，如下例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Order &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F;...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\npublic class User &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F; ...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;</code></pre>\n\n<p>IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Order &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F;...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F; 需要将上面一行代码，替换为下面一行代码\n        long id &#x3D; OrderIdGenerator.getIntance().getId();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\npublic class User &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F; ...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F; 需要将上面一行代码，替换为下面一行代码\n        long id &#x3D; UserIdGenerator.getIntance().getId();\n    &#125;\n&#125;</code></pre>\n\n<p>除此之外，单例对继承、多态特性的支持也不友好。这里之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性</p>\n<h3 id=\"1-3-2-单例会隐藏类之间的依赖关系\"><a href=\"#1-3-2-单例会隐藏类之间的依赖关系\" class=\"headerlink\" title=\"1.3.2 单例会隐藏类之间的依赖关系\"></a>1.3.2 单例会隐藏类之间的依赖关系</h3><p>代码的可读性非常重要。在阅读代码的时候，希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类</p>\n<h3 id=\"1-3-3-单例对代码的扩展性不友好\"><a href=\"#1-3-3-单例对代码的扩展性不友好\" class=\"headerlink\" title=\"1.3.3 单例对代码的扩展性不友好\"></a>1.3.3 单例对代码的扩展性不友好</h3><p>单例类只能有一个对象实例。如果未来某一天，需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。这时可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？</p>\n<p>在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，把数据库连接池类设计成了单例类。但之后发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行</p>\n<p>如果将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类</p>\n<h3 id=\"1-3-4-单例对代码的可测试性不友好\"><a href=\"#1-3-4-单例对代码的可测试性不友好\" class=\"headerlink\" title=\"1.3.4 单例对代码的可测试性不友好\"></a>1.3.4 单例对代码的可测试性不友好</h3><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换</p>\n<p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题</p>\n<h3 id=\"1-3-5-单例不支持有参数的构造函数\"><a href=\"#1-3-5-单例不支持有参数的构造函数\" class=\"headerlink\" title=\"1.3.5 单例不支持有参数的构造函数\"></a>1.3.5 单例不支持有参数的构造函数</h3><p>单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。针对这个问题，可以来看下都有哪些解决方案：</p>\n<p><strong>1、创建完实例之后，再调用 <code>init()</code> 函数传递参数。需要注意的是，在使用这个单例类的时候，要先调用 <code>init()</code> 方法，然后才能调用 <code>getInstance()</code> 方法，否则代码会抛出异常</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n    public static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            throw new RuntimeException(&quot;Run init() first.&quot;);\n        &#125;\n        return instance;\n    &#125;\n    public synchronized static Singleton init(int paramA, int paramB) &#123;\n        if (instance !&#x3D; null)&#123;\n            throw new RuntimeException(&quot;Singleton has been created!&quot;);\n        &#125;\n        instance &#x3D; new Singleton(paramA, paramB);\n        return instance;\n    &#125;\n&#125;\n\nSingleton.init(10, 50); &#x2F;&#x2F; 先init，再使用\nSingleton singleton &#x3D; Singleton.getInstance();</code></pre>\n\n<p><strong>2、将参数放到 <code>getIntance()</code> 方法中</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n    public synchronized static Singleton getInstance(int paramA, int paramB) &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton(paramA, paramB);\n        &#125;\n        return instance;\n    &#125;\n&#125;\nSingleton singleton &#x3D; Singleton.getInstance(10, 50);</code></pre>\n\n<p>但上面的代码实现稍微有点问题。如果如下两次执行 <code>getInstance()</code> 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Singleton singleton1 &#x3D; Singleton.getInstance(10, 50);\nSingleton singleton2 &#x3D; Singleton.getInstance(20, 30);</code></pre>\n\n<p><strong>3、将参数放到另外一个全局变量中</strong></p>\n<p>具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Config &#123;\n    public static final int PARAM_A &#x3D; 123;\n    public static fianl int PARAM_B &#x3D; 245;\n&#125;\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n    private Singleton() &#123;\n        this.paramA &#x3D; Config.PARAM_A;\n        this.paramB &#x3D; Config.PARAM_B;\n    &#125;\n    public synchronized static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"1-4-有何替代解决方案？\"><a href=\"#1-4-有何替代解决方案？\" class=\"headerlink\" title=\"1.4 有何替代解决方案？\"></a>1.4 有何替代解决方案？</h2><p>如果不用单例，怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如，上面讲到的 ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 静态方法实现方式\npublic class IdGenerator &#123;\n    private static AtomicLong id &#x3D; new AtomicLong(0);\n    public static long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用举例\nlong id &#x3D; IdGenerator.getId();</code></pre>\n\n<p>不过，静态方法这种实现思路，并不能解决之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。再来看看有没有其他办法。实际上，单例除了之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 1. 老的使用方式\npublic demofunction() &#123;\n    &#x2F;&#x2F;...\n    long id &#x3D; IdGenerator.getInstance().getId();\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) &#123;\n    long id &#x3D; idGenerator.getId();\n&#125;\n&#x2F;&#x2F; 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator &#x3D; IdGenerator.getInsance();\ndemofunction(idGenerator);</code></pre>\n\n<p>基于新的使用方式，将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决</p>\n<p>所以，如果要完全解决这些问题，可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的</p>\n<h2 id=\"1-5-如何理解单例模式中的唯一性？\"><a href=\"#1-5-如何理解单例模式中的唯一性？\" class=\"headerlink\" title=\"1.5 如何理解单例模式中的唯一性？\"></a>1.5 如何理解单例模式中的唯一性？</h2><p>首先看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。”</p>\n<p>定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的</p>\n<p>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，完全可以简单地理解为就是代码本身</p>\n<p>当使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 <code>User user = new User();</code> 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象</p>\n<p>进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 <code>fork()</code> 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的</p>\n<h2 id=\"1-6-如何实现线程唯一的单例？\"><a href=\"#1-6-如何实现线程唯一的单例？\" class=\"headerlink\" title=\"1.6 如何实现线程唯一的单例？\"></a>1.6 如何实现线程唯一的单例？</h2><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一</p>\n<p>线程唯一单例的代码实现很简单，如下所示。在代码中，通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n\tprivate AtomicLong id &#x3D; new AtomicLong(0);\n\tprivate static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances\n\t    &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate IdGenerator() &#123;&#125;\n\tpublic static IdGenerator getInstance() &#123;\n\t\tLong currentThreadId &#x3D; Thread.currentThread().getId();\n\t\tinstances.putIfAbsent(currentThreadId, new IdGenerator());\n\t\treturn instances.get(currentThreadId);\n\t&#125;\n\tpublic long getId() &#123;\n\t\treturn id.incrementAndGet();\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"1-7-如何实现集群环境下的单例？\"><a href=\"#1-7-如何实现集群环境下的单例？\" class=\"headerlink\" title=\"1.7 如何实现集群环境下的单例？\"></a>1.7 如何实现集群环境下的单例？</h2><p>“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象</p>\n<p>如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。具体来说，需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。实现如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n\tprivate AtomicLong id &#x3D; new AtomicLong(0);\n\tprivate static IdGenerator instance;\n\tprivate static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;** 省略入参 **&#x2F;);\n\tprivate static DistributedLock lock &#x3D; new DistributedLock();\n\tprivate IdGenerator() &#123;&#125;\n\tpublic synchronized static IdGenerator getInstance() &#123;\n\t\tif (instance &#x3D;&#x3D; null) &#123;\n\t\t\tlock.lock();\n\t\t\tinstance &#x3D; storage.load(IdGenerator.class);\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n\tpublic synchroinzed void freeInstance() &#123;\n\t\tstorage.save(this, IdGeneator.class);\n\t\tinstance &#x3D; null; &#x2F;&#x2F;释放对象\n\t\tlock.unlock();\n\t&#125;\n\tpublic long getId() &#123;\n\t\treturn id.incrementAndGet();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; IdGenerator使用举例\nIdGenerator idGeneator &#x3D; IdGenerator.getInstance();\nlong id &#x3D; idGenerator.getId();\nIdGenerator.freeInstance();</code></pre>\n\n<h2 id=\"1-7-如何实现一个多例模式？\"><a href=\"#1-7-如何实现一个多例模式？\" class=\"headerlink\" title=\"1.7 如何实现一个多例模式？\"></a>1.7 如何实现一个多例模式？</h2><p>“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BackendServer &#123;\n\tprivate long serverNo;\n\tprivate String serverAddress;\n\tprivate static final int SERVER_COUNT &#x3D; 3;\n\tprivate static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\n\n\tstatic &#123;\n\t\tserverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n\t\tserverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n\t\tserverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n\t&#125;\n\tprivate BackendServer(long serverNo, String serverAddress) &#123;\n\t\tthis.serverNo &#x3D; serverNo;\n\t\tthis.serverAddress &#x3D; serverAddress;\n\t&#125;\n\tpublic BackendServer getInstance(long serverNo) &#123;\n\t\treturn serverInstances.get(serverNo);\n\t&#125;\n\tpublic BackendServer getRandomInstance() &#123;\n\t\tRandom r &#x3D; new Random();\n\t\tint no &#x3D; r.nextInt(SERVER_COUNT)+1;\n\t\treturn serverInstances.get(no);\n\t&#125;\n&#125;</code></pre>\n\n<p>实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？</p>\n<p>如下例，在代码中，loggerName 就是刚刚说的“类型”，同一个 loggerName 获取到的对象实例是相同的，不同的 loggerName 获取到的对象实例是不同的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Logger &#123;\n\tprivate static final ConcurrentHashMap&lt;String, Logger&gt; instances\n\t    &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate Logger() &#123;&#125;\n\tpublic static Logger getInstance(String loggerName) &#123;\n\t\tinstances.putIfAbsent(loggerName, new Logger());\n\t\treturn instances.get(loggerName);\n\t&#125;\n\tpublic void log() &#123;\n            &#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</code></pre>\n\n<p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，实际上，它还有点类似享元模式。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象</p>\n<h1 id=\"2-工厂模式（Factory-Design-Pattern）\"><a href=\"#2-工厂模式（Factory-Design-Pattern）\" class=\"headerlink\" title=\"2. 工厂模式（Factory Design Pattern）\"></a>2. 工厂模式（Factory Design Pattern）</h1><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，这里沿用第一种分类方法</p>\n<p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。因此，重点是前两种工厂模式，搞清楚应用场景</p>\n<ul>\n<li>什么时候该用工厂模式？</li>\n<li>相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？</li>\n</ul>\n<h2 id=\"2-1-简单工厂（Simple-Factory）\"><a href=\"#2-1-简单工厂（Simple-Factory）\" class=\"headerlink\" title=\"2.1 简单工厂（Simple Factory）\"></a>2.1 简单工厂（Simple Factory）</h2><p>在下面这段代码中，根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125; else &#123;\n\t\t\tthrow new InvalidRuleConfigException(\n\t\t\t    &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath)\n\t\t&#125;\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;</code></pre>\n\n<p>为了让代码逻辑更加清晰，可读性更好，要善于将功能独立的代码块封装成函数。按照这个设计思路，可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 <code>createParser()</code> 函数。重构之后的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParser parser &#x3D; createParser(ruleConfigFileExtension);\n\t\tif (parser &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(\n\t\t\t    &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath\n\t\t&#125;\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n\tprivate IRuleConfigParser createParser(String configFormat) &#123;\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125;\n\t\treturn parser;\n\t&#125;\n&#125;</code></pre>\n\n<p>为了让类的职责更加单一、代码更加清晰，还可以进一步将 <code>createParser()</code> 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是简单工厂模式类。具体的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParser parser &#x3D; RuleConfigParserFactory.createParser(ruleConfig);\n\t\tif (parser &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(\n\t\t\t    &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n\t\t&#125;\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\npublic class RuleConfigParserFactory &#123;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125;\n\t\treturn parser;\n\t&#125;\n&#125;</code></pre>\n\n<p>大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如 Java 中的 DateFormat、Calender。除此之外，工厂类中创建对象的方法一般都是 create 开头，比如代码中的 <code>createParser()</code>，但有的也命名为 <code>getInstance()</code>、<code>createInstance()</code>、<code>newInstance()</code>，有的甚至命名为 <code>valueOf()</code>（比如 Java String 类的 <code>valueOf()</code> 函数）等等，这个根据具体的场景和习惯来命名就好</p>\n<p>在上面的代码实现中，每次调用 RuleConfigParserFactory 的 <code>createParser()</code> 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，可以将 parser 事先创建好缓存起来。当调用 <code>createParser()</code> 函数的时候，我们从缓存中取出 parser 对象直接使用</p>\n<p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。这里把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigParserFactory &#123;\n\tprivate static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n\t\tcachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n\t\tcachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n\t\tcachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n\t&#125;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tif (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;\n\t\t\treturn null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());\n\t\treturn parser;\n\t&#125;\n&#125;</code></pre>\n\n<p>对于上面两种简单工厂模式的实现方法，如果要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的</p>\n<p>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性</p>\n<h2 id=\"2-2-工厂方法（Factory-Method）\"><a href=\"#2-2-工厂方法（Factory-Method）\" class=\"headerlink\" title=\"2.2 工厂方法（Factory Method）\"></a>2.2 工厂方法（Factory Method）</h2><p>如果非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IRuleConfigParserFactory &#123;\n\tIRuleConfigParser createParser();\n&#125;\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n&#125;\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n&#125;\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new YamlRuleConfigParser();\n\t&#125;\n&#125;\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new PropertiesRuleConfigParser();\n\t&#125;\n&#125;</code></pre>\n\n<p>实际上，这就是工厂方法模式的典型代码实现。这样当新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则</strong></p>\n<p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来看一下，如何用这些工厂类来实现 RuleConfigSource 的 <code>load()</code> 函数。具体的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new JsonRuleConfigParserFactory();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new XmlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new YamlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new PropertiesRuleConfigParserFactory();\n\t\t&#125; else &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file format is not support&quot;);\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; parserFactory.createParser();\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;</code></pre>\n\n<p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 <code>load()</code> 函数中，跟最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</p>\n<p>可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。代码实现如下，其中，<br>RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，<code>getParserFactory()</code> 返回的是缓存好的单例工厂对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n\t\tif (parserFactory &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file format is not support&quot;);\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; parserFactory.createParser();\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，\n&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n\tprivate static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory())\n\t&#125;\n\tpublic static IRuleConfigParserFactory getParserFactory(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\tIRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n\t\treturn parserFactory;\n\t&#125;\n&#125;</code></pre>\n\n<p>当需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则</p>\n<p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适</p>\n<h2 id=\"2-3-什么时候该用工厂方法模式，而非简单工厂模式呢？\"><a href=\"#2-3-什么时候该用工厂方法模式，而非简单工厂模式呢？\" class=\"headerlink\" title=\"2.3 什么时候该用工厂方法模式，而非简单工厂模式呢？\"></a>2.3 什么时候该用工厂方法模式，而非简单工厂模式呢？</h2><p>前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，完全没必要将它拆分成单独的函数或者类</p>\n<p>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂</p>\n<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果还想避免烦人的 if-else 分支逻辑，这个时候，就推荐使用工厂方法模式</p>\n<ul>\n<li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明</li>\n<li>代码复用：创建代码抽离到独立的工厂类之后可以复用</li>\n<li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象</li>\n<li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁</li>\n</ul>\n<h2 id=\"2-4-抽象工厂（Abstract-Factory）\"><a href=\"#2-4-抽象工厂（Abstract-Factory）\" class=\"headerlink\" title=\"2.4 抽象工厂（Abstract Factory）\"></a>2.4 抽象工厂（Abstract Factory）</h2><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser</code></pre>\n\n<p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。过多的类也会让系统难维护。这个问题该怎么解决呢？</p>\n<p>抽象工厂就是针对这种非常特殊的场景而诞生的。可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IConfigParserFactory &#123;\n\tIRuleConfigParser createRuleParser();\n\tISystemConfigParser createSystemParser();\n        &#x2F;&#x2F; 此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new JsonSystemConfigParser();\n\t&#125;\n&#125;\npublic class XmlConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new XmlSystemConfigParser();\n\t&#125;\n&#125;\n&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</code></pre>\n\n<h2 id=\"2-5-如何设计实现一个-Dependency-Injection-框架？\"><a href=\"#2-5-如何设计实现一个-Dependency-Injection-框架？\" class=\"headerlink\" title=\"2.5 如何设计实现一个 Dependency Injection 框架？\"></a>2.5 如何设计实现一个 Dependency Injection 框架？</h2><h3 id=\"2-5-1-工厂模式和-DI-容器有何区别？\"><a href=\"#2-5-1-工厂模式和-DI-容器有何区别？\" class=\"headerlink\" title=\"2.5.1 工厂模式和 DI 容器有何区别？\"></a>2.5.1 工厂模式和 DI 容器有何区别？</h3><p>实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”</p>\n<p>DI 容器相对于工厂模式来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建</p>\n<p>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理</p>\n<h3 id=\"2-5-2-DI-容器的核心功能有哪些？\"><a href=\"#2-5-2-DI-容器的核心功能有哪些？\" class=\"headerlink\" title=\"2.5.2 DI 容器的核心功能有哪些？\"></a>2.5.2 DI 容器的核心功能有哪些？</h3><p>总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理</p>\n<p><strong>1、配置解析</strong></p>\n<p>在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是配置</p>\n<p>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象</p>\n<p>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RateLimiter &#123;\n\tprivate RedisCounter redisCounter;\n\tpublic RateLimiter(RedisCounter redisCounter) &#123;\n\t\tthis.redisCounter &#x3D; redisCounter;\n\t&#125;\n\tpublic void test() &#123;\n\t\tSystem.out.println(&quot;Hello World!&quot;);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\npublic class RedisCounter &#123;\n\tprivate String ipAddress;\n\tprivate int port;\n\tpublic RedisCounter(String ipAddress, int port) &#123;\n\t\tthis.ipAddress &#x3D; ipAddress;\n\t\tthis.port &#x3D; port;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">配置文件beans.xml：\n&lt;beans&gt;\n\t&lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n\t\t&lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n\t&lt;&#x2F;bean&gt;\n\t&lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n\t&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p><strong>2、对象创建</strong></p>\n<p>在 DI 容器中，如果给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难，只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。运用“反射”这种机制，在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的</p>\n<p><strong>3、对象的生命周期管理</strong></p>\n<p>简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象</p>\n<p>除此之外，还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：<code>BeansFactory.getBean(“userService”)）</code> 才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好</p>\n<p>不仅如此，还可以配置对象的 init-method 和 destroy-method 方法，比如 <code>init-method=loadProperties()</code>，<code>destroy-method=updateConfigFile()</code>。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件</p>\n<h3 id=\"2-5-3-最小原型设计\"><a href=\"#2-5-3-最小原型设计\" class=\"headerlink\" title=\"2.5.3 最小原型设计\"></a>2.5.3 最小原型设计</h3><p>实际上，用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象</p>\n<p>这里只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，只支持下面配置文件中涉及的配置语法</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">配置文件beans.xml：\n&lt;beans&gt;\n\t&lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n\t\t&lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n\t&lt;&#x2F;bean&gt;\n\t&lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n\t&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext\n\t\t&quot;beans.xml&quot;);\n\t\tRateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;RateLimiter&quot;);\n\t\trateLimiter.test();\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"2-5-4-提供执行入口\"><a href=\"#2-5-4-提供执行入口\" class=\"headerlink\" title=\"2.5.4 提供执行入口\"></a>2.5.4 提供执行入口</h3><p>面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类</p>\n<p>通过刚刚的最小原型使用示例代码可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ApplicationContext &#123;\n\tObject getBean(String beanId);\n&#125;\npublic class ClassPathXmlApplicationContext implements ApplicationContext &#123;\n\tprivate BeansFactory beansFactory;\n\tprivate BeanConfigParser beanConfigParser;\n\tpublic ClassPathXmlApplicationContext(String configLocation) &#123;\n\t\tthis.beansFactory &#x3D; new BeansFactory();\n\t\tthis.beanConfigParser &#x3D; new XmlBeanConfigParser();\n\t\tloadBeanDefinitions(configLocation);\n\t&#125;\n\tprivate void loadBeanDefinitions(String configLocation) &#123;\n\t\tInputStream in &#x3D; null;\n\t\ttry &#123;\n\t\t\tin &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);\n\t\t\tif (in &#x3D;&#x3D; null) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Can not find config file: &quot; + configLocatio\n\t\t\t&#125;\n\t\t\tList&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);\n\t\t\tbeansFactory.addBeanDefinitions(beanDefinitions);\n\t\t&#125; finally &#123;\n\t\t\tif (in !&#x3D; null) &#123;\n\t\t\t\ttry &#123;\n\t\t\t\t\tin.close();\n\t\t\t\t&#125; catch (IOException e) &#123;\n\t\t\t\t\t&#x2F;&#x2F; TODO: log error\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t@Override\n\tpublic Object getBean(String beanId) &#123;\n\t\treturn beansFactory.getBean(beanId);\n\t&#125;\n&#125;</code></pre>\n\n<p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象</p>\n<h3 id=\"2-5-5-配置文件解析\"><a href=\"#2-5-5-配置文件解析\" class=\"headerlink\" title=\"2.5.5 配置文件解析\"></a>2.5.5 配置文件解析</h3><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象</p>\n<p>配置文件的解析比较繁琐，这里只给出两个类的大致设计思路，并未给出具体的实现代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface BeanConfigParser &#123;\n\tList&lt;BeanDefinition&gt; parse(InputStream inputStream);\n\tList&lt;BeanDefinition&gt; parse(String configContent);\n&#125;\npublic class XmlBeanConfigParser implements BeanConfigParser &#123;\n\t@Override\n\tpublic List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;\n\t\tString content &#x3D; null;\n\t\t&#x2F;&#x2F; TODO:...\n\t\treturn parse(content);\n\t&#125;\n\t@Override\n\tpublic List&lt;BeanDefinition&gt; parse(String configContent) &#123;\n\t\tList&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F; TODO:...\n\t\treturn beanDefinitions;\n\t&#125;\n&#125;\npublic class BeanDefinition &#123;\n\tprivate String id;\n\tprivate String className;\n\tprivate List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();\n\tprivate Scope scope &#x3D; Scope.SINGLETON;\n\tprivate boolean lazyInit &#x3D; false;\n\t&#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n\tpublic boolean isSingleton() &#123;\n\t\treturn scope.equals(Scope.SINGLETON);\n\t&#125;\n\tpublic static enum Scope &#123;\n\t\tSINGLETON,\n\t\tPROTOTYPE\n\t&#125;\n\tpublic static class ConstructorArg &#123;\n\t\tprivate boolean isRef;\n\t\tprivate Class type;\n\t\tprivate Object arg;\n\t\t&#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"2-5-6-核心工厂类设计\"><a href=\"#2-5-6-核心工厂类设计\" class=\"headerlink\" title=\"2.5.6 核心工厂类设计\"></a>2.5.6 核心工厂类设计</h3><p>最后来看 BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象</p>\n<p>如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回</p>\n<p>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 自动完成了，需要利用 Java 提供的反射语法自己去编写代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BeansFactory &#123;\n\tprivate ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n\tpublic void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;\n\t\tfor (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n\t\t\tthis.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition)\n\t\t&#125;\n\t\tfor (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n\t\t\tif (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;\n\t\t\t\tcreateBean(beanDefinition);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tpublic Object getBean(String beanId) &#123;\n\t\tBeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);\n\t\tif (beanDefinition &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n\t\t&#125;\n\t\treturn createBean(beanDefinition);\n\t&#125;\n\n\t@VisibleForTesting\n\tprotected Object createBean(BeanDefinition beanDefinition) &#123;\n\t\tif (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition)) &#123;\n\t\t\treturn singletonObjects.get(beanDefinition.getId());\n\t\t&#125;\n\t\tObject bean &#x3D; null;\n\t\ttry &#123;\n\t\t\tClass beanClass &#x3D; Class.forName(beanDefinition.getClassName());\n\t\t\tList&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorA\n\t\t\tif (args.isEmpty()) &#123;\n\t\t\t\tbean &#x3D; beanClass.newInstance();\n\t\t\t&#125; else &#123;\n\t\t\t\tClass[] argClasses &#x3D; new Class[args.size()];\n\t\t\t\tObject[] argObjects &#x3D; new Object[args.size()];\n\t\t\t\tfor (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;\n\t\t\t\t\tBeanDefinition.ConstructorArg arg &#x3D; args.get(i);\n\t\t\t\t\tif (!arg.getIsRef()) &#123;\n\t\t\t\t\t\targClasses[i] &#x3D; arg.getType();\n\t\t\t\t\t\targObjects[i] &#x3D; arg.getArg();\n\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\tBeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());\n\t\t\t\t\t\tif (refBeanDefinition &#x3D;&#x3D; null) &#123;\n\t\t\t\t\t\t\tthrow new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot;);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\targClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());\n\t\t\t\t\t\targObjects[i] &#x3D; createBean(refBeanDefinition);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tbean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);\n\t\t\t&#125;\n\t\t&#125; catch (ClassNotFoundException | IllegalAccessException) &#123;\n\t\t\t| InstantiationException | NoSuchMethodException | InvocationTarget\n\t\t\tthrow new BeanCreationFailureException(&quot;&quot;, e);\n\t\t&#125;\n\t\tif (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;\n\t\t\tsingletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n\t\t\treturn singletonObjects.get(beanDefinition.getId());\n\t\t&#125;\n\t\treturn bean;\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"3-建造者-x2F-构建者-x2F-生成器模式（Builder-Design-Pattern）\"><a href=\"#3-建造者-x2F-构建者-x2F-生成器模式（Builder-Design-Pattern）\" class=\"headerlink\" title=\"3. 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）\"></a>3. 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）</h1><h2 id=\"3-1-为什么需要建造者模式？\"><a href=\"#3-1-为什么需要建造者模式？\" class=\"headerlink\" title=\"3.1 为什么需要建造者模式？\"></a>3.1 为什么需要建造者模式？</h2><p>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。但什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？如下例：</p>\n<p>假设有这样一道设计面试题：需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请编写代码实现这个 ResourcePoolConfig 类</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9635dab4e59f488186cc0154ba5264c9.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ResourcePoolConfig &#123;\n\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\tprivate String name;\n\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\tpublic ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Int minIdle) &#123;\n\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;name should not be empty.&quot;);\n\t\t&#125;\n\t\tthis.name &#x3D; name;\n\t\tif (maxTotal !&#x3D; null) &#123;\n\t\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxTotal &#x3D; maxTotal;\n\t\t&#125;\n\t\tif (maxIdle !&#x3D; null) &#123;\n\t\t\tif (maxIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxIdle &#x3D; maxIdle;\n\t\t&#125;\n\t\tif (minIdle !&#x3D; null) &#123;\n\t\t\tif (minIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n\t\t\t&#125;\n\t\t\tthis.minIdle &#x3D; minIdle;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n&#125;</code></pre>\n\n<p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug</p>\n<p>解决这个问题的办法就是用 <code>set()</code> 函数来给成员变量赋值，以替代冗长的构造函数。代码如下所示，其中，配置项 name 是必填的，所以把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以通过 <code>set()</code> 函数来设置，让使用者自主选择填写或者不填写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ResourcePoolConfig &#123;\n\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\tprivate String name;\n\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\tpublic ResourcePoolConfig(String name) &#123;\n\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;name should not be empty.&quot;);\n\t\t&#125;\n\t\tthis.name &#x3D; name;\n\t&#125;\n\tpublic void setMaxTotal(int maxTotal) &#123;\n\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n\t\t&#125;\n\t\tthis.maxTotal &#x3D; maxTotal;\n\t&#125;\n\tpublic void setMaxIdle(int maxIdle) &#123;\n\t\tif (maxIdle &lt; 0) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n\t\t&#125;\n\t\tthis.maxIdle &#x3D; maxIdle;\n\t&#125;\n\tpublic void setMinIdle(int minIdle) &#123;\n\t\tif (minIdle &lt; 0) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n\t\t&#125;\n\t\tthis.minIdle &#x3D; minIdle;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n&#125;</code></pre>\n\n<p>接下来，来看新的 ResourcePoolConfig 类该如何使用。代码如下所示，没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; ResourcePoolConfig 使用举例\nResourcePoolConfig config &#x3D; new ResourcePoolConfig(&quot;dbconnectionpool&quot;);\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);</code></pre>\n\n<p>至此，仍然没有用到建造者模式，通过构造函数设置必填项，通过 <code>set()</code> 方法设置可选配置项，就能实现我们的设计需求。如果把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了</p>\n<ol>\n<li>刚刚讲到，name 是必填的，所以把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果把必填项也通过 <code>set()</code> 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了</li>\n<li>除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了</li>\n<li>如果希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，就不能在 ResourcePoolConfig 类中暴露 <code>set()</code> 方法</li>\n</ol>\n<p>为了解决这些问题，建造者模式就派上用场了。可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 <code>set()</code> 方法设置建造者的变量值，然后在使用 <code>build()</code> 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 <code>set()</code> 方法，这样创建出来的对象就是不可变对象了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ResourcePoolConfig &#123;\n\tprivate String name;\n\tprivate int maxTotal;\n\tprivate int maxIdle;\n\tprivate int minIdle;\n\tprivate ResourcePoolConfig(Builder builder) &#123;\n\t\tthis.name &#x3D; builder.name;\n\t\tthis.maxTotal &#x3D; builder.maxTotal;\n\t\tthis.maxIdle &#x3D; builder.maxIdle;\n\t\tthis.minIdle &#x3D; builder.minIdle;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n\t&#x2F;&#x2F; 将Builder类设计成了ResourcePoolConfig的内部类。\n\t&#x2F;&#x2F; 也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n\tpublic static class Builder &#123;\n\t\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\t\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\t\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\t\tprivate String name;\n\t\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\t\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\t\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\t\tpublic ResourcePoolConfig build() &#123;\n\t\t\t&#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (maxIdle &gt; maxTotal) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\treturn new ResourcePoolConfig(this);\n\t\t&#125;\n\t\tpublic Builder setName(String name) &#123;\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.name &#x3D; name;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxTotal(int maxTotal) &#123;\n\t\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxTotal &#x3D; maxTotal;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxIdle(int maxIdle) &#123;\n\t\t\tif (maxIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxIdle &#x3D; maxIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMinIdle(int minIdle) &#123;\n\t\t\tif (minIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.minIdle &#x3D; minIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()\n\t.setName(&quot;dbconnectionpool&quot;)\n\t.setMaxTotal(16)\n\t.setMaxIdle(10)\n\t.setMinIdle(12)\n\t.build();\n</code></pre>\n\n<p>实际上，使用建造者模式创建对象，还能避免对象存在无效状态。比如定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之前，对象处于无效状态。具体代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Rectangle r &#x3D; new Rectange(); &#x2F;&#x2F; r is invalid\nr.setWidth(2); &#x2F;&#x2F; r is invalid\nr.setHeight(3); &#x2F;&#x2F; r is valid</code></pre>\n\n<p>为了避免这种无效状态的存在，就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态</p>\n<p>实际上，如果并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那直接暴露 <code>set()</code> 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍</p>\n<h2 id=\"3-2-与工厂模式有何区别？\"><a href=\"#3-2-与工厂模式有何区别？\" class=\"headerlink\" title=\"3.2 与工厂模式有何区别？\"></a>3.2 与工厂模式有何区别？</h2><p>建造者模式是让建造者类来负责对象的创建工作。工厂模式是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</p>\n<p>实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象</p>\n<p>有一个经典的例子很好地解释了两者的区别</p>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨</p>\n<p>实际上，也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题</p>\n<h1 id=\"4-原型模式（Prototype-Design-Pattern）\"><a href=\"#4-原型模式（Prototype-Design-Pattern）\" class=\"headerlink\" title=\"4. 原型模式（Prototype Design Pattern）\"></a>4. 原型模式（Prototype Design Pattern）</h1><p>对于熟悉 JavaScript 语言的前端程序员来说，原型模式是一种比较常用的开发模式。这是因为，有别于 Java、C++ 等基于类的面向对象编程语言，JavaScript 是一种基于原型的面向对象编程语言。即便 JavaScript 现在也引入了类的概念，但它也只是基于原型的语法糖而已。不过，如果熟悉的是 Java、C++ 等这些编程语言，那在实际的开发中，就很少用到原型模式了</p>\n<h2 id=\"4-1-原型模式的原理与应用\"><a href=\"#4-1-原型模式的原理与应用\" class=\"headerlink\" title=\"4.1 原型模式的原理与应用\"></a>4.1 原型模式的原理与应用</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式</p>\n<p><strong>何为“对象的创建成本比较大”？</strong></p>\n<p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失</p>\n<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作</p>\n<p>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，给关键词建立一个散列表索引</p>\n<p>如果熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。只需要将数据从数据库中读取出来，放入 HashMap 就可以了</p>\n<p>不过，还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，对 v2 版本的数据进行更新，得到 v3 版本的数据。这里假设只有更新和新添关键词，没有删除关键词的行为</p>\n<p><img src=\"https://img-blog.csdnimg.cn/cf4f2b48420948249936d069a213ed48.png\" alt=\"在这里插入图片描述\"></p>\n<p>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。该如何实现这个需求呢？</p>\n<p>实际上，也不难。只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，就将它插入到散列表中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tprivate ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords &#x3D; new Concurren\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (currentKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tcurrentKeywords.replace(searchWord.getKeyword(), searchWord);\n\t\t\t&#125; else &#123;\n\t\t\t\tcurrentKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t\t&#125;\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n\t\t&#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;</code></pre>\n\n<p>不过，现在有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了。除此之外，还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。该如何实现现在这个需求呢？</p>\n<p>实际上，也不难。把正在使用的数据的版本定义为“服务版本”，当要更新内存中的数据的时候，并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tpublic void refresh() &#123;\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new LinkedHashMap&lt;&gt;();\n                &#x2F;&#x2F; 从数据库中取出所有的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords();\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t&#125;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords() &#123;\n                &#x2F;&#x2F; TODO: 从数据库中取出所有的数据\n\t\treturn null;\n\t&#125;\n&#125;</code></pre>\n\n<p>不过，在上面的代码实现中，newKeywords 构建的成本比较高。需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了</p>\n<p>拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tSearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n\t\t\t\toldSearchWord.setCount(searchWord.getCount());\n\t\t\t\toldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n\t\t\t&#125; else &#123;\n\t\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t\t&#125;\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n                &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;</code></pre>\n\n<p>这里利用了 Java 中的 <code>clone()</code> 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的</p>\n<p>不过，实际上，刚刚的代码实现是有问题的。这里需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）</p>\n<h2 id=\"4-2-原型模式的实现方式：深拷贝和浅拷贝\"><a href=\"#4-2-原型模式的实现方式：深拷贝和浅拷贝\" class=\"headerlink\" title=\"4.2 原型模式的实现方式：深拷贝和浅拷贝\"></a>4.2 原型模式的实现方式：深拷贝和浅拷贝</h2><p>先来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。大致结构如下图所示，从图中可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/34cd19eeec164cb5a59652aa484151b4.png\" alt=\"在这里插入图片描述\"></p>\n<p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1774992e5d394a0fa903269d4c40e94a.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/46918ac5ad9244188921e3a0662428f1.png\" alt=\"在这里插入图片描述\"></p>\n<p>在 Java 语言中，Object 类的 <code>clone()</code> 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身</p>\n<p>在上面的代码中，通过调用 HashMap 上的 <code>clone()</code> 浅拷贝方法来实现原型模式。当通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。又该如何来解决这个问题呢？</p>\n<p>可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了</p>\n<p>那如何实现深拷贝呢？总结一下的话，有下面两种方法：</p>\n<p><strong>第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止</strong></p>\n<p>根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; Deep copy\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new HashMap&lt;&gt;();\n\t\tfor (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;\n\t\t\tSearchWord searchWord &#x3D; e.getValue();\n\t\t\tSearchWord newSearchWord &#x3D; new SearchWord(\n\t\t\t    searchWord.getKeyword(), searchWord.getCount(), searchWord.getLas\n\t\t\t    newKeywords.put(e.getKey(), newSearchWord);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tSearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n\t\t\t\toldSearchWord.setCount(searchWord.getCount());\n\t\t\t\toldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n\t\t\t&#125; else &#123;\n\t\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t\t&#125;\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n\t\t&#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>第二种方法：先将对象序列化，然后再反序列化成新的对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Object deepCopy(Object object) &#123;\n\tByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream();\n\tObjectOutputStream oo &#x3D; new ObjectOutputStream(bo);\n\too.writeObject(object);\n\tByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());\n\tObjectInputStream oi &#x3D; new ObjectInputStream(bi);\n\treturn oi.readObject();\n&#125;</code></pre>\n\n<p>上面的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这个应用场景，有没有更快、更省内存的实现方式呢？</p>\n<p>可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，使用深度拷贝的方式创建一份老对象的备份，在 newKeywords 更新 SearchWord 对象之后再替换为原先 currentKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是在这个应用场景下，最快速 clone 散列表的方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; Shallow copy\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tnewKeywords.remove(searchWord.getKeyword());\n\t\t\t&#125;\n\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n\t\t&#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;</code></pre>\n","feature":false,"text":"前三篇见： 设计模式之美总结（面向对象篇）_凡 223 的博客 设计模式之美总结（设计原则篇）_凡 223 的博客 设计模式之美总结（重构篇）_凡 223 的博客 1. 单例模式（Singleton Design Pattern）1.1 为什么要使用单例？单例设计模式（Singl...","link":"","photos":[],"count_time":{"symbolsCount":"61k","symbolsTime":"55 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">1. 单例模式（Singleton Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%EF%BC%9F\"><span class=\"toc-text\">1.1 为什么要使用单例？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E5%A4%84%E7%90%86%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">1.1.1 处理资源访问冲突</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E8%A1%A8%E7%A4%BA%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E7%B1%BB\"><span class=\"toc-text\">1.1.2 表示全局唯一类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%EF%BC%9F\"><span class=\"toc-text\">1.2 如何实现一个单例？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E9%A5%BF%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">1.1.1 饿汉式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E6%87%92%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">1.1.2 懒汉式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-3-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">1.1.3 双重检测</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">1.1.4 静态内部类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-5-%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">1.1.5 枚举</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%8D%95%E4%BE%8B%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.3 单例存在哪些问题?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-1-%E5%8D%95%E4%BE%8B%E5%AF%B9-OOP-%E7%89%B9%E6%80%A7%E7%9A%84%E6%94%AF%E6%8C%81%E4%B8%8D%E5%8F%8B%E5%A5%BD\"><span class=\"toc-text\">1.3.1 单例对 OOP 特性的支持不友好</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-2-%E5%8D%95%E4%BE%8B%E4%BC%9A%E9%9A%90%E8%97%8F%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">1.3.2 单例会隐藏类之间的依赖关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-3-%E5%8D%95%E4%BE%8B%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7%E4%B8%8D%E5%8F%8B%E5%A5%BD\"><span class=\"toc-text\">1.3.3 单例对代码的扩展性不友好</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-4-%E5%8D%95%E4%BE%8B%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7%E4%B8%8D%E5%8F%8B%E5%A5%BD\"><span class=\"toc-text\">1.3.4 单例对代码的可测试性不友好</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-5-%E5%8D%95%E4%BE%8B%E4%B8%8D%E6%94%AF%E6%8C%81%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1.3.5 单例不支持有参数的构造函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E6%9C%89%E4%BD%95%E6%9B%BF%E4%BB%A3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F\"><span class=\"toc-text\">1.4 有何替代解决方案？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">1.5 如何理解单例模式中的唯一性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%94%AF%E4%B8%80%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F\"><span class=\"toc-text\">1.6 如何实现线程唯一的单例？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F\"><span class=\"toc-text\">1.7 如何实现集群环境下的单例？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">1.7 如何实现一个多例模式？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2. 工厂模式（Factory Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%EF%BC%88Simple-Factory%EF%BC%89\"><span class=\"toc-text\">2.1 简单工厂（Simple Factory）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%88Factory-Method%EF%BC%89\"><span class=\"toc-text\">2.2 工厂方法（Factory Method）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%80%8C%E9%9D%9E%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">2.3 什么时候该用工厂方法模式，而非简单工厂模式呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%EF%BC%88Abstract-Factory%EF%BC%89\"><span class=\"toc-text\">2.4 抽象工厂（Abstract Factory）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Dependency-Injection-%E6%A1%86%E6%9E%B6%EF%BC%9F\"><span class=\"toc-text\">2.5 如何设计实现一个 Dependency Injection 框架？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C-DI-%E5%AE%B9%E5%99%A8%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">2.5.1 工厂模式和 DI 容器有何区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-2-DI-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">2.5.2 DI 容器的核心功能有哪些？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-3-%E6%9C%80%E5%B0%8F%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">2.5.3 最小原型设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-4-%E6%8F%90%E4%BE%9B%E6%89%A7%E8%A1%8C%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">2.5.4 提供执行入口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-5-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">2.5.5 配置文件解析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-6-%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%8E%82%E7%B1%BB%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">2.5.6 核心工厂类设计</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%BB%BA%E9%80%A0%E8%80%85-x2F-%E6%9E%84%E5%BB%BA%E8%80%85-x2F-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3. 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">3.1 为什么需要建造者模式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3.2 与工厂模式有何区别？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">4. 原型模式（Prototype Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.1 原型模式的原理与应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">4.2 原型模式的实现方式：深拷贝和浅拷贝</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Vue3 总结","uid":"253be1f39f8482a0ee0e446a428827b1","slug":"BlogRepository/Vue/Vue3 总结","date":"2022-11-06T15:57:57.000Z","updated":"2023-03-13T19:13:04.944Z","comments":true,"path":"api/articles/BlogRepository/Vue/Vue3 总结.json","keywords":null,"cover":"https://cover.png","text":"Vue2 基础见：Vue2 总结（Basic）_凡 223 的博客 Vue2 开发见：Vue2 总结（开发）_凡 223 的博客 1. 简介 性能的提升 打包大小减少41% 初次渲染快55%，更新渲染快133% 内存减少54%…… 源码的升级 使用Proxy代替definePro...","link":"","photos":[],"count_time":{"symbolsCount":"42k","symbolsTime":"38 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"设计模式之美总结（设计原则篇）","uid":"b2a78a3230e27441fbeed95c211733e9","slug":"BlogRepository/设计模式/设计模式之美总结（设计原则篇）","date":"2022-10-27T09:31:42.000Z","updated":"2023-03-13T19:13:04.973Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（设计原则篇）.json","keywords":null,"cover":"https://cover.png","text":"上一篇见： 设计模式之美总结（面向对象篇）_凡 223 的博客 上一篇介绍了面向对象相关的知识。接下来介绍一些经典的设计原则，其中包括 SOLID、KISS、YAGNI、DRY、LOD 等 1. 单一职责原则（SRP）1.1 如何理解单一职责原则？实际上，SOLID 原则并非单纯...","link":"","photos":[],"count_time":{"symbolsCount":"100k","symbolsTime":"1:31"},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}