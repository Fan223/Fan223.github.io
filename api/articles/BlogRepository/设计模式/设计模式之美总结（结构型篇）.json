{"title":"设计模式之美总结（结构型篇）","uid":"dc36ba1463e60735e3396234d94e7099","slug":"BlogRepository/设计模式/设计模式之美总结（结构型篇）","date":"2022-12-21T01:59:11.000Z","updated":"2023-03-13T19:13:04.964Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（结构型篇）.json","keywords":null,"cover":"https://cover.png","content":"<p>前四篇见：</p>\n<ul>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/126966428\">设计模式之美总结（面向对象篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127412458\">设计模式之美总结（设计原则篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127573227\">设计模式之美总结（重构篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127668978\">设计模式之美总结（创建型篇）_凡 223 的博客</a></strong></li>\n</ul>\n<h1 id=\"1-代理模式（Proxy-Design-Pattern）\"><a href=\"#1-代理模式（Proxy-Design-Pattern）\" class=\"headerlink\" title=\"1. 代理模式（Proxy Design Pattern）\"></a>1. 代理模式（Proxy Design Pattern）</h1><h2 id=\"1-1-原理解析\"><a href=\"#1-1-原理解析\" class=\"headerlink\" title=\"1.1 原理解析\"></a>1.1 原理解析</h2><p>代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握，它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。如下例，这是一个性能计数器，用来收集接口请求的原始数据，比如访问时间、处理时长等</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController &#123;\n\t&#x2F;&#x2F;...省略其他属性和方法...\n\tprivate MetricsCollector metricsCollector; &#x2F;&#x2F; 依赖注入\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong  &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; ... 省略login逻辑...\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; ... 省略register逻辑...\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n&#125;</code></pre>\n\n<p>很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理</p>\n<p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IUserController &#123;\n\tUserVo login(String telephone, String password);\n\tUserVo register(String telephone, String password);\n&#125;\npublic class UserController implements IUserController &#123;\n\t&#x2F;&#x2F;...省略其他属性和方法...\n\t@Override\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;...省略login逻辑...\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n\t@Override\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;...省略register逻辑...\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n&#125;\npublic class UserControllerProxy implements IUserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tprivate UserController userController;\n\tpublic UserControllerProxy(UserController userController) &#123;\n\t\tthis.userController &#x3D; userController;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\t@Override\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; 委托\n\t\tUserVo userVo &#x3D; userController.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n\t@Override\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; userController.register(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;UserControllerProxy使用举例\n&#x2F;&#x2F;因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n&#x2F;&#x2F;将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController &#x3D; new UserControllerProxy(new UserController())</code></pre>\n\n<p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，该如何实现代理模式呢？</p>\n<p>对于这种外部类的扩展，一般都是采用继承的方式。让代理类继承原始类，然后扩展附加功能，具体代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserControllerProxy extends UserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tpublic UserControllerProxy() &#123;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; super.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; super.register(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n&#x2F;&#x2F;UserControllerProxy使用举例\nUserController userController &#x3D; new UserControllerProxy();</code></pre>\n\n<h2 id=\"1-2-动态代理\"><a href=\"#1-2-动态代理\" class=\"headerlink\" title=\"1.2 动态代理\"></a>1.2 动态代理</h2><p>不过，刚刚的代码实现还是有点问题。一方面，需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，需要针对每个类都创建一个代理类</p>\n<p>如果有 50 个要添加附加功能的原始类，那就要创建 50 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？</p>\n<p>可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？</p>\n<p>如果熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法），代码如下所示。其中，MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MetricsCollectorProxy &#123;\n\tprivate MetricsCollector metricsCollector;\n\tpublic MetricsCollectorProxy() &#123;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\tpublic Object createProxy(Object proxiedObject) &#123;\n\t\tClass&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();\n\t\tDynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);\n\t\treturn Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces\n\t&#125;\n\tprivate class DynamicProxyHandler implements InvocationHandler &#123;\n\t\tprivate Object proxiedObject;\n\t\tpublic DynamicProxyHandler(Object proxiedObject) &#123;\n\t\t\tthis.proxiedObject &#x3D; proxiedObject;\n\t\t&#125;\n\t\t@Override\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n\t\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t\tObject result &#x3D; method.invoke(proxiedObject, args);\n\t\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\t\tString apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n\t\t\tRequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);\n\t\t\tmetricsCollector.recordRequest(requestInfo);\n\t\t\treturn result;\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F;MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();\nIUserController userController &#x3D; (IUserController) proxy.createProxy(new userController());</code></pre>\n\n<p>实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的</p>\n<h2 id=\"1-3-应用场景\"><a href=\"#1-3-应用场景\" class=\"headerlink\" title=\"1.3 应用场景\"></a>1.3 应用场景</h2><p><strong>1、业务系统的非功能性需求开发</strong></p>\n<p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发</p>\n<p>如果熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的，Spring AOP 底层的实现原理就是基于动态代理</p>\n<p><strong>2、代理模式在 RPC 中的应用</strong></p>\n<p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节</p>\n<p><strong>3、代理模式在缓存中的应用</strong></p>\n<p>假设要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，让其调用实时查询接口，对于不需要实时数据的需求，让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？</p>\n<p>最简单的实现方法就是上面讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）</p>\n<p>针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http:&#x2F;&#x2F;…?..&amp;cached&#x3D;true），便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回</p>\n<h1 id=\"2-桥接-x2F-桥梁模式（Bridge-Design-Pattern）\"><a href=\"#2-桥接-x2F-桥梁模式（Bridge-Design-Pattern）\" class=\"headerlink\" title=\"2. 桥接&#x2F;桥梁模式（Bridge Design Pattern）\"></a>2. 桥接&#x2F;桥梁模式（Bridge Design Pattern）</h1><h2 id=\"2-1-原理解析\"><a href=\"#2-1-原理解析\" class=\"headerlink\" title=\"2.1 原理解析\"></a>2.1 原理解析</h2><p>这个模式有两种不同的理解方式。当然，这其中“最纯正”的理解方式，当属 GoF 的《设计模式》一书中对桥接模式的定义。毕竟，这 23 种经典的设计模式，最初就是由这本书总结出来的。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</p>\n<p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于之前讲过的“组合优于继承”设计原则，所以这里重点看下 GoF 的理解方式</p>\n<p>GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序\nString url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;\nConnection con &#x3D; DriverManager.getConnection(url);\nStatement stmt &#x3D; con.createStatement()；\nString query &#x3D; &quot;select * from test&quot;;\nResultSet rs&#x3D;stmt.executeQuery(query);\nwhile(rs.next()) &#123;\n    rs.getString(1);\n    rs.getInt(2);\n&#125;</code></pre>\n\n<p>如果想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，都不需要修改代码，只需要修改配置文件就可以了</p>\n<p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？</p>\n<p>从 com.mysql.jdbc.Driver 这个类的代码看起，摘抄了部分相关源码，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;\n\tstatic &#123;\n\t\ttry &#123;\n\t\t\tjava.sql.DriverManager.registerDriver(new Driver());\n\t\t&#125; catch (SQLException E) &#123;\n\t\t\tthrow new RuntimeException(&quot;Can&#39;t register driver!&quot;);\n\t\t&#125;\n\t&#125;\n\t&#x2F;**\n\t* Construct a new driver and register it with DriverManager\n\t* @throws SQLException if a database error occurs.\n\t*&#x2F;\n\tpublic Driver() throws SQLException &#123;\n\t\t&#x2F;&#x2F; Required for Class.forName().newInstance()\n\t&#125;\n&#125;</code></pre>\n\n<p>结合 com.mysql.jdbc.Driver 的代码实现，可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中</p>\n<p>再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DriverManager &#123;\n\tprivate final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;&gt;();\n\t&#x2F;&#x2F;...\n\tstatic &#123;\n\t\tloadInitialDrivers();\n\t\tprintln(&quot;JDBC DriverManager initialized&quot;);\n\t&#125;\n\t&#x2F;&#x2F;...\n\tpublic static synchronized void registerDriver(java.sql.Driver driver) throws NullPointerException &#123;\n\t\tif (driver !&#x3D; null) &#123;\n\t\t\tregisteredDrivers.addIfAbsent(new DriverInfo(driver));\n\t\t&#125; else &#123;\n\t\t\tthrow new NullPointerException();\n\t\t&#125;\n\t&#125;\n\tpublic static Connection getConnection(String url, String user, String password) &#123;\n\t\tjava.util.Properties info &#x3D; new java.util.Properties();\n\t\tif (user !&#x3D; null) &#123;\n\t\t\tinfo.put(&quot;user&quot;, user);\n\t\t&#125;\n\t\tif (password !&#x3D; null) &#123;\n\t\t\tinfo.put(&quot;password&quot;, password);\n\t\t&#125;\n\t\treturn (getConnection(url, info, Reflection.getCallerClass()));\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”、“实现”和“解耦”三个概念，就是理解桥接模式的关键</p>\n<ul>\n<li>抽象，可以理解为存在于多个实体中的共同的概念性联系，就是忽略一些信息，从而把不同的实体当做同样的实体对待</li>\n<li>实现，即抽象给出的具体实现，可能有多种不同的实现方式</li>\n<li>解耦，所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称解耦。在这里，解耦是指将抽象和实现之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联，即抽象和实现之间使用组合&#x2F;聚合关系而不是继承关系</li>\n</ul>\n<p>那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？</p>\n<p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行</p>\n<p><img src=\"https://img-blog.csdnimg.cn/51f16502e9dd48f590398b16ad06a556.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-2-应用举例\"><a href=\"#2-2-应用举例\" class=\"headerlink\" title=\"2.2 应用举例\"></a>2.2 应用举例</h2><p>之前讲过一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。先来看最简单、最直接的一种实现方式。代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum NotificationEmergencyLevel &#123;\n\tSEVERE, URGENCY, NORMAL, TRIVIAL\n&#125;\npublic class Notification &#123;\n\tprivate List&lt;String&gt; emailAddresses;\n\tprivate List&lt;String&gt; telephones;\n\tprivate List&lt;String&gt; wechatIds;\n\tpublic Notification() &#123;&#125;\n\n\tpublic void setEmailAddress(List&lt;String&gt; emailAddress) &#123;\n\t\tthis.emailAddresses &#x3D; emailAddress;\n\t&#125;\n\tpublic void setTelephones(List&lt;String&gt; telephones) &#123;\n\t\tthis.telephones &#x3D; telephones;\n\t&#125;\n\tpublic void setWechatIds(List&lt;String&gt; wechatIds) &#123;\n\t\tthis.wechatIds &#x3D; wechatIds;\n\t&#125;\n\n\tpublic void notify(NotificationEmergencyLevel level, String message) &#123;\n\t\tif (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;\n\t\t\t&#x2F;&#x2F;...自动语音电话\n\t\t&#125; else if (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;\n\t\t\t&#x2F;&#x2F;...发微信\n\t\t&#125; else if (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;\n\t\t\t&#x2F;&#x2F;...发邮件\n\t\t&#125; else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;\n\t\t\t&#x2F;&#x2F;...发邮件\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F;在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler &#123;\n\tpublic ErrorAlertHandler(AlertRule rule, Notification notification) &#123;\n\t\tsuper(rule, notification);\n\t&#125;\n\t@Override\n\tpublic void check(ApiStatInfo apiStatInfo) &#123;\n\t\tif (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi())) &#123;\n\t\t\tnotification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑</p>\n<p>不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起</p>\n<p>针对 Notification 的代码，将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，可以动态地去指定（比如，通过读取配置来获取对应关系）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface MsgSender &#123;\n\tvoid send(String message);\n&#125;\npublic class TelephoneMsgSender implements MsgSender &#123;\n\tprivate List&lt;String&gt; telephones;\n\tpublic TelephoneMsgSender(List&lt;String&gt; telephones) &#123;\n\t\tthis.telephones &#x3D; telephones;\n\t&#125;\n\t@Override\n\tpublic void send(String message) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class EmailMsgSender implements MsgSender &#123;\n\t&#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...\n&#125;\npublic class WechatMsgSender implements MsgSender &#123;\n\t&#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...\n&#125;\npublic abstract class Notification &#123;\n\tprotected MsgSender msgSender;\n\tpublic Notification(MsgSender msgSender) &#123;\n\t\tthis.msgSender &#x3D; msgSender;\n\t&#125;\n\tpublic abstract void notify(String message);\n&#125;\n\npublic class SevereNotification extends Notification &#123;\n\tpublic SevereNotification(MsgSender msgSender) &#123;\n\t\tsuper(msgSender);\n\t&#125;\n\t@Override\n\tpublic void notify(String message) &#123;\n\t\tmsgSender.send(message);\n\t&#125;\n&#125;\npublic class UrgencyNotification extends Notification &#123;\n\t&#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...\n&#125;\npublic class NormalNotification extends Notification &#123;\n\t&#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...\n&#125;\npublic class TrivialNotification extends Notification &#123;\n\t&#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...\n&#125;</code></pre>\n\n<h1 id=\"3-装饰器模式（Decorator-Design-Pattern）\"><a href=\"#3-装饰器模式（Decorator-Design-Pattern）\" class=\"headerlink\" title=\"3. 装饰器模式（Decorator Design Pattern）\"></a>3. 装饰器模式（Decorator Design Pattern）</h1><h2 id=\"3-1-Java-IO-类\"><a href=\"#3-1-Java-IO-类\" class=\"headerlink\" title=\"3.1 Java IO 类\"></a>3.1 Java IO 类</h2><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，可以从下面两个维度将它划分为四类。具体如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5cbe1adb0be24e659082848c86ee81e3.png\" alt=\"在这里插入图片描述\"></p>\n<p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c15ad0a0863b444f8ed7680fe28713c9.png\" alt=\"在这里插入图片描述\"></p>\n<p>假如要打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">InputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nbyte[] data &#x3D; new byte[128];\nwhile (bin.read(data) !&#x3D; -1) &#123;\n\t&#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p>初看上面的代码，会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream对象，然后再传递给 BufferedInputStream 对象来使用。Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">InputStream bin &#x3D; new BufferedFileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nbyte[] data &#x3D; new byte[128];\nwhile (bin.read(data) !&#x3D; -1) &#123;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<h2 id=\"3-2-基于继承的设计方案\"><a href=\"#3-2-基于继承的设计方案\" class=\"headerlink\" title=\"3.2 基于继承的设计方案\"></a>3.2 基于继承的设计方案</h2><p>如果 InputStream 只有一个子类 FileInputStream 的话，那在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。需要给每一个 InputStream的子类，再继续派生支持缓存读取的子类</p>\n<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">FileInputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nDataInputStream din &#x3D; new DataInputStream(in);\nint data &#x3D; din.readInt();</code></pre>\n\n<p>在这种情况下，如果继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护</p>\n<h2 id=\"3-3-基于装饰器模式的设计方案\"><a href=\"#3-3-基于装饰器模式的设计方案\" class=\"headerlink\" title=\"3.3 基于装饰器模式的设计方案\"></a>3.3 基于装饰器模式的设计方案</h2><p>这里展示了 Java IO 的这种设计思路，对代码做了简化：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class InputStream &#123;\n\t&#x2F;&#x2F;...\n\tpublic int read(byte b[]) throws IOException &#123;\n\t\treturn read(b, 0, b.length);\n\t&#125;\n\tpublic int read(byte b[], int off, int len) throws IOException &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic long skip(long n) throws IOException &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic int available() throws IOException &#123;\n\t\treturn 0;\n\t&#125;\n\tpublic void close() throws IOException &#123;&#125;\n\tpublic synchronized void mark(int readlimit) &#123;&#125;\n\tpublic synchronized void reset() throws IOException &#123;\n\t\tthrow new IOException(&quot;mark&#x2F;reset not supported&quot;);\n\t&#125;\n\tpublic boolean markSupported() &#123;\n\t\treturn false;\n\t&#125;\n&#125;\npublic class BufferedInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\tprotected BufferedInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\t&#x2F;&#x2F;...实现基于缓存的读数据接口...\n&#125;\npublic class DataInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\tprotected DataInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\t&#x2F;&#x2F;...实现读取基本类型数据的接口\n&#125;</code></pre>\n\n<p>看了上面的代码可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方</p>\n<p><strong>1、装饰器类和原始类继承同样的父类，这样可以对原始类“嵌套”多个装饰器类</strong></p>\n<p>比如，下面这样一段代码，对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">InputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nDataInputStream din &#x3D; new DataInputStream(bin);\nint data &#x3D; din.readInt();</code></pre>\n\n<p><strong>2、装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点</strong></p>\n<p>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class AProxy impements IA &#123;\n\tprivate IA a;\n\tpublic AProxy(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t\ta.f();\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ADecorator impements IA &#123;\n\tprivate IA a;\n\tpublic ADecorator(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 功能增强代码\n\t\ta.f();\n\t\t&#x2F;&#x2F; 功能增强代码\n\t&#125;\n&#125;</code></pre>\n\n<p>实际上，如果去查看 JDK 的源码会发现，BufferedInputStream、DataInputStream并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？</p>\n<p>再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的</p>\n<p>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BufferedInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\tprotected BufferedInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\t&#x2F;&#x2F; f()函数不需要增强，只是重新调用一下InputStream in对象的f()\n\tpublic void f() &#123;\n\t\tin.f();\n\t&#125;\n&#125;</code></pre>\n\n<p>如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。因为假设我们没有重写方法 <code>f()</code>，然后在内部调用传递进来的 InputStream 对象的 <code>f()</code>，在使用 <code>f()</code>方法时调用的只会是最顶层的 <code>f()</code>方法，假如存在多个装饰器时就会出现问题，出现链式中断（整体的调用过程其实就是一个链式调用）。同样，假如我们重写了 <code>f()</code>方法，但是在内部忘记调用了传递进来的 InputStream 对象的 <code>f()</code> 方法，即上一个 InputStream 对象，也会出现链式中断</p>\n<p>实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FilterInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\n\tprotected FilterInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\tpublic int read() throws IOException &#123;\n\t\treturn in.read();\n\t&#125;\n\tpublic int read(byte b[]) throws IOException &#123;\n\t\treturn read(b, 0, b.length);\n\t&#125;\n\tpublic int read(byte b[], int off, int len) throws IOException &#123;\n\t\treturn in.read(b, off, len);\n\t&#125;\n\tpublic long skip(long n) throws IOException &#123;\n\t\treturn in.skip(n);\n\t&#125;\n\tpublic int available() throws IOException &#123;\n\t\treturn in.available();\n\t&#125;\n\tpublic void close() throws IOException &#123;\n\t\tin.close();\n\t&#125;\n\tpublic synchronized void mark(int readlimit) &#123;\n\t\tin.mark(readlimit);\n\t&#125;\n\tpublic synchronized void reset() throws IOException &#123;\n\t\tin.reset();\n\t&#125;\n\tpublic boolean markSupported() &#123;\n\t\treturn in.markSupported();\n\t&#125;\n&#125;</code></pre>\n\n<p>这里贴一段 BufferedInputStream 的 <code>read()</code> 方法调用的源码，省略了逻辑部分</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public synchronized int read() throws IOException &#123;\n        &#x2F;&#x2F; 省略其他\n        fill();\n&#125;\n\nprivate void fill() throws IOException &#123;\n        &#x2F;&#x2F; 省略其他\n        int n &#x3D; getInIfOpen().read(buffer, pos, buffer.length - pos);\n&#125;\n\nprivate InputStream getInIfOpen() throws IOException &#123;\n        &#x2F;&#x2F; in 就是通过构造函数传递进来的 InputStream 对象\n        InputStream input &#x3D; in;\n        if (input &#x3D;&#x3D; null)\n            throw new IOException(&quot;Stream closed&quot;);\n        return input;\n&#125;</code></pre>\n\n<p>可以看到 BufferedInputStream 重写了 <code>read()</code> 方法后，通过 <code>getInIfOpen()</code> 这个方法获取了传进来的 InputStream in，然后通过 <code>in.read()</code> 调用了前面传递进来的 InputStream 对象的 <code>read()</code> 方法。但从这个方法看 FilterInputStream 的 <code>read()</code> 的包裹调用是完全没起作用的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FilterInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\n\tprotected FilterInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\tpublic int read() throws IOException &#123;\n\t\treturn in.read();\n\t&#125;\n\tpublic int read(byte b[]) throws IOException &#123;\n\t\treturn read(b, 0, b.length);\n\t&#125;\n\tpublic int read(byte b[], int off, int len) throws IOException &#123;\n\t\treturn in.read(b, off, len);\n\t&#125;\n        &#x2F;&#x2F; 省略其他\n&#125;</code></pre>\n\n<p>但是就像上面所说，没有重写的方法，就必须包裹调用，不然会出现链式中断。为了代码复用，扩展性，包括避免出现漏调用的情况，所以这里 FilterInputStream 实现了所有 InputStream 方法的包裹调用。假如子类（如 BufferedInputStream）重写了，就用子类的，子类没有重写，则用 FilterInputStream 的（这点其实是继承的知识）</p>\n<p>完整示例如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Father &#123;\n    public void run() &#123;\n        System.out.println(&quot;Father run&quot;);\n    &#125;\n&#125;\n\nclass Son extends Father&#123;\n    public void run() &#123;\n        System.out.println(&quot;Son run&quot;);\n    &#125;\n&#125;\n\nclass ChildDecorator extends Father &#123;\n    protected Father father;\n\n    public ChildDecorator(Father father) &#123;\n        this.father &#x3D; father;\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;ChildDecorator run&quot;);\n    &#125;\n&#125;\n\nclass Child1 extends ChildDecorator&#123;\n\n    public Child1(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child1 run&quot;);\n    &#125;\n&#125;\n\nclass Child2 extends ChildDecorator &#123;\n\n    public Child2(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child2 run&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        Father son &#x3D; new Son();\n        Father child1 &#x3D; new Child1(son);\n        Child2 child2 &#x3D; new Child2(child1);\n        child2.run();\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/4ab550d914974f239e8b06cdcec6b2f4.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-适配器模式（Adapter-Design-Pattern）\"><a href=\"#4-适配器模式（Adapter-Design-Pattern）\" class=\"headerlink\" title=\"4. 适配器模式（Adapter Design Pattern）\"></a>4. 适配器模式（Adapter Design Pattern）</h1><h2 id=\"4-1-原理与实现\"><a href=\"#4-1-原理与实现\" class=\"headerlink\" title=\"4.1 原理与实现\"></a>4.1 原理与实现</h2><p>顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作</p>\n<p>原理很简单，再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor extends Adaptee implements ITarget &#123;\n\tpublic void f1() &#123;\n\t\tsuper.fa();\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\t&#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor implements ITarget &#123;\n\tprivate Adaptee adaptee;\n\tpublic Adaptor(Adaptee adaptee) &#123;\n\t\tthis.adaptee &#x3D; adaptee;\n\t&#125;\n\tpublic void f1() &#123;\n\t\tadaptee.fa(); &#x2F;&#x2F;委托给Adaptee\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\tpublic void fc() &#123;\n\t\tadaptee.fc();\n\t&#125;\n&#125;</code></pre>\n\n<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度</p>\n<p>如果 Adaptee 接口并不多，那两种实现方式都可以。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那推荐使用对象适配器，因为组合结构相对于继承更加灵活</p>\n<h2 id=\"4-2-应用场景\"><a href=\"#4-2-应用场景\" class=\"headerlink\" title=\"4.2 应用场景\"></a>4.2 应用场景</h2><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了</p>\n<p><strong>1、封装有缺陷的接口设计</strong></p>\n<p>假设依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CD &#123; &#x2F;&#x2F;这个类来自外部sdk，我们无权修改它的代码\n\t&#x2F;&#x2F;...\n\tpublic static void staticFunction1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void uglyNamingFunction2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void tooManyParamsFunction3(int paramA, int paramB, ...) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void lowPerformanceFunction4() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 使用适配器模式进行重构\npublic interface ITarget &#123;\n\tvoid function1();\n\tvoid function2();\n\tvoid fucntion3(ParamsWrapperDefinition paramsWrapper);\n\tvoid function4();\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F; 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget &#123;\n\t&#x2F;&#x2F;...\n\tpublic void function1() &#123;\n\t\tsuper.staticFunction1();\n\t&#125;\n\tpublic void function2() &#123;\n\t\tsuper.uglyNamingFucntion2();\n\t&#125;\n\tpublic void function3(ParamsWrapperDefinition paramsWrapper) &#123;\n\t\tsuper.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n\t&#125;\n\tpublic void function4() &#123;\n\t\t&#x2F;&#x2F;...reimplement it...\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>2、统一多个类的接口设计</strong></p>\n<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后就可以使用多态的特性来复用代码逻辑</p>\n<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着没法复用一套逻辑来调用各个系统。这个时候，就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样可以复用调用敏感词过滤的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; A敏感词过滤系统提供的接口\npublic class ASensitiveWordsFilter &#123;\n\t&#x2F;&#x2F;text是原始文本，函数输出用***替换敏感词之后的文本\n\tpublic String filterSexyWords(String text) &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n\tpublic String filterPoliticalWords(String text) &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n&#125;\n&#x2F;&#x2F; B敏感词过滤系统提供的接口\npublic class BSensitiveWordsFilter &#123;\n\tpublic String filter(String text) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; C敏感词过滤系统提供的接口\npublic class CSensitiveWordsFilter &#123;\n\tpublic String filter(String text, String mask) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement &#123;\n\tprivate ASensitiveWordsFilter aFilter &#x3D; new ASensitiveWordsFilter();\n\tprivate BSensitiveWordsFilter bFilter &#x3D; new BSensitiveWordsFilter();\n\tprivate CSensitiveWordsFilter cFilter &#x3D; new CSensitiveWordsFilter();\n\tpublic String filterSensitiveWords(String text) &#123;\n\t\tString maskedText &#x3D; aFilter.filterSexyWords(text);\n\t\tmaskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n\t\tmaskedText &#x3D; bFilter.filter(maskedText);\n\t\tmaskedText &#x3D; cFilter.filter(maskedText, &quot;***&quot;);\n\t\treturn maskedText;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter &#123; &#x2F;&#x2F; 统一接口定义\n\tString filter(String text);\n&#125;\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123;\n\tprivate ASensitiveWordsFilter aFilter;\n\tpublic String filter(String text) &#123;\n\t\tString maskedText &#x3D; aFilter.filterSexyWords(text);\n\t\tmaskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n\t\treturn maskedText;\n\t&#125;\n&#125;\n&#x2F;&#x2F;...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n&#x2F;&#x2F; 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n&#x2F;&#x2F; 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement &#123;\n\tprivate List&lt;ISensitiveWordsFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n\tpublic void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123;\n\t\tfilters.add(filter);\n\t&#125;\n\tpublic String filterSensitiveWords(String text) &#123;\n\t\tString maskedText &#x3D; text;\n\t\tfor (ISensitiveWordsFilter filter : filters) &#123;\n\t\t\tmaskedText &#x3D; filter.filter(maskedText);\n\t\t&#125;\n\t\treturn maskedText;\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>3、替换依赖的外部系统</strong></p>\n<p>当把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 外部系统A\npublic interface IA &#123;\n\t&#x2F;&#x2F;...\n\tvoid fa();\n&#125;\npublic class A implements IA &#123;\n\t&#x2F;&#x2F;...\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 在我们的项目中，外部系统A的使用示例\npublic class Demo &#123;\n\tprivate IA a;\n\tpublic Demo(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\nDemo d &#x3D; new Demo(new A());\n\n&#x2F;&#x2F; 将外部系统A替换成外部系统B\npublic class BAdaptor implemnts IA &#123;\n\tprivate B b;\n\tpublic BAdaptor(B b) &#123;\n\t\tthis.b&#x3D; b;\n\t&#125;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t\tb.fb();\n\t&#125;\n&#125;\n&#x2F;&#x2F; 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n&#x2F;&#x2F; 只需要将BAdaptor如下注入到Demo即可。\nDemo d &#x3D; new Demo(new BAdaptor(new B()));</code></pre>\n\n<p><strong>4、兼容老版本接口</strong></p>\n<p>在做版本升级的时候，对于一些要废弃的接口，不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改</p>\n<p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行</p>\n<p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Collections &#123;\n\tpublic static Emueration emumeration(final Collection c) &#123;\n\t\treturn new Enumeration() &#123;\n\t\t\tIterator i &#x3D; c.iterator();\n\t\t\tpublic boolean hasMoreElments() &#123;\n\t\t\t\treturn i.hashNext();\n\t\t\t&#125;\n\t\t\tpublic Object nextElement() &#123;\n\t\t\t\treturn i.next():\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>5、适配不同格式的数据</strong></p>\n<p>前面说到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 <code>Arrays.asList()</code> 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>List stooges &#x3D; Arrays.asList(“Larry”, “Moe”, “Curly”);</p></blockquote>\n<h2 id=\"4-3-适配器模式在-Java-日志中的应用\"><a href=\"#4-3-适配器模式在-Java-日志中的应用\" class=\"headerlink\" title=\"4.3 适配器模式在 Java 日志中的应用\"></a>4.3 适配器模式在 Java 日志中的应用</h2><p>Java 中有很多日志框架，在项目开发中，常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等</p>\n<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、error……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范</p>\n<p>如果只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了</p>\n<p>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架</p>\n<p>如果是做 Java 开发的，那 Slf4j 这个日志框架肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用</p>\n<p>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger &#123;\n\tpublic boolean isTraceEnabled();\n\tpublic void trace(String msg);\n\tpublic void trace(String format, Object arg);\n\tpublic void trace(String format, Object arg1, Object arg2);\n\tpublic void trace(String format, Object[] argArray);\n\tpublic void trace(String msg, Throwable t);\n\tpublic boolean isDebugEnabled();\n\tpublic void debug(String msg);\n\tpublic void debug(String format, Object arg);\n\tpublic void debug(String format, Object arg1, Object arg2)\n\tpublic void debug(String format, Object[] argArray)\n\tpublic void debug(String msg, Throwable t);\n\t&#x2F;&#x2F;...省略info、warn、error等一堆接口\n&#125;\n\n&#x2F;&#x2F; log4j日志框架的适配器\n&#x2F;&#x2F; Log4jLoggerAdapter实现了LocationAwareLogger接口，\n&#x2F;&#x2F; 其中LocationAwareLogger继承自Logger接口，\n&#x2F;&#x2F; 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n\timplements LocationAwareLogger, Serializable &#123;\n\tfinal transient org.apache.log4j.Logger logger; &#x2F;&#x2F; log4j\n\tpublic boolean isDebugEnabled() &#123;\n\t\treturn logger.isDebugEnabled();\n\t&#125;\n\tpublic void debug(String msg) &#123;\n\t\tlogger.log(FQCN, Level.DEBUG, msg, null);\n\t&#125;\n\tpublic void debug(String format, Object arg) &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tFormattingTuple ft &#x3D; MessageFormatter.format(format, arg);\n\t\t\tlogger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n\t\t&#125;\n\t&#125;\n\tpublic void debug(String format, Object arg1, Object arg2) &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tFormattingTuple ft &#x3D; MessageFormatter.format(format, arg1, arg2);\n\t\t\tlogger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n\t\t&#125;\n\t&#125;\n\tpublic void debug(String format, Object[] argArray) &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tFormattingTuple ft &#x3D; MessageFormatter.arrayFormat(format, argArray);\n\t\t\tlogger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n\t\t&#125;\n\t&#125;\n\tpublic void debug(String msg, Throwable t) &#123;\n\t\tlogger.log(FQCN, Level.DEBUG, msg, t);\n\t&#125;\n\t&#x2F;&#x2F;...省略一堆接口的实现...\n&#125;</code></pre>\n\n<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术），只需要将相应的 SDK 导入到项目中即可</p>\n<p>如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，就能成功将 log4j 切换为了 logback</p>\n<h2 id=\"4-4-代理、桥接、装饰器、适配器-4-种设计模式的区别\"><a href=\"#4-4-代理、桥接、装饰器、适配器-4-种设计模式的区别\" class=\"headerlink\" title=\"4.4 代理、桥接、装饰器、适配器 4 种设计模式的区别\"></a>4.4 代理、桥接、装饰器、适配器 4 种设计模式的区别</h2><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类</p>\n<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别</p>\n<p><strong>代理模式：</strong> 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同</p>\n<p><strong>桥接模式：</strong> 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变</p>\n<p><strong>装饰器模式：</strong> 装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用</p>\n<p><strong>适配器模式：</strong> 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口</p>\n<h1 id=\"5-门面-x2F-外观模式（Facade-Design-Pattern）\"><a href=\"#5-门面-x2F-外观模式（Facade-Design-Pattern）\" class=\"headerlink\" title=\"5. 门面&#x2F;外观模式（Facade Design Pattern）\"></a>5. 门面&#x2F;外观模式（Facade Design Pattern）</h1><p>如果平时的工作涉及接口开发，不知道你有没有遇到关于接口粒度的问题呢？</p>\n<p>为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，责任单一一点，但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用</p>\n<p>相反，如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。那如何来解决接口的可复用性（通用性）和易用性之间的矛盾呢？</p>\n<h2 id=\"5-1-原理与实现\"><a href=\"#5-1-原理与实现\" class=\"headerlink\" title=\"5.1 原理与实现\"></a>5.1 原理与实现</h2><p>门面模式，也叫外观模式，英文全称是 Facade Design Pattern。在 GoF 的《设计模式》一书中，门面模式是这样定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.<br>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用</p></blockquote>\n<p>假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用</p>\n<p>这时可能会有这样的疑问，让系统 B 直接调用 a、b、d 感觉没有太大问题呀，为什么还要提供一个包裹 a、b、d 的接口 x 呢？</p>\n<p>假设刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过后端服务器提供的接口来获取数据。App 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之间的网络通信次数</p>\n<p>假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接口，因自身业务的特点，不支持并发调用这三个接口</p>\n<p>如果现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度</p>\n<p>这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应用场景下，使用门面模式的意图也不同</p>\n<h2 id=\"5-2-应用场景\"><a href=\"#5-2-应用场景\" class=\"headerlink\" title=\"5.2 应用场景\"></a>5.2 应用场景</h2><p>在 GoF 给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。除此之外，还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块</p>\n<p><strong>1、解决易用性问题</strong></p>\n<p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互</p>\n<p>设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节</p>\n<p><strong>2、解决性能问题</strong></p>\n<p>关于利用门面模式解决性能问题这一点，前面已经讲过了。通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。现在来讨论一下这样一个问题：从代码实现的角度来看，该如何组织门面接口和非门面接口？</p>\n<p>如果门面接口不多，完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口放到一个新的子系统中</p>\n<p><strong>3、解决分布式事务问题</strong></p>\n<p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）</p>\n<p>对于这样一个简单的业务需求，可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败</p>\n<p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作</p>\n<h1 id=\"6-组合模式（Composite-Design-Pattern）\"><a href=\"#6-组合模式（Composite-Design-Pattern）\" class=\"headerlink\" title=\"6. 组合模式（Composite Design Pattern）\"></a>6. 组合模式（Composite Design Pattern）</h1><p>组合模式跟之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，可以简单理解为一组对象集合</p>\n<p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁</p>\n<h2 id=\"6-1-原理与实现\"><a href=\"#6-1-原理与实现\" class=\"headerlink\" title=\"6.1 原理与实现\"></a>6.1 原理与实现</h2><p>在 GoF 的《设计模式》一书中，组合模式是这样定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.<br>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者）可以统一单个对象和组合对象的处理逻辑</p></blockquote>\n<p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p>\n<ul>\n<li>动态地添加、删除某个目录下的子目录或文件</li>\n<li>统计指定目录下的文件个数</li>\n<li>统计指定目录下的文件总大小</li>\n</ul>\n<p>骨架代码如下所示，其中的核心逻辑并未实现。在下面的代码实现中，把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FileSystemNode &#123;\n\tprivate String path;\n\tprivate boolean isFile;\n\tprivate List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\tpublic FileSystemNode(String path, boolean isFile) &#123;\n\t\tthis.path &#x3D; path;\n\t\tthis.isFile &#x3D; isFile;\n\t&#125;\n\tpublic int countNumOfFiles() &#123;\n\t\t&#x2F;&#x2F; TODO:...\n\t&#125;\n\tpublic long countSizeOfFiles() &#123;\n\t\t&#x2F;&#x2F; TODO:...\n\t&#125;\n\tpublic String getPath() &#123;\n\t\treturn path;\n\t&#125;\n\tpublic void addSubNode(FileSystemNode fileOrDir) &#123;\n\t\tsubNodes.add(fileOrDir);\n\t&#125;\n\tpublic void removeSubNode(FileSystemNode fileOrDir) &#123;\n\t\tint size &#x3D; subNodes.size();\n\t\tint i &#x3D; 0;\n\t\tfor (; i &lt; size; ++i) &#123;\n\t\t\tif (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (i &lt; size) &#123;\n\t\t\tsubNodes.remove(i);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p><code>countNumOfFiles()</code> 和 <code>countSizeOfFiles()</code> 这两个函数，实际上这就是树的递归遍历算法。对于文件，可以直接返回文件的个数（返回 1）或大小。对于目录，遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int countNumOfFiles() &#123;\n\tif (isFile) &#123;\n\t\treturn 1;\n\t&#125;\n\tint numOfFiles &#x3D; 0;\n\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\tnumOfFiles +&#x3D; fileOrDir.countNumOfFiles();\n\t&#125;\n\treturn numOfFiles;\n&#125;\npublic long countSizeOfFiles() &#123;\n\tif (isFile) &#123;\n\t\tFile file &#x3D; new File(path);\n\t\tif (!file.exists()) return 0;\n\t\treturn file.length();\n\t&#125;\n\tlong sizeofFiles &#x3D; 0;\n\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\tsizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();\n\t&#125;\n\treturn sizeofFiles;\n&#125;</code></pre>\n\n<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了想要的功能。但是，如果开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，最好对文件和目录进行区分设计，定义为 File 和 Directory两个类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class FileSystemNode &#123;\n\tprotected String path;\n\tpublic FileSystemNode(String path) &#123;\n\t\tthis.path &#x3D; path;\n\t&#125;\n\tpublic abstract int countNumOfFiles();\n\tpublic abstract long countSizeOfFiles();\n\tpublic String getPath() &#123;\n\t\treturn path;\n\t&#125;\n&#125;\npublic class File extends FileSystemNode &#123;\n\tpublic File(String path) &#123;\n\t\tsuper(path);\n\t&#125;\n\t@Override\n\tpublic int countNumOfFiles() &#123;\n\t\treturn 1;\n\t&#125;\n\t@Override\n\tpublic long countSizeOfFiles() &#123;\n\t\tjava.io.File file &#x3D; new java.io.File(path);\n\t\tif (!file.exists()) return 0;\n\t\treturn file.length();\n\t&#125;\n&#125;\npublic class Directory extends FileSystemNode &#123;\n\tprivate List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\tpublic Directory(String path) &#123;\n\t\tsuper(path);\n\t&#125;\n\t@Override\n\tpublic int countNumOfFiles() &#123;\n\t\tint numOfFiles &#x3D; 0;\n\t\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\t\tnumOfFiles +&#x3D; fileOrDir.countNumOfFiles();\n\t\t&#125;\n\t\treturn numOfFiles;\n\t&#125;\n\t@Override\n\tpublic long countSizeOfFiles() &#123;\n\t\tlong sizeofFiles &#x3D; 0;\n\t\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\t\tsizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();\n\t\t&#125;\n\t\treturn sizeofFiles;\n\t&#125;\n\tpublic void addSubNode(FileSystemNode fileOrDir) &#123;\n\t\tsubNodes.add(fileOrDir);\n\t&#125;\n\tpublic void removeSubNode(FileSystemNode fileOrDir) &#123;\n\t\tint size &#x3D; subNodes.size();\n\t\tint i &#x3D; 0;\n\t\tfor (; i &lt; size; ++i) &#123;\n\t\t\tif (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (i &lt; size) &#123;\n\t\t\tsubNodes.remove(i);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>文件和目录类都设计好了，现在来看如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;**\n\t\t* &#x2F;\n\t\t* &#x2F;wz&#x2F;\n\t\t* &#x2F;wz&#x2F;a.txt\n\t\t* &#x2F;wz&#x2F;b.txt\n\t\t* &#x2F;wz&#x2F;movies&#x2F;\n\t\t* &#x2F;wz&#x2F;movies&#x2F;c.avi\n\t\t* &#x2F;xzg&#x2F;\n\t\t* &#x2F;xzg&#x2F;docs&#x2F;\n\t\t* &#x2F;xzg&#x2F;docs&#x2F;d.txt\n\t\t*&#x2F;\n\t\tDirectory fileSystemTree &#x3D; new Directory(&quot;&#x2F;&quot;);\n\t\tDirectory node_wz &#x3D; new Directory(&quot;&#x2F;wz&#x2F;&quot;);\n\t\tDirectory node_xzg &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;&quot;);\n\t\tfileSystemTree.addSubNode(node_wz);\n\t\tfileSystemTree.addSubNode(node_xzg);\n\t\tFile node_wz_a &#x3D; new File(&quot;&#x2F;wz&#x2F;a.txt&quot;);\n\t\tFile node_wz_b &#x3D; new File(&quot;&#x2F;wz&#x2F;b.txt&quot;);\n\t\tDirectory node_wz_movies &#x3D; new Directory(&quot;&#x2F;wz&#x2F;movies&#x2F;&quot;);\n\t\tnode_wz.addSubNode(node_wz_a);\n\t\tnode_wz.addSubNode(node_wz_b);\n\t\tnode_wz.addSubNode(node_wz_movies);\n\t\tFile node_wz_movies_c &#x3D; new File(&quot;&#x2F;wz&#x2F;movies&#x2F;c.avi&quot;);\n\t\tnode_wz_movies.addSubNode(node_wz_movies_c);\n\t\tDirectory node_xzg_docs &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;docs&#x2F;&quot;);\n\t\tnode_xzg.addSubNode(node_xzg_docs);\n\t\tFile node_xzg_docs_d &#x3D; new File(&quot;&#x2F;xzg&#x2F;docs&#x2F;d.txt&quot;);\n\t\tnode_xzg_docs.addSubNode(node_xzg_docs_d);\n\t\tSystem.out.println(&quot;&#x2F; files num:&quot; + fileSystemTree.countNumOfFiles());\n\t\tSystem.out.println(&quot;&#x2F;wz&#x2F; files num:&quot; + node_wz.countNumOfFiles());\n\t&#125;\n&#125;</code></pre>\n\n<p>对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现</p>\n<h2 id=\"6-2-应用场景\"><a href=\"#6-2-应用场景\" class=\"headerlink\" title=\"6.2 应用场景\"></a>6.2 应用场景</h2><p>假设在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d42a6aeefdd3499ca190c83d1f258bd3.png\" alt=\"在这里插入图片描述\"></p>\n<p>现在希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）</p>\n<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现</p>\n<p>示例代码如下，其中，HumanResource 是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责从数据库中读取数据并在内存中构建组织架构图</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class HumanResource &#123;\n\tprotected long id;\n\tprotected double salary;\n\tpublic HumanResource(long id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\tpublic long getId() &#123;\n\t\treturn id;\n\t&#125;\n\tpublic abstract double calculateSalary();\n&#125;\npublic class Employee extends HumanResource &#123;\n\tpublic Employee(long id, double salary) &#123;\n\t\tsuper(id);\n\t\tthis.salary &#x3D; salary;\n\t&#125;\n\t@Override\n\tpublic double calculateSalary() &#123;\n\t\treturn salary;\n\t&#125;\n&#125;\npublic class Department extends HumanResource &#123;\n\tprivate List&lt;HumanResource&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\tpublic Department(long id) &#123;\n\t\tsuper(id);\n\t&#125;\n\t@Override\n\tpublic double calculateSalary() &#123;\n\t\tdouble totalSalary &#x3D; 0;\n\t\tfor (HumanResource hr : subNodes) &#123;\n\t\t\ttotalSalary +&#x3D; hr.calculateSalary();\n\t\t&#125;\n\t\tthis.salary &#x3D; totalSalary;\n\t\treturn totalSalary;\n\t&#125;\n\tpublic void addSubNode(HumanResource hr) &#123;\n\t\tsubNodes.add(hr);\n\t&#125;\n&#125;\n&#x2F;&#x2F; 构建组织架构的代码\npublic class Demo &#123;\n\tprivate static final long ORGANIZATION_ROOT_ID &#x3D; 1001;\n\tprivate DepartmentRepo departmentRepo; &#x2F;&#x2F; 依赖注入\n\tprivate EmployeeRepo employeeRepo; &#x2F;&#x2F; 依赖注入\n\tpublic void buildOrganization() &#123;\n\t\tDepartment rootDepartment &#x3D; new Department(ORGANIZATION_ROOT_ID);\n\t\tbuildOrganization(rootDepartment);\n\t&#125;\n\tprivate void buildOrganization(Department department) &#123;\n\t\tList&lt;Long&gt; subDepartmentIds &#x3D; departmentRepo.getSubDepartmentIds(department);\n\t\tfor (Long subDepartmentId : subDepartmentIds) &#123;\n\t\tDepartment subDepartment &#x3D; new Department(subDepartmentId);\n\t\t\tdepartment.addSubNode(subDepartment);\n\t\t\tbuildOrganization(subDepartment);\n\t\t&#125;\n\t\tList&lt;Long&gt; employeeIds &#x3D; employeeRepo.getDepartmentEmployeeIds(department.getId());\n\t\tfor (Long employeeId : employeeIds) &#123;\n\t\tdouble salary &#x3D; employeeRepo.getEmployeeSalary(employeeId);\n\t\t\tdepartment.addSubNode(new Employee(employeeId, salary));\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p>\n<h1 id=\"7-享元模式（Flyweight-Design-Pattern）\"><a href=\"#7-享元模式（Flyweight-Design-Pattern）\" class=\"headerlink\" title=\"7. 享元模式（Flyweight Design Pattern）\"></a>7. 享元模式（Flyweight Design Pattern）</h1><h2 id=\"7-1-原理与实现\"><a href=\"#7-1-原理与实现\" class=\"headerlink\" title=\"7.1 原理与实现\"></a>7.1 原理与实现</h2><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象</p>\n<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元</p>\n<p>定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 <code>set()</code> 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码</p>\n<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChessPiece &#123;&#x2F;&#x2F;棋子\n\tprivate int id;\n\tprivate String text;\n\tprivate Color color;\n\tprivate int positionX;\n\tprivate int positionY;\n\tpublic ChessPiece(int id, String text, Color color, int positionX, int positionY) &#123;\n\t\tthis.id &#x3D; id;\n\t\tthis.text &#x3D; text;\n\t\tthis.color &#x3D; color;\n\t\tthis.positionX &#x3D; positionX;\n\t\tthis.positionY &#x3D; positionX;\n\t&#125;\n\tpublic static enum Color &#123;\n\t\tRED, BLACK\n\t&#125;\n\t&#x2F;&#x2F; ...省略其他属性和getter&#x2F;setter方法...\n&#125;\npublic class ChessBoard &#123;&#x2F;&#x2F;棋局\n\tprivate Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\tpublic ChessBoard() &#123;\n\t\tinit();\n\t&#125;\n\tprivate void init() &#123;\n\t\tchessPieces.put(1, new ChessPiece(1, &quot;車&quot;, ChessPiece.Color.BLACK, 0, 0));\n\t\tchessPieces.put(2, new ChessPiece(2,&quot;馬&quot;, ChessPiece.Color.BLACK, 0, 1));\n\t\t&#x2F;&#x2F;...省略摆放其他棋子的代码...\n\t&#125;\n\tpublic void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n\t\t&#x2F;&#x2F;...省略...\n\t&#125;\n&#125;</code></pre>\n\n<p>为了记录每个房间当前的棋局情况，需要给每个房间都创建一个 ChessBoard 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？</p>\n<p>这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 享元类\npublic class ChessPieceUnit &#123;\n\tprivate int id;\n\tprivate String text;\n\tprivate Color color;\n\tpublic ChessPieceUnit(int id, String text, Color color) &#123;\n\t\tthis.id &#x3D; id;\n\t\tthis.text &#x3D; text;\n\t\tthis.color &#x3D; color;\n\t&#125;\n\tpublic static enum Color &#123;\n\t\tRED, BLACK\n\t&#125;\n\t&#x2F;&#x2F; ...省略其他属性和getter方法...\n&#125;\npublic class ChessPieceUnitFactory &#123;\n\tprivate static final Map&lt;Integer, ChessPieceUnit&gt; pieces &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tpieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));\n\t\tpieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));\n\t\t&#x2F;&#x2F;...省略摆放其他棋子的代码...\n\t&#125;\n\tpublic static ChessPieceUnit getChessPiece(int chessPieceId) &#123;\n\t\treturn pieces.get(chessPieceId);\n\t&#125;\n&#125;\npublic class ChessPiece &#123;\n\tprivate ChessPieceUnit chessPieceUnit;\n\tprivate int positionX;\n\tprivate int positionY;\n\tpublic ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;\n\t\tthis.chessPieceUnit &#x3D; unit;\n\t\tthis.positionX &#x3D; positionX;\n\t\tthis.positionY &#x3D; positionY;\n\t&#125;\n\t&#x2F;&#x2F; 省略getter、setter方法\n&#125;\npublic class ChessBoard &#123;\n\tprivate Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\tpublic ChessBoard() &#123;\n\t\tinit();\n\t&#125;\n\tprivate void init() &#123;\n\t\tchessPieces.put(1, new ChessPiece(\n\t\t                    ChessPieceUnitFactory.getChessPiece(1), 0,0));\n\t\tchessPieces.put(1, new ChessPiece(\n\t\t                    ChessPieceUnitFactory.getChessPiece(2), 1,0));\n\t\t&#x2F;&#x2F;...省略摆放其他棋子的代码...\n\t&#125;\n\tpublic void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n\t\t&#x2F;&#x2F;...省略...\n\t&#125;\n&#125;</code></pre>\n\n<p>在上面的代码实现中，利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存</p>\n<p>总结一下它的代码结构。实际上，代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的</p>\n<h2 id=\"7-2-在文本编辑器中的应用\"><a href=\"#7-2-在文本编辑器中的应用\" class=\"headerlink\" title=\"7.2 在文本编辑器中的应用\"></a>7.2 在文本编辑器中的应用</h2><p>可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息</p>\n<p>尽管在实际的文档编写中，一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Character &#123;&#x2F;&#x2F;文字\n\tprivate char c;\n\tprivate Font font;\n\tprivate int size;\n\tprivate int colorRGB;\n\tpublic Character(char c, Font font, int size, int colorRGB) &#123;\n\t\tthis.c &#x3D; c;\n\t\tthis.font &#x3D; font;\n\t\tthis.size &#x3D; size;\n\t\tthis.colorRGB &#x3D; colorRGB;\n\t&#125;\n&#125;\npublic class Editor &#123;\n\tprivate List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\tpublic void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n\t\tCharacter character &#x3D; new Character(c, font, size, colorRGB);\n\t\tchars.add(character);\n\t&#125;\n&#125;</code></pre>\n\n<p>在文本编辑器中，每敲一个文字，都会调用 Editor 类中的 <code>appendCharacter()</code> 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那就要在内存中存储这么多 Character 对象。那有没有办法可以节省一点内存呢？</p>\n<p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，对上面的代码进行重构。重构后的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CharacterStyle &#123;\n\tprivate Font font;\n\tprivate int size;\n\tprivate int colorRGB;\n\tpublic CharacterStyle(Font font, int size, int colorRGB) &#123;\n\t\tthis.font &#x3D; font;\n\t\tthis.size &#x3D; size;\n\t\tthis.colorRGB &#x3D; colorRGB;\n\t&#125;\n\t@Override\n\tpublic boolean equals(Object o) &#123;\n\t\tCharacterStyle otherStyle &#x3D; (CharacterStyle) o;\n\t\treturn font.equals(otherStyle.font)\n\t\t       &amp;&amp; size &#x3D;&#x3D; otherStyle.size\n\t\t       &amp;&amp; colorRGB &#x3D;&#x3D; otherStyle.colorRGB;\n\t&#125;\n&#125;\npublic class CharacterStyleFactory &#123;\n\tprivate static final List&lt;CharacterStyle&gt; styles &#x3D; new ArrayList&lt;&gt;();\n\tpublic static CharacterStyle getStyle(Font font, int size, int colorRGB) &#123;\n\t\tCharacterStyle newStyle &#x3D; new CharacterStyle(font, size, colorRGB);\n\t\tfor (CharacterStyle style : styles) &#123;\n\t\t\tif (style.equals(newStyle)) &#123;\n\t\t\t\treturn style;\n\t\t\t&#125;\n\t\t&#125;\n\t\tstyles.add(newStyle);\n\t\treturn newStyle;\n\t&#125;\n&#125;\npublic class Character &#123;\n\tprivate char c;\n\tprivate CharacterStyle style;\n\tpublic Character(char c, CharacterStyle style) &#123;\n\t\tthis.c &#x3D; c;\n\t\tthis.style &#x3D; style;\n\t&#125;\n&#125;\npublic class Editor &#123;\n\tprivate List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\tpublic void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n\t\tCharacter character &#x3D; new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB);\n\t\tchars.add(character);\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"7-3-享元模式-vs-单例、缓存、对象池\"><a href=\"#7-3-享元模式-vs-单例、缓存、对象池\" class=\"headerlink\" title=\"7.3 享元模式 vs 单例、缓存、对象池\"></a>7.3 享元模式 vs 单例、缓存、对象池</h2><p><strong>1、享元模式跟单例的区别</strong></p>\n<p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例</p>\n<p>但区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数</p>\n<p><strong>2、享元模式跟缓存的区别</strong></p>\n<p>在享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。平时所讲的缓存，主要是为了提高访问效率，而非复用</p>\n<p><strong>3、享元模式跟对象池的区别</strong></p>\n<p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</p>\n<p>很多人可能对连接池、线程池比较熟悉，对对象池比较陌生，这里简单解释一下对象池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉</p>\n<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念</p>\n<p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间</p>\n<h2 id=\"7-4-在-Java-Integer-中的应用\"><a href=\"#7-4-在-Java-Integer-中的应用\" class=\"headerlink\" title=\"7.4 在 Java Integer 中的应用\"></a>7.4 在 Java Integer 中的应用</h2><p>先来看下面这样一段代码，思考下这段代码会输出什么样的结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i1 &#x3D; 56;\nInteger i2 &#x3D; 56;\nInteger i3 &#x3D; 129;\nInteger i4 &#x3D; 129;\nSystem.out.println(i1 &#x3D;&#x3D; i2);\nSystem.out.println(i3 &#x3D;&#x3D; i4);</code></pre>\n\n<p>如果不熟悉 Java 语言，可能会觉得，i1 和 i2 值都是 56，i3 和 i4 值都是 129，i1 跟 i2值相等，i3 跟 i4 值相等，所以输出结果应该是两个 true。这样的分析是不对的，要正确地分析上面的代码，需要弄清楚下面两个问题：</p>\n<ul>\n<li>如何判定两个 Java 对象是否相等（也就代码中的“&#x3D;&#x3D;”操作符的含义）？</li>\n<li>什么是自动装箱（Autoboxing）和自动拆箱（Unboxing）？</li>\n</ul>\n<p>Java 为基本数据类型提供了对应的包装器类型。具体如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/df403d510e034967b447e9d7b036068d.png\" alt=\"在这里插入图片描述\"></p>\n<p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型。具体的代码示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i &#x3D; 56; &#x2F;&#x2F;自动装箱\nint j &#x3D; i; &#x2F;&#x2F;自动拆箱</code></pre>\n\n<p>数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语句：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i &#x3D; 59; 底层执行了: Integer i &#x3D; Integer.valueOf(59);</code></pre>\n\n<p>反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int j &#x3D; i; 底层执行了: int j &#x3D; i.intValue();</code></pre>\n\n<p>弄清楚了自动装箱和自动拆箱，再来看，如何判定两个对象是否相等？不过，在此之前，先要搞清楚，Java 对象在内存中是如何存储的。如下例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">User a &#x3D; new User(123, 23); &#x2F;&#x2F; id&#x3D;123, age&#x3D;23</code></pre>\n\n<p>a 存储的值是 User 对象的内存地址，在图中就表现为 a 指向 User 对象。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/057f3e17c24e4f528fad74cc7d3c9044.png\" alt=\"在这里插入图片描述\"></p>\n<p>当通过“&#x3D;&#x3D;”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象</p>\n<p>再来看之前的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i1 &#x3D; 56;\nInteger i2 &#x3D; 56;\nInteger i3 &#x3D; 129;\nInteger i4 &#x3D; 129;\nSystem.out.println(i1 &#x3D;&#x3D; i2);\nSystem.out.println(i3 &#x3D;&#x3D; i4);</code></pre>\n\n<p>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、i3、i4 这四个变量。根据刚刚的讲解，i1、i2 尽管存储的数值相同，都是 56，但是指向不同的 Integer 对象，所以通过“&#x3D;&#x3D;”来判定是否相同的时候，会返回 false。同理，<code>i3==i4</code> 判定语句也会返回 false</p>\n<p>不过，上面的分析还是不对，答案并非是两个 false，而是一个 true，一个 false。看到这里可能会比较纳闷了。实际上，这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果。当通过自动装箱，也就是调用 <code>valueOf()</code> 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 <code>valueOf()</code> 函数的具体代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static Integer valueOf(int i) &#123;\n    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;</code></pre>\n\n<p>实际上，这里的 IntegerCache 相当于前面讲的生成享元对象的工厂类，只不过名字不叫 xxxFactory 而已。下面来看它的具体代码实现。这个类是 Integer 的内部类，也可以自行查看 JDK 源码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Cache to support the object identity semantics of autoboxing for values betw\n* -128 and 127 (inclusive) as required by JLS.\n*\n* The cache is initialized on first usage. The size of the cache\n* may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125; option.\n* During VM initialization, java.lang.Integer.IntegerCache.high property\n* may be set and saved in the private system properties in the\n* sun.misc.VM class.\n*&#x2F;\nprivate static class IntegerCache &#123;\n\tstatic final int low &#x3D; -128;\n\tstatic final int high;\n\tstatic final Integer cache[];\n\tstatic &#123;\n\t\t&#x2F;&#x2F; high value may be configured by property\n\t\tint h &#x3D; 127;\n\t\tString integerCacheHighPropValue &#x3D;\n\t\t    sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;)\n\t\tif (integerCacheHighPropValue !&#x3D; null) &#123;\n\t\t\ttry &#123;\n\t\t\t\tint i &#x3D; parseInt(integerCacheHighPropValue);\n\t\t\t\ti &#x3D; Math.max(i, 127);\n\t\t\t\t&#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE\n\t\t\t\th &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);\n\t\t\t&#125; catch( NumberFormatException nfe) &#123;\n\t\t\t\t&#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.\n\t\t\t&#125;\n\t\t&#125;\n\t\thigh &#x3D; h;\n\t\tcache &#x3D; new Integer[(high - low) + 1];\n\t\tint j &#x3D; low;\n\t\tfor(int k &#x3D; 0; k &lt; cache.length; k++)\n\t\t\tcache[k] &#x3D; new Integer(j++);\n\t\t&#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)\n\t\tassert IntegerCache.high &gt;&#x3D; 127;\n\t&#125;\n\tprivate IntegerCache() &#123;&#125;\n&#125;</code></pre>\n\n<p>为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？</p>\n<p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）</p>\n<p>实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没有提供设置最小值的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;方法一：\n-Djava.lang.Integer.IntegerCache.high&#x3D;255\n&#x2F;&#x2F;方法二：\n-XX:AutoBoxCacheMax&#x3D;255</code></pre>\n\n<p>实际上，除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据。比如，Long 类型对应的 LongCache 享元工厂类及 <code>valueOf()</code> 函数代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static class LongCache &#123;\n\tprivate LongCache() &#123;&#125;\n\tstatic final Long cache[] &#x3D; new Long[-(-128) + 127 + 1];\n\tstatic &#123;\n\t\tfor(int i &#x3D; 0; i &lt; cache.length; i++)\n\t\t\tcache[i] &#x3D; new Long(i - 128);\n\t&#125;\n&#125;\npublic static Long valueOf(long l) &#123;\n\tfinal int offset &#x3D; 128;\n\tif (l &gt;&#x3D; -128 &amp;&amp; l &lt;&#x3D; 127) &#123; &#x2F;&#x2F; will cache\n\t\treturn LongCache.cache[(int)l + offset];\n\t&#125;\n\treturn new Long(l);\n&#125;</code></pre>\n\n<p>在平时的开发中，对于下面这样三种创建整型对象的方式，优先使用后两种：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer a &#x3D; new Integer(123);\nInteger a &#x3D; 123;\nInteger a &#x3D; Integer.valueOf(123);</code></pre>\n\n<p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，最多只需要分配 256 个 Integer 对象的内存空间</p>\n<h2 id=\"7-5-在-Java-String-中的应用\"><a href=\"#7-5-在-Java-String-中的应用\" class=\"headerlink\" title=\"7.5 在 Java String 中的应用\"></a>7.5 在 Java String 中的应用</h2><p>同样，还是先来看一段代码，这段代码输出的结果是什么呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; &quot;小争哥&quot;;\nString s2 &#x3D; &quot;小争哥&quot;;\nString s3 &#x3D; new String(&quot;小争哥&quot;);\nSystem.out.println(s1 &#x3D;&#x3D; s2);\nSystem.out.println(s1 &#x3D;&#x3D; s3);</code></pre>\n\n<p>上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存储结构如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/19396b9d848a4042b33c6b20a1544d33.png\" alt=\"在这里插入图片描述\"></p>\n<p>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了</p>\n<p>实际上，享元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反倒可能会浪费更多的内存。所以，除非经过线上验证，利用享元模式真的可以大大节省内存，否则，就不要过度使用这个模式，为了一点点内存的节省而引入一个复杂的设计模式，得不偿失</p>\n","feature":false,"text":"前四篇见： 设计模式之美总结（面向对象篇）_凡 223 的博客 设计模式之美总结（设计原则篇）_凡 223 的博客 设计模式之美总结（重构篇）_凡 223 的博客 设计模式之美总结（创建型篇）_凡 223 的博客 1. 代理模式（Proxy Design Pattern）1.1 ...","link":"","photos":[],"count_time":{"symbolsCount":"61k","symbolsTime":"55 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">1. 代理模式（Proxy Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">1.1 原理解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">1.2 动态代理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.3 应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%A1%A5%E6%8E%A5-x2F-%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2. 桥接&#x2F;桥梁模式（Bridge Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">2.1 原理解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">2.2 应用举例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3. 装饰器模式（Decorator Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Java-IO-%E7%B1%BB\"><span class=\"toc-text\">3.1 Java IO 类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E5%9F%BA%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">3.2 基于继承的设计方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%9F%BA%E4%BA%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">3.3 基于装饰器模式的设计方案</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">4. 适配器模式（Adapter Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.1 原理与实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">4.2 应用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-Java-%E6%97%A5%E5%BF%97%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.3 适配器模式在 Java 日志中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E4%BB%A3%E7%90%86%E3%80%81%E6%A1%A5%E6%8E%A5%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8-4-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.4 代理、桥接、装饰器、适配器 4 种设计模式的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E9%97%A8%E9%9D%A2-x2F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">5. 门面&#x2F;外观模式（Facade Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">5.1 原理与实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">5.2 应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">6. 组合模式（Composite Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">6.1 原理与实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">6.2 应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">7. 享元模式（Flyweight Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">7.1 原理与实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E5%9C%A8%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">7.2 在文本编辑器中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-vs-%E5%8D%95%E4%BE%8B%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B1%A0\"><span class=\"toc-text\">7.3 享元模式 vs 单例、缓存、对象池</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-%E5%9C%A8-Java-Integer-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">7.4 在 Java Integer 中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-5-%E5%9C%A8-Java-String-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">7.5 在 Java String 中的应用</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"SpringBoot 结合 MyBatis-Plus 配置多数据源以及结合 p6spy 打印 SQL 日志","uid":"0e3cbfa1ef18be6a0efacfe867734435","slug":"BlogRepository/开发技术及框架/SpringBoot 结合 MyBatis-Plus 配置多数据源以及结合 p6spy 打印 SQL 日志","date":"2022-12-23T03:23:16.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/SpringBoot 结合 MyBatis-Plus 配置多数据源以及结合 p6spy 打印 SQL 日志.json","keywords":null,"cover":"https://cover.png","text":"1. 配置多数据源官网：多数据源 | MyBatis-Plus (baomidou.com) 1.1 引入依赖&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":8,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","count":2,"path":"api/tags/MyBatis-Plus.json"},{"name":"SpringBoot","slug":"SpringBoot","count":4,"path":"api/tags/SpringBoot.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"Vue3 总结（开发）","uid":"6c3cfbb59bb90aa0cd86d47a59e86094","slug":"BlogRepository/Vue/Vue3 总结（开发）","date":"2022-12-20T16:57:55.000Z","updated":"2023-03-13T19:13:04.944Z","comments":true,"path":"api/articles/BlogRepository/Vue/Vue3 总结（开发）.json","keywords":null,"cover":"https://cover.png","text":"更详细的 API 和使用见：Vue2 总结（开发）_凡 223 的博客 1. Vue Router官网地址：Home | Vue Router (vuejs.org) 1.1 安装npm install vue-router@4 1.2 使用1.2.1 new Router 变成...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}