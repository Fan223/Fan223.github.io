{"title":"23 种设计模式总结","uid":"2236ff817b0fd532c388d0cf8bb4c954","slug":"BlogRepository/设计模式/23 种设计模式总结","date":"2022-12-30T08:53:46.000Z","updated":"2023-03-13T19:13:04.964Z","comments":true,"path":"api/articles/BlogRepository/设计模式/23 种设计模式总结.json","keywords":null,"cover":"https://cover.png","content":"<p><strong>设计模式相关的详细知识见如下三篇：</strong></p>\n<ul>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127668978\">设计模式之美总结（创建型篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a></strong></li>\n</ul>\n<p>这里主要是对上面三篇内容的总结，用于清晰 23 种设计模式的原理概念和应用场景，以及它们之间的异同点，区分 23 种设计模式，对其有一个整体的认知，具体详细实现见上面三篇文章。建议先看完上面三篇文章或者对设计模式有一定了解再来阅读本章内容，对知识做一个归纳汇总，或者也可在本章任一一节末尾点击链接直达对应的详细知识部分</p>\n<h1 id=\"1-创建型\"><a href=\"#1-创建型\" class=\"headerlink\" title=\"1. 创建型\"></a>1. 创建型</h1><p><strong>创建型设计模式主要解决“对象的创建”问题</strong></p>\n<h2 id=\"1-1-单例模式（Singleton-Design-Pattern）\"><a href=\"#1-1-单例模式（Singleton-Design-Pattern）\" class=\"headerlink\" title=\"1.1 单例模式（Singleton Design Pattern）\"></a>1.1 单例模式（Singleton Design Pattern）</h2><h3 id=\"1-1-1-概述与实现\"><a href=\"#1-1-1-概述与实现\" class=\"headerlink\" title=\"1.1.1 概述与实现\"></a>1.1.1 概述与实现</h3><p><strong>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式</strong></p>\n<p><strong>应用场景：</strong></p>\n<ul>\n<li>解决资源访问冲突</li>\n<li>表示全局唯一类</li>\n</ul>\n<p>实现方式：</p>\n<p>1、饿汉式：不支持延迟加载</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>2、懒汉式：支持延迟加载，但可以看到给 <code>getInstance()</code> 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低，有性能问题，不支持高并发</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static synchronized IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new IdGenerator();\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>3、双重检测：既支持延迟加载、又支持高并发</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new IdGenerator();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>4、静态内部类：比双重检测更加简单的实现方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private IdGenerator() &#123;&#125;\n    private static class SingletonHolder&#123;\n        private static final IdGenerator instance &#x3D; new IdGenerator();\n    &#125;\n    public static IdGenerator getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<p>5、枚举：利用 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private IdGenerator() &#123;&#125;\n    private static class SingletonHolder&#123;\n        private static final IdGenerator instance &#x3D; new IdGenerator();\n    &#125;\n    public static IdGenerator getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"1-1-2-多例\"><a href=\"#1-1-2-多例\" class=\"headerlink\" title=\"1.1.2 多例\"></a>1.1.2 多例</h3><p>单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BackendServer &#123;\n\tprivate long serverNo;\n\tprivate String serverAddress;\n\tprivate static final int SERVER_COUNT &#x3D; 3;\n\tprivate static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\n\n\tstatic &#123;\n\t\tserverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n\t\tserverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n\t\tserverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n\t&#125;\n\tprivate BackendServer(long serverNo, String serverAddress) &#123;\n\t\tthis.serverNo &#x3D; serverNo;\n\t\tthis.serverAddress &#x3D; serverAddress;\n\t&#125;\n\tpublic BackendServer getInstance(long serverNo) &#123;\n\t\treturn serverInstances.get(serverNo);\n\t&#125;\n\tpublic BackendServer getRandomInstance() &#123;\n\t\tRandom r &#x3D; new Random();\n\t\tint no &#x3D; r.nextInt(SERVER_COUNT)+1;\n\t\treturn serverInstances.get(no);\n\t&#125;\n&#125;</code></pre>\n\n<p>对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？</p>\n<p>如下例，在代码中，loggerName 就是上面说的“类型”，同一个 loggerName 获取到的对象实例是相同的，不同的 loggerName 获取到的对象实例是不同的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Logger &#123;\n\tprivate static final ConcurrentHashMap&lt;String, Logger&gt; instances\n\t    &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate Logger() &#123;&#125;\n\tpublic static Logger getInstance(String loggerName) &#123;\n\t\tinstances.putIfAbsent(loggerName, new Logger());\n\t\treturn instances.get(loggerName);\n\t&#125;\n\tpublic void log() &#123;\n            &#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</code></pre>\n\n<p><strong>这种多例模式的理解方式有点类似工厂模式</strong>。它跟工厂模式的不同之处在于：</p>\n<ul>\n<li><strong>多例模式创建的对象都是同一个类的对象</strong></li>\n<li><strong>而工厂模式创建的是不同子类的对象</strong></li>\n</ul>\n<p><strong>实际上，它还有点类似享元模式。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象</strong></p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127668978\">设计模式之美总结（创建型篇）_凡 223 的博客</a>** 单例模式部分</p>\n<h2 id=\"1-2-工厂模式（Factory-Design-Pattern）\"><a href=\"#1-2-工厂模式（Factory-Design-Pattern）\" class=\"headerlink\" title=\"1.2 工厂模式（Factory Design Pattern）\"></a>1.2 工厂模式（Factory Design Pattern）</h2><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见</p>\n<h3 id=\"1-2-1-简单工厂（Simple-Factory）\"><a href=\"#1-2-1-简单工厂（Simple-Factory）\" class=\"headerlink\" title=\"1.2.1 简单工厂（Simple Factory）\"></a>1.2.1 简单工厂（Simple Factory）</h3><p>如下，根据不同的后缀名，创建不同的解析器类。这里每次调用 <code>createParser()</code> 方法的时候，都要创建一个新的 parser，把这一种实现方法叫作简单工厂模式的第一种实现方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigParserFactory &#123;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125;\n\t\treturn parser;\n\t&#125;\n&#125;</code></pre>\n\n<p>如果 parser 可以复用，为了节省内存和对象创建的时间，可以将 parser 事先创建好缓存起来，如下。这种实现方法叫作简单工厂模式的第二种实现方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigParserFactory &#123;\n\tprivate static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n\t\tcachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n\t\tcachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n\t\tcachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n\t&#125;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tif (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;\n                        &#x2F;&#x2F; 或抛出 IllegalArgumentException\n\t\t\treturn null;\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());\n\t\treturn parser;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"1-2-2-工厂方法（Factory-Method）\"><a href=\"#1-2-2-工厂方法（Factory-Method）\" class=\"headerlink\" title=\"1.2.2 工厂方法（Factory Method）\"></a>1.2.2 工厂方法（Factory Method）</h3><p>在简单工厂模式的第一种实现方法中，有一组 if 分支逻辑，实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的</p>\n<p>也可以应用多态或设计模式来替代 if 分支判断逻辑，但也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。这里按照多态的实现思路，对上面的代码进行重构</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IRuleConfigParserFactory &#123;\n\tIRuleConfigParser createParser();\n&#125;\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n&#125;\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n&#125;\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new YamlRuleConfigParser();\n\t&#125;\n&#125;\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new PropertiesRuleConfigParser();\n\t&#125;\n&#125;</code></pre>\n\n<p>这就是工厂方法模式的典型代码实现。这样当新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则</strong></p>\n<p>但这些工厂类的使用上存在挺大的问题，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; null;\n\n\t\tif (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new JsonRuleConfigParserFactory();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new XmlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new YamlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new PropertiesRuleConfigParserFactory();\n\t\t&#125; else &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file fo support&quot;)rmat is not</code></pre>\n\n<p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 <code>load()</code> 函数中，跟简单工厂模式的第一种实现方法非常相似。怎么来解决这个问题呢？可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n\t\tif (parserFactory &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file format is not support&quot;);\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; parserFactory.createParser();\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F; 从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F; ...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 因为工厂类只包含方法，不包含成员变量，完全可以复用，不需要每次都创建新的工厂类对象，\n&#x2F;&#x2F; 所以，简单工厂模式的第二种实现思路更加合适\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n\tprivate static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory())\n\t&#125;\n\tpublic static IRuleConfigParserFactory getParserFactory(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\tIRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n\t\treturn parserFactory;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"1-2-3-工厂方法模式-VS-简单工厂模式\"><a href=\"#1-2-3-工厂方法模式-VS-简单工厂模式\" class=\"headerlink\" title=\"1.2.3 工厂方法模式 VS 简单工厂模式\"></a>1.2.3 工厂方法模式 VS 简单工厂模式</h3><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂</p>\n<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果还想避免烦人的 if-else 分支逻辑，这个时候，就推荐使用工厂方法模式</p>\n<h3 id=\"1-2-4-抽象工厂（Abstract-Factory）\"><a href=\"#1-2-4-抽象工厂（Abstract-Factory）\" class=\"headerlink\" title=\"1.2.4 抽象工厂（Abstract Factory）\"></a>1.2.4 抽象工厂（Abstract Factory）</h3><p>在上面简单工厂和工厂方法中，类只有一种分类方式。但是，如果类有两种分类方式，比如上面的解析器例子，假如既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">针对规则配置的解析器: 基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n针对系统配置的解析器: 基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser</code></pre>\n\n<p>如果还是继续用工厂方法来实现的话，要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。过多的类也会让系统难维护。这个问题该怎么解决呢？</p>\n<p>抽象工厂就是针对这种非常特殊的场景而诞生的。可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IConfigParserFactory &#123;\n\tIRuleConfigParser createRuleParser();\n\tISystemConfigParser createSystemParser();\n        &#x2F;&#x2F; 此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new JsonSystemConfigParser();\n\t&#125;\n&#125;\npublic class XmlConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new XmlSystemConfigParser();\n\t&#125;\n&#125;\n&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</code></pre>\n\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127668978\">设计模式之美总结（创建型篇）_凡 223 的博客</a>** 工厂模式部分</p>\n<h2 id=\"1-3-建造者-x2F-构建者-x2F-生成器模式（Builder-Design-Pattern）\"><a href=\"#1-3-建造者-x2F-构建者-x2F-生成器模式（Builder-Design-Pattern）\" class=\"headerlink\" title=\"1.3 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）\"></a>1.3 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）</h2><p>在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。但什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？</p>\n<p>先来看什么是对象的无效状态，如下，定义了一个长方形类，采用先创建后 set 的方式，那就会导致在第一个 set 之前，对象处于无效状态</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Rectangle r &#x3D; new Rectange(); &#x2F;&#x2F; r is invalid\nr.setWidth(2); &#x2F;&#x2F; r is invalid\nr.setHeight(3); &#x2F;&#x2F; r is valid</code></pre>\n\n<p>为了避免这种无效状态的存在，就需要使用构造函数一次性初始化好所有的成员变量。<strong>如果构造函数参数过多，代码在可读性和易用性上都会变差。在使用构造函数的时候，就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug，这时就需要考虑使用建造者模式</strong>，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ResourcePoolConfig &#123;\n\tprivate String name;\n\tprivate int maxTotal;\n\tprivate int maxIdle;\n\tprivate int minIdle;\n\tprivate ResourcePoolConfig(Builder builder) &#123;\n\t\tthis.name &#x3D; builder.name;\n\t\tthis.maxTotal &#x3D; builder.maxTotal;\n\t\tthis.maxIdle &#x3D; builder.maxIdle;\n\t\tthis.minIdle &#x3D; builder.minIdle;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n\t&#x2F;&#x2F; 将Builder类设计成了ResourcePoolConfig的内部类。\n\t&#x2F;&#x2F; 也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n\tpublic static class Builder &#123;\n\t\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\t\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\t\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\t\tprivate String name;\n\t\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\t\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\t\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\t\tpublic ResourcePoolConfig build() &#123;\n\t\t\t&#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (maxIdle &gt; maxTotal) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\treturn new ResourcePoolConfig(this);\n\t\t&#125;\n\t\tpublic Builder setName(String name) &#123;\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.name &#x3D; name;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxTotal(int maxTotal) &#123;\n\t\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxTotal &#x3D; maxTotal;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxIdle(int maxIdle) &#123;\n\t\t\tif (maxIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxIdle &#x3D; maxIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMinIdle(int minIdle) &#123;\n\t\t\tif (minIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.minIdle &#x3D; minIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()\n\t.setName(&quot;dbconnectionpool&quot;)\n\t.setMaxTotal(16)\n\t.setMaxIdle(10)\n\t.setMinIdle(12)\n\t.build();</code></pre>\n\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127668978\">设计模式之美总结（创建型篇）_凡 223 的博客</a>** 建造者模式部分，这里只简要描述</p>\n<h3 id=\"1-3-1-与工厂模式有何区别？\"><a href=\"#1-3-1-与工厂模式有何区别？\" class=\"headerlink\" title=\"1.3.1 与工厂模式有何区别？\"></a>1.3.1 与工厂模式有何区别？</h3><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象</p>\n<p>比如，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨</p>\n<h2 id=\"1-4-原型模式（Prototype-Design-Pattern）\"><a href=\"#1-4-原型模式（Prototype-Design-Pattern）\" class=\"headerlink\" title=\"1.4 原型模式（Prototype Design Pattern）\"></a>1.4 原型模式（Prototype Design Pattern）</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，可以<strong>利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象</strong>，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式</p>\n<p>概念应该不难理解，通过概念应该就大致知道该设计模式的原理和用法，详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127668978\">设计模式之美总结（创建型篇）_凡 223 的博客</a>** 原型模式部分</p>\n<h1 id=\"2-结构型\"><a href=\"#2-结构型\" class=\"headerlink\" title=\"2. 结构型\"></a>2. 结构型</h1><p><strong>结构型设计模式主要解决“类或对象的组合或组装”问题</strong></p>\n<h2 id=\"2-1-代理模式（Proxy-Design-Pattern）\"><a href=\"#2-1-代理模式（Proxy-Design-Pattern）\" class=\"headerlink\" title=\"2.1 代理模式（Proxy Design Pattern）\"></a>2.1 代理模式（Proxy Design Pattern）</h2><p><strong>在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能</strong>。如下例，在 UserController 中实现了接口 IUserController 的 <code>login()</code> 方法，用来处理登录逻辑</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IUserController &#123;\n\tUserVo login(String telephone, String password);\n&#125;\n\npublic class UserController implements IUserController &#123;\n\t&#x2F;&#x2F;...省略其他属性和方法...\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F; ... 省略login逻辑...\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n&#125;</code></pre>\n\n<p>假设要在不改变该方法的情况下，扩展附加功能，比如收集接口请求的原始数据，比如访问时间、处理时长等，这时代理模式就派上用场了</p>\n<p>如下，代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserControllerProxy implements IUserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tprivate UserController userController;\n\n\tpublic UserControllerProxy(UserController userController) &#123;\n\t\tthis.userController &#x3D; userController;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\t@Override\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; 委托\n\t\tUserVo userVo &#x3D; userController.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n&#x2F;&#x2F; 将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController &#x3D; new UserControllerProxy(new UserController())</code></pre>\n\n<p>假如原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。对于这种外部类的扩展，一般都是采用继承的方式。让代理类继承原始类，然后扩展附加功能，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserControllerProxy extends UserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tpublic UserControllerProxy() &#123;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; super.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n&#x2F;&#x2F; UserControllerProxy使用举例\nUserController userController &#x3D; new UserControllerProxy();</code></pre>\n\n<p><strong>应用场景：</strong></p>\n<ol>\n<li>业务系统的非功能性需求开发</li>\n<li>在 RPC 中应用</li>\n<li>在缓存中应用</li>\n</ol>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a>** 代理模式部分</p>\n<h2 id=\"2-2-桥接-x2F-桥梁模式（Bridge-Design-Pattern）\"><a href=\"#2-2-桥接-x2F-桥梁模式（Bridge-Design-Pattern）\" class=\"headerlink\" title=\"2.2 桥接&#x2F;桥梁模式（Bridge Design Pattern）\"></a>2.2 桥接&#x2F;桥梁模式（Bridge Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，桥接模式是这么定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Decouple an abstraction from its implementation so that the two can vary independently.<br>将抽象和实现解耦，让它们可以独立变化</p></blockquote>\n<p>弄懂定义中“抽象”、“实现”和“解耦”三个概念，就是理解桥接模式的关键</p>\n<ul>\n<li>抽象，可以理解为存在于多个实体中的共同的概念性联系，就是忽略一些信息，从而把不同的实体当做同样的实体对待</li>\n<li>实现，即抽象给出的具体实现，可能有多种不同的实现方式</li>\n<li>解耦，所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称解耦。在这里，解耦是指将抽象和实现之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联，即抽象和实现之间使用组合&#x2F;聚合关系而不是继承关系</li>\n</ul>\n<p>建议对照示例来进行理解，具体可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a>** 桥接模式部分</p>\n<h2 id=\"2-3-装饰器模式（Decorator-Design-Pattern）\"><a href=\"#2-3-装饰器模式（Decorator-Design-Pattern）\" class=\"headerlink\" title=\"2.3 装饰器模式（Decorator Design Pattern）\"></a>2.3 装饰器模式（Decorator Design Pattern）</h2><p>装饰器模式和代理模式比较相似，不过在代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class AProxy impements IA &#123;\n\tprivate IA a;\n\tpublic AProxy(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t\ta.f();\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ADecorator impements IA &#123;\n\tprivate IA a;\n\tpublic ADecorator(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 功能增强代码\n\t\ta.f();\n\t\t&#x2F;&#x2F; 功能增强代码\n\t&#125;\n&#125;</code></pre>\n\n<p>还可以进行多重装饰：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Father &#123;\n    public void run() &#123;\n        System.out.println(&quot;Father run&quot;);\n    &#125;\n&#125;\n\nclass Son extends Father&#123;\n    public void run() &#123;\n        System.out.println(&quot;Son run&quot;);\n    &#125;\n&#125;\n\nclass ChildDecorator extends Father &#123;\n    protected Father father;\n\n    public ChildDecorator(Father father) &#123;\n        this.father &#x3D; father;\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;ChildDecorator run&quot;);\n    &#125;\n&#125;\n\nclass Child1 extends ChildDecorator&#123;\n\n    public Child1(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child1 run&quot;);\n    &#125;\n&#125;\n\nclass Child2 extends ChildDecorator &#123;\n\n    public Child2(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child2 run&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        Father son &#x3D; new Son();\n        Father child1 &#x3D; new Child1(son);\n        Child2 child2 &#x3D; new Child2(child1);\n        child2.run();\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/4ab550d914974f239e8b06cdcec6b2f4.png\" alt=\"在这里插入图片描述\"></p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a>** 装饰器模式部分</p>\n<h2 id=\"2-4-适配器模式（Adapter-Design-Pattern）\"><a href=\"#2-4-适配器模式（Adapter-Design-Pattern）\" class=\"headerlink\" title=\"2.4 适配器模式（Adapter Design Pattern）\"></a>2.4 适配器模式（Adapter Design Pattern）</h2><p>顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作</p>\n<p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现</p>\n<p><strong>1、类适配器</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor extends Adaptee implements ITarget &#123;\n\tpublic void f1() &#123;\n\t\tsuper.fa();\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\t&#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;</code></pre>\n\n<p><strong>2、对象适配器</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor implements ITarget &#123;\n\tprivate Adaptee adaptee;\n\tpublic Adaptor(Adaptee adaptee) &#123;\n\t\tthis.adaptee &#x3D; adaptee;\n\t&#125;\n\tpublic void f1() &#123;\n\t\tadaptee.fa(); &#x2F;&#x2F;委托给Adaptee\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\tpublic void fc() &#123;\n\t\tadaptee.fc();\n\t&#125;\n&#125;</code></pre>\n\n<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度</p>\n<p>如果 Adaptee 接口并不多，那两种实现方式都可以。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那推荐使用对象适配器，因为组合结构相对于继承更加灵活</p>\n<p><strong>应用场景：</strong></p>\n<ol>\n<li>封装有缺陷的接口设计</li>\n<li>统一多个类的接口设计</li>\n<li>替换依赖的外部系统</li>\n<li>兼容老版本接口</li>\n<li>适配不同格式的数据</li>\n</ol>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a>** 适配器模式部分</p>\n<h2 id=\"2-5-代理、桥接、装饰器、适配器-4-种设计模式的区别\"><a href=\"#2-5-代理、桥接、装饰器、适配器-4-种设计模式的区别\" class=\"headerlink\" title=\"2.5 代理、桥接、装饰器、适配器 4 种设计模式的区别\"></a>2.5 代理、桥接、装饰器、适配器 4 种设计模式的区别</h2><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类</p>\n<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别</p>\n<ol>\n<li><strong>代理模式：</strong> 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同</li>\n<li><strong>桥接模式：</strong> 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变</li>\n<li><strong>装饰器模式：</strong> 装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用</li>\n<li><strong>适配器模式：</strong> 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口</li>\n</ol>\n<h2 id=\"2-6-门面-x2F-外观模式（Facade-Design-Pattern）\"><a href=\"#2-6-门面-x2F-外观模式（Facade-Design-Pattern）\" class=\"headerlink\" title=\"2.6 门面&#x2F;外观模式（Facade Design Pattern）\"></a>2.6 门面&#x2F;外观模式（Facade Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，门面模式是这样定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.<br>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用</p></blockquote>\n<p>概念很简单，假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用</p>\n<p><strong>应用场景：</strong></p>\n<ol>\n<li>解决易用性问题：门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口</li>\n<li>解决性能问题，通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度</li>\n<li>解决分布式事务问题</li>\n</ol>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a>** 门面模式部分</p>\n<h2 id=\"2-7-组合模式（Composite-Design-Pattern）\"><a href=\"#2-7-组合模式（Composite-Design-Pattern）\" class=\"headerlink\" title=\"2.7 组合模式（Composite Design Pattern）\"></a>2.7 组合模式（Composite Design Pattern）</h2><p>组合模式跟面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，可以简单理解为一组对象集合</p>\n<p>在 GoF 的《设计模式》一书中，组合模式是这样定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.<br>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者）可以统一单个对象和组合对象的处理逻辑</p></blockquote>\n<p>比如公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构，这个时候就可以使用组合模式来设计和实现</p>\n<p>再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a>** 组合模式部分</p>\n<h2 id=\"2-8-享元模式（Flyweight-Design-Pattern）\"><a href=\"#2-8-享元模式（Flyweight-Design-Pattern）\" class=\"headerlink\" title=\"2.8 享元模式（Flyweight Design Pattern）\"></a>2.8 享元模式（Flyweight Design Pattern）</h2><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象</p>\n<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元</p>\n<p>定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 <code>set()</code> 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码</p>\n<p>概念其实很简单，就是<strong>将重复对象或相似对象的重复部分进行复用</strong></p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a>** 享元模式部分</p>\n<h3 id=\"2-8-1-享元模式-vs-单例、缓存、对象池\"><a href=\"#2-8-1-享元模式-vs-单例、缓存、对象池\" class=\"headerlink\" title=\"2.8.1 享元模式 vs 单例、缓存、对象池\"></a>2.8.1 享元模式 vs 单例、缓存、对象池</h3><p><strong>1、享元模式跟单例的区别</strong></p>\n<p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例</p>\n<p>但区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数</p>\n<p><strong>2、享元模式跟缓存的区别</strong></p>\n<p>在享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。平时所讲的缓存，主要是为了提高访问效率，而非复用</p>\n<p><strong>3、享元模式跟对象池的区别</strong></p>\n<p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</p>\n<p>很多人可能对连接池、线程池比较熟悉，对对象池比较陌生，这里简单解释一下对象池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉</p>\n<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念</p>\n<p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间</p>\n<h1 id=\"3-行为型\"><a href=\"#3-行为型\" class=\"headerlink\" title=\"3. 行为型\"></a>3. 行为型</h1><p><strong>行为型设计模式主要解决的就是“类或对象之间的交互”问题</strong></p>\n<h2 id=\"3-1-观察者-x2F-发布订阅模式（Observer-Design-Pattern-x2F-Publish-Subscribe-Design-Pattern）\"><a href=\"#3-1-观察者-x2F-发布订阅模式（Observer-Design-Pattern-x2F-Publish-Subscribe-Design-Pattern）\" class=\"headerlink\" title=\"3.1 观察者&#x2F;发布订阅模式（Observer Design Pattern&#x2F;Publish-Subscribe Design Pattern）\"></a>3.1 观察者&#x2F;发布订阅模式（Observer Design Pattern&#x2F;Publish-Subscribe Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，它的定义是这样的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.<br>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p></blockquote>\n<p>一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式</p>\n<p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，这里来看最经典的一种实现方式，这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Subject &#123;\n\tvoid registerObserver(Observer observer);\n\tvoid removeObserver(Observer observer);\n\tvoid notifyObservers(Message message);\n&#125;\npublic interface Observer &#123;\n\tvoid update(Message message);\n&#125;\npublic class ConcreteSubject implements Subject &#123;\n\tprivate List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n\t@Override\n\tpublic void registerObserver(Observer observer) &#123;\n\t\tobservers.add(observer);\n\t&#125;\n\t@Override\n\tpublic void removeObserver(Observer observer) &#123;\n\t\tobservers.remove(observer);\n\t&#125;\n\t@Override\n\tpublic void notifyObservers(Message message) &#123;\n\t\tfor (Observer observer : observers) &#123;\n\t\t\tobserver.update(message);\n\t\t&#125;\n\t&#125;\n&#125;\npublic class ConcreteObserverOne implements Observer &#123;\n\t@Override\n\tpublic void update(Message message) &#123;\n\t\t&#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n\t\tSystem.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n\t&#125;\n&#125;\npublic class ConcreteObserverTwo implements Observer &#123;\n\t@Override\n\tpublic void update(Message message) &#123;\n\t\t&#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n\t\tSystem.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n\t&#125;\n&#125;\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tConcreteSubject subject &#x3D; new ConcreteSubject();\n\t\tsubject.registerObserver(new ConcreteObserverOne());\n\t\tsubject.registerObserver(new ConcreteObserverTwo());\n\t\tsubject.notifyObservers(new Message());\n\t&#125;\n&#125;</code></pre>\n\n<p>上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。不过，万变不离其宗，设计思路都是差不多的</p>\n<p>观察者模式的核心概念其实就在它的定义中。详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 观察者模式部分</p>\n<h2 id=\"3-2-模板模式（Template-Method-Design-Pattern）\"><a href=\"#3-2-模板模式（Template-Method-Design-Pattern）\" class=\"headerlink\" title=\"3.2 模板模式（Template Method Design Pattern）\"></a>3.2 模板模式（Template Method Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，它是这么定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.<br>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤</p></blockquote>\n<p>这里的“算法”，可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。代码示例如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractClass &#123;\n\tpublic final void templateMethod() &#123;\n\t\t&#x2F;&#x2F;...\n\t\tmethod1();\n\t\t&#x2F;&#x2F;...\n\t\tmethod2();\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tprotected abstract void method1();\n\tprotected abstract void method2();\n&#125;\npublic class ConcreteClass1 extends AbstractClass &#123;\n\t@Override\n\tprotected void method1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tprotected void method2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ConcreteClass2 extends AbstractClass &#123;\n\t@Override\n\tprotected void method1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tprotected void method2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\nAbstractClass demo &#x3D; ConcreteClass1();\ndemo.templateMethod();</code></pre>\n\n<ul>\n<li><strong>作用一：复用</strong><br>模板模式把一个算法中不变的流程抽象到父类的模板方法 <code>templateMethod()</code> 中，将可变的部分 <code>method1()</code>、<code>method2()</code> 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码</li>\n<li><strong>作用二：扩展</strong><br>这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能</li>\n</ul>\n<p>假如用过 Java Servlet，继承 HttpServlet 类然后重写 <code>doGet()</code> 和 <code>doPost()</code> 就是典型的模板模式，这里是框架的扩展作用。它将 Servlet 的执行流程进行了封装，然后将可变的 <code>doGet()</code> 和 <code>doPost()</code> 部分留给继承的子类来具体实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServlet extends HttpServlet &#123;\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tthis.doPost(req, resp);\n\t&#125;\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tresp.getWriter().write(&quot;Hello World.&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"3-2-1-模板模式-VS-回调\"><a href=\"#3-2-1-模板模式-VS-回调\" class=\"headerlink\" title=\"3.2.1 模板模式 VS 回调\"></a>3.2.1 模板模式 VS 回调</h3><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式</p>\n<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系</p>\n<p>前面也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点：</p>\n<ul>\n<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类</li>\n<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，只需要往用到的模板方法中注入回调对象即可</li>\n</ul>\n<p>回调等详细知识，可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 模板模式部分</p>\n<h2 id=\"3-3-策略模式（Strategy-Design-Pattern）\"><a href=\"#3-3-策略模式（Strategy-Design-Pattern）\" class=\"headerlink\" title=\"3.3 策略模式（Strategy Design Pattern）\"></a>3.3 策略模式（Strategy Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，它是这样定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.<br>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）</p></blockquote>\n<p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分</p>\n<h3 id=\"3-3-1-策略的定义\"><a href=\"#3-3-1-策略的定义\" class=\"headerlink\" title=\"3.3.1 策略的定义\"></a>3.3.1 策略的定义</h3><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Strategy &#123;\n\tvoid algorithmInterface();\n&#125;\npublic class ConcreteStrategyA implements Strategy &#123;\n\t@Override\n\tpublic void algorithmInterface() &#123;\n\t\t&#x2F;&#x2F;具体的算法...\n\t&#125;\n&#125;\npublic class ConcreteStrategyB implements Strategy &#123;\n\t@Override\n\tpublic void algorithmInterface() &#123;\n\t\t&#x2F;&#x2F;具体的算法...\n\t&#125;\n&#125;</code></pre>\n\n<p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 <code>getStrategy()</code> 的时候，都创建一个新的策略对象。针对这种情况，可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回</p>\n<p>相反，如果策略类是有状态的，根据业务场景的需要，希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那就需要按照如下方式来实现策略工厂类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StrategyFactory &#123;\n\tpublic static Strategy getStrategy(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;type should not be empty.&quot;);\n\t\t&#125;\n\t\tif (type.equals(&quot;A&quot;)) &#123;\n\t\t\treturn new ConcreteStrategyA();\n\t\t&#125; else if (type.equals(&quot;B&quot;)) &#123;\n\t\t\treturn new ConcreteStrategyB();\n\t\t&#125;\n\t\treturn null;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-2-策略的创建\"><a href=\"#3-3-2-策略的创建\" class=\"headerlink\" title=\"3.3.2 策略的创建\"></a>3.3.2 策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，需要对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。示例代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StrategyFactory &#123;\n\tprivate static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tstrategies.put(&quot;A&quot;, new ConcreteStrategyA());\n\t\tstrategies.put(&quot;B&quot;, new ConcreteStrategyB());\n\t&#125;\n\tpublic static Strategy getStrategy(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;type should not be empty.&quot;);\n\t\t&#125;\n\t\treturn strategies.get(type);\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"3-3-3-策略的使用\"><a href=\"#3-3-3-策略的使用\" class=\"headerlink\" title=\"3.3.3 策略的使用\"></a>3.3.3 策略的使用</h3><p>策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。这里的“运行时动态”指的是，事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 策略接口：EvictionStrategy\n&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory\npublic class UserCache &#123;\n\tprivate Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();\n\tprivate EvictionStrategy eviction;\n\tpublic UserCache(EvictionStrategy eviction) &#123;\n\t\tthis.eviction &#x3D; eviction;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tEvictionStrategy evictionStrategy &#x3D; null;\n\t\tProperties props &#x3D; new Properties();\n\t\tprops.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));\n\t\tString type &#x3D; props.getProperty(&quot;eviction_type&quot;);\n\t\tevictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);\n\t\tUserCache userCache &#x3D; new UserCache(evictionStrategy);\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tEvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();\n\t\tUserCache userCache &#x3D; new UserCache(evictionStrategy);\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;</code></pre>\n\n<p>从上面的代码中，也可以看出，“非运行时动态确定”，也就是第二个 Application 中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”</p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 策略模式部分</p>\n<h2 id=\"3-4-职责链模式（Chain-Of-Responsibility-Design-Pattern\"><a href=\"#3-4-职责链模式（Chain-Of-Responsibility-Design-Pattern\" class=\"headerlink\" title=\"3.4 职责链模式（Chain Of Responsibility Design Pattern\"></a>3.4 职责链模式（Chain Of Responsibility Design Pattern</h2><p>在 GoF 的《设计模式》中，它是这么定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.<br>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止</p></blockquote>\n<p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式</p>\n<p>职责链模式有多种实现方式，这里介绍两种比较常用的</p>\n<p><strong>1、链表</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Handler &#123;\n\tprotected Handler successor &#x3D; null;\n\tpublic void setSuccessor(Handler successor) &#123;\n\t\tthis.successor &#x3D; successor;\n\t&#125;\n\tpublic final void handle() &#123;\n\t\tboolean handled &#x3D; doHandle();\n\t\tif (successor !&#x3D; null &amp;&amp; !handled) &#123;\n\t\t\tsuccessor.handle();\n\t\t&#125;\n\t&#125;\n\tprotected abstract boolean doHandle();\n&#125;\npublic class HandlerA extends Handler &#123;\n\t@Override\n\tprotected boolean doHandle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerB extends Handler &#123;\n\t@Override\n\tprotected boolean doHandle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\n\npublic class HandlerChain &#123;\n\tprivate Handler head &#x3D; null;\n\tprivate Handler tail &#x3D; null;\n\tpublic void addHandler(Handler handler) &#123;\n\t\thandler.setSuccessor(null);\n\t\tif (head &#x3D;&#x3D; null) &#123;\n\t\t\thead &#x3D; handler;\n\t\t\ttail &#x3D; handler;\n\t\t\treturn;\n\t\t&#125;\n\t\ttail.setSuccessor(handler);\n\t\ttail &#x3D; handler;\n\t&#125;\n\tpublic void handle() &#123;\n\t\tif (head !&#x3D; null) &#123;\n\t\t\thead.handle();\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tHandlerChain chain &#x3D; new HandlerChain();\n\t\tchain.addHandler(new HandlerA());\n\t\tchain.addHandler(new HandlerB());\n\t\tchain.handle();\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>2、HandlerChain 类用数组而非链表来保存所有的处理器，并且需要在 HandlerChain 的 <code>handle()</code> 函数中，依次调用每个处理器的 <code>handle()</code> 函数</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IHandler &#123;\n\tboolean handle();\n&#125;\npublic class HandlerA implements IHandler &#123;\n\t@Override\n\tpublic boolean handle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerB implements IHandler &#123;\n\t@Override\n\tpublic boolean handle() &#123;\n\t\tboolean handled &#x3D; false;\n                &#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerChain &#123;\n\tprivate List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();\n\tpublic void addHandler(IHandler handler) &#123;\n\t\tthis.handlers.add(handler);\n\t&#125;\n\tpublic void handle() &#123;\n\t\tfor (IHandler handler : handlers) &#123;\n\t\t\tboolean handled &#x3D; handler.handle();\n\t\t\tif (handled) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tHandlerChain chain &#x3D; new HandlerChain();\n\t\tchain.addHandler(new HandlerA());\n\t\tchain.addHandler(new HandlerB());\n\t\tchain.handle();\n\t&#125;\n&#125;</code></pre>\n\n<p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可</p>\n<p>其实可以对照拦截器和过滤器链来理解，详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 责任链模式部分</p>\n<h2 id=\"3-5-状态模式（State-Design-Pattern）\"><a href=\"#3-5-状态模式（State-Design-Pattern）\" class=\"headerlink\" title=\"3.5 状态模式（State Design Pattern）\"></a>3.5 状态模式（State Design Pattern）</h2><p>在实际的软件开发中，状态模式并不是很常用，但是在能够用到的场景里，它可以发挥很大的作用。从这一点上来看，它有点像之前讲到的组合模式。状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法</p>\n<p>有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作</p>\n<p>比如“超级马里奥”，在游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分</p>\n<p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）</p>\n<p>概念不难理解，具体可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 状态模式部分</p>\n<h2 id=\"3-6-迭代器-x2F-游标模式（Iterator-Design-Pattern-x2F-Cursor-Design-Pattern）\"><a href=\"#3-6-迭代器-x2F-游标模式（Iterator-Design-Pattern-x2F-Cursor-Design-Pattern）\" class=\"headerlink\" title=\"3.6 迭代器&#x2F;游标模式（Iterator Design Pattern&#x2F;Cursor Design Pattern）\"></a>3.6 迭代器&#x2F;游标模式（Iterator Design Pattern&#x2F;Cursor Design Pattern）</h2><p>迭代器模式用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一</p>\n<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。简单的类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9b2b63c4a5dc4029b73c693c926c5c3e.png\" alt=\"在这里插入图片描述\"></p>\n<p>概念也很简单，可以对照 Java 的 Iterator 迭代器来理解，其他编程语言也大部分都提供了遍历容器的迭代器类，在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器</p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 迭代器模式部分</p>\n<h2 id=\"3-7-访问者模式（Visitor-Design-Pattern）\"><a href=\"#3-7-访问者模式（Visitor-Design-Pattern）\" class=\"headerlink\" title=\"3.7 访问者模式（Visitor Design Pattern）\"></a>3.7 访问者模式（Visitor Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，它是这么定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.<br>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身</p></blockquote>\n<p>访问者模式这里不太好理解，建议直接去看详细的说明：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 访问者模式部分</p>\n<p>这里涉及到一个双分派的问题，Double Dispatch。既然有 Double Dispatch，对应的就有 Single Dispatch</p>\n<ul>\n<li>所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定</li>\n<li>所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定</li>\n</ul>\n<p>支持双分派的语言是不需要访问者模式的，访问者模式主要是为了解决 Single Dispatch 下多态的时候，重载方法参数存在的多态问题</p>\n<h2 id=\"3-8-备忘录-x2F-快照（Snapshot）模式（Memento-Design-Pattern）\"><a href=\"#3-8-备忘录-x2F-快照（Snapshot）模式（Memento-Design-Pattern）\" class=\"headerlink\" title=\"3.8 备忘录&#x2F;快照（Snapshot）模式（Memento Design Pattern）\"></a>3.8 备忘录&#x2F;快照（Snapshot）模式（Memento Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，备忘录模式是这么定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.<br>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态</p></blockquote>\n<p>这个模式的定义主要表达了两部分内容，一部分是，存储副本以便后期恢复，另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复</p>\n<p>概念理解起来也很简单，可以对照平时所说的备份进行理解。这两者的应用场景很类似，都应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计</p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 备忘录模式部分</p>\n<h2 id=\"3-9-命令模式（Command-Design-Pattern）\"><a href=\"#3-9-命令模式（Command-Design-Pattern）\" class=\"headerlink\" title=\"3.9 命令模式（Command Design Pattern）\"></a>3.9 命令模式（Command Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，它是这么定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.<br>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能</p></blockquote>\n<p>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。C 语言支持函数指针，可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法作为参数传递给其他函数，也没法赋值给变量。借助命令模式，可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似前面提到的回调</p>\n<p>当把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方</p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 命令模式部分</p>\n<h3 id=\"3-9-1-命令模式-VS-策略模式\"><a href=\"#3-9-1-命令模式-VS-策略模式\" class=\"headerlink\" title=\"3.9.1 命令模式 VS 策略模式\"></a>3.9.1 命令模式 VS 策略模式</h3><p>看到上面的定义可能会觉得，命令模式跟策略模式、工厂模式非常相似，那它们的区别在哪里呢？不仅如此，感觉前面的很多模式都很相似，不知道你有没有类似的感觉呢？</p>\n<p>实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉</p>\n<p>实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式</p>\n<p>前面讲策略模式的时候有讲到，策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿</p>\n<p>再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别</p>\n<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换</p>\n<h2 id=\"3-10-解释器模式（Interpreter-Design-Pattern）\"><a href=\"#3-10-解释器模式（Interpreter-Design-Pattern）\" class=\"headerlink\" title=\"3.10 解释器模式（Interpreter Design Pattern）\"></a>3.10 解释器模式（Interpreter Design Pattern）</h2><p>在 GoF 的《设计模式》一书中，它是这样定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.<br>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法</p></blockquote>\n<p>这里面有很多平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等</p>\n<p>要想了解“语言”表达的信息，就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器</p>\n<p>假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：</p>\n<ul>\n<li>运算符只包含加、减、乘、除，并且没有优先级的概念</li>\n<li>表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开</li>\n<li>按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果</li>\n</ul>\n<p>比如“ 8 3 2 4 - + * ”这样一个表达式，按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。处理出这个结果的，就是解释器</p>\n<p>概念应该不难理解，具体可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 解释器模式部分</p>\n<h2 id=\"3-11-中介模式（Mediator-Design-Pattern）\"><a href=\"#3-11-中介模式（Mediator-Design-Pattern）\" class=\"headerlink\" title=\"3.11 中介模式（Mediator Design Pattern）\"></a>3.11 中介模式（Mediator Design Pattern）</h2><p>在 GoF 中的《设计模式》一书中，它是这样定义的：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.<br>中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互</p></blockquote>\n<p>在讲到“如何给代码解耦”时，其中一个方法就是引入中间层。实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性</p>\n<p>如下画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关系优化之后的结果，从图中可以很直观地看出，右边的交互关系更加清晰、简洁</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b89beeb11502474c815d65973771bf46.png\" alt=\"在这里插入图片描述\"></p>\n<p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制</p>\n<p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络</p>\n<p>详细可见：**<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a>** 中介模式部分</p>\n<h3 id=\"3-11-1-中介模式-VS-观察者模式\"><a href=\"#3-11-1-中介模式-VS-观察者模式\" class=\"headerlink\" title=\"3.11.1 中介模式 VS 观察者模式\"></a>3.11.1 中介模式 VS 观察者模式</h3><p>前面讲观察者模式的时候讲到，观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的 <code>update()</code> 方法。但是，在跨进程的实现方式中，可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在</p>\n<p>而中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？</p>\n<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理</p>\n<p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的</p>\n","feature":false,"text":"设计模式相关的详细知识见如下三篇： 设计模式之美总结（创建型篇）_凡 223 的博客 设计模式之美总结（结构型篇）_凡 223 的博客 设计模式之美总结（行为型篇）_凡 223 的博客 这里主要是对上面三篇内容的总结，用于清晰 23 种设计模式的原理概念和应用场景，以及它们之间的...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E5%9E%8B\"><span class=\"toc-text\">1. 创建型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">1.1 单例模式（Singleton Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">1.1.1 概述与实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E5%A4%9A%E4%BE%8B\"><span class=\"toc-text\">1.1.2 多例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">1.2 工厂模式（Factory Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%EF%BC%88Simple-Factory%EF%BC%89\"><span class=\"toc-text\">1.2.1 简单工厂（Simple Factory）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%88Factory-Method%EF%BC%89\"><span class=\"toc-text\">1.2.2 工厂方法（Factory Method）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-3-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-VS-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.2.3 工厂方法模式 VS 简单工厂模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-4-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%EF%BC%88Abstract-Factory%EF%BC%89\"><span class=\"toc-text\">1.2.4 抽象工厂（Abstract Factory）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%BB%BA%E9%80%A0%E8%80%85-x2F-%E6%9E%84%E5%BB%BA%E8%80%85-x2F-%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">1.3 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-1-%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">1.3.1 与工厂模式有何区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">1.4 原型模式（Prototype Design Pattern）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E7%BB%93%E6%9E%84%E5%9E%8B\"><span class=\"toc-text\">2. 结构型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2.1 代理模式（Proxy Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%A1%A5%E6%8E%A5-x2F-%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2.2 桥接&#x2F;桥梁模式（Bridge Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2.3 装饰器模式（Decorator Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2.4 适配器模式（Adapter Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E4%BB%A3%E7%90%86%E3%80%81%E6%A1%A5%E6%8E%A5%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8-4-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.5 代理、桥接、装饰器、适配器 4 种设计模式的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E9%97%A8%E9%9D%A2-x2F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2.6 门面&#x2F;外观模式（Facade Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2.7 组合模式（Composite Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">2.8 享元模式（Flyweight Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-8-1-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-vs-%E5%8D%95%E4%BE%8B%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%AF%B9%E8%B1%A1%E6%B1%A0\"><span class=\"toc-text\">2.8.1 享元模式 vs 单例、缓存、对象池</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E8%A1%8C%E4%B8%BA%E5%9E%8B\"><span class=\"toc-text\">3. 行为型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E8%A7%82%E5%AF%9F%E8%80%85-x2F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Design-Pattern-x2F-Publish-Subscribe-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.1 观察者&#x2F;发布订阅模式（Observer Design Pattern&#x2F;Publish-Subscribe Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.2 模板模式（Template Method Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F-VS-%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">3.2.1 模板模式 VS 回调</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.3 策略模式（Strategy Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">3.3.1 策略的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-%E7%AD%96%E7%95%A5%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">3.3.2 策略的创建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-3-%E7%AD%96%E7%95%A5%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3.3.3 策略的使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Chain-Of-Responsibility-Design-Pattern\"><span class=\"toc-text\">3.4 职责链模式（Chain Of Responsibility Design Pattern</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88State-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.5 状态模式（State Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-%E8%BF%AD%E4%BB%A3%E5%99%A8-x2F-%E6%B8%B8%E6%A0%87%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator-Design-Pattern-x2F-Cursor-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.6 迭代器&#x2F;游标模式（Iterator Design Pattern&#x2F;Cursor Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Visitor-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.7 访问者模式（Visitor Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-8-%E5%A4%87%E5%BF%98%E5%BD%95-x2F-%E5%BF%AB%E7%85%A7%EF%BC%88Snapshot%EF%BC%89%E6%A8%A1%E5%BC%8F%EF%BC%88Memento-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.8 备忘录&#x2F;快照（Snapshot）模式（Memento Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-9-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Command-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.9 命令模式（Command Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-9-1-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-VS-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.9.1 命令模式 VS 策略模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-10-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Interpreter-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.10 解释器模式（Interpreter Design Pattern）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-11-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Mediator-Design-Pattern%EF%BC%89\"><span class=\"toc-text\">3.11 中介模式（Mediator Design Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-11-1-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F-VS-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.11.1 中介模式 VS 观察者模式</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"设计模式之美总结（开源实战篇）","uid":"860180e4219f9ce98400fc5559b6d34d","slug":"BlogRepository/设计模式/设计模式之美总结（开源实战篇）","date":"2023-01-10T09:13:05.000Z","updated":"2023-03-13T19:13:04.964Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（开源实战篇）.json","keywords":null,"cover":"https://cover.png","text":"设计模式相关的详细知识见如下三篇： 设计模式之美总结（创建型篇）_凡 223 的博客 设计模式之美总结（结构型篇）_凡 223 的博客 设计模式之美总结（行为型篇）_凡 223 的博客 1. Java JDK 应用到的设计模式1.1 工厂模式在 Calendar 类中的应用在前面...","link":"","photos":[],"count_time":{"symbolsCount":"113k","symbolsTime":"1:43"},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"Java Integer.toBinaryString() 方法源码及原理解析（进制转换、位运算）","uid":"f836b7c416a11f5069436de43f7aa730","slug":"BlogRepository/Java/Java Integer.toBinaryString() 方法源码及原理解析（进制转换、位运算）","date":"2022-12-27T09:31:38.000Z","updated":"2023-03-13T19:13:04.933Z","comments":true,"path":"api/articles/BlogRepository/Java/Java Integer.toBinaryString() 方法源码及原理解析（进制转换、位运算）.json","keywords":null,"cover":"https://cover.png","text":"1. 使用及源码概览Integer.toBinaryString() 方法用于将十进制整数转为二进制，如下例： 完整源码调用如下： public static String toBinaryString(int i) &#123; return toUnsignedString0...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"10 mins."},"categories":[{"name":"Java","slug":"Java","count":4,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}