{"title":"设计模式之美总结（开源实战篇）","uid":"860180e4219f9ce98400fc5559b6d34d","slug":"BlogRepository/设计模式/设计模式之美总结（开源实战篇）","date":"2023-01-10T09:13:05.000Z","updated":"2023-03-13T19:13:04.964Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（开源实战篇）.json","keywords":null,"cover":"https://cover.png","content":"<p><strong>设计模式相关的详细知识见如下三篇：</strong></p>\n<ul>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/127668978\">设计模式之美总结（创建型篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128393238\">设计模式之美总结（结构型篇）_凡 223 的博客</a></strong></li>\n<li><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/128408142\">设计模式之美总结（行为型篇）_凡 223 的博客</a></strong></li>\n</ul>\n<h1 id=\"1-Java-JDK-应用到的设计模式\"><a href=\"#1-Java-JDK-应用到的设计模式\" class=\"headerlink\" title=\"1. Java JDK 应用到的设计模式\"></a>1. Java JDK 应用到的设计模式</h1><h2 id=\"1-1-工厂模式在-Calendar-类中的应用\"><a href=\"#1-1-工厂模式在-Calendar-类中的应用\" class=\"headerlink\" title=\"1.1 工厂模式在 Calendar 类中的应用\"></a>1.1 工厂模式在 Calendar 类中的应用</h2><p>在前面讲到工厂模式的时候，大部分工厂类都是以 Factory 作为后缀来命名，并且工厂类主要负责创建对象这样一件事情。但在实际的项目开发中，工厂类的设计更加灵活。比如工厂模式在 Java JDK 中的一个应用：<code>java.util.Calendar</code>。从命名上，我们无法看出它是一个工厂类</p>\n<p>Calendar 类提供了大量跟日期相关的功能代码，同时，又提供了一个 <code>getInstance()</code> 工厂方法，用来根据不同的 TimeZone 和 Locale 创建不同的 Calendar 子类对象。也就是说，功能代码和工厂方法代码耦合在了一个类中。所以，即便去查看它的源码，如果不细心的话，也很难发现它用到了工厂模式。同时，因为它不单单是一个工厂类，所以，它并没有以 Factory 作为后缀来命名</p>\n<p>Calendar 类的相关代码如下所示，大部分代码都已经省略，只给出了 <code>getInstance()</code> 工厂方法的代码实现。从代码中可以看出，<code>getInstance()</code> 方法可以根据不同 TimeZone 和 Locale，创建不同的 Calendar 子类对象，比如 BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar，这些细节完全封装在工厂方法中，使用者只需要传递当前的时区和地址，就能够获得一个 Calendar 类对象来使用，而获得的对象具体是哪个 Calendar 子类的对象，使用者在使用的时候并不关心</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123;\n\t&#x2F;&#x2F;...\n\tpublic static Calendar getInstance(TimeZone zone, Locale aLocale) &#123;\n\t\treturn createCalendar(zone, aLocale);\n\t&#125;\n\tprivate static Calendar createCalendar(TimeZone zone,Locale aLocale) &#123;\n\t\tCalendarProvider provider &#x3D; LocaleProviderAdapter.getAdapter(\n\t\t                                CalendarProvider.class, aLocale).getCalendarProvider();\n\t\tif (provider !&#x3D; null) &#123;\n\t\t\ttry &#123;\n\t\t\t\treturn provider.getInstance(zone, aLocale);\n\t\t\t&#125; catch (IllegalArgumentException iae) &#123;\n                                &#x2F;&#x2F; fall back to the default instantiation\n\t\t\t&#125;\n\t\t&#125;\n\t\tCalendar cal &#x3D; null;\n\t\tif (aLocale.hasExtensions()) &#123;\n\t\t\tString caltype &#x3D; aLocale.getUnicodeLocaleType(&quot;ca&quot;);\n\t\t\tif (caltype !&#x3D; null) &#123;\n\t\t\t\tswitch (caltype) &#123;\n\t\t\t\tcase &quot;buddhist&quot;:\n\t\t\t\t\tcal &#x3D; new BuddhistCalendar(zone, aLocale);\n\t\t\t\t\tbreak;\n\t\t\t\tcase &quot;japanese&quot;:\n\t\t\t\t\tcal &#x3D; new JapaneseImperialCalendar(zone, aLocale);\n\t\t\t\t\tbreak;\n\t\t\t\tcase &quot;gregory&quot;:\n\t\t\t\t\tcal &#x3D; new GregorianCalendar(zone, aLocale);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (cal &#x3D;&#x3D; null) &#123;\n\t\t\tif (aLocale.getLanguage() &#x3D;&#x3D; &quot;th&quot; &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;TH&quot;) &#123;\n\t\t\t\tcal &#x3D; new BuddhistCalendar(zone, aLocale);\n\t\t\t&#125; else if (aLocale.getVariant() &#x3D;&#x3D; &quot;JP&quot; &amp;&amp; aLocale.getLanguage() &#x3D;&#x3D; &quot;ja&quot;) &#123;\n\t\t\t\tcal &#x3D; new JapaneseImperialCalendar(zone, aLocale);\n\t\t\t&#125; else &#123;\n\t\t\t\tcal &#x3D; new GregorianCalendar(zone, aLocale);\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn cal;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;</code></pre>\n\n<h2 id=\"1-2-建造者模式在-Calendar-类中的应用\"><a href=\"#1-2-建造者模式在-Calendar-类中的应用\" class=\"headerlink\" title=\"1.2 建造者模式在 Calendar 类中的应用\"></a>1.2 建造者模式在 Calendar 类中的应用</h2><p>还是刚刚的 Calendar 类，它不仅仅用到了工厂模式，还用到了建造者模式。建造者模式有两种实现方法，一种是单独定义一个 Builder 类，另一种是将 Builder 实现为原始类的内部类。Calendar 就采用了第二种实现思路</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123;\n\t&#x2F;&#x2F;...\n\tpublic static class Builder &#123;\n\t\tprivate static final int NFIELDS &#x3D; FIELD_COUNT + 1;\n\t\tprivate static final int WEEK_YEAR &#x3D; FIELD_COUNT;\n\t\tprivate long instant;\n\t\tprivate int[] fields;\n\t\tprivate int nextStamp;\n\t\tprivate int maxFieldIndex;\n\t\tprivate String type;\n\t\tprivate TimeZone zone;\n\t\tprivate boolean lenient &#x3D; true;\n\t\tprivate Locale locale;\n\t\tprivate int firstDayOfWeek, minimalDaysInFirstWeek;\n\t\tpublic Builder() &#123;&#125;\n\t\tpublic Builder setInstant(long instant) &#123;\n\t\t\tif (fields !&#x3D; null) &#123;\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t&#125;\n\t\t\tthis.instant &#x3D; instant;\n\t\t\tnextStamp &#x3D; COMPUTED;\n\t\t\treturn this;\n\t\t&#125;\n                &#x2F;&#x2F;...省略n多set()方法\n\t\tpublic Calendar build() &#123;\n\t\t\tif (locale &#x3D;&#x3D; null) &#123;\n\t\t\t\tlocale &#x3D; Locale.getDefault();\n\t\t\t&#125;\n\t\t\tif (zone &#x3D;&#x3D; null) &#123;\n\t\t\t\tzone &#x3D; TimeZone.getDefault();\n\t\t\t&#125;\n\t\t\tCalendar cal;\n\t\t\tif (type &#x3D;&#x3D; null) &#123;\n\t\t\t\ttype &#x3D; locale.getUnicodeLocaleType(&quot;ca&quot;);\n\t\t\t&#125;\n\t\t\tif (type &#x3D;&#x3D; null) &#123;\n\t\t\t\tif (locale.getCountry() &#x3D;&#x3D; &quot;TH&quot; &amp;&amp; locale.getLanguage() &#x3D;&#x3D; &quot;th&quot;) &#123;\n\t\t\t\t\ttype &#x3D; &quot;buddhist&quot;;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\ttype &#x3D; &quot;gregory&quot;;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tswitch (type) &#123;\n\t\t\tcase &quot;gregory&quot;:\n\t\t\t\tcal &#x3D; new GregorianCalendar(zone, locale, true);\n\t\t\t\tbreak;\n\t\t\tcase &quot;iso8601&quot;:\n\t\t\t\tGregorianCalendar gcal &#x3D; new GregorianCalendar(zone, locale, true);\n                                &#x2F;&#x2F; make gcal a proleptic Gregorian\n\t\t\t\tgcal.setGregorianChange(new Date(Long.MIN_VALUE));\n                                &#x2F;&#x2F; and week definition to be compatible with ISO 8601\n\t\t\t\tsetWeekDefinition(MONDAY, 4);\n\t\t\t\tcal &#x3D; gcal;\n\t\t\t\tbreak;\n\t\t\tcase &quot;buddhist&quot;:\n\t\t\t\tcal &#x3D; new BuddhistCalendar(zone, locale);\n\t\t\t\tcal.clear();\n\t\t\t\tbreak;\n\t\t\tcase &quot;japanese&quot;:\n\t\t\t\tcal &#x3D; new JapaneseImperialCalendar(zone, locale, true);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(&quot;unknown calendar type: &quot; + type)\n\t\t\t&#125;\n\t\t\tcal.setLenient(lenient);\n\t\t\tif (firstDayOfWeek !&#x3D; 0) &#123;\n\t\t\t\tcal.setFirstDayOfWeek(firstDayOfWeek);\n\t\t\t\tcal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);\n\t\t\t&#125;\n\t\t\tif (isInstantSet()) &#123;\n\t\t\t\tcal.setTimeInMillis(instant);\n\t\t\t\tcal.complete();\n\t\t\t\treturn cal;\n\t\t\t&#125;\n\t\t\tif (fields !&#x3D; null) &#123;\n\t\t\t\tboolean weekDate &#x3D; isSet(WEEK_YEAR) &amp;&amp; fields[WEEK_YEAR] &gt; fields[YEAR]\n\t\t\t\tif (weekDate &amp;&amp; !cal.isWeekDateSupported()) &#123;\n\t\t\t\t\tthrow new IllegalArgumentException(&quot;week date is unsupported by &quot; + t\n\t\t\t\t&#125;\n\t\t\t\tfor (int stamp &#x3D; MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) &#123;\n\t\t\t\t\tfor (int index &#x3D; 0; index &lt;&#x3D; maxFieldIndex; index++) &#123;\n\t\t\t\t\t\tif (fields[index] &#x3D;&#x3D; stamp) &#123;\n\t\t\t\t\t\t\tcal.set(index, fields[NFIELDS + index]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tif (weekDate) &#123;\n\t\t\t\t\tint weekOfYear &#x3D; isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;\n\t\t\t\t\tint dayOfWeek &#x3D; isSet(DAY_OF_WEEK)\n\t\t\t\t\t                ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();\n\t\t\t\t\tcal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);\n\t\t\t\t&#125;\n\t\t\t\tcal.complete();\n\t\t\t&#125;\n\t\t\treturn cal;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>看了上面的代码，有一个问题思考一下：既然已经有了 <code>getInstance()</code> 工厂方法来创建 Calendar 类对象，为什么还要用 Builder 来创建 Calendar 类对象呢？这两者之间的区别在哪里呢？</p>\n<p>实际上，在前面讲到这两种模式的时候，对它们之间的区别做了详细的对比。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象</p>\n<p>粗看 Calendar 的 Builder 类的 <code>build()</code> 方法，可能会觉得它有点像工厂模式。前面一半代码确实跟 <code>getInstance()</code> 工厂方法类似，根据不同的 type 创建了不同的 Calendar 子类。实际上，后面一半代码才属于标准的建造者模式，根据 <code>setXXX()</code> 方法设置的参数，来定制化刚刚创建的 Calendar 子类对象</p>\n<p>这时可能会说，这还能算是建造者模式吗？引用前面提到过的一段话</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式，创造出新的模式来解决特定场景的问题</p></blockquote>\n<p>实际上，从 Calendar 这个例子也能学到，不要过于死板地套用各种模式的原理和实现，不要不敢做丝毫的改动。模式是死的，用的人是活的。在实际上的项目开发中，不仅各种模式可以混合在一起使用，而且具体的代码实现，也可以根据具体的功能需求做灵活的调整</p>\n<h2 id=\"1-3-装饰器模式在-Collections-类中的应用\"><a href=\"#1-3-装饰器模式在-Collections-类中的应用\" class=\"headerlink\" title=\"1.3 装饰器模式在 Collections 类中的应用\"></a>1.3 装饰器模式在 Collections 类中的应用</h2><p>前面讲到，Java IO 类库是装饰器模式的非常经典的应用。实际上，Java 的 Collections 类也用到了装饰器模式</p>\n<p>Collections 类是一个集合容器的工具类，提供了很多静态方法，用来创建各种集合容器，比如通过 <code>unmodifiableColletion()</code> 静态方法，来创建 UnmodifiableCollection 类对象。而这些容器类中的 UnmodifiableCollection 类、CheckedCollection 和 SynchronizedCollection 类，就是针对 Collection 类的装饰器类</p>\n<p>因为刚刚提到的这三个装饰器类，在代码结构上几乎一样，所以这里只拿其中的 UnmodifiableCollection 类来举例讲解一下。UnmodifiableCollection 类是 Collections 类的一个内部类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Collections &#123;\n\tprivate Collections() &#123;&#125;\n\tpublic static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123;\n\t\treturn new UnmodifiableCollection&lt;&gt;(c);\n\t&#125;\n\n\t&#x2F;**\n\t * @serial include\n\t *&#x2F;\n\tstatic class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable &#123;\n\t\tprivate static final long serialVersionUID &#x3D; 1820017752578914078L;\n\n\t\tfinal Collection&lt;? extends E&gt; c;\n\n\t\tUnmodifiableCollection(Collection&lt;? extends E&gt; c) &#123;\n\t\t\tif (c&#x3D;&#x3D;null)\n\t\t\t\tthrow new NullPointerException();\n\t\t\tthis.c &#x3D; c;\n\t\t&#125;\n\n\t\tpublic int size()                   &#123;\n\t\t\treturn c.size();\n\t\t&#125;\n\t\tpublic boolean isEmpty()            &#123;\n\t\t\treturn c.isEmpty();\n\t\t&#125;\n\t\tpublic boolean contains(Object o)   &#123;\n\t\t\treturn c.contains(o);\n\t\t&#125;\n\t\tpublic Object[] toArray()           &#123;\n\t\t\treturn c.toArray();\n\t\t&#125;\n\t\tpublic &lt;T&gt; T[] toArray(T[] a)       &#123;\n\t\t\treturn c.toArray(a);\n\t\t&#125;\n\t\tpublic String toString()            &#123;\n\t\t\treturn c.toString();\n\t\t&#125;\n\n\t\tpublic Iterator&lt;E&gt; iterator() &#123;\n\t\t\treturn new Iterator&lt;E&gt;() &#123;\n\t\t\t\tprivate final Iterator&lt;? extends E&gt; i &#x3D; c.iterator();\n\n\t\t\t\tpublic boolean hasNext() &#123;\n\t\t\t\t\treturn i.hasNext();\n\t\t\t\t&#125;\n\t\t\t\tpublic E next()          &#123;\n\t\t\t\t\treturn i.next();\n\t\t\t\t&#125;\n\t\t\t\tpublic void remove() &#123;\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t&#125;\n\t\t\t\t@Override\n\t\t\t\tpublic void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n\t\t\t\t\t&#x2F;&#x2F; Use backing collection version\n\t\t\t\t\ti.forEachRemaining(action);\n\t\t\t\t&#125;\n\t\t\t&#125;;\n\t\t&#125;\n\t\tpublic boolean add(E e) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean remove(Object o) &#123;\n\t\t\throw new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean containsAll(Collection&lt;?&gt; coll) &#123;\n\t\t\treturn c.containsAll(coll);\n\t\t&#125;\n\t\tpublic boolean addAll(Collection&lt;? extends E&gt; coll) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean removeAll(Collection&lt;?&gt; coll) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean retainAll(Collection&lt;?&gt; coll) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic void clear() &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\t&#x2F;&#x2F; Override default methods in Collection\n\t\t@Override\n\t\tpublic void forEach(Consumer&lt;? super E&gt; action) &#123;\n\t\t\tc.forEach(action);\n\t\t&#125;\n\t\t@Override\n\t\tpublic boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\t@SuppressWarnings(&quot;unchecked&quot;)\n\t\t@Override\n\t\tpublic Spliterator&lt;E&gt; spliterator() &#123;\n\t\t\treturn (Spliterator&lt;E&gt;)c.spliterator();\n\t\t&#125;\n\t\t@SuppressWarnings(&quot;unchecked&quot;)\n\t\t@Override\n\t\tpublic Stream&lt;E&gt; stream() &#123;\n\t\t\treturn (Stream&lt;E&gt;)c.stream();\n\t\t&#125;\n\t\t@SuppressWarnings(&quot;unchecked&quot;)\n\t\t@Override\n\t\tpublic Stream&lt;E&gt; parallelStream() &#123;\n\t\t\treturn (Stream&lt;E&gt;)c.parallelStream();\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>看了上面的代码思考一下，为什么说 UnmodifiableCollection 类是 Collection 类的装饰器类呢？这两者之间可以看作简单的接口实现关系或者类继承关系吗？</p>\n<p>前面讲过，装饰器模式中的装饰器类是对原始类功能的增强。尽管 UnmodifiableCollection 类可以算是对 Collection 类的一种功能增强，但这点还不具备足够的说服力来断定 UnmodifiableCollection 就是 Collection 类的装饰器类</p>\n<p>实际上，最关键的一点是，UnmodifiableCollection 的构造函数接收一个 Collection 类对象，然后对其所有的函数进行了包裹（Wrap）：重新实现（比如 add() 函数）或者简单封装（比如 stream() 函数）。而简单的接口实现或者继承，并不会如此来实现 UnmodifiableCollection 类。所以，从代码实现的角度来说， UnmodifiableCollection类是典型的装饰器类</p>\n<h2 id=\"1-4-适配器模式在-Collections-类中的应用\"><a href=\"#1-4-适配器模式在-Collections-类中的应用\" class=\"headerlink\" title=\"1.4 适配器模式在 Collections 类中的应用\"></a>1.4 适配器模式在 Collections 类中的应用</h2><p>前面讲到适配器模式的时候说到，适配器模式可以用来兼容老的版本接口。当时举了一个 JDK 的例子，这里再重新仔细看一下</p>\n<p>老版本的 JDK 提供了 Enumeration 类来遍历容器。新版本的 JDK 用 Iterator 类替代 Enumeration 类来遍历容器。为了兼容老的客户端代码（使用老版本 JDK 的代码），保留了 Enumeration 类，并且在 Collections 类中，仍然保留了 <code>enumaration()</code> 静态方法（因为一般都是通过这个静态函数来创建一个容器的 Enumeration 类对象）</p>\n<p>不过，保留 Enumeration 类和 <code>enumeration()</code> 函数，都只是为了兼容，实际上，跟适配器没有一点关系。那到底哪一部分才是适配器呢？</p>\n<p>在新版本的 JDK 中，Enumeration 类是适配器类。它适配的是客户端代码（使用 Enumeration 类）和新版本 JDK 中新的迭代器 Iterator 类。不过，从代码实现的角度来说，这个适配器模式的代码实现，跟经典的适配器模式的代码实现，差别稍微有点大。<code>enumeration()</code> 静态函数的逻辑和 Enumeration 适配器类的代码耦合在一起，<code>enumeration()</code> 静态函数直接通过 new 的方式创建了匿名类对象。具体的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Returns an enumeration over the specified collection. This provides\n* interoperability with legacy APIs that require an enumeration\n* as input.\n*\n* @param &lt;T&gt; the class of the objects in the collection\n* @param c the collection for which an enumeration is to be returned.\n* @return an enumeration over the specified collection.\n* @see Enumeration\n*&#x2F;\npublic static &lt;T&gt; Enumeration&lt;T&gt; enumeration(final Collection&lt;T&gt; c) &#123;\n\treturn new Enumeration&lt;T&gt;() &#123;\n\t\tprivate final Iterator&lt;T&gt; i &#x3D; c.iterator();\n\t\tpublic boolean hasMoreElements() &#123;\n\t\t\treturn i.hasNext();\n\t\t&#125;\n\t\tpublic T nextElement() &#123;\n\t\t\treturn i.next();\n\t\t&#125;\n\t&#125;;\n&#125;</code></pre>\n\n<h2 id=\"1-5-模板模式在-Collections-类中的应用\"><a href=\"#1-5-模板模式在-Collections-类中的应用\" class=\"headerlink\" title=\"1.5 模板模式在 Collections 类中的应用\"></a>1.5 模板模式在 Collections 类中的应用</h2><p>前面提到，策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。Java 中的 Collections 类的 <code>sort()</code> 函数就是利用了模板模式的这个扩展特性</p>\n<p>首先，看下 <code>Collections.sort()</code> 函数是如何使用的。示例代码如下所示。这个代码实现了按照不同的排序方式（按照年龄从小到大、按照名字字母序从小到大、按照成绩从大到小）对 students 数组进行排序</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;();\n\t\tstudents.add(new Student(&quot;Alice&quot;, 19, 89.0f));\n\t\tstudents.add(new Student(&quot;Peter&quot;, 20, 78.0f));\n\t\tstudents.add(new Student(&quot;Leo&quot;, 18, 99.0f));\n\t\tCollections.sort(students, new AgeAscComparator());\n\t\tprint(students);\n\t\tCollections.sort(students, new NameAscComparator());\n\t\tprint(students);\n\t\tCollections.sort(students, new ScoreDescComparator());\n\t\tprint(students);\n\t&#125;\n\tpublic static void print(List&lt;Student&gt; students) &#123;\n\t\tfor (Student s : students) &#123;\n\t\t\tSystem.out.println(s.getName() + &quot; &quot; + s.getAge() + &quot; &quot; + s.getScore());\n\t\t&#125;\n\t&#125;\n\tpublic static class AgeAscComparator implements Comparator&lt;Student&gt; &#123;\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) &#123;\n\t\t\treturn o1.getAge() - o2.getAge();\n\t\t&#125;\n\t&#125;\n\tpublic static class NameAscComparator implements Comparator&lt;Student&gt; &#123;\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) &#123;\n\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t&#125;\n\t&#125;\n\tpublic static class ScoreDescComparator implements Comparator&lt;Student&gt; &#123;\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) &#123;\n\t\t\tif (Math.abs(o1.getScore() - o2.getScore()) &lt; 0.001) &#123;\n\t\t\t\treturn 0;\n\t\t\t&#125; else if (o1.getScore() &lt; o2.getScore()) &#123;\n\t\t\t\treturn 1;\n\t\t\t&#125; else &#123;\n\t\t\t\treturn -1;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>结合刚刚这个例子，再来看下，为什么说 <code>Collections.sort()</code> 函数用到了模板模式？<code>Collections.sort()</code> 实现了对集合的排序。为了扩展性，它将其中“比较大小”这部分逻辑，委派给用户来实现。如果把比较大小这部分逻辑看作整个排序逻辑的其中一个步骤，那就可以把它看作模板模式。不过，从代码实现的角度来看，它看起来有点类似之前讲过的 JdbcTemplate，并不是模板模式的经典代码实现，而是基于 Callback 回调机制来实现的</p>\n<p>不过，在其他资料中，还看到有人说，<code>Collections.sort()</code> 使用的是策略模式。这样的说法也不是没有道理的。如果并不把“比较大小”看作排序逻辑中的一个步骤，而是看作一种算法或者策略，那就可以把它看作一种策略模式的应用。不过，这也不是典型的策略模式，前面讲到在典型的策略模式中，策略模式分为策略的定义、创建、使用这三部分。策略通过工厂模式来创建，并且在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。而在 <code>Collections.sort()</code> 函数中，策略的创建并非通过工厂模式，策略的使用也非动态确定</p>\n<h2 id=\"1-6-观察者模式在-JDK-中的应用\"><a href=\"#1-6-观察者模式在-JDK-中的应用\" class=\"headerlink\" title=\"1.6 观察者模式在 JDK 中的应用\"></a>1.6 观察者模式在 JDK 中的应用</h2><p>在前面讲到观察者模式的时候，重点讲解了 Google Guava 的 EventBus 框架，它提供了观察者模式的骨架代码。使用 EventBus，我们不需要从零开始开发观察者模式。实际上，Java JDK 也提供了观察者模式的简单框架实现。在平时的开发中，如果不希望引入 Google Guava 开发库，可以直接使用 Java 语言本身提供的这个框架类</p>\n<p>不过，它比 EventBus 要简单多了，只包含两个类：java.util.Observable 和 java.util.Observer。前者是被观察者，后者是观察者。它们的代码实现也非常简单</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Observer &#123;\n\tvoid update(Observable o, Object arg);\n&#125;\npublic class Observable &#123;\n\tprivate boolean changed &#x3D; false;\n\tprivate Vector&lt;Observer&gt; obs;\n\tpublic Observable() &#123;\n\t\tobs &#x3D; new Vector&lt;&gt;();\n\t&#125;\n\tpublic synchronized void addObserver(Observer o) &#123;\n\t\tif (o &#x3D;&#x3D; null)\n\t\t\tthrow new NullPointerException();\n\t\tif (!obs.contains(o)) &#123;\n\t\t\tobs.addElement(o);\n\t\t&#125;\n\t&#125;\n\tpublic synchronized void deleteObserver(Observer o) &#123;\n\t\tobs.removeElement(o);\n\t&#125;\n\tpublic void notifyObservers() &#123;\n\t\tnotifyObservers(null);\n\t&#125;\n\tpublic void notifyObservers(Object arg) &#123;\n\t\tObject[] arrLocal;\n\t\tsynchronized (this) &#123;\n\t\t\tif (!changed)\n\t\t\t\treturn;\n\t\t\tarrLocal &#x3D; obs.toArray();\n\t\t\tclearChanged();\n\t\t&#125;\n\t\tfor (int i &#x3D; arrLocal.length-1; i&gt;&#x3D;0; i--)\n\t\t\t((Observer)arrLocal[i]).update(this, arg);\n\t&#125;\n\tpublic synchronized void deleteObservers() &#123;\n\t\tobs.removeAllElements();\n\t&#125;\n\tprotected synchronized void setChanged() &#123;\n\t\tchanged &#x3D; true;\n\t&#125;\n\tprotected synchronized void clearChanged() &#123;\n\t\tchanged &#x3D; false;\n\t&#125;\n&#125;</code></pre>\n\n<p>对于 Observable、Observer 的代码实现，大部分都很好理解，重点来看其中的两个地方。一个是 changed 成员变量，另一个是 <code>notifyObservers()</code> 函数</p>\n<p><strong>先来看 changed 成员变量</strong></p>\n<p>它用来表明被观察者（Observable）有没有状态更新。当有状态更新时，需要手动调用 <code>setChanged()</code> 函数，将 changed 变量设置为 true，这样才能在调用 <code>notifyObservers()</code> 函数的时候，真正触发观察者（Observer）执行 <code>update()</code> 函数。否则，即便调用了 <code>notifyObservers()</code> 函数，观察者的 <code>update()</code> 函数也不会被执行。也就是说，当通知观察者被观察者状态更新的时候，需要依次调用 <code>setChanged()</code> 和<br><code>notifyObservers()</code> 两个函数，单独调用 <code>notifyObservers()</code> 函数是不起作用的</p>\n<p><strong>再来看 <code>notifyObservers()</code> 函数</strong></p>\n<p>为了保证在多线程环境下，添加、移除、通知观察者三个操作之间不发生冲突，Observable 类中的大部分函数都通过 synchronized 加了锁，不过，也有特例，<code>notifyObservers()</code> 这函数就没有加 synchronized 锁。这是为什么呢？在 JDK 的代码实现中，<code>notifyObservers()</code> 函数是如何保证跟其他函数操作不冲突的呢？这种加锁方法是否存在问题？又存在什么问题呢？</p>\n<p><code>notifyObservers()</code> 函数之所以没有像其他函数那样，一把大锁加在整个函数上，主要还是出于性能的考虑</p>\n<p><code>notifyObservers()</code> 函数依次执行每个观察者的 update() 函数，每个 <code>update()</code> 函数执行的逻辑提前未知，有可能会很耗时。如果在 <code>notifyObservers()</code> 函数上加 synchronized 锁，<code>notifyObservers()</code> 函数持有锁的时间就有可能会很长，这就会导致其他线程迟迟获取不到锁，影响整个 Observable 类的并发性能</p>\n<p>Vector 类不是线程安全的，在多线程环境下，同时添加、删除、遍历 Vector 类对象中的元素，会出现不可预期的结果。所以，在 JDK 的代码实现中，为了避免直接给 <code>notifyObservers()</code> 函数加锁而出现性能问题，JDK 采用了一种折中的方案。这个方案有点类似于之前讲过的让迭代器支持”快照“的解决方案</p>\n<p>在 <code>notifyObservers()</code> 函数中，先拷贝一份观察者列表，赋值给函数的局部变量，局部变量是线程私有的，并不在线程间共享。这个拷贝出来的线程私有的观察者列表就相当于一个快照。遍历快照，逐一执行每个观察者的 <code>update()</code> 函数。而这个遍历执行的过程是在快照这个局部变量上操作的，不存在线程安全问题，不需要加锁。所以，只需要对拷贝创建快照的过程加锁，加锁的范围减少了很多，并发性能提高了</p>\n<p>为什么说这是一种折中的方案呢？这是因为，这种加锁方法实际上是存在一些问题的。在创建好快照之后，添加、删除观察者都不会更新快照，新加入的观察者就不会被通知到，新删除的观察者仍然会被通知到。这种权衡是否能接受完全看你的业务场景。实际上，这种处理方式也是多线程编程中减小锁粒度、提高并发性能的常用方法</p>\n<h2 id=\"1-7-单例模式在-Runtime-类中的应用\"><a href=\"#1-7-单例模式在-Runtime-类中的应用\" class=\"headerlink\" title=\"1.7 单例模式在 Runtime 类中的应用\"></a>1.7 单例模式在 Runtime 类中的应用</h2><p>每个 Java 应用在运行时会启动一个 JVM 进程，每个 JVM 进程都只对应一个 Runtime 实例，用于查看 JVM 状态以及控制 JVM 行为。进程内唯一，所以比较适合设计为单例。在编程的时候，我们不能自己去实例化一个 Runtime 对象，只能通过 <code>getRuntime()</code> 静态方法来获得</p>\n<p>Runtime 类的的代码实现如下所示。这里面只包含部分相关代码，其他代码做了省略。从代码中也可以看出，它使用了最简单的饿汉式的单例实现方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Every Java application has a single instance of class\n* &lt;code&gt;Runtime&lt;&#x2F;code&gt; that allows the application to interface with\n* the environment in which the application is running. The current\n* runtime can be obtained from the &lt;code&gt;getRuntime&lt;&#x2F;code&gt; method.\n* &lt;p&gt;\n* An application cannot create its own instance of this class.\n*\n* @author unascribed\n* @see java.lang.Runtime#getRuntime()\n* @since JDK1.0\n*&#x2F;\npublic class Runtime &#123;\n\tprivate static Runtime currentRuntime &#x3D; new Runtime();\n\tpublic static Runtime getRuntime() &#123;\n\t\treturn currentRuntime;\n\t&#125;\n\t&#x2F;** Don&#39;t let anyone else instantiate this class *&#x2F;\n\tprivate Runtime() &#123;&#125;\n\t&#x2F;&#x2F;....\n\tpublic void addShutdownHook(Thread hook) &#123;\n\t\tSecurityManager sm &#x3D; System.getSecurityManager();\n\t\tif (sm !&#x3D; null) &#123;\n\t\t\tsm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n\t\t&#125;\n\t\tApplicationShutdownHooks.add(hook);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;</code></pre>\n\n<h2 id=\"1-8-其他模式在-JDK-中的应用汇总\"><a href=\"#1-8-其他模式在-JDK-中的应用汇总\" class=\"headerlink\" title=\"1.8 其他模式在 JDK 中的应用汇总\"></a>1.8 其他模式在 JDK 中的应用汇总</h2><p>实际上，在讲解理论部分的时候（见文章开头的前三篇内容），已经讲过很多模式在 Java JDK 中的应用了。这里再回顾一下：</p>\n<ul>\n<li>在讲到模板模式的时候，结合 Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList 四个例子，来具体讲解了它的两个作用：扩展性和复用性</li>\n<li>在讲到享元模式的时候，讲到 Integer 类中的 -128~127 之间的整型对象是可以复用的，还讲到 String 类型中的常量字符串也是可以复用的。这些都是享元模式的经典应用</li>\n<li>在讲到职责链模式的时候，讲到Java Servlet 中的 Filter 就是通过职责链来实现的，同时还对比了 Spring 中的 interceptor。实际上，拦截器、过滤器这些功能绝大部分都是采用职责链模式来实现的</li>\n<li>在讲到的迭代器模式的时候，重点剖析了 Java 中 Iterator 迭代器的实现</li>\n</ul>\n<h1 id=\"2-从-Unix-学习应对大型复杂项目开发\"><a href=\"#2-从-Unix-学习应对大型复杂项目开发\" class=\"headerlink\" title=\"2. 从 Unix 学习应对大型复杂项目开发\"></a>2. 从 Unix 学习应对大型复杂项目开发</h1><p>软件开发的难度无外乎两点，一是技术难，意思是说，代码量不一定多，但要解决的问题比较难，需要用到一些比较深的技术解决方案或者算法，不是靠“堆人”就能搞定的，比如自动驾驶、图像识别、高性能消息队列等；二是复杂度，意思是说，技术不难，但项目很庞大，业务复杂，代码量多，参与开发的人多，比如物流系统、财务系统等。第一点涉及细分专业的领域知识，这里重点来讲第二点，如何应对软件开发的复杂度</p>\n<p>简单的“hello world”程序，谁都能写得出来。几千行的代码谁都能维护得了。但是，当代码超过几万行、十几万，甚至几十万行、上百万行的时候，软件的复杂度就会呈指数级增长。这种情况下，不仅仅要求程序运行得了，运行得正确，还要求代码看得懂、维护得了。实际上，复杂度不仅仅体现在代码本身，还体现在协作研发上，如何管理庞大的团队，来进行有条不紊地协作开发，也是一个很复杂的难题</p>\n<p>如何应对复杂软件开发？Unix 开源项目就是一个值得学习的例子</p>\n<p>Unix 从 1969 年诞生，一直演进至今，代码量有几百万行，如此庞大的项目开发，能够如此完美的协作开发，并且长期维护，保持足够的代码质量，这里面有很多成功的经验可以借鉴。所以，接下来就以 Unix 开源项目的开发为引子，通过下面三个话题，详细地讲讲应对复杂软件开发的方法论</p>\n<ul>\n<li>从设计原则和思想的角度来看，如何应对庞大而复杂的项目开发？</li>\n<li>从研发管理和开发技巧的角度来看，如何应对庞大而复杂的项目开发？</li>\n<li>聚焦在 Code Review 上来看，如何通过 Code Reviwe 保持项目的代码质量？</li>\n</ul>\n<h2 id=\"2-1-设计原则和思想\"><a href=\"#2-1-设计原则和思想\" class=\"headerlink\" title=\"2.1 设计原则和思想\"></a>2.1 设计原则和思想</h2><h3 id=\"2-1-1-封装与抽象\"><a href=\"#2-1-1-封装与抽象\" class=\"headerlink\" title=\"2.1.1 封装与抽象\"></a>2.1.1 封装与抽象</h3><p>在 Unix、Linux 系统中，有一句经典的话，“Everything is a file”，翻译成中文就是“一切皆文件”。这句话的意思就是，在 Unix、Linux 系统中，很多东西都被抽象成“文件”这样一个概念，比如 Socket、驱动、硬盘、系统信息等。它们使用文件系统的路径作为统一的命名空间（namespace），使用统一的 read、write 标准函数来访问</p>\n<p>比如要查看 CPU 的信息，在 Linux 系统中，只需要使用 Vim、Gedit 等编辑器或者 cat 命令，像打开其他文件一样，打开 <code>/proc/cpuinfo</code>，就能查看到相应的信息。除此之外，还可以通过查看 <code>/proc/uptime</code> 文件，了解系统运行了多久，查看 <code>/proc/version</code> 了解系统的内核版本等</p>\n<p>实际上，“一切皆文件”就体现了封装和抽象的设计思想</p>\n<p>封装了不同类型设备的访问细节，抽象为统一的文件访问方式，更高层的代码就能基于统一的访问方式，来访问底层不同类型的设备。这样做的好处是，隔离底层设备访问的复杂性</p>\n<p>统一的访问方式能够简化上层代码的编写，并且代码更容易复用。除此之外，抽象和封装还能有效控制代码复杂性的蔓延，将复杂性封装在局部代码中，隔离实现的易变性，提供简单、统一的访问接口，让其他模块来使用，其他模块基于抽象的接口而非具体的实现编程，代码会更加稳定</p>\n<h3 id=\"2-1-2-分层与模块化\"><a href=\"#2-1-2-分层与模块化\" class=\"headerlink\" title=\"2.1.2 分层与模块化\"></a>2.1.2 分层与模块化</h3><p>模块化是构建复杂系统的常用手段</p>\n<p>对于像 Unix 这样的复杂系统，没有人能掌控所有的细节。之所以能开发出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，比如进程调度、进程通信、内存管理、虚拟文件系统、网络接口等模块。不同的模块之间通过接口来进行通信，模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样，将各个模块组装起来，构建成一个超级复杂的系统</p>\n<p>除此之外，Unix、Linux 等大型系统之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好。不同的团队负责不同的模块开发，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转</p>\n<p>实际上，除了模块化之外，分层也是常用来架构复杂系统的方法</p>\n<p>我们常说，计算机领域的任何问题都可以通过增加一个间接的中间层来解决，这本身就体现了分层的重要性。比如，Unix 系统也是基于分层开发的，它可以大致上分为三层，分别是内核、系统调用、应用层。每一层都对上层封装实现细节，暴露抽象的接口来调用。而且，任意一层都可以被重新实现，不会影响到其他层的代码</p>\n<p>面对复杂系统的开发，要善于应用分层技术，把容易复用、跟具体业务关系不大的代码，尽量下沉到下层，把容易变动、跟具体业务强相关的代码，尽量上移到上层</p>\n<h3 id=\"2-1-3-基于接口通信\"><a href=\"#2-1-3-基于接口通信\" class=\"headerlink\" title=\"2.1.3 基于接口通信\"></a>2.1.3 基于接口通信</h3><p>前面讲了分层、模块化，那不同的层之间、不同的模块之间，是如何通信的呢？一般来讲都是通过接口调用。在设计模块（module）或者层（layer）要暴露的接口的时候，要学会隐藏实现，接口从命名到定义都要抽象一些，尽量少涉及具体的实现细节</p>\n<p>比如，Unix 系统提供的 <code>open()</code> 文件操作函数，底层实现非常复杂，涉及权限控制、并发控制、物理存储，但用起来却非常简单。除此之外，因为 <code>open()</code> 函数基于抽象而非具体的实现来定义，所以在改动 <code>open()</code> 函数的底层实现的时候，并不需要改动依赖它的上层代码</p>\n<h3 id=\"2-1-4-高内聚、松耦合\"><a href=\"#2-1-4-高内聚、松耦合\" class=\"headerlink\" title=\"2.1.4 高内聚、松耦合\"></a>2.1.4 高内聚、松耦合</h3><p>高内聚、松耦合是一个比较通用的设计思想，内聚性好、耦合少的代码，能让我们在修改或者阅读代码的时候，聚集到在一个小范围的模块或者类中，不需要了解太多其他模块或类的代码，让焦点不至于太发散，也就降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不会牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多</p>\n<p>实际上，前面讲到的很多方法，比如封装、抽象、分层、模块化、基于接口通信，都能有效地实现代码的高内聚、松耦合。反过来，代码的高内聚、松耦合，也就意味着，抽象、封装做到比较到位、代码结构清晰、分层和模块化合理、依赖关系简单，那代码整体的质量就不会太差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围也是非常有限的。可以聚焦于这个模块或者类做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就小多了</p>\n<h3 id=\"2-1-5-为扩展而设计\"><a href=\"#2-1-5-为扩展而设计\" class=\"headerlink\" title=\"2.1.5 为扩展而设计\"></a>2.1.5 为扩展而设计</h3><p>越是复杂项目，越要在前期设计上多花点时间。提前思考项目中未来可能会有哪些功能需要扩展，提前预留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构的情况下，轻松地添加新功能</p>\n<p>做到代码可扩展，需要代码满足开闭原则。特别是像 Unix 这样的开源项目，有 N 多人参与开发，任何人都可以提交代码到代码库中。代码满足开闭原则，基于扩展而非修改来添加新功能，最小化、集中化代码改动，避免新代码影响到老代码，降低引入 bug 的风险</p>\n<p>除了满足开闭原则，做到代码可扩展，前面也提到很多方法，比如封装和抽象，基于接口编程等。识别出代码可变部分和不可变部分，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，供上层系统使用。当具体的实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改</p>\n<h3 id=\"2-1-6-KISS-首要原则\"><a href=\"#2-1-6-KISS-首要原则\" class=\"headerlink\" title=\"2.1.6 KISS 首要原则\"></a>2.1.6 KISS 首要原则</h3><p>简单清晰、可读性好，是任何大型软件开发要遵循的首要原则。只要可读性好，即便扩展性不好，顶多就是多花点时间、多改动几行代码的事情。但是，如果可读性不好，连看都看不懂，那就不是多花时间可以解决得了的了。如果对现有代码的逻辑似懂非懂，抱着尝试的心态去修改代码，引入 bug 的可能性就会很大</p>\n<p>不管是自己还是团队，在参与大型项目开发的时候，要尽量避免过度设计、过早优化，在扩展性和可读性有冲突的时候，或者在两者之间权衡，模棱两可的时候，应该选择遵循 KISS原则，首选可读性</p>\n<h3 id=\"2-1-7-最小惊奇原则\"><a href=\"#2-1-7-最小惊奇原则\" class=\"headerlink\" title=\"2.1.7 最小惊奇原则\"></a>2.1.7 最小惊奇原则</h3><p>《Unix 编程艺术》一书中提到一个 Unix 的经典设计原则，叫“最小惊奇原则”，英文是“The Least Surprise Priciple”。实际上，这个原则等同于“遵守开发规范”，意思是，在做设计或者编码的时候要遵守统一的开发规范，避免反直觉的设计</p>\n<p>遵从统一的编码规范，所有的代码都像一个人写出来的，能有效地减少阅读干扰。在大型软件开发中，参与开发的人员很多，如果每个人都按照自己的编码习惯来写代码，那整个项目的代码风格就会千奇百怪，这个类是这种编码风格，另一个类又是另外一种风格。在阅读的时候，要不停地切换去适应不同的编码风格，可读性就变差了。所以，对于大型项目的开发来说，要特别重视遵守统一的开发规范</p>\n<h2 id=\"2-2-研发管理和开发技巧\"><a href=\"#2-2-研发管理和开发技巧\" class=\"headerlink\" title=\"2.2 研发管理和开发技巧\"></a>2.2 研发管理和开发技巧</h2><p>项目越复杂、代码量越多、参与开发人员越多、开发维护时间越长，就越是要重视代码质量。代码质量下降会导致项目研发困难重重，比如：开发效率低，招了很多人，天天加班，出活却不多；线上 bug 频发，查找 bug 困难，领导发飙，中层束手无策，工程师抱怨不断</p>\n<p>导致代码质量不高的原因有很多，比如：代码无注释，无文档，命名差，层次结构不清晰，调用关系混乱，到处 hardcode，充斥着各种临时解决方案等等。那怎么才能时刻保证代码质量呢？当然，首要的是团队技术素质要过硬，能够适当地利用设计原则、思想、模式编写高质量的代码。除此之外，还有一些外在的方法可循</p>\n<h3 id=\"2-2-1-吹毛求疵般地执行编码规范\"><a href=\"#2-2-1-吹毛求疵般地执行编码规范\" class=\"headerlink\" title=\"2.2.1 吹毛求疵般地执行编码规范\"></a>2.2.1 吹毛求疵般地执行编码规范</h3><p>严格执行代码规范，可以使一个项目乃至整个公司的代码具有完全统一的风格，就像同一个人编写的。而且，命名良好的变量、函数、类和注释，也可以提高代码的可读性。编码规范不难掌握，关键是要严格执行。在 Code Review 时，一定要严格要求，看到不符合规范的代码，一定要指出并要求修改</p>\n<p>但是，实际情况往往事与愿违。虽然大家都知道优秀的代码规范是怎样的，但在具体写代码的过程中，执行得却不好。这种情况产生的主要原因还是不够重视。很多人会觉得，一个变量或者函数命名成啥样，关系并不大。所以命名时不推敲，注释也不写，Code Review 的时候也都一副事不关己的心态，觉得没必要太抠细节。日积月累，项目代码就会变得越来越差。所以这里还是要强调一下，细节决定成败，代码规范的严格执行极为关键</p>\n<h3 id=\"2-2-2-编写高质量的单元测试\"><a href=\"#2-2-2-编写高质量的单元测试\" class=\"headerlink\" title=\"2.2.2 编写高质量的单元测试\"></a>2.2.2 编写高质量的单元测试</h3><p>单元测试是最容易执行且对提高代码质量见效最快的方法之一。高质量的单元测试不仅仅要求测试覆盖率要高，还要求测试的全面性，除了测试正常逻辑的执行之外，还要重点、全面地测试异常下的执行情况。毕竟代码出问题的地方大部分都发生在异常、边界条件下</p>\n<p>对于大型复杂项目，集成测试、黑盒测试都很难测试全面，因为组合爆炸，穷举所有测试用例的成本很高，几乎是不可能的。单元测试就是很好的补充。它可以在类、函数这些细粒度的代码层面，保证代码运行无误。底层细粒度的代码 bug 少了，组合起来构建而成的整个系统的 bug 也就相应的减少了</p>\n<h3 id=\"2-2-3-不流于形式的-Code-Review\"><a href=\"#2-2-3-不流于形式的-Code-Review\" class=\"headerlink\" title=\"2.2.3 不流于形式的 Code Review\"></a>2.2.3 不流于形式的 Code Review</h3><p>如果说很多工程师对单元测试不怎么重视，那对 Code Review 就是不怎么接受。我之前跟一些同行聊起 Code Review 的时候，很多人的反应是，这玩意儿不可能很好地执行，形式大于效果，纯粹是浪费时间。是的，即便 Code Review 做得再流畅，也是要花时间的。所以，在业务开发任务繁重的时候，Code Review 往往会流于形式、虎头蛇尾，效果确实不怎么好</p>\n<p>但并不能因此就否定 Code Review 本身的价值。在 Google、Facebook 等外企中，Code Review 应用得非常成功，已经成为了开发流程中不可或缺的一部分。所以，要想真正发挥 Code Review 的作用，关键还是要执行到位，不能流于形式</p>\n<h3 id=\"2-2-4-开发未动、文档先行\"><a href=\"#2-2-4-开发未动、文档先行\" class=\"headerlink\" title=\"2.2.4 开发未动、文档先行\"></a>2.2.4 开发未动、文档先行</h3><p>对大部分工程师来说，编写技术文档是件挺让人“反感”的事情。一般来讲，在开发某个系统或者重要模块或者功能之前，应该先写技术文档，然后，发送给同组或者相关同事审查，在审查没有问题的情况下再开发。这样能够保证事先达成共识，开发出来的东西不至于走样。而且，当开发完成之后，进行 Code Review 的时候，代码审查者通过阅读开发文档，也可以快速理解代码</p>\n<p>除此之外，对于团队和公司来讲，文档是重要的财富。对新人熟悉代码或任务的交接等，技术文档很有帮助。而且，作为一个规范化的技术团队，技术文档是一种摒弃作坊式开发和个人英雄主义的有效方法，是保证团队有效协作的途径</p>\n<h3 id=\"2-2-5-持续重构、重构、重构\"><a href=\"#2-2-5-持续重构、重构、重构\" class=\"headerlink\" title=\"2.2.5 持续重构、重构、重构\"></a>2.2.5 持续重构、重构、重构</h3><p>我个人比较反对平时不注重代码质量，堆砌烂代码，实在维护不了了就大刀阔斧地重构甚至重写。有的时候，因为项目代码太多，重构很难做到彻底，最后又搞出来一个四不像的怪物，这就更麻烦了！</p>\n<p>优秀的代码或架构不是一开始就能设计好的，就像优秀的公司或产品也都是迭代出来的。我们无法 100% 预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单。所以，随着系统的演进，重构是不可避免的</p>\n<p>虽然刚刚说不支持大刀阔斧、推倒重来式的大重构，但持续的小重构还是比较提倡的。它也是时刻保证代码质量、防止代码腐化的有效手段。换句话说，不要等到问题堆得太多了再去解决，要时刻有人对代码整体质量负责任，平时没事就改改代码</p>\n<p>特别是一些业务开发团队，有时候为了快速完成一个业务需求，只追求速度，到处 hardcode，在完全不考虑非功能性需求、代码质量的情况下，堆砌烂代码。实际上，这种情况还是比较常见的。不过没关系，等有时间了，一定要记着重构，不然烂代码越堆越多，总有一天代码会变得无法维护</p>\n<h3 id=\"2-2-6-对项目与团队进行拆分\"><a href=\"#2-2-6-对项目与团队进行拆分\" class=\"headerlink\" title=\"2.2.6 对项目与团队进行拆分\"></a>2.2.6 对项目与团队进行拆分</h3><p>团队人比较少，比如十几个人的时候，代码量不多，不超过 10 万行，怎么开发、怎么管理都没问题，大家互相都比较了解彼此做的东西。即便代码质量太差了，我们大不了把它重写一遍。但是，对于一个大型项目来说，参与开发的人员会比较多，代码量很大，有几十万、甚至几百万行代码，有几十、甚至几百号人同时开发维护，那研发管理就变得极其重要</p>\n<p>面对大型复杂项目，不仅仅需要对代码进行拆分，还需要对研发团队进行拆分。前讲到了一些代码拆分的方法，比如模块化、分层等。同理，也可以把大团队拆成几个小团队。每个小团队对应负责一个小的项目（模块、微服务等），这样每个团队负责的项目包含的代码都不至于很多，也不至于出现代码质量太差无法维护的情况</p>\n<h2 id=\"2-3-Code-Review\"><a href=\"#2-3-Code-Review\" class=\"headerlink\" title=\"2.3 Code Review\"></a>2.3 Code Review</h2><h3 id=\"2-3-1-优势\"><a href=\"#2-3-1-优势\" class=\"headerlink\" title=\"2.3.1 优势\"></a>2.3.1 优势</h3><p><strong>1、Code Review 践行“三人行必有我师”</strong></p>\n<p>有时候可能会觉得，团队中的资深员工或者技术 leader 的技术比较牛，写的代码很好，他们的代码就不需要 Review 了，重点 Review 资历浅的员工的代码就可以了。实际上，这种认识是不对的</p>\n<p>Google 工程师的平均研发水平都很高，但即便如此，不管谁提交的代码，包括 Jeff Dean 的，只要需要 Review，都会收到很多 comments（修改意见）。“三人行必有我师”，即便自己觉得写得已经很好的代码，只要经过不停地推敲，都有持续改进的空间</p>\n<p>所以，永远不要觉得自己很厉害，写的代码就不需要别人 Review 了；永远不要觉得自己水平很一般，就没有资格给别人 Review 了；更不要觉得技术大牛让你 Review 代码只是缺少你的一个“approve”，随便看看就可以</p>\n<p><strong>2、Code Review 能摒弃“个人英雄主义”</strong></p>\n<p>在一个成熟的公司里，所有的架构设计、实现，都应该是一个团队的产出。尽管这个过程可能会由某个人来主导，但应该是整个团队共同智慧的结晶</p>\n<p>如果一个人默默地写代码提交，不经过团队的 Review，这样的代码蕴含的是一个人的智慧。代码的质量完全依赖于这个人的技术水平。这就会导致代码质量参差不齐。如果经过团队多人 Review、打磨，代码蕴含的是整个团队的智慧，可以保证代码按照团队中的最高水准输出</p>\n<p><strong>3、Code Review 能有效提高代码可读性</strong></p>\n<p>前面反复强调，在大部分情况下，代码的可读性比任何其他方面（比如扩展性等）都重要。可读性好，代表后期维护成本低，线上 bug 容易排查，新人容易熟悉代码，老人离职时代码容易接手。而且，可读性好，也说明代码足够简单，出错可能性小、bug 少</p>\n<p>不过，自己看自己写的代码，总是会觉得很易读，但换另外一个人来读你的代码，可能就不这么认为了。毕竟自己写的代码，其中涉及的业务、技术自己很熟悉，别人不一定会熟悉。既然自己对可读性的判断很容易出现错觉，那 Code Review 就是一种考察代码可读性的很好手段。如果代码审查者很费劲才能看懂你写的代码，那就说明代码的可读性有待提高了</p>\n<p><strong>4、Code Review 是技术传帮带的有效途径</strong></p>\n<p>良好的团队需要技术和业务的“传帮带”，那如何来做“传帮带”呢？当然，业务上面，可能通过文档或口口相传的方式，那技术呢？如何培养初级工程师的技术能力呢？Code Review 就是一种很好的途径。每次 Code Review 都是一次真实案例的讲解。通过 Code Review，在实践中将技术传递给初级工程师，比让他们自己学习、自己摸索来得更高效！</p>\n<p><strong>5、Code Review 保证代码不止一个人熟悉</strong></p>\n<p>如果一段代码只有一个人熟悉，如果这个同事休假了或离职了，代码交接起来就比较费劲。有时候，单纯只看代码还看不大懂，又要跟 PM、业务团队、或者其他技术团队，再重复来一轮沟通，搞的其他团队的人都很烦。而 Code Review 能保证任何代码同时都至少有两个同事熟悉，互为备份，有备无患，除非两个同事同时都离职……</p>\n<p><strong>6、Code Review 能打造良好的技术氛围</strong></p>\n<p>提交代码 Review 的人，希望自己写的代码足够优秀，毕竟被同事 Review 出很多问题，是件很丢人的事情。而做 Code review 的人，也希望自己尽可能地提出有建设性意见，展示自己的能力。所以，Code Review 还能增进技术交流，活跃技术氛围，培养大家的极客精神，以及对代码质量的追求</p>\n<p>一个良好的技术氛围，能让团队有很强的自驱力。不用技术 leader 反复强调代码质量有多重要，团队中的成员就会自己主动去关注代码质量的问题。这比制定各种规章制度、天天督促执行要更加有效。实际上，好的技术氛围也能降低团队的离职率</p>\n<p><strong>7、Code Review 是一种技术沟通方式</strong></p>\n<p>Talk is cheap，show me the code。怎么“show”，通过 Code Review 工具来“show”，这样也方便别人反馈意见。特别是对于跨不同办公室、跨时区的沟通，Code Review 是一种很好的沟通方式。今天白天写的代码，明天来上班的时候，跨时区的同事已经 Review 好了，改改提交，继续写新的代码了。这样的协作效率会很高</p>\n<p><strong>8、Code Review 能提高团队的自律性</strong></p>\n<p>在开发过程中，难免会有人不自律，存在侥幸心理：反正写的代码也没人看，随便写写就提交了。Code Review 相当于一次代码直播，曝光 dirty code，有一定的威慑力。这样大家就不敢随便应付一下就提交代码了</p>\n<h3 id=\"2-3-2-如何在团队中落地执行-Code-Review？\"><a href=\"#2-3-2-如何在团队中落地执行-Code-Review？\" class=\"headerlink\" title=\"2.3.2 如何在团队中落地执行 Code Review？\"></a>2.3.2 如何在团队中落地执行 Code Review？</h3><p>1、有人认为，Code Review 流程太长，太浪费时间，特别是工期紧的时候，今天改的代码，明天就要上，如果要等同事 Review，同事有可能没时间，这样就来不及。这个时候该怎么办呢？</p>\n<p>我所经历的项目还没有一个因为工期紧，导致没有时间 Code Review 的。工期都是人排的，稍微排松点就行了。关键还是在于整个公司对 Code Review 的接受程度。而且，Code Review 熟练之后，并不需要花费太长的时间。尽管开始做 Code Review 的时候，可能因为不熟练，需要有一个 checklist 对照着来做。起步阶段可能会比较耗时。但熟练之后，Code Review 就像键盘盲打一样，已经忘记了哪个手指按的是哪个键了，扫一遍代码就能揪出绝大部分问题</p>\n<p>2、有人认为，业务一直在变，今天写的代码明天可能就要再改，代码可能不会长期维护，写得太好也没用。这种情况下是不是就不需要 Code Review 了呢？</p>\n<p>这种现象在游戏开发、一些早期的创业公司或者项目验证阶段比较常见。项目讲求短平快，先验证产品，再优化技术。如果确实面对的还只是生存问题，代码质量确实不是首要的，特殊情况下，不做 Code Review 是支持的！</p>\n<p>3、有人说，团队成员技术水平不高，过往也没有 Code Review 的经验，不知道 Review 什么，也 Review 不出什么。自己代码都没写明白，不知道什么样的代码是好的，什么样的代码是差的，更不要说 Review 别人的代码了。在 Code Review 的时候，团队成员大眼瞪小眼，只能 Review 点语法，形式大于效果。这种情况该怎么办？</p>\n<p>这种情况也挺常见。不过没关系，团队的技术水平都是可以培养的。可以先让资深同事、技术好的同事或技术 leader，来 Review 其他所有人的代码。Review 的过程本身就是一种“传帮带”的过程。慢慢地，整个团队就知道该如何 Review 了。虽然这可能会有一个相当长的过程，但如果真的想在团队中执行 Code Review，这不失为一种“曲线救国”的方法</p>\n<p>4、还有人说，刚开始 Code Review 的时候，大家都还挺认真，但时间长了，大家觉得这事跟 KPI 无关，而且还要看别人的代码，理解别人写的代码的业务，多浪费时间啊。慢慢地，Code Review 就变得流于形式了。有人提交了代码，随便抓个人 Review。Review 的人也不认真，随便扫一眼就点“approve”。这种情况该如何应对？</p>\n<p>首先，要明确的告诉 Code Review 的重要性，要严格执行，让大家不要懈怠，适当的时候可以“杀鸡儆猴”。其次，可以像 Google 一样，将 Code Review 间接地跟 KPI、升职等联系在一块，高级工程师有义务做 Code Review，就像有义务做技术面试一样。再次，想办法活跃团队的技术氛围，把 Code Review 作为一种展示自己技术的机会，带动起大家对 Code Review 的积极性，提高大家对 Code Review 的认同感</p>\n<h1 id=\"3-Google-Guava\"><a href=\"#3-Google-Guava\" class=\"headerlink\" title=\"3. Google Guava\"></a>3. Google Guava</h1><p>Google Guava 是 Google 公司内部 Java 开发工具库的开源版本。Google 内部的很多 Java 项目都在使用它。它提供了一些 JDK 没有提供的功能，以及对 JDK 已有功能的增强功能。其中就包括：集合（Collections）、缓存（Caching）、原生类型支持（Primitives Support）、并发库（Concurrency Libraries）、通用注解（Common Annotation）、字符串处理（Strings Processing）、数学计算（Math）、I&#x2F;O、事件总线（EventBus）等等</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d520a9601f26436f99abf8c62e0bd66e.png\" alt=\"在这里插入图片描述\"></p>\n<p>JDK 的全称是 Java Development Kit。它本身就是 Java 提供的工具类库。那既然有了 JDK，为什么 Google 还要开发一套新的类库 Google Guava？是否是重复造轮子？两者的差异化在哪里？</p>\n<h2 id=\"3-1-如何发现通用的功能模块？\"><a href=\"#3-1-如何发现通用的功能模块？\" class=\"headerlink\" title=\"3.1 如何发现通用的功能模块？\"></a>3.1 如何发现通用的功能模块？</h2><p>很多人觉得做业务开发没有挑战，实际上，做业务开发也会涉及很多非业务功能的开发，比如前面讲到的 ID 生成器、性能计数器、EventBus、DI 容器，以及后面会讲到的限流框架、幂等框架、灰度组件。关键在于，要有善于发现、善于抽象的能力，并且具有扎实的设计、开发能力，能够发现这些非业务的、可复用的功能点，并且从业务逻辑中将其解耦抽象出来，设计并开发成独立的功能模块</p>\n<p>在我看来，在业务开发中，跟业务无关的通用功能模块，常见的一般有三类：类库（library）、框架（framework）、功能组件（component）等</p>\n<p>其中，Google Guava 属于类库，提供一组 API 接口。EventBus、DI 容器属于框架，提供骨架代码，能让业务开发人员聚焦在业务开发部分，在预留的扩展点里填充业务代码。ID生成器、性能计数器属于功能组件，提供一组具有某一特殊功能的 API 接口，有点类似类库，但更加聚焦和重量级，比如，ID 生成器有可能会依赖 Redis 等外部系统，不像类库那么简单</p>\n<p>前面提到的限流、幂等、灰度，到底是属于框架还是功能组件，要视具体情况而定。如果业务代码嵌套在它们里面开发，那就可以称它们为框架。如果它们只是开放 API 接口，供业务系统调用，那就可以称它们为组件。不过，叫什么没有太大关系，不必太深究概念</p>\n<p>那如何发现项目中的这些通用的功能模块呢？</p>\n<p>实际上，不管是类库、框架还是功能组件，这些通用功能模块有两个最大的特点：复用和业务无关。Google Guava 就是一个典型的例子</p>\n<p>如果没有复用场景，那也就没有了抽离出来，设计成独立模块的必要了。如果与业务有关又可复用，大部分情况下会设计成独立的系统（比如微服务），而不是类库、框架或功能组件。所以，如果负责开发的代码，与业务无关并且可能会被复用，那就可以考虑将它独立出来，开发成类库、框架、功能组件等通用功能模块</p>\n<p>这里讲的是，在业务开发中，如何发现通用的功能模块。除了业务开发团队之外，很多公司还有一些基础架构团队、架构开发团队，他们除了开发类库、框架、功能组件之外，也会开发一些通用的系统、中间件，比如，Google MapReduce、Kafka 消息中间件、监控系统、分布式调用链追踪系统等</p>\n<h2 id=\"3-2-如何开发通用的功能模块？\"><a href=\"#3-2-如何开发通用的功能模块？\" class=\"headerlink\" title=\"3.2 如何开发通用的功能模块？\"></a>3.2 如何开发通用的功能模块？</h2><p>当发现了通用功能模块的开发需求之后，如何将它设计开发成一个优秀的类库、框架或功能组件呢？这里先不讲具体的开发技巧，先讲一些更普适的开发思想</p>\n<p>作为通用的类库、框架、功能组件，我们希望开发出来之后，不仅仅是自己项目使用，还能用在其他团队的项目中，甚至可以开源出来供更多人所用，这样才能发挥它更大的价值，构建自己的影响力</p>\n<p>所以，对于这些类库、框架、功能组件的开发，不能闭门造车，要把它们当作“产品”来开发。这个产品是一个“技术产品”，目标用户是“程序员”，解决的是他们的“开发痛点”。要多换位思考，站在用户的角度上，来想他们到底想要什么样的功能</p>\n<p>对于一个技术产品来说，尽管 Bug 少、性能好等技术指标至关重要，但是否易用、易集成、易插拔、文档是否全面、是否容易上手等，这些产品素质也非常重要，甚至还能起到决定性作用。往往就是这些很容易忽视、不被重视的东西，会决定一个技术产品是否能在众多的同类中脱颖而出</p>\n<p>具体到 Google Guava，它是一个开发类库，目标用户是 Java 开发工程师，解决用户主要痛点是，相对于 JDK，提供更多的工具类，简化代码编写，比如，它提供了用来判断 null 值的 Preconditions 类；Splitter、Joiner、CharMatcher 字符串处理类；Multisets、Multimaps、Tables 等更丰富的 Collections 类等等</p>\n<p>它的优势有这样几点：第一，由 Google 管理、长期维护，经过充分的单元测试，代码质量有保证；第二，可靠、性能好、高度优化，比如 Google Guava 提供的 Immutable Collections 要比 JDK 的 unmodifiableCollection 性能好；第三，全面、完善的文档，容易上手，学习成本低，可以去看下它的 Github Wiki</p>\n<p>刚刚讲的是“产品意识”，再来讲讲“服务意识”。如果开发的东西是提供给其他团队用的，一定要有“服务意识”。对于程序员来说，这点可能比“产品意识”更加欠缺</p>\n<p>首先，从心态上，别的团队使用我们开发出来的技术产品，要学会感谢。这点很重要。心态不同了，做起事来就会有微妙的不同。其次，除了写代码，还要有抽出大量时间答疑、充当客服角色的心理准备。有了这个心理准备，别的团队的人在问问题的时候，也就不会很烦了</p>\n<p>相对于业务代码来说，开发这种被多处复用的通用代码，对代码质量的要求更高些，因为这些项目的影响面更大，一旦出现 bug，会牵连很多系统或其他项目。特别是如果你要把项目开源，影响就更大了。所以，这类项目的代码质量一般都很好，开发这类项目对代码能力的锻炼更有大</p>\n<p>具体到 Google Guava，它是 Google 员工开发的，单元测试很完善，注释写得很规范，代码写得也很好，可以说是学习 Google 开发经验的一手资料，建议你如果有时间的话，可以认真阅读一下它的代码</p>\n<p>尽管开发这些通用功能模块更加锻炼技术，但也不要重复造轮子，能复用的尽量复用。而且，在项目中，如果想把所有的通用功能都开发为独立的类库、框架、功能组件，这就有点大动干戈了，有可能会得不到领导的支持。毕竟从项目中将这部分通用功能独立出来开发，比起作为项目的一部分来开发，会更加耗时</p>\n<p>所以，权衡一下的话，建议初期先把这些通用的功能作为项目的一部分来开发。不过，在开发的时候，做好模块化工作，将它们尽量跟其他模块划清界限，通过接口、扩展点等松耦合的方式跟其他模式交互。等到时机成熟了，再将它从项目中剥离出来。因为之前模块化做的好，耦合程度低，剥离出来的成本也就不会很高</p>\n<h2 id=\"3-3-Google-Guava-中用到的几种设计模式\"><a href=\"#3-3-Google-Guava-中用到的几种设计模式\" class=\"headerlink\" title=\"3.3 Google Guava 中用到的几种设计模式\"></a>3.3 Google Guava 中用到的几种设计模式</h2><h3 id=\"3-3-1-Builder-模式\"><a href=\"#3-3-1-Builder-模式\" class=\"headerlink\" title=\"3.3.1 Builder 模式\"></a>3.3.1 Builder 模式</h3><p>在项目开发中，经常用到缓存。它可以非常有效地提高访问速度。常用的缓存系统有 Redis、Memcache 等。但是，如果要缓存的数据比较少，完全没必要在项目中独立部署一套缓存系统。毕竟系统都有一定出错的概率，项目中包含的系统越多，那组合起来，项目整体出错的概率就会升高，可用性就会降低。同时，多引入一个系统就要多维护一个系统，项目维护的成本就会变高</p>\n<p>取而代之，可以在系统内部构建一个内存缓存，跟系统集成在一起开发、部署。那如何构建内存缓存呢？可以基于 JDK 提供的类，比如 HashMap，从零开始开发内存缓存。不过，从零开发一个内存缓存，涉及的工作就会比较多，比如缓存淘汰策略等。为了简化开发，就可以使用 Google Guava 提供的现成的缓存工具类<br><code>com.google.common.cache.*</code>，如下例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CacheDemo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tCache&lt;String, String&gt; cache &#x3D; CacheBuilder.newBuilder()\n\t\t                              .initialCapacity(100)\n\t\t                              .maximumSize(1000)\n\t\t                              .expireAfterWrite(10, TimeUnit.MINUTES)\n\t\t                              .build();\n\t\tcache.put(&quot;key1&quot;, &quot;value1&quot;);\n\t\tString value &#x3D; cache.getIfPresent(&quot;key1&quot;);\n\t\tSystem.out.println(value);\n\t&#125;\n&#125;</code></pre>\n\n<p>从上面的代码中，可以发现，Cache 对象是通过 CacheBuilder 这样一个 Builder 类来创建的。为什么要由 Builder 类来创建 Cache 对象呢？</p>\n<p>构建一个缓存，需要配置 n 多参数，比如过期时间、淘汰策略、最大缓存大小等等。相应地，Cache 类就会包含 n 多成员变量。需要在构造函数中，设置这些成员变量的值，但又不是所有的值都必须设置，设置哪些值由用户来决定。为了满足这个需求，就需要定义多个包含不同参数列表的构造函数</p>\n<p>为了避免构造函数的参数列表过长、不同的构造函数过多，一般有两种解决方案。其中，一个解决方案是使用 Builder 模式；另一个方案是先通过无参构造函数创建对象，然后再通过 <code>setXXX()</code> 方法来逐一设置需要的设置的成员变量</p>\n<p>为什么 Guava 选择第一种而不是第二种解决方案呢？使用第二种解决方案是否也可以呢？答案是不行的，先看下源码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public &lt;K1 extends K, V1 extends V&gt; Cache&lt;K1, V1&gt; build() &#123;\n\tthis.checkWeightWithWeigher();\n\tthis.checkNonLoadingCache();\n\treturn new LocalManualCache(this);\n&#125;\nprivate void checkNonLoadingCache() &#123;\n\tPreconditions.checkState(this.refreshNanos &#x3D;&#x3D; -1L, &quot;refreshAfterWrite require&quot;);\n&#125;\nprivate void checkWeightWithWeigher() &#123;\n\tif (this.weigher &#x3D;&#x3D; null) &#123;\n\t\tPreconditions.checkState(this.maximumWeight &#x3D;&#x3D; -1L, &quot;maximumWeight requires&quot;);\n\t&#125; else if (this.strictParsing) &#123;\n\t\tPreconditions.checkState(this.maximumWeight !&#x3D; -1L, &quot;weigher requires maximnum&quot;);\n\t&#125; else if (this.maximumWeight &#x3D;&#x3D; -1L) &#123;\n\t\tlogger.log(Level.WARNING, &quot;ignoring weigher specified without maximumWeight&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<p>必须使用 Builder 模式的主要原因是，在真正构造 Cache 对象的时候，必须做一些必要的参数校验，也就是 <code>build()</code> 函数中前两行代码要做的工作。如果采用无参默认构造函数加 <code>setXXX()</code> 方法的方案，这两个校验就无处安放了。而不经过校验，创建的 Cache 对象有可能是不合法、不可用的</p>\n<h3 id=\"3-3-2-Wrapper-模式\"><a href=\"#3-3-2-Wrapper-模式\" class=\"headerlink\" title=\"3.3.2 Wrapper 模式\"></a>3.3.2 Wrapper 模式</h3><p>在 Google Guava 的 collection 包路径下，有一组以 Forwarding 开头命名的类</p>\n<p><img src=\"https://img-blog.csdnimg.cn/aae77bf28e374024b6305ddcf225cc09.png\" alt=\"在这里插入图片描述\"></p>\n<p>这组 Forwarding 类很多，但实现方式都很相似。这里摘抄了其中的 ForwardingCollection 中的部分代码到这里</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GwtCompatible\npublic abstract class ForwardingCollection&lt;E&gt; extends ForwardingObject implement Collection &#123;\n\tprotected ForwardingCollection() &#123;\n\t&#125;\n\tprotected abstract Collection&lt;E&gt; delegate();\n\tpublic Iterator&lt;E&gt; iterator() &#123;\n\t\treturn this.delegate().iterator();\n\t&#125;\n\tpublic int size() &#123;\n\t\treturn this.delegate().size();\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean removeAll(Collection&lt;?&gt; collection) &#123;\n\t\treturn this.delegate().removeAll(collection);\n\t&#125;\n\tpublic boolean isEmpty() &#123;\n\t\treturn this.delegate().isEmpty();\n\t&#125;\n\tpublic boolean contains(Object object) &#123;\n\t\treturn this.delegate().contains(object);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean add(E element) &#123;\n\t\treturn this.delegate().add(element);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean remove(Object object) &#123;\n\t\treturn this.delegate().remove(object);\n\t&#125;\n\tpublic boolean containsAll(Collection&lt;?&gt; collection) &#123;\n\t\treturn this.delegate().containsAll(collection);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean addAll(Collection&lt;? extends E&gt; collection) &#123;\n\t\treturn this.delegate().addAll(collection);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean retainAll(Collection&lt;?&gt; collection) &#123;\n\t\treturn this.delegate().retainAll(collection);\n\t&#125;\n\tpublic void clear() &#123;\n\t\tthis.delegate().clear();\n\t&#125;\n\tpublic Object[] toArray() &#123;\n\t\treturn this.delegate().toArray();\n\t&#125;\n\t&#x2F;&#x2F;...省略部分代码...\n&#125;</code></pre>\n\n<p>再来看他的用法示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AddLoggingCollection&lt;E&gt; extends ForwardingCollection&lt;E&gt; &#123;\n\tprivate static final Logger logger &#x3D; LoggerFactory.getLogger(AddLoggingCollec\n\t                                     private Collection&lt;E&gt; originalCollection;\n\tpublic AddLoggingCollection(Collection&lt;E&gt; originalCollection) &#123;\n\t\tthis.originalCollection &#x3D; originalCollection;\n\t&#125;\n\t@Override\n\tprotected Collection delegate() &#123;\n\t\treturn this.originalCollection;\n\t&#125;\n\t@Override\n\tpublic boolean add(E element) &#123;\n\t\tlogger.info(&quot;Add element: &quot; + element);\n\t\treturn this.delegate().add(element);\n\t&#125;\n\t@Override\n\tpublic boolean addAll(Collection&lt;? extends E&gt; collection) &#123;\n\t\tlogger.info(&quot;Size of elements to add: &quot; + collection.size());\n\t\treturn this.delegate().addAll(collection);\n\t&#125;\n&#125;</code></pre>\n\n<p>在上面的代码中，AddLoggingCollection 是基于代理模式实现的一个代理类，它在原始 Collection 类的基础之上，针对“add”相关的操作，添加了记录日志的功能</p>\n<p>前面讲到，代理模式、装饰器、适配器模式可以统称为 Wrapper 模式，通过 Wrapper 类二次封装原始类。它们的代码实现也很相似，都可以通过组合的方式，将 Wrapper 类的函数实现委托给原始类的函数来实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Interf &#123;\n\tvoid f1();\n\tvoid f2();\n&#125;\npublic class OriginalClass implements Interf &#123;\n\t@Override\n\tpublic void f1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class WrapperClass implements Interf &#123;\n\tprivate OriginalClass oc;\n\tpublic WrapperClass(OriginalClass oc) &#123;\n\t\tthis.oc &#x3D; oc;\n\t&#125;\n\t@Override\n\tpublic void f1() &#123;\n\t\t&#x2F;&#x2F;...附加功能...\n\t\tthis.oc.f1();\n\t\t&#x2F;&#x2F;...附加功能...\n\t&#125;\n\t@Override\n\tpublic void f2() &#123;\n\t\tthis.oc.f2();\n\t&#125;\n&#125;</code></pre>\n\n<p>实际上，这个 ForwardingCollection 类是一个“默认 Wrapper 类”或者叫“缺省Wrapper 类”。Java IO 的 FilterInputStream 缺省装饰器类</p>\n<p>如果不使用这个 ForwardinCollection 类，而是让 AddLoggingCollection 代理类直接实现 Collection 接口，那 Collection 接口中的所有方法，都要在 AddLoggingCollection 类中实现一遍，而真正需要添加日志功能的只有 <code>add()</code> 和 <code>addAll()</code> 两个函数，其他函数的实现，都只是类似 Wrapper 类中 <code>f2()</code> 函数的实现那样，简单地委托给原始 collection 类对象的对应函数</p>\n<p>为了简化 Wrapper 模式的代码实现，Guava 提供一系列缺省的 Forwarding 类。用户在实现自己的 Wrapper 类的时候，基于缺省的 Forwarding 类来扩展，就可以只实现自己关心的方法，其他不关心的方法使用缺省 Forwarding 类的实现，就像 AddLoggingCollection 类的实现那样</p>\n<h3 id=\"3-3-3-Immutable-模式\"><a href=\"#3-3-3-Immutable-模式\" class=\"headerlink\" title=\"3.3.3 Immutable 模式\"></a>3.3.3 Immutable 模式</h3><p>Immutable 模式，中文叫作不变模式，它并不属于经典的 23 种设计模式，但作为一种较常用的设计思路，可以总结为一种设计模式来学习</p>\n<p>一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是不变类（Immutable Class），对象就是不变对象（Immutable Object）。在 Java 中，最常用的不变类就是 String 类，String 对象一旦创建之后就无法改变</p>\n<p>不变模式可以分为两类，一类是普通不变模式，另一类是深度不变模式（Deeply Immutable Pattern）。普通的不变模式指的是，对象中包含的引用对象是可以改变的。如果不特别说明，通常所说的不变模式，指的就是普通的不变模式。深度不变模式指的是，对象包含的引用对象也不可变。它们两个之间的关系，有点类似之前讲过的浅拷贝和深拷贝之间的关系。如下例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 普通不变模式\npublic class User &#123;\n\tprivate String name;\n\tprivate int age;\n\tprivate Address addr;\n\tpublic User(String name, int age, Address addr) &#123;\n\t\tthis.name &#x3D; name;\n\t\tthis.age &#x3D; age;\n\t\tthis.addr &#x3D; addr;\n\t&#125;\n\t&#x2F;&#x2F; 只有getter方法，无setter方法...\n&#125;\npublic class Address &#123;\n\tprivate String province;\n\tprivate String city;\n\tpublic Address(String province, String city) &#123;\n\t\tthis.province &#x3D; province;\n\t\tthis.city&#x3D; city;\n\t&#125;\n\t&#x2F;&#x2F; 有getter方法，也有setter方法...\n&#125;\n&#x2F;&#x2F; 深度不变模式\npublic class User &#123;\n\tprivate String name;\n\tprivate int age;\n\tprivate Address addr;\n\tpublic User(String name, int age, Address addr) &#123;\n\t\tthis.name &#x3D; name;\n\t\tthis.age &#x3D; age;\n\t\tthis.addr &#x3D; addr;\n\t&#125;\n\t&#x2F;&#x2F; 只有getter方法，无setter方法...\n&#125;\npublic class Address &#123;\n\tprivate String province;\n\tprivate String city;\n\tpublic Address(String province, String city) &#123;\n\t\tthis.province &#x3D; province;\n\t\tthis.city&#x3D; city;\n\t&#125;\n\t&#x2F;&#x2F; 只有getter方法，无setter方法..\n&#125;</code></pre>\n\n<p>在某个业务场景下，如果一个对象符合创建之后就不会被修改这个特性，那就可以把它设计成不变类。显式地强制它不可变，这样能避免意外被修改。那如何将一个不变类呢？方法很简单，只要这个类满足：所有的成员变量都通过构造函数一次性设置好，不暴露任何 set 等修改成员变量的方法。除此之外，因为数据不变，所以不存在并发读写问题，因此不变模式常用在多线程环境下，来避免线程加锁。所以，不变模式也常被归类为多线程设计模式</p>\n<p>接下来，来看一种特殊的不变类，那就是不变集合。Google Guava 针对集合类（Collection、List、Set、Map…）提供了对应的不变集合类（ImmutableCollection、ImmutableList、ImmutableSet、ImmutableMap…）。上面讲过，不变模式分为两种，普通不变模式和深度不变模式。Google Guava 提供的不变集合类属于前者，也就是说，集合中的对象不会增删，但是对象的成员变量（或叫属性值）是可以改变的</p>\n<p>实际上，Java JDK 也提供了不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）。那它跟 Google Guava 提供的不变集合类的区别在哪里呢？如下例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ImmutableDemo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String&gt; originalList &#x3D; new ArrayList&lt;&gt;();\n\t\toriginalList.add(&quot;a&quot;);\n\t\toriginalList.add(&quot;b&quot;);\n\t\toriginalList.add(&quot;c&quot;);\n\t\tList&lt;String&gt; jdkUnmodifiableList &#x3D; Collections.unmodifiableList(originalList);\n\t\tList&lt;String&gt; guavaImmutableList &#x3D; ImmutableList.copyOf(originalList);\n\t\t&#x2F;&#x2F;jdkUnmodifiableList.add(&quot;d&quot;); &#x2F;&#x2F; 抛出UnsupportedOperationException\n\t\t&#x2F;&#x2F; guavaImmutableList.add(&quot;d&quot;); &#x2F;&#x2F; 抛出UnsupportedOperationException\n\t\toriginalList.add(&quot;d&quot;);\n\t\tprint(originalList); &#x2F;&#x2F; a b c d\n\t\tprint(jdkUnmodifiableList); &#x2F;&#x2F; a b c d\n\t\tprint(guavaImmutableList); &#x2F;&#x2F; a b c\n\t&#125;\n\tprivate static void print(List&lt;String&gt; list) &#123;\n\t\tfor (String s : list) &#123;\n\t\t\tSystem.out.print(s + &quot; &quot;);\n\t\t&#125;\n\t\tSystem.out.println();\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"3-4-函数式编程\"><a href=\"#3-4-函数式编程\" class=\"headerlink\" title=\"3.4 函数式编程\"></a>3.4 函数式编程</h2><p>现在主流的编程范式主要有三种，面向过程、面向对象和函数式编程。函数式编程并非一个很新的东西，早在 50 多年前就已经出现了。近几年，函数式编程越来越被人关注，出现了很多新的函数式编程语言，比如 Clojure、Scala、Erlang 等。一些非函数式编程语言也加入了很多特性、语法、类库来支持函数式编程，比如 Java、Python、Ruby、JavaScript 等。除此之外，Google Guava 也有对函数式编程的增强功能</p>\n<p>函数式编程因其编程的特殊性，仅在科学计算、数据处理、统计分析等领域，才能更好地发挥它的优势，所以个人觉得，它并不能完全替代更加通用的面向对象编程范式。但是，作为一种补充，它也有很大存在、发展和学习的意义</p>\n<h3 id=\"3-4-1-概念\"><a href=\"#3-4-1-概念\" class=\"headerlink\" title=\"3.4.1 概念\"></a>3.4.1 概念</h3><p>函数式编程的英文翻译是 Functional Programming。 那到底什么是函数式编程呢？</p>\n<p>前面讲到，面向过程、面向对象编程并没有严格的官方定义，实际上，函数式编程也是如此，也没有一个严格的官方定义。所以，接下来就从特性上来说说什么是函数式编程</p>\n<p>严格上来讲，函数式编程中的“函数”，并不是指编程语言中的“函数”概念，而是指数学“函数”或者“表达式”（比如，<code>y=f(x)</code>）。不过，在编程实现的时候，对于数学“函数”或“表达式”，一般习惯性地将它们设计成函数。所以，如果不深究的话，函数式编程中的“函数”也可以理解为编程语言中的“函数”</p>\n<p>每个编程范式都有自己独特的地方，这就是它们会被抽象出来作为一种范式的原因。面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性。面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离。那函数式编程最独特的地方又在哪里呢？</p>\n<p>实际上，函数式编程最独特的地方在于它的编程思想。函数式编程认为，程序可以用一系列数学函数或表达式的组合来表示。函数式编程是程序面向数学的更底层的抽象，将计算过程描述为表达式。不过，真的可以把任何程序都表示成一组数学表达式吗？</p>\n<p>理论上讲是可以的。但是，并不是所有的程序都适合这么做。函数式编程有它自己适合的应用场景，比如本节开头提到的科学计算、数据处理、统计分析等。在这些领域，程序往往比较容易用数学表达式来表示，比起非函数式编程，实现同样的功能，函数式编程可以用很少的代码就能搞定。但是，对于强业务相关的大型业务系统开发来说，费劲地将它抽象成数学表达式，硬要用函数式编程来实现，显然是自讨苦吃。相反，在这种应用场景下，面向对象编程更加合适，写出来的代码更加可读、可维护</p>\n<p>具体到编程实现，函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。不过，它跟面向过程编程的区别在于，它的函数是无状态的。何为无状态？简单点讲就是，函数内部涉及的变量都是局部变量，不会像面向对象编程那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求，如下例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 有状态函数: 执行结果依赖b的值是多少，即便入参相同，多次执行函数，函数的返回值有可能不同\nint b;\nint increase(int a) &#123;\n    return a + b;\n&#125;\n&#x2F;&#x2F; 无状态函数：执行结果不依赖任何外部变量值，只要入参相同，不管执行多少次，函数的返回值就相同\nint increase(int a, int b) &#123;\n    return a + b;\n&#125;</code></pre>\n\n<p>不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念，最顶层都要有 main 函数执行入口，来组装编程单元（类、函数等）。只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数</p>\n<h3 id=\"3-4-2-Java-对函数式编程的支持\"><a href=\"#3-4-2-Java-对函数式编程的支持\" class=\"headerlink\" title=\"3.4.2 Java 对函数式编程的支持\"></a>3.4.2 Java 对函数式编程的支持</h3><p>实现面向对象编程不一定非得使用面向对象编程语言，同理，实现函数式编程也不一定非得使用函数式编程语言。现在，很多面向对象编程语言，也提供了相应的语法、类库来支持函数式编程</p>\n<p>Java 为函数式编程引入了三个新的语法概念：Stream 类、Lambda 表达式和函数接口（Functional Inteface）。Stream 类用来支持通过“.”级联多个函数操作的代码编写方式；引入 Lambda 表达式的作用是简化代码编写；函数接口的作用是可以把函数包裹成函数接口，来实现把函数当做参数一样来使用（Java 不像 C 一样支持函数指针，可以把函数直接当参数来使用）</p>\n<p>详细的相关知识可自行了解</p>\n<h3 id=\"3-4-3-Guava-对函数式编程的增强\"><a href=\"#3-4-3-Guava-对函数式编程的增强\" class=\"headerlink\" title=\"3.4.3 Guava 对函数式编程的增强\"></a>3.4.3 Guava 对函数式编程的增强</h3><p>如果你是 Google Guava 的设计者，对于 Java 函数式编程，Google Guava 还能做些什么呢？</p>\n<p>颠覆式创新是很难的。不过可以进行一些补充，一方面，可以增加 Stream 类上的操作（类似 map、filter、max 这样的终止操作和中间操作），另一方面，也可以增加更多的函数接口（类似 Function、Predicate 这样的函数接口）。实际上，还可以设计一些类似 Stream 类的新的支持级联操作的类。这样，使用 Java 配合 Guava 进行函数式编程会更加方便</p>\n<p>但是，跟预期的相反，Google Guava 并没有提供太多函数式编程的支持，仅仅封装了几个遍历集合操作的接口，代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Iterables.transform(Iterable, Function);\nIterators.transform(Iterator, Function);\nCollections.transfrom(Collection, Function);\nLists.transform(List, Function);\nMaps.transformValues(Map, Function);\nMultimaps.transformValues(Mltimap, Function);\n...\nIterables.filter(Iterable, Predicate);\nIterators.filter(Iterator, Predicate);\nCollections2.filter(Collection, Predicate);\n...</code></pre>\n\n<p>从 Google Guava 的 GitHub Wiki 中发现，Google 对于函数式编程的使用还是很谨慎的，认为过度地使用函数式编程，会导致代码可读性变差，强调不要滥用。所以，在函数式编程方面，Google Guava 并没有提供太多的支持</p>\n<p>之所以对遍历集合操作做了优化，主要是因为函数式编程一个重要的应用场景就是遍历集合。如果不使用函数式编程，只能 for 循环，一个一个的处理集合中的数据。使用函数式编程，可以大大简化遍历集合操作的代码编写，一行代码就能搞定，而且在可读性方面也没有太大损失</p>\n<h1 id=\"4-Spring-框架\"><a href=\"#4-Spring-框架\" class=\"headerlink\" title=\"4. Spring 框架\"></a>4. Spring 框架</h1><h2 id=\"4-1-蕴含的设计思想\"><a href=\"#4-1-蕴含的设计思想\" class=\"headerlink\" title=\"4.1 蕴含的设计思想\"></a>4.1 蕴含的设计思想</h2><h3 id=\"4-1-1-约定优于配置\"><a href=\"#4-1-1-约定优于配置\" class=\"headerlink\" title=\"4.1.1 约定优于配置\"></a>4.1.1 约定优于配置</h3><p>在使用 Spring 开发的项目中，配置往往会比较复杂、繁琐。比如利用 Spring MVC 来开发 Web 应用，需要配置每个 Controller 类以及 Controller 类中的接口对应的 URL。如何来简化配置呢？一般来讲，有两种方法，一种是基于注解，另一种是基于约定。这两种配置方式在 Spring 中都有用到。Spring 在最小化配置方面做得淋漓尽致，有很多值得借鉴的地方</p>\n<ul>\n<li>基于注解的配置方式：在指定类上使用指定的注解，来替代集中的 XML 配置。比如，使用 <code>@RequestMapping</code> 注解，在 Controller 类或者接口上，标注对应的 URL；使用 <code>@Transaction</code> 注解表明支持事务等</li>\n<li>基于约定的配置方式：也常叫作“约定优于配置”或者“规约优于配置”（Convention over Configuration）。通过约定的代码结构或者命名来减少配置。说直白点，就是提供配置的默认值，优先使用默认值。程序员只需要设置那些偏离约定的配置就可以了</li>\n</ul>\n<p>比如，在 Spring JPA（基于 ORM 框架、JPA 规范的基础上，封装的一套 JPA 应用框架）中，约定类名默认跟表名相同，属性名默认跟表字段名相同，String 类型对应数据库中的 varchar 类型，long 类型对应数据库中的 bigint 类型等等</p>\n<p>基于刚刚的约定，代码中定义的 Order 类就对应数据库中的“order”表。只有在偏离这一约定的时候，例如数据库中表命名为“order_info”而非“order”，才需要显示地去配置类与表的映射关系（Order 类 -&gt; order_info 表）</p>\n<p>实际上，约定优于配置，很好地体现了“二八法则”。在平时的项目开发中，80% 的配置使用默认配置就可以了，只有 20% 的配置必须用户显式地去设置。所以，基于约定来配置，在没有牺牲配置灵活性的前提下，节省了大量编写配置的时间，省掉了很多不动脑子的纯体力劳动，提高了开发效率。除此之外，基于相同的约定来做开发，也减少了项目的学习成本和维护成本。</p>\n<h3 id=\"4-1-2-低侵入、松耦合\"><a href=\"#4-1-2-低侵入、松耦合\" class=\"headerlink\" title=\"4.1.2 低侵入、松耦合\"></a>4.1.2 低侵入、松耦合</h3><p>框架的侵入性是衡量框架好坏的重要指标。所谓低侵入指的是，框架代码很少耦合在业务代码中。低侵入意味着，当要替换一个框架的时候，对原有的业务代码改动会很少。相反，如果一个框架是高度侵入的，代码高度侵入到业务代码中，那替换成另一个框架的成本将非常高，甚至几乎不可能。这也是一些长期维护的老项目，使用的框架、技术比较老旧，又无法更新的一个很重要的原因</p>\n<p>实际上，低侵入是 Spring 框架遵循的一个非常重要的设计思想</p>\n<p>Spring 提供的 IOC 容器，在不需要 Bean 继承任何父类或者实现任何接口的情况下，仅仅通过配置，就能将它们纳入进 Spring 的管理中。如果换一个 IOC 容器，也只是重新配置一下就可以了，原有的 Bean 都不需要任何修改</p>\n<p>除此之外，Spring 提供的 AOP 功能，也体现了低侵入的特性。在项目中，对于非业务功能，比如请求日志、数据采点、安全校验、事务等等，没必要将它们侵入进业务代码中。因为一旦侵入，这些代码将分散在各个业务代码中，删除、修改的成本就变得很高。而基于 AOP 这种开发模式，将非业务代码集中放到切面中，删除、修改的成本就变得很低了</p>\n<h3 id=\"4-1-3-模块化、轻量级\"><a href=\"#4-1-3-模块化、轻量级\" class=\"headerlink\" title=\"4.1.3 模块化、轻量级\"></a>4.1.3 模块化、轻量级</h3><p>十几年前，EJB 是 Java 企业级应用的主流开发框架。但是，它非常臃肿、复杂，侵入性、耦合性高，开发、维护和学习成本都不低。所以，为了替代笨重的 EJB，Rod Johnson 开发了一套开源的 Interface21 框架，提供了最基本的 IOC 功能。实际上，Interface21 框架就是 Spring 框架的前身</p>\n<p>但是，随着不断的发展，Spring 现在也不单单只是一个只包含 IOC 功能的小框架了，它显然已经壮大成了一个“平台”或者叫“生态”，包含了各种五花八门的功能。尽管如此，但它也并没有重蹈覆辙，变成一个像 EJB 那样的庞大难用的框架。那 Spring 是怎么做到的呢？</p>\n<p>这就要归功于 Spring 的模块化设计思想，下图是 Spring Framework 的模块和分层介绍图</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2a35cb9c77094815989d919717814003.png\" alt=\"在这里插入图片描述\"></p>\n<p>从图中可以看出，Spring 在分层、模块化方面做得非常好。每个模块都只负责一个相对独立的功能。模块之间关系，仅有上层对下层的依赖关系，而同层之间以及下层对上层，几乎没有依赖和耦合。除此之外，在依赖 Spring 的项目中，开发者可以有选择地引入某几个模块，而不会因为需要一个小的功能，就被强迫引入整个 Spring 框架。所以，尽管 Spring Framework 包含的模块很多，已经有二十几个，但每个模块都非常轻量级，都可以单独拿来使用。正因如此，到现在，Spring 框架仍然可以被称为是一个轻量级的开发框架</p>\n<h3 id=\"4-1-4-再封装、再抽象\"><a href=\"#4-1-4-再封装、再抽象\" class=\"headerlink\" title=\"4.1.4 再封装、再抽象\"></a>4.1.4 再封装、再抽象</h3><p>Spring 不仅仅提供了各种 Java 项目开发的常用功能模块，而且还对市面上主流的中间件、系统的访问类库，做了进一步的封装和抽象，提供了更高层次、更统一的访问接口</p>\n<p>比如，Spring 提供了 spring-data-redis 模块，对 Redis Java 开发类库（比如 Jedis、Lettuce）做了进一步的封装，适配 Spring 的访问方式，让编程访问 Redis 更加简单。还有 Spring Cache，实际上也是一种再封装、再抽象。它定义了统一、抽象的 Cache 访问接口，这些接口不依赖具体的 Cache 实现（Redis、Guava Cache、Caffeine 等）。在项目中，基于 Spring 提供的抽象统一的接口来访问 Cache。这样，就能在不修改代码的情况下，实现不同 Cache 之间的切换</p>\n<p>除此之外，Spring 对 JDBC 异常也做了进一步的封装。封装的数据库异常继承自 DataAccessException 运行时异常。这类异常在开发中无需强制捕获，从而减少了不必要的异常捕获和处理。除此之外，Spring 封装的数据库异常，还屏蔽了不同数据库异常的细节（比如，不同的数据库对同一报错定义了不同的错误码），让异常的处理更加简单</p>\n<h2 id=\"4-2-用来支持扩展的两种设计模式\"><a href=\"#4-2-用来支持扩展的两种设计模式\" class=\"headerlink\" title=\"4.2 用来支持扩展的两种设计模式\"></a>4.2 用来支持扩展的两种设计模式</h2><h3 id=\"4-2-1-观察者模式在-Spring-中的应用\"><a href=\"#4-2-1-观察者模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.2.1 观察者模式在 Spring 中的应用\"></a>4.2.1 观察者模式在 Spring 中的应用</h3><p>Spring 中实现的观察者模式包含三部分：Event 事件（相当于消息）、Listener 监听者（相当于观察者）、Publisher 发送者（相当于被观察者）。示例如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Event事件\npublic class DemoEvent extends ApplicationEvent &#123;\n\tprivate String message;\n\tpublic DemoEvent(Object source, String message) &#123;\n\t\tsuper(source);\n\t&#125;\n\tpublic String getMessage() &#123;\n\t\treturn this.message;\n\t&#125;\n&#125;\n&#x2F;&#x2F; Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123;\n\t@Override\n\tpublic void onApplicationEvent(DemoEvent demoEvent) &#123;\n\t\tString message &#x3D; demoEvent.getMessage();\n\t\tSystem.out.println(message);\n\t&#125;\n&#125;\n&#x2F;&#x2F; Publisher发送者\n@Component\npublic class DemoPublisher &#123;\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\tpublic void publishEvent(DemoEvent demoEvent) &#123;\n\t\tthis.applicationContext.publishEvent(demoEvent);\n\t&#125;\n&#125;</code></pre>\n\n<p>从代码中可以看出，框架使用起来并不复杂，主要包含三部分工作：定义一个继承 ApplicationEvent 的事件（DemoEvent）；定义一个实现了 ApplicationListener 的监听器（DemoListener）；定义一个发送者（DemoPublisher），发送者调用 ApplicationContext 来发送事件消息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class ApplicationEvent extends EventObject &#123;\n\tprivate static final long serialVersionUID &#x3D; 7099057708183571937L;\n\tprivate final long timestamp &#x3D; System.currentTimeMillis();\n\tpublic ApplicationEvent(Object source) &#123;\n\t\tsuper(source);\n\t&#125;\n\tpublic final long getTimestamp() &#123;\n\t\treturn this.timestamp;\n\t&#125;\n&#125;\npublic class EventObject implements java.io.Serializable &#123;\n\tprivate static final long serialVersionUID &#x3D; 5516075349620653480L;\n\tprotected transient Object source;\n\tpublic EventObject(Object source) &#123;\n\t\tif (source &#x3D;&#x3D; null)\n\t\t\tthrow new IllegalArgumentException(&quot;null source&quot;);\n\t\tthis.source &#x3D; source;\n\t&#125;\n\tpublic Object getSource() &#123;\n\t\treturn source;\n\t&#125;\n\tpublic String toString() &#123;\n\t\treturn getClass().getName() + &quot;[source&#x3D;&quot; + source + &quot;]&quot;;\n\t&#125;\n&#125;\npublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventObject &#123;\n\tvoid onApplicationEvent(E var1);\n&#125;</code></pre>\n\n<p>在之前讲到观察者模式的时候提到，观察者需要事先注册到被观察者（JDK 的实现方式）或者事件总线（EventBus 的实现方式）中。那在 Spring 的实现中，观察者注册到了哪里呢？又是如何注册的呢？</p>\n<p>Spring 把观察者注册到了 ApplicationContext 对象中。这里的 ApplicationContext 就相当于 Google EventBus 框架中的“事件总线”。不过，ApplicationContext 这个类并不只是为观察者模式服务的。它底层依赖 BeanFactory（IOC 的主要实现类），提供应用启动、运行时的上下文信息，是访问这些信息的最顶层接口</p>\n<p>实际上，具体到源码来说，ApplicationContext 只是一个接口，具体的代码实现包含在它的实现类 AbstractApplicationContext 中。其中跟观察者模式相关的代码如下，只需要关注它是如何发送事件和注册监听者就好</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractApplicationContext extends ...&#123;\n    private final Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;\n\n    public AbstractApplicationContext() &#123;\n        this.applicationListeners &#x3D; new LinkedHashSet();\n        &#x2F;&#x2F;...\n    &#125;\n\n    public void publishEvent(ApplicationEvent event) &#123;\n        this.publishEvent(event, (ResolvableType) null);\n    &#125;\n\n    public void publishEvent(Object event) &#123;\n        this.publishEvent(event, (ResolvableType) null);\n    &#125;\n\n    protected void publishEvent(Object event, ResolvableType eventType) &#123;\n        &#x2F;&#x2F;...\n        Object applicationEvent;\n        if (event instanceof ApplicationEvent) &#123;\n            applicationEvent &#x3D; (ApplicationEvent) event;\n        &#125; else &#123;\n            applicationEvent &#x3D; new PayloadApplicationEvent(this, event);\n            if (eventType &#x3D;&#x3D; null) &#123;\n                eventType &#x3D; ((PayloadApplicationEvent) applicationEvent).getResolvableTy\n            &#125;\n        &#125;\n        if (this.earlyApplicationEvents !&#x3D; null) &#123;\n            this.earlyApplicationEvents.add(applicationEvent);\n        &#125; else &#123;\n            this.getApplicationEventMulticaster().multicastEvent(\n                    (ApplicationEvent) applicationEvent, eventType);\n        &#125;\n        if (this.parent !&#x3D; null) &#123;\n            if (this.parent instanceof AbstractApplicationContext) &#123;\n                ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);\n            &#125; else &#123;\n                this.parent.publishEvent(event);\n            &#125;\n        &#125;\n    &#125;\n\n    public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;\n        Assert.notNull(listener, &quot;ApplicationListener must not be null&quot;);\n        if (this.applicationEventMulticaster !&#x3D; null) &#123;\n            this.applicationEventMulticaster.addApplicationListener(listener);\n        &#125; else &#123;\n            this.applicationListeners.add(listener);\n        &#125;\n    &#125;\n\n    public Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;\n        return this.applicationListeners;\n    &#125;\n\n    protected void registerListeners() &#123;\n        Iterator var1 &#x3D; this.getApplicationListeners().iterator();\n        while (var1.hasNext()) &#123;\n            ApplicationListener&lt;?&gt; listener &#x3D; (ApplicationListener) var1.next();\n        &#125;\n        String[] listenerBeanNames &#x3D; this.getBeanNamesForType(ApplicationListener.c\n        String[]var7 &#x3D; listenerBeanNames;\n        int var3 &#x3D; listenerBeanNames.length;\n        for (int var4 &#x3D; 0; var4 &lt; var3; ++var4) &#123;\n            String listenerBeanName &#x3D; var7[var4];\n            this.getApplicationEventMulticaster().addApplicationListenerBean(listene\n        &#125;\n        Set&lt;ApplicationEvent&gt; earlyEventsToProcess &#x3D; this.earlyApplicationEvents;\n        this.earlyApplicationEvents &#x3D; null;\n        if (earlyEventsToProcess !&#x3D; null) &#123;\n            Iterator var9 &#x3D; earlyEventsToProcess.iterator();\n            while (var9.hasNext()) &#123;\n                ApplicationEvent earlyEvent &#x3D; (ApplicationEvent) var9.next();\n                this.getApplicationEventMulticaster().multicastEvent(earlyEvent);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>从上面的代码中可以发现，真正的消息发送，实际上是通过 ApplicationEventMulticaster 这个类来完成的。这个类的源码这里只摘抄了最关键的一部分，也就是 <code>multicastEvent()</code> 这个消息发送函数。不过，它的代码也并不复杂，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void multicastEvent(ApplicationEvent event) &#123;\n    this.multicastEvent(event,this.resolveDefaultEventType(event));\n&#125;\n\npublic void multicastEvent(final ApplicationEvent event,ResolvableType eventType) &#123;\n    ResolvableType type &#x3D; eventType !&#x3D;null ? eventType : this.resolveDefaultEvent;\n    Iterator var4&#x3D;this.getApplicationListeners(event,type).iterator();\n    while(var4.hasNext()) &#123;\n        final ApplicationListener&lt;?&gt; listener&#x3D;(ApplicationListener)var4.next();\n        Executor executor&#x3D;this.getTaskExecutor();\n        if(executor!&#x3D;null)&#123;\n            executor.execute(new Runnable()&#123;\n                public void run()&#123;\n                    SimpleApplicationEventMulticaster.this.invokeListener(listener,event\n                &#125;\n            &#125;);\n        &#125;else&#123;\n            this.invokeListener(listener,event);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>借助 Spring 提供的观察者模式的骨架代码，如果要在 Spring 下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往 ApplicationContext 中发送事件就可以了，剩下的工作都由 Spring 框架来完成。实际上，这也体现了 Spring 框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听</p>\n<h3 id=\"4-2-2-模板模式在-Spring-中的应用\"><a href=\"#4-2-2-模板模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.2.2 模板模式在 Spring 中的应用\"></a>4.2.2 模板模式在 Spring 中的应用</h3><p>一个经常在面试中被问到的一个问题：请你说下 Spring Bean 的创建过程包含哪些主要的步骤。这其中就涉及模板模式。它也体现了 Spring 的扩展性。利用模板模式，Spring 能让用户定制 Bean 的创建过程</p>\n<p>Spring Bean 的创建过程，可以大致分为两大步：对象的创建和对象的初始化</p>\n<p>对象的创建是通过反射来动态生成对象，而不是 new 方法。不管是哪种方式，说白了，总归还是调用构造函数来生成对象，没有什么特殊的。对象的初始化有两种实现方式。一种是在类中自定义一个初始化函数，并且通过配置文件，显式地告知 Spring，哪个函数是初始化函数。如下所示，在配置文件中，通过 init-method 属性来指定初始化函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DemoClass &#123;\n    &#x2F;&#x2F;...\n    public void initDemo() &#123;\n        &#x2F;&#x2F;...初始化..\n    &#125;\n&#125;\n&#x2F;&#x2F; 配置：需要通过init-method显式地指定初始化方法\n&lt;bean id&#x3D;&quot;demoBean&quot; class&#x3D;&quot;com.xzg.cd.DemoClass&quot; init-method&#x3D;&quot;initDemo&quot;&gt;&lt;&#x2F;bean&gt;</code></pre>\n\n<p>这种初始化方式有一个缺点，初始化函数并不固定，由用户随意定义，这就需要 Spring 通过反射，在运行时动态地调用这个初始化函数。而反射又会影响代码执行的性能，那有没有替代方案呢？</p>\n<p>Spring 提供了另外一个定义初始化函数的方法，那就是让类实现 Initializingbean 接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet() 函数）。Spring 在初始化 Bean 的时候，可以直接通过 <code>bean.afterPropertiesSet()</code> 的方式，调用 Bean 对象上的这个函数，而不需要使用反射来调用了。如下所示</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DemoClass implements InitializingBean&#123;\n    @Override\n    public void afterPropertiesSet() throws Exception &#123;\n        &#x2F;&#x2F;...初始化...\n    &#125;\n&#125;\n&#x2F;&#x2F; 配置：不需要显式地指定初始化方法\n&lt;bean id&#x3D;&quot;demoBean&quot; class&#x3D;&quot;com.xzg.cd.DemoClass&quot;&gt;&lt;&#x2F;bean&gt;</code></pre>\n\n<p>尽管这种实现方式不会用到反射，执行效率提高了，但业务代码（DemoClass）跟框架代码（InitializingBean）耦合在了一起。框架代码侵入到了业务代码中，替换框架的成本就变高了。所以，并不是太推荐这种写法</p>\n<p>实际上，在 Spring 对 Bean 整个生命周期的管理中，还有一个跟初始化相对应的过程，那就是 Bean 的销毁过程。在 Java 中，对象的回收是通过 JVM 来自动完成的。但是可以在将 Bean 正式交给 JVM 垃圾回收前，执行一些销毁操作（比如关闭文件句柄等等）</p>\n<p>销毁过程跟初始化过程非常相似，也有两种实现方式。一种是通过配置 destroy-method 指定类中的销毁函数，另一种是让类实现 DisposableBean 接口</p>\n<p>实际上，Spring 针对对象的初始化过程，还做了进一步的细化，将它拆分成了三个小步骤：初始化前置操作、初始化、初始化后置操作。其中，中间的初始化操作就是刚刚讲的那部分，初始化的前置和后置操作，定义在接口 BeanPostProcessor 中。BeanPostProcessor 的接口定义如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface BeanPostProcessor &#123;\n    Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException;\n    Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;\n&#125;</code></pre>\n\n<p>再来看下，如何通过 BeanPostProcessor 来定义初始化前置和后置操作？</p>\n<p>只需要定义一个实现了 BeanPostProcessor 接口的处理器类，并在配置文件中像配置普通 Bean 一样去配置就可以了。Spring 中的 ApplicationContext 会自动检测在配置文件中实现了 BeanPostProcessor 接口的所有 Bean，并把它们注册到 BeanPostProcessor 处理器列表中。在 Spring 容器创建 Bean 的过程中，Spring 会逐一去调用这些处理器</p>\n<p><img src=\"https://img-blog.csdnimg.cn/57a00f0f9b2c4ae58799d8a1e18253a7.png\" alt=\"在这里插入图片描述\"></p>\n<p>到这里可能会说，这里哪里用到了模板模式啊？模板模式不是需要定义一个包含模板方法的抽象模板类，以及定义子类实现模板方法吗？</p>\n<p>实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似前面讲到的 Callback 回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成 InitializingBean 对象），传递给模板（BeanFactory）来执行</p>\n<h2 id=\"4-3-Spring-框架用到的-11-种设计模式\"><a href=\"#4-3-Spring-框架用到的-11-种设计模式\" class=\"headerlink\" title=\"4.3 Spring 框架用到的 11 种设计模式\"></a>4.3 Spring 框架用到的 11 种设计模式</h2><h3 id=\"4-3-1-适配器模式在-Spring-中的应用\"><a href=\"#4-3-1-适配器模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.3.1 适配器模式在 Spring 中的应用\"></a>4.3.1 适配器模式在 Spring 中的应用</h3><p>在 Spring MVC 中，定义一个 Controller 最常用的方式是，通过 <code>@Controller</code> 注解来标记某个类是 Controller 类，通过 <code>@RequesMapping</code> 注解来标记函数对应的 URL。不过，定义一个 Controller 远不止这一种方法。还可以通过让类实现 Controller 接口或者 Servlet 接口，来定义一个 Controller。针对这三种定义方式，示例代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController &#123;\n\t@RequestMapping(&quot;&#x2F;employname&quot;)\n\tpublic ModelAndView getEmployeeName() &#123;\n\t\tModelAndView model &#x3D; new ModelAndView(&quot;Greeting&quot;);\n\t\tmodel.addObject(&quot;message&quot;, &quot;Dinesh&quot;);\n\t\treturn model;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller &#123;\n\t@Override\n\tpublic ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse rep) &#123;\n\t\tModelAndView model &#x3D; new ModelAndView(&quot;Greeting&quot;);\n\t\tmodel.addObject(&quot;message&quot;, &quot;Dinesh Madhwal&quot;);\n\t\treturn model;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet &#123;\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tthis.doPost(req, resp);\n\t&#125;\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throw Exception &#123;\n\t\tresp.getWriter().write(&quot;Hello World.&quot;);\n\t&#125;\n&#125;\n</code></pre>\n\n<p>在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端</p>\n<p>但是，不同方式定义的 Controller，其函数的定义（函数名、入参、返回值等）是不统一的。如上示例代码所示，方法一中的函数的定义很随意、不固定，方法二中的函数定义是 <code>handleRequest()</code>、方法三中的函数定义是 <code>service()</code>（看似是定义了 <code>doGet()</code>、<code>doPost()</code>，实际上，这里用到了模板模式，Servlet 中的 <code>service()</code> 调用了 <code>doGet()</code> 或 <code>doPost()</code> 方法，DispatcherServlet 调用的是 <code>service()</code> 方法）。DispatcherServlet 需要根据不同类型的 Controller，调用不同的函数。下面是具体的伪代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Handler handler &#x3D; handlerMapping.get(URL);\nif (handler instanceof Controller) &#123;\n\t((Controller)handler).handleRequest(...);\n&#125; else if (handler instanceof Servlet) &#123;\n\t((Servlet)handler).service(...);\n&#125; else if (hanlder 对应通过注解来定义的Controller) &#123;\n\t反射调用方法...\n&#125;</code></pre>\n\n<p>从代码中可以看出，这种实现方式会有很多 if-else 分支判断，而且，如果要增加一个新的 Controller 的定义方法，就要在 DispatcherServlet 类代码中，对应地增加一段如上伪代码所示的 if 逻辑。这显然不符合开闭原则</p>\n<p>实际上，可以利用适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩赞。在前面讲到适配器其中一个作用是“统一多个类的接口设计”。利用适配器模式，将不同方式定义的 Controller 类中的函数，适配为统一的函数定义。这样，就能在 DispatcherServlet 类代码中，移除掉 if-else 分支判断逻辑，调用统一的函数</p>\n<p>具体看下 Spring 的代码实现，Spring 定义了统一的接口 HandlerAdapter，并且对每种 Controller 定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter 等，源码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface HandlerAdapter &#123;\n\tboolean supports(Object var1);\n\tModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object\n\t\tlong getLastModified(HttpServletRequest var1, Object var2);\n\t&#125;\n&#x2F;&#x2F; 对应实现Controller接口的Controller\npublic class SimpleControllerHandlerAdapter implements HandlerAdapter &#123;\n\tpublic SimpleControllerHandlerAdapter() &#123;\n\t&#125;\n\tpublic boolean supports(Object handler) &#123;\n\t\treturn handler instanceof Controller;\n\t&#125;\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse re\n\t\treturn ((Controller)handler).handleRequest(request, response);\n\t&#125;\n\tpublic long getLastModified(HttpServletRequest request, Object handler) &#123;\n\t\treturn handler instanceof LastModified ? ((LastModified)handler).getLastMod\n\t&#125;\n&#125;\n&#x2F;&#x2F; 对应实现Servlet接口的Controller\npublic class SimpleServletHandlerAdapter implements HandlerAdapter &#123;\n\tpublic SimpleServletHandlerAdapter() &#123;\n\t&#125;\n\tpublic boolean supports(Object handler) &#123;\n\t\treturn handler instanceof Servlet;\n\t&#125;\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response) &#123;\n\t\t((Servlet)handler).service(request, response);\n\t\treturn null;\n\t&#125;\n\tpublic long getLastModified(HttpServletRequest request, Object handler) &#123;\n\t\treturn -1L;\n\t&#125;\n&#125;\n&#x2F;&#x2F;AnnotationMethodHandlerAdapter对应通过注解实现的Controller，\n&#x2F;&#x2F;...</code></pre>\n\n<p>在 DispatcherServlet 类中，就不需要区分对待不同的 Controller 对象了，统一调用 HandlerAdapter 的 <code>handle()</code> 函数就可以了。按照这个思路实现的伪代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 之前的实现方式\nHandler handler &#x3D; handlerMapping.get(URL);\nif (handler instanceof Controller) &#123;\n\t((Controller)handler).handleRequest(...);\n&#125; else if (handler instanceof Servlet) &#123;\n\t((Servlet)handler).service(...);\n&#125; else if (hanlder 对应通过注解来定义的Controller) &#123;\n\t反射调用方法...\n&#125;\n&#x2F;&#x2F; 现在实现方式\nHandlerAdapter handlerAdapter &#x3D; handlerMapping.get(URL);\nhandlerAdapter.handle(...);</code></pre>\n\n<h3 id=\"4-3-2-策略模式在-Spring-中的应用\"><a href=\"#4-3-2-策略模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.3.2 策略模式在 Spring 中的应用\"></a>4.3.2 策略模式在 Spring 中的应用</h3><p>Spring AOP 是通过动态代理来实现的，具体到代码实现，Spring 支持两种动态代理实现方式，一种是 JDK 提供的动态代理实现方式，另一种是 Cglib 提供的动态代理实现方式</p>\n<p>前者需要被代理的类有抽象的接口定义，后者不需要。针对不同的被代理类，Spring 会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景</p>\n<p>前面讲过，策略模式包含三部分，策略的定义、创建和使用。接下来具体看下，这三个部分是如何体现在 Spring 源码中的</p>\n<p>在策略模式中，策略的定义这一部分很简单。只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到 Spring 源码，AopProxy 是策略接口，JdkDynamicAopProxy、CglibAopProxy 是两个实现了 AopProxy 接口的策略类。其中，AopProxy 接口的定义如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface AopProxy &#123;\n    Object getProxy();\n    Object getProxy(ClassLoader var1);\n&#125;</code></pre>\n\n<p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到 Spring 源码，AopProxyFactory 是一个工厂类接口，DefaultAopProxyFactory 是一个默认的工厂类，用来创建 AopProxy 对象。两者的源码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface AopProxyFactory &#123;\n\tAopProxy createAopProxy(AdvisedSupport var1) throws AopConfigException;\n&#125;\n\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;\n\tpublic DefaultAopProxyFactory() &#123;\n\t&#125;\n\tpublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException) &#123;\n\t\tif (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUse) &#123;\n\t\t\treturn new JdkDynamicAopProxy(config);\n\t\t&#125; else &#123;\n\t\t\tClass&lt;?&gt; targetClass &#x3D; config.getTargetClass();\n\t\t\tif (targetClass &#x3D;&#x3D; null) &#123;\n\t\t\t\tthrow new AopConfigException(&quot;TargetSource cannot determine target class&quot;);\n\t\t\t&#125; else &#123;\n\t\t\t\treturn (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;用来判断用哪个动态代理实现方式\n\tprivate boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) &#123;\n\t\tClass&lt;?&gt;[] ifcs &#x3D; config.getProxiedInterfaces();\n\t\treturn ifcs.length &#x3D;&#x3D; 0 || ifcs.length &#x3D;&#x3D; 1 &amp;&amp; SpringProxy.class.isAssignab\n\t&#125;\n&#125;</code></pre>\n\n<p>策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。对应到 Spring 源码中，可以参看刚刚给出的 DefaultAopProxyFactory 类中的 <code>createAopProxy()</code> 函数的代码实现。其中，第 10 行代码是动态选择哪种策略的判断条件</p>\n<h3 id=\"4-3-3-组合模式在-Spring-中的应用\"><a href=\"#4-3-3-组合模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.3.3 组合模式在 Spring 中的应用\"></a>4.3.3 组合模式在 Spring 中的应用</h3><p>前面讲到 Spring“再封装、再抽象”设计思想的时候，提到了 Spring Cache。Spring Cache 提供了一套抽象的 Cache 接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring 中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。Cache 接口的源码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Cache &#123;\n    String getName();\n    Object getNativeCache();\n    Cache.ValueWrapper get(Object var1);\n    &lt;T&gt; T get(Object var1, Class&lt;T&gt; var2);\n    &lt;T&gt; T get(Object var1, Callable&lt;T&gt; var2);\n    void put(Object var1, Object var2);\n    Cache.ValueWrapper putIfAbsent(Object var1, Object var2);\n    void evict(Object var1);\n    void clear();\n    public static class ValueRetrievalException extends RuntimeException &#123;\n        private final Object key;\n        public ValueRetrievalException(Object key, Callable&lt;?&gt; loader, Throwable exception) &#123;\n            super(String.format(&quot;Value for key &#39;%s&#39; could not be loaded using &#39;%s&#39;&quot;,\n                                this.key &#x3D; key;\n        &#125;\n        public Object getKey() &#123;\n            return this.key;\n        &#125;\n    &#125;\n    public interface ValueWrapper &#123;\n        Object get();\n    &#125;\n&#125;</code></pre>\n\n<p>在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到 Google Guava 缓存，也用到 Redis 缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）</p>\n<p>为了管理多个缓存，Spring 还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建 Cache 对象的时候要设置 name 属性）获取 Cache 对象；另一个是获取管理器管理的所有缓存的名字列表。对应的 Spring 源码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface CacheManager &#123;\n    Cache getCache(String var1);\n    Collection&lt;String&gt; getCacheNames();\n&#125;</code></pre>\n\n<p>刚刚给出的是 CacheManager 接口的定义，那如何来实现这两个接口呢？这就要用到了之前讲过的组合模式，组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点</p>\n<p>叶子节点包含的是它所管理的 Cache 对象，中间节点包含的是其他 CacheManager 管理器，既可以是 CompositeCacheManager，也可以是具体的管理器，比如 EhCacheManager、RedisManager 等</p>\n<p>CompositeCacheManger 的代码如下，其中，<code>getCache()</code>、<code>getCacheNames()</code> 两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CompositeCacheManager implements CacheManager, InitializingBean &#123;\n    private final List&lt;CacheManager&gt; cacheManagers &#x3D; new ArrayList();\n    private boolean fallbackToNoOpCache &#x3D; false;\n    public CompositeCacheManager() &#123;\n    &#125;\n    public CompositeCacheManager(CacheManager... cacheManagers) &#123;\n        this.setCacheManagers(Arrays.asList(cacheManagers));\n    &#125;\n    public void setCacheManagers(Collection&lt;CacheManager&gt; cacheManagers) &#123;\n        this.cacheManagers.addAll(cacheManagers);\n    &#125;\n    public void setFallbackToNoOpCache(boolean fallbackToNoOpCache) &#123;\n        this.fallbackToNoOpCache &#x3D; fallbackToNoOpCache;\n    &#125;\n    public void afterPropertiesSet() &#123;\n        if (this.fallbackToNoOpCache) &#123;\n            this.cacheManagers.add(new NoOpCacheManager());\n        &#125;\n    &#125;\n    public Cache getCache(String name) &#123;\n        Iterator var2 &#x3D; this.cacheManagers.iterator();\n        Cache cache;\n        do &#123;\n            if (!var2.hasNext()) &#123;\n                return null;\n            &#125;\n            CacheManager cacheManager &#x3D; (CacheManager)var2.next();\n            cache &#x3D; cacheManager.getCache(name);\n        &#125; while(cache &#x3D;&#x3D; null);\n        return cache;\n    &#125;\n    public Collection&lt;String&gt; getCacheNames() &#123;\n        Set&lt;String&gt; names &#x3D; new LinkedHashSet();\n        Iterator var2 &#x3D; this.cacheManagers.iterator();\n        while(var2.hasNext()) &#123;\n            CacheManager manager &#x3D; (CacheManager)var2.next();\n            names.addAll(manager.getCacheNames());\n        &#125;\n        return Collections.unmodifiableSet(names);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-3-4-装饰器模式在-Spring-中的应用\"><a href=\"#4-3-4-装饰器模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.3.4 装饰器模式在 Spring 中的应用\"></a>4.3.4 装饰器模式在 Spring 中的应用</h3><p>缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。为了解决这个问题，需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败</p>\n<p>实现这样一个功能，Spring 使用到了装饰器模式。TransactionAwareCacheDecorator 增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理</p>\n<p>TransactionAwareCacheDecorator 实现 Cache 接口，并且将所有的操作都委托给 targetCache 来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TransactionAwareCacheDecorator implements Cache &#123;\n    private final Cache targetCache;\n    public TransactionAwareCacheDecorator(Cache targetCache) &#123;\n        Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);\n        this.targetCache &#x3D; targetCache;\n    &#125;\n    public Cache getTargetCache() &#123;\n        return this.targetCache;\n    &#125;\n    public String getName() &#123;\n        return this.targetCache.getName();\n    &#125;\n    public Object getNativeCache() &#123;\n        return this.targetCache.getNativeCache();\n    &#125;\n    public ValueWrapper get(Object key) &#123;\n        return this.targetCache.get(key);\n    &#125;\n    public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) &#123;\n        return this.targetCache.get(key, type);\n    &#125;\n    public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) &#123;\n        return this.targetCache.get(key, valueLoader);\n    &#125;\n    public void put(final Object key, final Object value) &#123;\n        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;\n            TransactionSynchronizationManager.registerSynchronization(new Transaction() &#123;\n                public void afterCommit() &#123;\n                    TransactionAwareCacheDecorator.this.targetCache.put(key, value);\n                &#125;\n            &#125;);\n        &#125; else &#123;\n            this.targetCache.put(key, value);\n        &#125;\n    &#125;\n    public ValueWrapper putIfAbsent(Object key, Object value) &#123;\n        return this.targetCache.putIfAbsent(key, value);\n    &#125;\n    public void evict(final Object key) &#123;\n        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;\n            TransactionSynchronizationManager.registerSynchronization(new Transaction() &#123;\n                public void afterCommit() &#123;\n                    TransactionAwareCacheDecorator.this.targetCache.evict(key);\n                &#125;\n            &#125;);\n        &#125; else &#123;\n            this.targetCache.evict(key);\n        &#125;\n    &#125;\n    public void clear() &#123;\n        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;\n            TransactionSynchronizationManager.registerSynchronization(new Transaction() &#123;\n                public void afterCommit() &#123;\n                    TransactionAwareCacheDecorator.this.targetCache.clear();\n                &#125;\n            &#125;);\n        &#125; else &#123;\n            this.targetCache.clear();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-3-5-工厂模式在-Spring-中的应用\"><a href=\"#4-3-5-工厂模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.3.5 工厂模式在 Spring 中的应用\"></a>4.3.5 工厂模式在 Spring 中的应用</h3><p>在 Spring 中，工厂模式最经典的应用莫过于实现 IOC 容器，对应的 Spring 源码主要是 BeanFactory 类和 ApplicationContext 相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）</p>\n<p>在 Spring 中，创建 Bean 的方式有很多种，比如前面提到的纯构造函数、无参构造函数加 setter 方法，如下例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    private long id;\n    private String name;\n    public Student(long id, String name) &#123;\n        this.id &#x3D; id;\n        this.name &#x3D; name;\n    &#125;\n    public void setId(long id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.xzg.cd.Student&quot;&gt;\n  &lt; constructor arg&#x3D;&quot;&quot; name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;\n    &lt; constructor arg&#x3D;&quot;&quot; name&#x3D;&quot;name&quot; value&#x3D;&quot;wangzheng&quot;&gt;\n      &lt;  bean&#x3D;&quot;&quot;&gt;&#x2F;&#x2F; 使用无参构造函数+setter方法来创建Bean \n      &lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.xzg.cd.Student&quot;&gt;\n        &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;\n          &lt;  property&#x3D;&quot;&quot;&gt;\n            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;wangzheng&quot;&gt;\n              &lt;  property&#x3D;&quot;&quot;&gt;&lt;&#x2F; &gt;\n            &lt;&#x2F;property&gt;\n          &lt;&#x2F; &gt;\n        &lt;&#x2F;property&gt;\n      &lt;&#x2F;bean&gt;&lt;&#x2F; &gt;\n    &lt;&#x2F; constructor&gt;\n  &lt;&#x2F; constructor&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<p>实际上，除了这两种创建 Bean 的方式之外，还可以通过工厂方法来创建 Bean。还是刚刚这个例子，用这种方式来创建 Bean 的话就是下面这个样子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StudentFactory &#123;\n    private static Map&lt;Long, Student&gt; students &#x3D; new HashMap&lt;&gt;();\n    static &#123;\n        map.put(1, new Student(1, &quot;wang&quot;));\n        map.put(2, new Student(2, &quot;zheng&quot;));\n        map.put(3, new Student(3, &quot;xzg&quot;));\n    &#125;\n    public static Student getStudent(long id) &#123;\n        return students.get(id);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 通过工厂方法getStudent(2)来创建BeanId&#x3D;&quot;zheng&quot;&quot;的Bean\n&lt;bean id&#x3D;&quot;zheng&quot; class&#x3D;&quot;com.xzg.cd.StudentFactory&quot; factory-method&#x3D;&quot;getStudent&quot;&gt;\n  &lt;constructor-arg value&#x3D;&quot;2&quot;&gt;&lt;&#x2F;constructor-arg&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<h3 id=\"4-3-6-其他模式在-Spring-中的应用\"><a href=\"#4-3-6-其他模式在-Spring-中的应用\" class=\"headerlink\" title=\"4.3.6 其他模式在 Spring 中的应用\"></a>4.3.6 其他模式在 Spring 中的应用</h3><p>SpEL，全称叫 Spring Expression Language，是 Spring 中常用来编写配置的表达式语言。它定义了一系列的语法规则。只要按照这些语法规则来编写表达式，Spring 就能解析出表达式的含义。实际上，这就是前面讲到的解释器模式的典型应用场景</p>\n<p>因为解释器模式没有一个非常固定的代码实现结构，而且 Spring 中 SpEL 相关的代码也比较多，所以这里就不进行过多讲述了。如果感兴趣或者项目中正好要实现类似的功能的时候，可以再去阅读、借鉴它的代码实现。代码主要集中在 spring-expresssion 这个模块下面</p>\n<p>前面讲到单例模式的时候提到过，单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过 IOC 容器来管理对象，通过 IOC 容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个 IOC 容器内</p>\n<p>除此之外，Spring 还用到了观察者模式、模板模式、职责链模式、代理模式</p>\n<p>实际上，在 Spring 中，只要后缀带有 Template 的类，基本上都是模板类，而且大部分都是用 Callback 回调来实现的，比如 JdbcTemplate、RedisTemplate 等。剩下的两个模式在 Spring 中的应用应该人尽皆知了。职责链模式在 Spring 中的应用是拦截器（Interceptor），代理模式经典应用是 AOP</p>\n<h1 id=\"5-MyBatis\"><a href=\"#5-MyBatis\" class=\"headerlink\" title=\"5. MyBatis\"></a>5. MyBatis</h1><h2 id=\"5-1-Mybatis-和-ORM-框架介绍\"><a href=\"#5-1-Mybatis-和-ORM-框架介绍\" class=\"headerlink\" title=\"5.1 Mybatis 和 ORM 框架介绍\"></a>5.1 Mybatis 和 ORM 框架介绍</h2><p>MyBatis 是一个 ORM（Object Relational Mapping，对象 · 关系映射）框架。ORM 框架主要是根据类和数据库表之间的映射关系，帮助程序员自动实现对象与数据库中数据之间的互相转化。说得更具体点就是，ORM 负责将程序中的对象存储到数据库中、将数据库中的数据转化为程序中的对象。实际上，Java 中的 ORM 框架<br>有很多，除了刚刚提到的 MyBatis 之外，还有 Hibernate、TopLink 等</p>\n<p>在剖析 Spring 框架的时候讲到，如果用一句话来总结框架作用的话，那就是简化开发。MyBatis 框架也不例外。它简化的是数据库方面的开发。那 MyBatis 是如何简化数据库开发的呢？</p>\n<p>前面讲到 Java 提供了 JDBC 类库来封装不同类型的数据库操作。不过，直接使用 JDBC 来进行数据库编程，还是有点麻烦的。于是，Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来进一步简化数据库编程</p>\n<p>使用 JdbcTemplate 进行数据库编程，只需要编写跟业务相关的代码（比如，SQL 语句、数据库中数据与对象之间的互相转化的代码），其他流程性质的代码（比如，加载驱动、创建数据库连接、创建 statement、关闭连接、关闭 statement 等）都封装在了 JdbcTemplate 类中，不需要重复编写</p>\n<p>还是同样这个例子，再来看下，使用 MyBatis 该如何实现，是不是比使用 JdbcTemplate 更加简单</p>\n<p>因为 MyBatis 依赖 JDBC 驱动，所以，在项目中使用 MyBatis，除了需要引入 MyBatis 框架本身（mybatis.jar）之外，还需要引入 JDBC 驱动（比如，访问 MySQL 的 JDBC 驱动实现类库 mysql-connector-java.jar）。将两个 jar 包引入项目之后，就可以开始编程了。使用 MyBatis 来访问数据库中用户信息的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 1. 定义UserDO\npublic class UserDo &#123;\n    private long id;\n    private String name;\n    private String telephone;\n    &#x2F;&#x2F; 省略setter&#x2F;getter方法\n&#125;\n&#x2F;&#x2F; 2. 定义访问接口\npublic interface UserMapper &#123;\n    public UserDo selectById(long id);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&#x2F;&#x2F; 3. 定义映射关系：UserMapper.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;cn.xzg.cd.a87.repo.mapper.UserMapper&quot;&gt;\n  &lt;select id&#x3D;&quot;selectById&quot; resultType&#x3D;&quot;cn.xzg.cd.a87.repo.UserDo&quot;&gt;select * from user where id&#x3D;#&#123;id&#125;&lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n&#x2F;&#x2F; 4. 全局配置文件: mybatis.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n  &lt;environments default&#x3D;&quot;dev&quot;&gt;\n    &lt;environment id&#x3D;&quot;dev&quot;&gt;\n      &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;\n      &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n        &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;...&quot; &#x2F;&gt;\n      &lt;&#x2F;dataSource&gt;\n    &lt;&#x2F;environment&gt;\n  &lt;&#x2F;environments&gt;\n  &lt;mappers&gt;\n    &lt;mapper resource&#x3D;&quot;mapper&#x2F;UserMapper.xml&quot; &#x2F;&gt;\n  &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;</code></pre>\n\n<p>需要注意的是，在 UserMapper.xml 配置文件中，只定义了接口和 SQL 语句之间的映射关系，并没有显式地定义类（UserDo）字段与数据库表（user）字段之间的映射关系。实际上，这就体现了“约定优于配置”的设计原则。类字段与数据库表字段之间使用了默认映射关系：类字段跟数据库表中拼写相同的字段一一映射。当然，如果没办法做到一一映射，也可以自定义它们之间的映射关系</p>\n<p>有了上面的代码和配置，就可以像下面这样来访问数据库中的用户信息了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyBatisDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Reader reader &#x3D; Resources.getResourceAsReader(&quot;mybatis.xml&quot;);\n        SqlSessionFactory sessionFactory &#x3D; new SqlSessionFactoryBuilder().build(reader);\n        SqlSession session &#x3D; sessionFactory.openSession();\n        UserMapper userMapper &#x3D; session.getMapper(UserMapper.class);\n        UserDo userDo &#x3D; userMapper.selectById(8);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;</code></pre>\n\n<p>从代码中可以看出，相对于使用 JdbcTemplate 的实现方式，使用 MyBatis 的实现方式更加灵活。在使用 JdbcTemplate 的实现方式中，对象与数据库中数据之间的转化代码、SQL 语句，是硬编码在业务代码中的。而在使用 MyBatis 的实现方式中，类字段与数据库字段之间的映射关系、接口与 SQL 之间的映射关系，是写在 XML 配置文件中的，是跟代码相分离的，这样会更加灵活、清晰，维护起来更加方便</p>\n<h2 id=\"5-2-如何平衡易用性、性能和灵活性？\"><a href=\"#5-2-如何平衡易用性、性能和灵活性？\" class=\"headerlink\" title=\"5.2 如何平衡易用性、性能和灵活性？\"></a>5.2 如何平衡易用性、性能和灵活性？</h2><p>刚刚对 MyBatis 框架做了简单介绍，接下来，再对比一下另外两个框架：JdbcTemplate 和 Hibernate。通过对比来看，MyBatis 是如何权衡代码的易用性、性能和灵活性的</p>\n<p>先来看 JdbcTemplate。相对于 MyBatis 来说，JdbcTemplate 更加轻量级。因为它对 JDBC 只做了很简单的封装，所以性能损耗比较少。相对于其他两个框架来说，它的性能最好。但是，它的缺点也比较明显，那就是 SQL 与代码耦合在一起，而且不具备 ORM 的功能，需要自己编写代码，解析对象跟数据库中的数据之间的映射关系。所以，在易用性上它不及其他两个框架</p>\n<p>再来看 Hibernate。相对于 MyBatis 来说，Hibernate 更加重量级。Hibernate 提供了更加高级的映射功能，能够根据业务需求自动生成 SQL 语句。不需要像使用 MyBatis 那样自己编写 SQL。因此，有的时候，也把 MyBatis 称作半自动化的 ORM框架，把 Hibernate 称作全自动化的 ORM 框架。不过，虽然自动生成 SQL 简化了开发，但是毕竟是自动生成的，没有针对性的优化。在性能方面，这样得到的 SQL 可能没有程序员编写得好。同时，这样也丧失了程序员自己编写 SQL 的灵活性</p>\n<p>实际上，不管用哪种实现方式，从数据库中取出数据并且转化成对象，这个过程涉及的代码逻辑基本是一致的。不同实现方式的区别，只不过是哪部分代码逻辑放到了哪里。有的框架提供的功能比较强大，大部分代码逻辑都由框架来完成，程序员只需要实现很小的一部分代码就可以了。这样框架的易用性就更好些。但是，框架集成的功能越多，为了处理逻辑的通用性，就会引入更多额外的处理代码。比起针对具体问题具体编程，这样性能损耗就相对大一些</p>\n<p>所以，粗略地讲，有的时候，框架的易用性和性能成对立关系。追求易用性，那性能就差一些。相反，追求性能，易用性就差一些。除此之外，使用起来越简单，那灵活性就越差，实际上，JdbcTemplate、MyBatis、Hibernate 这几个框架也体现了刚刚说的这个规律</p>\n<p>JdbcTemplate 提供的功能最简单，易用性最差，性能损耗最少，用它编程性能最好。Hibernate 提供的功能最完善，易用性最好，但相对来说性能损耗就最高了。MyBatis 介于两者中间，在易用性、性能、灵活性三个方面做到了权衡。它支撑程序员自己编写 SQL，能够延续程序员对 SQL 知识的积累。相对于完全黑盒子的 Hibernate，很多程序员反倒是更加喜欢 MyBatis 这种半透明的框架。这也提醒我们，过度封装，提供过于简化的开发方式，也会丧失开发的灵活性</p>\n<h2 id=\"5-3-如何利用职责链与代理模式实现-MyBatis-Plugin？\"><a href=\"#5-3-如何利用职责链与代理模式实现-MyBatis-Plugin？\" class=\"headerlink\" title=\"5.3 如何利用职责链与代理模式实现 MyBatis Plugin？\"></a>5.3 如何利用职责链与代理模式实现 MyBatis Plugin？</h2><p>MyBatis Plugin，尽管名字叫 Plugin（插件），但它实际上跟之前讲到的 Servlet Filter（过滤器）、Spring Interceptor（拦截器）类似，设计的初衷都是为了框架的扩展性，用到的主要设计模式都是职责链模式</p>\n<p>不过，相对于 Servlet Filter 和 Spring Interceptor，MyBatis Plugin 中职责链模式的代码实现稍微有点复杂。它是借助动态代理模式来实现的职责链</p>\n<h3 id=\"5-3-1-MyBatis-Plugin-功能介绍\"><a href=\"#5-3-1-MyBatis-Plugin-功能介绍\" class=\"headerlink\" title=\"5.3.1 MyBatis Plugin 功能介绍\"></a>5.3.1 MyBatis Plugin 功能介绍</h3><p>实际上，MyBatis Plugin 跟 Servlet Filter、Spring Interceptor 的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。它们的唯一区别在于拦截的位置是不同的。Servlet Filter 主要拦截 Servlet 请求，Spring Interceptor 主要拦截 Spring 管理的 Bean 方法（比如 Controller 类的方法等），而 MyBatis Plugin 主要拦截的是 MyBatis 在执行 SQL 的过程中涉及的一些方法，MyBatis Plugin 使用起来比较简单，如下例：</p>\n<p>假设需要统计应用中每个 SQL 的执行耗时，如果使用 MyBatis Plugin 来实现的话，只需要定义一个 SqlCostTimeInterceptor 类，让它实现 MyBatis 的 Interceptor 接口，并且，在 MyBatis 的全局配置文件中，简单声明一下这个插件就可以了。具体的代码和配置如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Intercepts(&#123;\n    @Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;query&quot;, args &#x3D; &#123; StatementHandler &#125;\n    @Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;update&quot;, args &#x3D; &#123; StatementHandler&#125;\n    @Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;batch&quot;, args &#x3D; &#123; StatementHandler&#125;\n&#125;\npublic class SqlCostTimeInterceptor implements Interceptor &#123;\n    private static Logger logger &#x3D; LoggerFactory.getLogger(SqlCostTimeInterceptor);\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable &#123;\n        Object target &#x3D; invocation.getTarget();\n        long startTime &#x3D; System.currentTimeMillis();\n        StatementHandler statementHandler &#x3D; (StatementHandler) target;\n        try &#123;\n            return invocation.proceed();\n        &#125; finally &#123;\n            long costTime &#x3D; System.currentTimeMillis() - startTime;\n            BoundSql boundSql &#x3D; statementHandler.getBoundSql();\n            String sql &#x3D; boundSql.getSql();\n            logger.info(&quot;执行 SQL：[ &#123;&#125; ]执行耗时[ &#123;&#125; ms]&quot;, sql, costTime);\n        &#125;\n    &#125;\n    @Override\n    public Object plugin(Object target) &#123;\n        return Plugin.wrap(target, this);\n    &#125;\n    @Override\n    public void setProperties(Properties properties) &#123;\n        System.out.println(&quot;插件配置的信息：&quot; + properties);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- MyBatis全局配置文件：mybatis-config.xml --&gt;\n&lt;plugins&gt;\n  &lt;plugin interceptor&#x3D;&quot;com.xzg.cd.a88.SqlCostTimeInterceptor&quot;&gt;\n    &lt;property name&#x3D;&quot;someProperty&quot; value&#x3D;&quot;100&quot; &#x2F;&gt;\n  &lt;&#x2F;plugin&gt;\n&lt;&#x2F;plugins&gt;</code></pre>\n\n<p>先重点看下 <code>@Intercepts</code> 注解这一部分，不管是拦截器、过滤器还是插件，都需要明确地标明拦截的目标方法。<code>@Intercepts</code> 注解实际上就是起了这个作用。其中，<code>@Intercepts</code> 注解又可以嵌套 <code>@Signature</code> 注解。一个 <code>@Signature</code> 注解标明一个要拦截的目标方法。如果要拦截多个方法，可以像例子中那样，编写多条 <code>@Signature</code> 注解</p>\n<p><code>@Signature</code> 注解包含三个元素：type、method、args。其中，type 指明要拦截的类、method 指明方法名、args 指明方法的参数列表。通过指定这三个元素，就能完全确定一个要拦截的方法</p>\n<p>默认情况下，MyBatis Plugin 允许拦截的方法有下面这样几个：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b0b54742af5645e18e1690c6dce73f6c.png\" alt=\"在这里插入图片描述\"></p>\n<p>为什么默认允许拦截的是这样几个类的方法呢？</p>\n<p>MyBatis 底层是通过 Executor 类来执行 SQL 的。Executor 类会创建 StatementHandler、ParameterHandler、ResultSetHandler 三个对象，并且，首先使用 ParameterHandler 设置 SQL 中的占位符参数，然后使用 StatementHandler 执行SQL 语句，最后使用 ResultSetHandler 封装执行结果。所以，只需要拦截 Executor、ParameterHandler、ResultSetHandler、StatementHandler 这几个类的方法，基本上就能满足对整个 SQL 执行流程的拦截了</p>\n<p>实际上，除了统计 SQL 的执行耗时，利用 MyBatis Plugin，还可以做很多事情，比如分库分表、自动分页、数据脱敏、加密解密等等</p>\n<h3 id=\"5-3-2-MyBatis-Plugin-的设计与实现\"><a href=\"#5-3-2-MyBatis-Plugin-的设计与实现\" class=\"headerlink\" title=\"5.3.2 MyBatis Plugin 的设计与实现\"></a>5.3.2 MyBatis Plugin 的设计与实现</h3><p>职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。这两个部分对应到 Servlet Filter 的源码就是 Filter 和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和 HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和 InterceptorChain。除此之外，MyBatis Plugin 还包含另外一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理</p>\n<p>集成了 MyBatis 的应用在启动的时候，MyBatis 框架会读取全局配置文件（前面例子中的 mybatis-config.xml 文件），解析出 Interceptor（也就是例子中的 SqlCostTimeInterceptor），并且将它注入到 Configuration 类的 InterceptorChain 对象中。这部分逻辑对应到源码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class XMLConfigBuilder extends BaseBuilder &#123;\n    &#x2F;&#x2F;解析配置\n    private void parseConfiguration(XNode root) &#123;\n        try &#123;\n            &#x2F;&#x2F;省略部分代码...\n            pluginElement(root.evalNode(&quot;plugins&quot;)); &#x2F;&#x2F;解析插件\n        &#125; catch (Exception e) &#123;\n            throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause&quot;);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;解析插件\n    private void pluginElement(XNode parent) throws Exception &#123;\n        if (parent !&#x3D; null) &#123;\n            for (XNode child : parent.getChildren()) &#123;\n                String interceptor &#x3D; child.getStringAttribute(&quot;interceptor&quot;);\n                Properties properties &#x3D; child.getChildrenAsProperties();\n                &#x2F;&#x2F;创建Interceptor类对象\n                Interceptor interceptorInstance &#x3D; (Interceptor) resolveClass(interceptor);\n                &#x2F;&#x2F;调用Interceptor上的setProperties()方法设置properties\n                interceptorInstance.setProperties(properties);\n                &#x2F;&#x2F;下面这行代码会调用InterceptorChain.addInterceptor()方法\n                configuration.addInterceptor(interceptorInstance);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F; Configuration类的addInterceptor()方法的代码如下所示\npublic void addInterceptor(Interceptor interceptor) &#123;\n    interceptorChain.addInterceptor(interceptor);\n&#125;</code></pre>\n\n<p>再来看 Interceptor 和 InterceptorChain 这两个类的代码，如下所示。Interceptor 的 <code>setProperties()</code> 方法就是一个单纯的 setter 方法，主要是为了方便通过配置文件配置 Interceptor 的一些属性值，没有其他作用。Interceptor 类中 <code>intecept()</code> 和 <code>plugin()</code> 函数，以及 InterceptorChain 类中的 <code>pluginAll()</code> 函数，是最核心的三个函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Invocation &#123;\n    private final Object target;\n    private final Method method;\n    private final Object[] args;\n    &#x2F;&#x2F; 省略构造函数和getter方法...\n    public Object proceed() throws InvocationTargetException, IllegalAccessExcept\n        return method.invoke(target, args);\n&#125;\n&#125;\npublic interface Interceptor &#123;\n    Object intercept(Invocation invocation) throws Throwable;\n    Object plugin(Object target);\n    void setProperties(Properties properties);\n&#125;\npublic class InterceptorChain &#123;\n    private final List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;Interceptor&gt;();\n    public Object pluginAll(Object target) &#123;\n        for (Interceptor interceptor : interceptors) &#123;\n            target &#x3D; interceptor.plugin(target);\n        &#125;\n        return target;\n    &#125;\n    public void addInterceptor(Interceptor interceptor) &#123;\n        interceptors.add(interceptor);\n    &#125;\n    public List&lt;Interceptor&gt; getInterceptors() &#123;\n        return Collections.unmodifiableList(interceptors);\n    &#125;\n&#125;</code></pre>\n\n<p>解析完配置文件之后，所有的 Interceptor 都加载到了 InterceptorChain 中。接下来，再来看下，这些拦截器是在什么时候被触发执行的？又是如何被触发执行的呢？</p>\n<p>前面提到，在执行 SQL 的过程中，MyBatis 会创建 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这几个类的对象，对应的创建代码在 Configuration 类中，如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;\n    executorType &#x3D; executorType &#x3D;&#x3D; null ? defaultExecutorType : executorType;\n    executorType &#x3D; executorType &#x3D;&#x3D; null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;\n        executor &#x3D; new BatchExecutor(this, transaction);\n    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;\n        executor &#x3D; new ReuseExecutor(this, transaction);\n    &#125; else &#123;\n        executor &#x3D; new SimpleExecutor(this, transaction);\n    &#125;\n    if (cacheEnabled) &#123;\n        executor &#x3D; new CachingExecutor(executor);\n    &#125;\n    executor &#x3D; (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n&#125;\npublic ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object object) &#123;\n    ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameter);\n    parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n    return parameterHandler;\n&#125;\npublic ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement)\nResultHandler resultHandler, BoundSql boundSql) &#123;\n    ResultSetHandler resultSetHandler &#x3D; new DefaultResultSetHandler(executor, map);\n    resultSetHandler &#x3D; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n    return resultSetHandler;\n&#125;\npublic StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement) &#123;\n    StatementHandler statementHandler &#x3D; new RoutingStatementHandler(executor, map);\n    statementHandler &#x3D; (StatementHandler) interceptorChain.pluginAll(statementHandler);\n    return statementHandler;\n&#125;</code></pre>\n\n<p>从上面的代码中，可以发现，这几个类对象的创建过程都调用了 InteceptorChain 的 <code>pluginAll()</code> 方法。这个方法的代码前面已经给出了。它的代码实现很简单，嵌套调用 InterceptorChain 上每个 Interceptor 的 <code>plugin()</code> 方法。<code>plugin()</code>是一个接口方法（不包含实现代码），需要由用户给出具体的实现代码。在之前的例子中，SQLTimeCostInterceptor 的 <code>plugin()</code> 方法通过直接调用 Plugin 的 <code>wrap()</code> 方法来实现。<br><code>wrap()</code> 方法的代码实现如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 借助Java InvocationHandler实现的动态代理模式\npublic class Plugin implements InvocationHandler &#123;\n    private final Object target;\n    private final Interceptor interceptor;\n    private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;\n    private Plugin(Object target, Interceptor interceptor, Map &lt; Class&lt;?&gt;, Set &lt; Method&gt;&gt; signatureMap) &#123;\n        this.target &#x3D; target;\n        this.interceptor &#x3D; interceptor;\n        this.signatureMap &#x3D; signatureMap;\n    &#125;\n    &#x2F;&#x2F; wrap()静态方法，用来生成target的动态代理，\n    &#x2F;&#x2F; 动态代理对象&#x3D;target对象+interceptor对象。\n    public static Object wrap(Object target, Interceptor interceptor) &#123;\n        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap &#x3D; getSignatureMap(interceptor);\n        Class&lt;?&gt; type &#x3D; target.getClass();\n        Class&lt;?&gt;[] interfaces &#x3D; getAllInterfaces(type, signatureMap);\n        if (interfaces.length &gt; 0) &#123;\n            return Proxy.newProxyInstance(\n                       type.getClassLoader(),\n                       interfaces,\n                       new Plugin(target, interceptor, signatureMap));\n        &#125;\n        return target;\n    &#125;\n    &#x2F;&#x2F; 调用target上的f()方法，会触发执行下面这个方法。\n    &#x2F;&#x2F; 这个方法包含：执行interceptor的intecept()方法 + 执行target上f()方法。\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        try &#123;\n            Set&lt;Method&gt; methods &#x3D; signatureMap.get(method.getDeclaringClass());\n            if (methods !&#x3D; null &amp;&amp; methods.contains(method)) &#123;\n                return interceptor.intercept(new Invocation(target, method, args));\n            &#125;\n            return method.invoke(target, args);\n        &#125; catch (Exception e) &#123;\n            throw ExceptionUtil.unwrapThrowable(e);\n        &#125;\n    &#125;\n    private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;\n        Intercepts interceptsAnnotation &#x3D; interceptor.getClass().getAnnotation(interceptor);\n        &#x2F;&#x2F; issue #251\n        if (interceptsAnnotation &#x3D;&#x3D; null) &#123;\n            throw new PluginException(&quot;No @Intercepts annotation was found in interce\n        &#125;\n        Signature[] sigs &#x3D; interceptsAnnotation.value();\n        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap &#x3D; new HashMap &lt; Class&lt;?&gt;, Set &lt; Method&gt;&gt; signatureMap);\n        for (Signature sig : sigs) &#123;\n        Set&lt;Method&gt; methods &#x3D; signatureMap.get(sig.type());\n            if (methods &#x3D;&#x3D; null) &#123;\n                methods &#x3D; new HashSet&lt;Method&gt;();\n                signatureMap.put(sig.type(), methods);\n            &#125;\n            try &#123;\n                Method method &#x3D; sig.type().getMethod(sig.method(), sig.args());\n                methods.add(method);\n            &#125; catch (NoSuchMethodException e) &#123;\n                throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot;\n            &#125;\n        &#125;\n        return signatureMap;\n    &#125;\n    private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map &lt; Class&lt;?&gt;, Set &lt; Method&gt;&gt; signatureMap) &#123;\n        Set&lt;Class&lt;?&gt;&gt; interfaces &#x3D; new HashSet&lt;Class&lt;?&gt;&gt;();\n        while (type !&#x3D; null) &#123;\n            for (Class&lt;?&gt; c : type.getInterfaces()) &#123;\n                if (signatureMap.containsKey(c)) &#123;\n                    interfaces.add(c);\n                &#125;\n            &#125;\n            type &#x3D; type.getSuperclass();\n        &#125;\n        return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);\n    &#125;\n&#125;</code></pre>\n\n<p>实际上，Plugin 是借助 Java InvocationHandler 实现的动态代理类。用来代理给 target 对象添加 Interceptor 功能。其中，要代理的 target 对象就是 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类的对象。<code>wrap()</code> 静态方法是一个工具函数，用来生成 target 对象的动态代理对象</p>\n<p>当然，只有 interceptor 与 target 互相匹配的时候，<code>wrap()</code> 方法才会返回代理对象，否则就返回 target 对象本身。怎么才算是匹配呢？那就是 interceptor 通过 @Signature 注解要拦截的类包含 target 对象</p>\n<p>MyBatis 中的职责链模式的实现方式比较特殊。它对同一个目标对象嵌套多次代理（也就是 InteceptorChain 中的 <code>pluginAll()</code> 函数要执行的任务）。每个代理对象（Plugin 对象）代理一个拦截器（Interceptor 对象）功能。<code>pluginAll()</code> 函数的代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Object pluginAll(Object target) &#123;\n    &#x2F;&#x2F; 嵌套代理\n    for (Interceptor interceptor : interceptors) &#123;\n        target &#x3D; interceptor.plugin(target);\n        &#x2F;&#x2F; 上面这行代码等于下面这行代码，target(代理对象)&#x3D;target(目标对象)+interceptor(拦截器)\n        &#x2F;&#x2F; target &#x3D; Plugin.wrap(target, interceptor);\n    &#125;\n    return target;\n&#125;\n&#x2F;&#x2F; MyBatis像下面这样创建target(Executor、StatementHandler、ParameterHandler、Resul\nObject target &#x3D; interceptorChain.pluginAll(target);</code></pre>\n\n<p>当执行 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类上的某个方法的时候，MyBatis 会嵌套执行每层代理对象（Plugin 对象）上的 <code>invoke()</code> 方法。而 <code>invoke()</code> 方法会先执行代理对象中的 interceptor 的 <code>intecept()</code> 函数，然后再执行被代理对象上的方法。就这样，一层一层地把代理对象上的 <code>intercept()</code> 函数执行完之后，MyBatis 才最终执行那 4 个原始类对象上的方法</p>\n<h2 id=\"5-4-总结-MyBatis-框架中用到的-10-种设计模式\"><a href=\"#5-4-总结-MyBatis-框架中用到的-10-种设计模式\" class=\"headerlink\" title=\"5.4 总结 MyBatis 框架中用到的 10 种设计模式\"></a>5.4 总结 MyBatis 框架中用到的 10 种设计模式</h2><h3 id=\"5-4-1-SqlSessionFactoryBuilder：为什么要用建造者模式来创建SqlSessionFactory？\"><a href=\"#5-4-1-SqlSessionFactoryBuilder：为什么要用建造者模式来创建SqlSessionFactory？\" class=\"headerlink\" title=\"5.4.1 SqlSessionFactoryBuilder：为什么要用建造者模式来创建SqlSessionFactory？\"></a>5.4.1 SqlSessionFactoryBuilder：为什么要用建造者模式来创建SqlSessionFactory？</h3><p>前面的用户查询例子如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyBatisDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Reader reader &#x3D; Resources.getResourceAsReader(&quot;mybatis.xml&quot;);\n        SqlSessionFactory sessionFactory &#x3D; new SqlSessionFactoryBuilder().build(reader);\n        SqlSession session &#x3D; sessionFactory.openSession();\n        UserMapper userMapper &#x3D; session.getMapper(UserMapper.class);\n        UserDo userDo &#x3D; userMapper.selectById(8);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;</code></pre>\n\n<p>之前讲到建造者模式的时候，使用 Builder 类来创建对象，一般都是先级联一组 <code>setXXX()</code> 方法来设置属性，然后再调用 <code>build()</code> 方法最终创建对象。但是，在上面这段代码中，通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 并不符合这个套路。它既没有 setter 方法，而且 <code>build()</code> 方法也并非无参，需要传递参数。除此之外，从上面的代码来看，SqlSessionFactory 对象的创建过程也并不复杂。那直接通过构造函数来创建 SqlSessionFactory 不就行了吗？为什么还要借助建造者模式创建 SqlSessionFactory呢？</p>\n<p>要回答这个问题，我们就要先看下 SqlSessionFactoryBuilder 类的源码。源码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SqlSessionFactoryBuilder &#123;\n    public SqlSessionFactory build(Reader reader) &#123;\n        return build(reader, null, null);\n    &#125;\n\n    public SqlSessionFactory build(Reader reader, String environment) &#123;\n        return build(reader, environment, null);\n\n    &#125;\n    public SqlSessionFactory build(Reader reader, Properties properties) &#123;\n        return build(reader, null, properties);\n    &#125;\n\n\n    public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;\n        try &#123;\n            XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(reader, environment, properties);\n            return build(parser.parse());\n        &#125; catch (Exception e) &#123;\n            throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);\n        &#125; finally &#123;\n            ErrorContext.instance().reset();\n            try &#123;\n                reader.close();\n            &#125; catch (IOException e) &#123;\n                &#x2F;&#x2F; Intentionally ignore. Prefer previous error.\n            &#125;\n        &#125;\n    &#125;\n    public SqlSessionFactory build(InputStream inputStream) &#123;\n        return build(inputStream, null, null);\n    &#125;\n\n\n    public SqlSessionFactory build(InputStream inputStream, String environment) &#123;\n        return build(inputStream, environment, null);\n    &#125;\n\n    public SqlSessionFactory build(InputStream inputStream, Properties properties) &#123;\n        return build(inputStream, null, properties);\n    &#125;\n\n    public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;\n        try &#123;\n\n            XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);\n            return build(parser.parse());\n        &#125; catch (Exception e) &#123;\n            throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);\n        &#125; finally &#123;\n            ErrorContext.instance().reset();\n            try &#123;\n                inputStream.close();\n            &#125; catch (IOException e) &#123;\n                &#x2F;&#x2F; Intentionally ignore. Prefer previous error.\n            &#125;\n        &#125;\n    &#125;\n    public SqlSessionFactory build(Configuration config) &#123;\n        return new DefaultSqlSessionFactory(config);\n    &#125;\n&#125;</code></pre>\n\n<p>SqlSessionFactoryBuilder 类中有大量的 <code>build()</code> 重载函数。为了方便查看，以及跟 SqlSessionFactory 类的代码作对比，这里把重载函数定义抽象出来如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SqlSessionFactoryBuilder &#123;\n    public SqlSessionFactory build(Reader reader);\n    public SqlSessionFactory build(Reader reader, String environment);\n    public SqlSessionFactory build(Reader reader, Properties properties);\n    public SqlSessionFactory build(Reader reader, String environment, Properties properties);\n    public SqlSessionFactory build(InputStream inputStream);\n    public SqlSessionFactory build(InputStream inputStream, String environment);\n    public SqlSessionFactory build(InputStream inputStream, Properties properties);\n    public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties);\n    &#x2F;&#x2F; 上面所有的方法最终都调用这个方法\n    public SqlSessionFactory build(Configuration config);\n&#125;</code></pre>\n\n<p>如果一个类包含很多成员变量，而构建对象并不需要设置所有的成员变量，只需要选择性地设置其中几个就可以。为了满足这样的构建需求，就要定义多个包含不同参数列表的构造函数。为了避免构造函数过多、参数列表过长，一般通过无参构造函数加 setter 方法或者通过建造者模式来解决</p>\n<p>从建造者模式的设计初衷上来看，SqlSessionFactoryBuilder 虽然带有 Builder 后缀，但不要被它的名字所迷惑，它并不是标准的建造者模式。一方面，原始类 SqlSessionFactory 的构建只需要一个参数，并不复杂。另一方面，Builder 类 SqlSessionFactoryBuilder 仍然定义了 n 多包含不同参数列表的构造函数</p>\n<p>实际上，SqlSessionFactoryBuilder 设计的初衷只不过是为了简化开发。因为构建 SqlSessionFactory 需要先构建 Configuration，而构建 Configuration 是非常复杂的，需要做很多工作，比如配置的读取、解析、创建 n 多对象等。为了将构建 SqlSessionFactory 的过程隐藏起来，对程序员透明，MyBatis 就设计了SqlSessionFactoryBuilder 类封装这些构建细节</p>\n<h3 id=\"5-4-2-SqlSessionFactory：到底属于工厂模式还是建造器模式？\"><a href=\"#5-4-2-SqlSessionFactory：到底属于工厂模式还是建造器模式？\" class=\"headerlink\" title=\"5.4.2 SqlSessionFactory：到底属于工厂模式还是建造器模式？\"></a>5.4.2 SqlSessionFactory：到底属于工厂模式还是建造器模式？</h3><p>在上面那段 MyBatis 示例代码中，通过 SqlSessionFactoryBuilder 创建了 SqlSessionFactory，然后再通过 SqlSessionFactory 创建了 SqlSession。前面讲了SqlSessionFactoryBuilder，现在再来看下 SqlSessionFactory</p>\n<p>从名字上可能已经猜到，SqlSessionFactory 是一个工厂类，用到的设计模式是工厂模式。不过，它跟 SqlSessionFactoryBuilder 类似，名字有很大的迷惑性。实际上，它也并不是标准的工厂模式。为什么这么说呢？先来看下 SqlSessionFactory 类的源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface SqlSessionFactory &#123;\n    SqlSession openSession();\n    SqlSession openSession(boolean autoCommit);\n    SqlSession openSession(Connection connection);\n    SqlSession openSession(TransactionIsolationLevel level);\n    SqlSession openSession(ExecutorType execType);\n    SqlSession openSession(ExecutorType execType, boolean autoCommit);\n    SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);\n    SqlSession openSession(ExecutorType execType, Connection connection);\n    Configuration getConfiguration();\n&#125;</code></pre>\n\n<p>SqlSessionFactory 是一个接口，DefaultSqlSessionFactory 是它唯一的实现类。DefaultSqlSessionFactory 源码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;\n    private final Configuration configuration;\n    public DefaultSqlSessionFactory(Configuration configuration) &#123;\n        this.configuration &#x3D; configuration;\n    &#125;\n    @Override\n    public SqlSession openSession() &#123;\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), null);\n    &#125;\n    @Override\n    public SqlSession openSession(boolean autoCommit) &#123;\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), null);\n    &#125;\n    @Override\n    public SqlSession openSession(ExecutorType execType) &#123;\n        return openSessionFromDataSource(execType, null, false);\n    &#125;\n    @Override\n    public SqlSession openSession(TransactionIsolationLevel level) &#123;\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), level);\n    &#125;\n    @Override\n    public SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level) &#123;\n        return openSessionFromDataSource(execType, level, false);\n    &#125;\n    @Override\n    public SqlSession openSession(ExecutorType execType, boolean autoCommit) &#123;\n        return openSessionFromDataSource(execType, null, autoCommit);\n    &#125;\n    @Override\n    public SqlSession openSession(Connection connection) &#123;\n        return openSessionFromConnection(configuration.getDefaultExecutorType(), co\n    &#125;\n           @Override\n    public SqlSession openSession(ExecutorType execType, Connection connection) &#123;\n        return openSessionFromConnection(execType, connection);\n    &#125;\n    @Override\n    public Configuration getConfiguration() &#123;\n        return configuration;\n    &#125;\n    private SqlSession openSessionFromDataSource(ExecutorType execType, Transacti\n            Transaction tx &#x3D; null;\n    try &#123;\n        final Environment environment &#x3D; configuration.getEnvironment();\n        final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEn\n                tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level\n                        final Executor executor &#x3D; configuration.newExecutor(tx, execType);\n                        return new DefaultSqlSession(configuration, executor, autoCommit);\n    &#125; catch (Exception e) &#123;\n        closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close\n        throw ExceptionFactory.wrapException(&quot;Error opening session. Cause: &quot; +\n    &#125; finally &#123;\n        ErrorContext.instance().reset();\n    &#125;\n&#125;\nprivate SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) &#123;\n    try &#123;\n        boolean autoCommit;\n        try &#123;\n            autoCommit &#x3D; connection.getAutoCommit();\n        &#125; catch (SQLException e) &#123;\n            &#x2F;&#x2F; Failover to true, as most poor drivers\n            &#x2F;&#x2F; or databases won&#39;t support transactions\n            autoCommit &#x3D; true;\n        &#125;\n        final Environment environment &#x3D; configuration.getEnvironment();\n        final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEn\n                final Transaction tx &#x3D; transactionFactory.newTransaction(connection);\n        final Executor executor &#x3D; configuration.newExecutor(tx, execType);\n        return new DefaultSqlSession(configuration, executor, autoCommit);\n    &#125; catch (Exception e) &#123;\n        throw ExceptionFactory.wrapException(&quot;Error opening session. Cause: &quot; +\n    &#125; finally &#123;\n        ErrorContext.instance().reset();\n    &#125;\n&#125;\n&#x2F;&#x2F;...省略部分代码...</code></pre>\n\n<p>从 SqlSessionFactory 和 DefaultSqlSessionFactory 的源码来看，它的设计非常类似刚刚讲到的 SqlSessionFactoryBuilder，通过重载多个 <code>openSession()</code> 函数，支持通过组合 autoCommit、Executor、Transaction 等不同参数，来创建 SqlSession 对象。标准的工厂模式通过 type 来创建继承同一个父类的不同子类对象，而这里只不过是通过传递进不同的参数，来创建同一个类的对象。所以，它更像建造者模式</p>\n<p>虽然设计思路基本一致，但一个叫 xxxBuilder（SqlSessionFactoryBuilder），一个叫 xxxFactory（SqlSessionFactory）。而且，叫 xxxBuilder 的也并非标准的建造者模式，叫 xxxFactory 的也并非标准的工厂模式。所以，个人觉得，MyBatis 对这部分代码的设计还是值得优化的</p>\n<p>实际上，这两个类的作用只不过是为了创建 SqlSession 对象，没有其他作用。所以，更建议参照 Spring 的设计思路，把 SqlSessionFactoryBuilder 和 SqlSessionFactory 的逻辑，放到一个叫“ApplicationContext”的类中。让这个类来全权负责读入配置文件，创建 Congfiguration，生成 SqlSession</p>\n<h3 id=\"5-4-3-BaseExecutor：模板模式跟普通的继承有什么区别？\"><a href=\"#5-4-3-BaseExecutor：模板模式跟普通的继承有什么区别？\" class=\"headerlink\" title=\"5.4.3 BaseExecutor：模板模式跟普通的继承有什么区别？\"></a>5.4.3 BaseExecutor：模板模式跟普通的继承有什么区别？</h3><p>如果去查阅 SqlSession 与 DefaultSqlSession 的源码，会发现，SqlSession 执行 SQL的业务逻辑，都是委托给了 Executor 来实现。Executor 相关的类主要是用来执行 SQL</p>\n<p>其中，Executor 本身是一个接口；BaseExecutor 是一个抽象类，实现了 Executor 接口；而 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类继承 BaseExecutor 抽象类</p>\n<p>那 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类跟 BaseExecutor 是简单的继承关系，还是模板模式关系呢？怎么来判断呢？看一下 BaseExecutor 的源码就清楚了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class BaseExecutor implements Executor &#123;\n    &#x2F;&#x2F;...省略其他无关代码...\n    @Override\n    public int update(MappedStatement ms, Object parameter) throws SQLException &#123;\n        ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;);\n        if (closed) &#123;\n            throw new ExecutorException(&quot;Executor was closed.&quot;);\n        &#125;\n        clearLocalCache();\n        return doUpdate(ms, parameter);\n    &#125;\n    public List&lt;BatchResult&gt; flushStatements(boolean isRollBack) throws SQLException) &#123;\n        if (closed) &#123;\n            throw new ExecutorException(&quot;Executor was closed.&quot;);\n        &#125;\n        return doFlushStatements(isRollBack);\n    &#125;\n\n    private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBouds rowBounds) &#123;\n        List&lt;E&gt; list;\n        localCache.putObject(key, EXECUTION_PLACEHOLDER);\n        try &#123;\n            list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n        &#125; finally &#123;\n            localCache.removeObject(key);\n        &#125;\n        localCache.putObject(key, list);\n        if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;\n            localOutputParameterCache.putObject(key, parameter);\n        &#125;\n        return list;\n    &#125;\n    @Override\n    public &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBouds rowBounds) &#123;\n        BoundSql boundSql &#x3D; ms.getBoundSql(parameter);\n        return doQueryCursor(ms, parameter, rowBounds, boundSql);\n    &#125;\n    protected abstract int doUpdate(MappedStatement ms, Object parameter);\n    protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback);\n    protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter);\n    protected abstract &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter);\n&#125;</code></pre>\n\n<p>模板模式基于继承来实现代码复用。如果抽象类中包含模板方法，模板方法调用有待子类实现的抽象方法，那这一般就是模板模式的代码实现。而且，在命名上，模板方法与抽象方法一般是一一对应的，抽象方法在模板方法前面多一个“do”，比如，在 BaseExecutor 类中，其中一个模板方法叫 <code>update()</code>，那对应的抽象方法就叫 <code>doUpdate()</code></p>\n<h3 id=\"5-4-4-SqlNode：如何利用解释器模式来解析动态-SQL？\"><a href=\"#5-4-4-SqlNode：如何利用解释器模式来解析动态-SQL？\" class=\"headerlink\" title=\"5.4.4 SqlNode：如何利用解释器模式来解析动态 SQL？\"></a>5.4.4 SqlNode：如何利用解释器模式来解析动态 SQL？</h3><p>持配置文件中编写动态 SQL，是 MyBatis 一个非常强大的功能。所谓动态 SQL，就是在 SQL 中可以包含在 trim、if、#{}等语法标签，在运行时根据条件来生成不同的 SQL，如下例：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;update id&#x3D;&quot;update&quot; parameterType&#x3D;&quot;com.xzg.cd.a89.User&quot; UPDATE&#x3D;&quot;&quot; user&#x3D;&quot;&quot;&gt;\n&lt;trim prefix&#x3D;&quot;SET&quot; prefixOverrides&#x3D;&quot;,&quot;&gt;\n  &lt;if test&#x3D;&quot;name !&#x3D; null and name !&#x3D; &#39;&#39;&quot;&gt;name &#x3D; #&#123;name&#125;&lt;&#x2F;if&gt;\n  &lt;if test&#x3D;&quot;age !&#x3D; null and age !&#x3D; &#39;&#39;&quot;&gt;, age &#x3D; #&#123;age&#125;&lt;&#x2F;if&gt;\n  &lt;if test&#x3D;&quot;birthday !&#x3D; null and birthday !&#x3D; &#39;&#39;&quot;&gt;, birthday &#x3D; #&#123;birthday&#125;&lt;&#x2F;if&gt;\n&lt;&#x2F;trim&gt;where id &#x3D; $&#123;id&#125;&lt;&#x2F;update&gt;</code></pre>\n\n<p>显然，动态 SQL 的语法规则是 MyBatis 自定义的。如果想要根据语法规则，替换掉动态 SQL 中的动态元素，生成真正可以执行的 SQL 语句，MyBatis 还需要实现对应的解释器</p>\n<p>这一部分功能就可以看做是解释器模式的应用。解释器模式在解释语法规则的时候，一般会把规则分割成小的单元，特别是可以嵌套的小单元，针对每个小单元来解析，最终再把解析结果合并在一起。这里也不例外。MyBatis 把每个语法小单元叫 SqlNode。SqlNode 的定义如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface SqlNode &#123;\n    boolean apply(DynamicContext context);\n&#125;</code></pre>\n\n<p>对于不同的语法小单元，MyBatis 定义不同的 SqlNode 实现类</p>\n<p><img src=\"https://img-blog.csdnimg.cn/cc2a99f770a54c438668d79cff9bf28a.png\" alt=\"在这里插入图片描述\"></p>\n<p>整个解释器的调用入口在 DynamicSqlSource.getBoundSql 方法中，它调用了 <code>rootSqlNode.apply(context)</code> 方法</p>\n<h3 id=\"5-4-5-ErrorContext：如何实现一个线程唯一的单例模式？\"><a href=\"#5-4-5-ErrorContext：如何实现一个线程唯一的单例模式？\" class=\"headerlink\" title=\"5.4.5 ErrorContext：如何实现一个线程唯一的单例模式？\"></a>5.4.5 ErrorContext：如何实现一个线程唯一的单例模式？</h3><p>在单例模式那一部分讲到，单例模式是进程唯一的。同时还讲到单例模式的几种变形，比如线程唯一的单例、集群唯一的单例等。在 MyBatis 中，ErrorContext 这个类就是标准单例的变形：线程唯一的单例</p>\n<p>代码实现如下，它基于 Java 中的 ThreadLocal 来实现，实际上，这里的 ThreadLocal 就相当于那里的 ConcurrentHashMap</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ErrorContext &#123;\n    private static final String LINE_SEPARATOR &#x3D; System.getProperty(&quot;line.separate&quot;);\n    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL &#x3D; new ThreadLocal &lt; ErrorContext&gt; ();\n    private ErrorContext stored;\n    private String resource;\n    private String activity;\n    private String object;\n    private String message;\n    private String sql;\n    private Throwable cause;\n    private ErrorContext() &#123;\n    &#125;\n    public static ErrorContext instance() &#123;\n        ErrorContext context &#x3D; LOCAL.get();\n        if (context &#x3D;&#x3D; null) &#123;\n            context &#x3D; new ErrorContext();\n            LOCAL.set(context);\n        &#125;\n        return context;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"5-4-6-Cache：为什么要用装饰器模式而不设计成继承子类？\"><a href=\"#5-4-6-Cache：为什么要用装饰器模式而不设计成继承子类？\" class=\"headerlink\" title=\"5.4.6 Cache：为什么要用装饰器模式而不设计成继承子类？\"></a>5.4.6 Cache：为什么要用装饰器模式而不设计成继承子类？</h3><p>MyBatis 是一个 ORM 框架。实际上，它不只是简单地完成了对象和数据库数据之间的互相转化，还提供了很多其他功能，比如缓存、事务等。接下来，再讲讲它的缓存实现</p>\n<p>在 MyBatis 中，缓存功能由接口 Cache 定义。PerpetualCache 类是最基础的缓存类，是一个大小无限的缓存。除此之外，MyBatis 还设计了 9 个包裹 PerpetualCache 类的装饰器类，用来实现功能增强。它们分别是：FifoCache、LoggingCache、LruCache、ScheduledCache、SerializedCache、SoftCache、SynchronizedCache、WeakCache、TransactionalCache</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Cache &#123;\n    String getId();\n    void putObject(Object key, Object value);\n    Object getObject(Object key);\n    Object removeObject(Object key);\n    void clear();\n    int getSize();\n    ReadWriteLock getReadWriteLock();\n&#125;\npublic class PerpetualCache implements Cache &#123;\n    private final String id;\n    private Map&lt;Object, Object&gt; cache &#x3D; new HashMap&lt;Object, Object&gt;();\n    public PerpetualCache(String id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    @Override\n    public String getId() &#123;\n        return id;\n    &#125;\n    @Override\n    public int getSize() &#123;\n        return cache.size();\n    &#125;\n    @Override\n    public void putObject(Object key, Object value) &#123;\n        cache.put(key, value);\n    &#125;\n    @Override\n    public Object getObject(Object key) &#123;\n        return cache.get(key);\n    &#125;\n    @Override\n    public Object removeObject(Object key) &#123;\n        return cache.remove(key);\n    &#125;\n    @Override\n    public void clear() &#123;\n        cache.clear();\n    &#125;\n    @Override\n    public ReadWriteLock getReadWriteLock() &#123;\n        return null;\n    &#125;\n    &#x2F;&#x2F;省略部分代码...\n&#125;</code></pre>\n\n<p>这 9 个装饰器类的代码结构都类似，这里只将其中的 LruCache 的源码贴到这里。从代码中可以看出，它是标准的装饰器模式的代码实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LruCache implements Cache &#123;\n    private final Cache delegate;\n    private Map&lt;Object, Object&gt; keyMap;\n    private Object eldestKey;\n    public LruCache(Cache delegate) &#123;\n        this.delegate &#x3D; delegate;\n        setSize(1024);\n    &#125;\n    @Override\n    public String getId() &#123;\n        return delegate.getId();\n    &#125;\n    @Override\n    public int getSize() &#123;\n        return delegate.getSize();\n    &#125;\n    public void setSize(final int size) &#123;\n        keyMap &#x3D; new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123;\n            private static final long serialVersionUID &#x3D; 4267176411845948333L;\n            @Override\n            protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123;\n                boolean tooBig &#x3D; size() &gt; size;\n                if (tooBig) &#123;\n                    eldestKey &#x3D; eldest.getKey();\n                &#125;\n                return tooBig;\n            &#125;\n        &#125;;\n    &#125;\n    @Override\n    public void putObject(Object key, Object value) &#123;\n        delegate.putObject(key, value);\n        cycleKeyList(key);\n    &#125;\n    @Override\n    public Object getObject(Object key) &#123;\n        keyMap.get(key); &#x2F;&#x2F;touch\n        return delegate.getObject(key);\n    &#125;\n    @Override\n    public Object removeObject(Object key) &#123;\n        return delegate.removeObject(key);\n    &#125;\n    @Override\n    public void clear() &#123;\n        delegate.clear();\n        keyMap.clear();\n    &#125;\n    @Override\n    public ReadWriteLock getReadWriteLock() &#123;\n        return null;\n    &#125;\n    private void cycleKeyList(Object key) &#123;\n        keyMap.put(key, key);\n        if (eldestKey !&#x3D; null) &#123;\n            delegate.removeObject(eldestKey);\n            eldestKey &#x3D; null;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>之所以 MyBatis 采用装饰器模式来实现缓存功能，是因为装饰器模式采用了组合，而非继承，更加灵活，能够有效地避免继承关系的组合爆炸</p>\n<h3 id=\"5-4-7-PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？\"><a href=\"#5-4-7-PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？\" class=\"headerlink\" title=\"5.4.7 PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？\"></a>5.4.7 PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？</h3><p>迭代器模式常用来替代 for 循环遍历集合元素。Mybatis 的 PropertyTokenizer 类实现了 Java Iterator 接口，是一个迭代器，用来对配置属性进行解析。具体的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; person[0].birthdate.year 会被分解为3个PropertyTokenizer对象。其中，第一个Property\npublic class PropertyTokenizer implements Iterator&lt;PropertyTokenizer&gt; &#123;\n    private String name; &#x2F;&#x2F; person\n    private final String indexedName; &#x2F;&#x2F; person[0]\n    private String index; &#x2F;&#x2F; 0\n    private final String children; &#x2F;&#x2F; birthdate.year\n    public PropertyTokenizer(String fullname) &#123;\n        int delim &#x3D; fullname.indexOf(&#39;.&#39;);\n        if (delim &gt; -1) &#123;\n            name &#x3D; fullname.substring(0, delim);\n            children &#x3D; fullname.substring(delim + 1);\n        &#125; else &#123;\n            name &#x3D; fullname;\n            children &#x3D; null;\n        &#125;\n        indexedName &#x3D; name;\n        delim &#x3D; name.indexOf(&#39;[&#39;);\n        if (delim &gt; -1) &#123;\n            index &#x3D; name.substring(delim + 1, name.length() - 1);\n            name &#x3D; name.substring(0, delim);\n        &#125;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public String getIndex() &#123;\n        return index;\n    &#125;\n    public String getIndexedName() &#123;\n        return indexedName;\n    &#125;\n    public String getChildren() &#123;\n        return children;\n    &#125;\n    @Override\n    public boolean hasNext() &#123;\n        return children !&#x3D; null;\n    &#125;\n    @Override\n    public PropertyTokenizer next() &#123;\n        return new PropertyTokenizer(children);\n    &#125;\n    @Override\n    public void remove() &#123;\n        throw new UnsupportedOperationException(&quot;Remove is not supported, as it has&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>实际上，PropertyTokenizer 类也并非标准的迭代器类。它将配置的解析、解析之后的元素、迭代器，这三部分本该放到三个类中的代码，都耦合在一个类中，所以看起来稍微有点难懂。不过，这样做的好处是能够做到惰性解析。不需要事先将整个配置，解析成多个 PropertyTokenizer 对象。只有当在调用 <code>next()</code> 函数的时候，才会解析其中部分配置</p>\n<h3 id=\"5-4-8-Log：如何使用适配器模式来适配不同的日志框架？\"><a href=\"#5-4-8-Log：如何使用适配器模式来适配不同的日志框架？\" class=\"headerlink\" title=\"5.4.8 Log：如何使用适配器模式来适配不同的日志框架？\"></a>5.4.8 Log：如何使用适配器模式来适配不同的日志框架？</h3><p>在讲适配器模式的时候讲过，Slf4j 框架为了统一各个不同的日志框架（Log4j、JCL、Logback 等），提供了一套统一的日志接口。不过，MyBatis 并没有直接使用 Slf4j 提供的统一日志规范，而是自己又重复造轮子，定义了一套自己的日志访问接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Log &#123;\n    boolean isDebugEnabled();\n    boolean isTraceEnabled();\n    void error(String s, Throwable e);\n    void error(String s);\n    void debug(String s);\n    void trace(String s);\n    void warn(String s);\n&#125;</code></pre>\n\n<p>针对 Log 接口，MyBatis 还提供了各种不同的实现类，分别使用不同的日志框架来实现 Log 接口</p>\n<p><img src=\"https://img-blog.csdnimg.cn/52e5635f96aa49488709fb1a20923624.png\" alt=\"在这里插入图片描述\"></p>\n<p>这几个实现类的代码结构基本上一致。其中的 Log4jImpl 的源码如下。在适配器模式中，传递给适配器构造函数的是被适配的类对象，而这里是 clazz（相当于日志名称 name），所以，从代码实现上来讲，它并非标准的适配器模式。但是，从应用场景上来看，这里确实又起到了适配的作用，是典型的适配器模式的应用场景</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import org.apache.ibatis.logging.Log;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\npublic class Log4jImpl implements Log &#123;\n    private static final String FQCN &#x3D; Log4jImpl.class.getName();\n    private final Logger log;\n    public Log4jImpl(String clazz) &#123;\n        log &#x3D; Logger.getLogger(clazz);\n    &#125;\n    @Override\n    public boolean isDebugEnabled() &#123;\n        return log.isDebugEnabled();\n    &#125;\n    @Override\n    public boolean isTraceEnabled() &#123;\n        return log.isTraceEnabled();\n    &#125;\n    @Override\n    public void error(String s, Throwable e) &#123;\n        log.log(FQCN, Level.ERROR, s, e);\n    &#125;\n    @Override\n    public void error(String s) &#123;\n        log.log(FQCN, Level.ERROR, s, null);\n    &#125;\n    @Override\n    public void debug(String s) &#123;\n        log.log(FQCN, Level.DEBUG, s, null);\n    &#125;\n    @Override\n    public void trace(String s) &#123;\n        log.log(FQCN, Level.TRACE, s, null);\n    &#125;\n    @Override\n    public void warn(String s) &#123;\n        log.log(FQCN, Level.WARN, s, null);\n    &#125;\n&#125;</code></pre>\n","feature":false,"text":"设计模式相关的详细知识见如下三篇： 设计模式之美总结（创建型篇）_凡 223 的博客 设计模式之美总结（结构型篇）_凡 223 的博客 设计模式之美总结（行为型篇）_凡 223 的博客 1. Java JDK 应用到的设计模式1.1 工厂模式在 Calendar 类中的应用在前面...","link":"","photos":[],"count_time":{"symbolsCount":"113k","symbolsTime":"1:43"},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Java-JDK-%E5%BA%94%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1. Java JDK 应用到的设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%9C%A8-Calendar-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.1 工厂模式在 Calendar 类中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8-Calendar-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.2 建造者模式在 Calendar 类中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-Collections-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.3 装饰器模式在 Collections 类中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-Collections-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.4 适配器模式在 Collections 类中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E5%9C%A8-Collections-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.5 模板模式在 Collections 类中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8-JDK-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.6 观察者模式在 JDK 中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8-Runtime-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.7 单例模式在 Runtime 类中的应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E5%9C%A8-JDK-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">1.8 其他模式在 JDK 中的应用汇总</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E4%BB%8E-Unix-%E5%AD%A6%E4%B9%A0%E5%BA%94%E5%AF%B9%E5%A4%A7%E5%9E%8B%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">2. 从 Unix 学习应对大型复杂项目开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">2.1 设计原则和思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-1-%E5%B0%81%E8%A3%85%E4%B8%8E%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">2.1.1 封装与抽象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-2-%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96\"><span class=\"toc-text\">2.1.2 分层与模块化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-3-%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">2.1.3 基于接口通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-4-%E9%AB%98%E5%86%85%E8%81%9A%E3%80%81%E6%9D%BE%E8%80%A6%E5%90%88\"><span class=\"toc-text\">2.1.4 高内聚、松耦合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-5-%E4%B8%BA%E6%89%A9%E5%B1%95%E8%80%8C%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">2.1.5 为扩展而设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-6-KISS-%E9%A6%96%E8%A6%81%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">2.1.6 KISS 首要原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-7-%E6%9C%80%E5%B0%8F%E6%83%8A%E5%A5%87%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">2.1.7 最小惊奇原则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86%E5%92%8C%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">2.2 研发管理和开发技巧</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-%E5%90%B9%E6%AF%9B%E6%B1%82%E7%96%B5%E8%88%AC%E5%9C%B0%E6%89%A7%E8%A1%8C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">2.2.1 吹毛求疵般地执行编码规范</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">2.2.2 编写高质量的单元测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-3-%E4%B8%8D%E6%B5%81%E4%BA%8E%E5%BD%A2%E5%BC%8F%E7%9A%84-Code-Review\"><span class=\"toc-text\">2.2.3 不流于形式的 Code Review</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-4-%E5%BC%80%E5%8F%91%E6%9C%AA%E5%8A%A8%E3%80%81%E6%96%87%E6%A1%A3%E5%85%88%E8%A1%8C\"><span class=\"toc-text\">2.2.4 开发未动、文档先行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-5-%E6%8C%81%E7%BB%AD%E9%87%8D%E6%9E%84%E3%80%81%E9%87%8D%E6%9E%84%E3%80%81%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">2.2.5 持续重构、重构、重构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-6-%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%B8%8E%E5%9B%A2%E9%98%9F%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86\"><span class=\"toc-text\">2.2.6 对项目与团队进行拆分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-Code-Review\"><span class=\"toc-text\">2.3 Code Review</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-1-%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">2.3.1 优势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-2-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%9B%A2%E9%98%9F%E4%B8%AD%E8%90%BD%E5%9C%B0%E6%89%A7%E8%A1%8C-Code-Review%EF%BC%9F\"><span class=\"toc-text\">2.3.2 如何在团队中落地执行 Code Review？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Google-Guava\"><span class=\"toc-text\">3. Google Guava</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E9%80%9A%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%EF%BC%9F\"><span class=\"toc-text\">3.1 如何发现通用的功能模块？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%EF%BC%9F\"><span class=\"toc-text\">3.2 如何开发通用的功能模块？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Google-Guava-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.3 Google Guava 中用到的几种设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-Builder-%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.3.1 Builder 模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-Wrapper-%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.3.2 Wrapper 模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-3-Immutable-%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.3.3 Immutable 模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">3.4 函数式编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.4.1 概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-2-Java-%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">3.4.2 Java 对函数式编程的支持</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-3-Guava-%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">3.4.3 Guava 对函数式编程的增强</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Spring-%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">4. Spring 框架</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E8%95%B4%E5%90%AB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">4.1 蕴含的设计思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-1-%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">4.1.1 约定优于配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-2-%E4%BD%8E%E4%BE%B5%E5%85%A5%E3%80%81%E6%9D%BE%E8%80%A6%E5%90%88\"><span class=\"toc-text\">4.1.2 低侵入、松耦合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-3-%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7\"><span class=\"toc-text\">4.1.3 模块化、轻量级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-4-%E5%86%8D%E5%B0%81%E8%A3%85%E3%80%81%E5%86%8D%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">4.1.4 再封装、再抽象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E7%94%A8%E6%9D%A5%E6%94%AF%E6%8C%81%E6%89%A9%E5%B1%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.2 用来支持扩展的两种设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.2.1 观察者模式在 Spring 中的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-2-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.2.2 模板模式在 Spring 中的应用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-Spring-%E6%A1%86%E6%9E%B6%E7%94%A8%E5%88%B0%E7%9A%84-11-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.3 Spring 框架用到的 11 种设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.3.1 适配器模式在 Spring 中的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.3.2 策略模式在 Spring 中的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.3.3 组合模式在 Spring 中的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-4-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.3.4 装饰器模式在 Spring 中的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-5-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.3.5 工厂模式在 Spring 中的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-6-%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E5%9C%A8-Spring-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.3.6 其他模式在 Spring 中的应用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-MyBatis\"><span class=\"toc-text\">5. MyBatis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-Mybatis-%E5%92%8C-ORM-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">5.1 Mybatis 和 ORM 框架介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E5%A6%82%E4%BD%95%E5%B9%B3%E8%A1%A1%E6%98%93%E7%94%A8%E6%80%A7%E3%80%81%E6%80%A7%E8%83%BD%E5%92%8C%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">5.2 如何平衡易用性、性能和灵活性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%81%8C%E8%B4%A3%E9%93%BE%E4%B8%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0-MyBatis-Plugin%EF%BC%9F\"><span class=\"toc-text\">5.3 如何利用职责链与代理模式实现 MyBatis Plugin？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-1-MyBatis-Plugin-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">5.3.1 MyBatis Plugin 功能介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-2-MyBatis-Plugin-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">5.3.2 MyBatis Plugin 的设计与实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-%E6%80%BB%E7%BB%93-MyBatis-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84-10-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.4 总结 MyBatis 框架中用到的 10 种设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-1-SqlSessionFactoryBuilder%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BASqlSessionFactory%EF%BC%9F\"><span class=\"toc-text\">5.4.1 SqlSessionFactoryBuilder：为什么要用建造者模式来创建SqlSessionFactory？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-2-SqlSessionFactory%EF%BC%9A%E5%88%B0%E5%BA%95%E5%B1%9E%E4%BA%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%BF%98%E6%98%AF%E5%BB%BA%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">5.4.2 SqlSessionFactory：到底属于工厂模式还是建造器模式？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-3-BaseExecutor%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E8%B7%9F%E6%99%AE%E9%80%9A%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">5.4.3 BaseExecutor：模板模式跟普通的继承有什么区别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-4-SqlNode%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%8A%A8%E6%80%81-SQL%EF%BC%9F\"><span class=\"toc-text\">5.4.4 SqlNode：如何利用解释器模式来解析动态 SQL？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-5-ErrorContext%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%94%AF%E4%B8%80%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">5.4.5 ErrorContext：如何实现一个线程唯一的单例模式？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-6-Cache%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%80%8C%E4%B8%8D%E8%AE%BE%E8%AE%A1%E6%88%90%E7%BB%A7%E6%89%BF%E5%AD%90%E7%B1%BB%EF%BC%9F\"><span class=\"toc-text\">5.4.6 Cache：为什么要用装饰器模式而不设计成继承子类？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-7-PropertyTokenizer%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">5.4.7 PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-8-Log%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%9D%A5%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%EF%BC%9F\"><span class=\"toc-text\">5.4.8 Log：如何使用适配器模式来适配不同的日志框架？</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Spring Cloud 以及 Spring Cloud Alibaba 使用总结","uid":"f1cea3ae9e9660834ef5c504249979bd","slug":"BlogRepository/Spring/Spring Cloud 以及 Spring Cloud Alibaba 使用总结","date":"2023-01-13T03:54:15.000Z","updated":"2023-03-13T19:13:04.940Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring Cloud 以及 Spring Cloud Alibaba 使用总结.json","keywords":null,"cover":"https://cover.png","text":"1. 版本对应官网版本说明：版本说明 · alibaba&#x2F;spring-cloud-alibaba Wiki (github.com) 这里使用 Spring Boot 2.7.7、Spring Cloud 2021.0.4、Spring Cloud Alibaba 2...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"23 种设计模式总结","uid":"2236ff817b0fd532c388d0cf8bb4c954","slug":"BlogRepository/设计模式/23 种设计模式总结","date":"2022-12-30T08:53:46.000Z","updated":"2023-03-13T19:13:04.964Z","comments":true,"path":"api/articles/BlogRepository/设计模式/23 种设计模式总结.json","keywords":null,"cover":"https://cover.png","text":"设计模式相关的详细知识见如下三篇： 设计模式之美总结（创建型篇）_凡 223 的博客 设计模式之美总结（结构型篇）_凡 223 的博客 设计模式之美总结（行为型篇）_凡 223 的博客 这里主要是对上面三篇内容的总结，用于清晰 23 种设计模式的原理概念和应用场景，以及它们之间的...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}