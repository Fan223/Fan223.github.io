{"title":"Vue3 总结","uid":"253be1f39f8482a0ee0e446a428827b1","slug":"BlogRepository/Vue/Vue3 总结（基础）","date":"2022-11-06T15:57:57.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/Vue/Vue3 总结（基础）.json","keywords":null,"cover":"https://cover.png","content":"<p><strong>Vue2 基础见：<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/123573568\">Vue2 总结（基础）_凡 223 的博客</a></strong></p>\n<p><strong>Vue2 开发见：<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/123789272\">Vue2 总结（开发）_凡 223 的博客</a></strong></p>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><ol>\n<li><p>性能的提升</p>\n<ul>\n<li>打包大小减少41%</li>\n<li>初次渲染快55%，更新渲染快133%</li>\n<li>内存减少54%<br>……</li>\n</ul>\n</li>\n<li><p>源码的升级</p>\n<ul>\n<li>使用Proxy代替defineProperty实现响应式</li>\n<li>重写虚拟DOM的实现和Tree-Shaking<br>……</li>\n</ul>\n</li>\n<li><p>拥抱 TypeScript<br>Vue3 可以更好的支持 TypeScript</p>\n</li>\n<li><p>新的特性</p>\n<ol>\n<li>Composition API（组合API）<ul>\n<li>setup配置</li>\n<li>ref与reactive</li>\n<li>watch与watchEffect</li>\n<li>provide与inject<br>……</li>\n</ul>\n</li>\n<li>新的内置组件<ul>\n<li>Fragment</li>\n<li>Teleport</li>\n<li>Suspense</li>\n</ul>\n</li>\n<li>其他改变<ul>\n<li>新的生命周期钩子</li>\n<li>data 选项应始终被声明为一个函数</li>\n<li>移除 keyCode 支持作为 v-on 的修饰符<br>……</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"2-创建使用\"><a href=\"#2-创建使用\" class=\"headerlink\" title=\"2. 创建使用\"></a>2. 创建使用</h1><h2 id=\"2-1-使用-vue-cli-创建\"><a href=\"#2-1-使用-vue-cli-创建\" class=\"headerlink\" title=\"2.1 使用 vue-cli 创建\"></a>2.1 使用 vue-cli 创建</h2><p>官方文档：<a href=\"https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">## 查看@vue&#x2F;cli版本，确保@vue&#x2F;cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue&#x2F;cli\nnpm install -g @vue&#x2F;cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve</code></pre>\n\n<h2 id=\"2-2-使用-vite-创建\"><a href=\"#2-2-使用-vite-创建\" class=\"headerlink\" title=\"2.2 使用 vite 创建\"></a>2.2 使用 vite 创建</h2><p>官方文档：<a href=\"https://v3.cn.vuejs.org/guide/installation.html#vite\">https://v3.cn.vuejs.org/guide/installation.html#vite</a><br>vite官网：<a href=\"https://vitejs.cn/\">https://vitejs.cn</a></p>\n<p>什么是 vite？—— 新一代前端构建工具。</p>\n<ul>\n<li>开发环境中，无需打包操作，可快速的冷启动</li>\n<li>轻量快速的热重载（HMR）</li>\n<li>真正的按需编译，不再等待整个应用编译完成。</li>\n</ul>\n<p>传统构建 与 vite 构建对比图</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419095946.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419095958.png\"></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">## 创建工程\nnpm init vite-app &lt;project-name&gt;\n## 进入工程目录\ncd &lt;project-name&gt;\n## 安装依赖\nnpm install\n## 运行\nnpm run dev</code></pre>\n\n<h2 id=\"2-3-main-js-改动\"><a href=\"#2-3-main-js-改动\" class=\"headerlink\" title=\"2.3 main.js 改动\"></a>2.3 main.js 改动</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入的不再是Vue构造函数，引入的是一个名为 createApp 的工厂函数（不需要 new）\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\n&#x2F;&#x2F; createApp(App).mount(&#39;#app&#39;)\n\n&#x2F;&#x2F; 创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)\nconst app &#x3D; createApp(App)\n&#x2F;&#x2F;挂载\napp.mount(&#39;#app&#39;)</code></pre>\n\n<h2 id=\"2-4-App-vue-改动\"><a href=\"#2-4-App-vue-改动\" class=\"headerlink\" title=\"2.4 App.vue 改动\"></a>2.4 App.vue 改动</h2><p>Vue3 组件中的模板结构可以没有根标签</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;!-- Vue3组件中的模板结构可以没有根标签 --&gt;\n\t&lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;\n\t&lt;HelloWorld msg&#x3D;&quot;Welcome to Your Vue.js App&quot;&#x2F;&gt;\n&lt;&#x2F;template&gt;</code></pre>\n\n<h2 id=\"2-5-Vue3-开发者工具\"><a href=\"#2-5-Vue3-开发者工具\" class=\"headerlink\" title=\"2.5 Vue3 开发者工具\"></a>2.5 Vue3 开发者工具</h2><p><img src=\"http://img.fan223.cn/2023/04/20230419100011.png\"></p>\n<h1 id=\"3-常用-Composition-API\"><a href=\"#3-常用-Composition-API\" class=\"headerlink\" title=\"3. 常用 Composition API\"></a>3. 常用 Composition API</h1><h2 id=\"3-1-setup-函数\"><a href=\"#3-1-setup-函数\" class=\"headerlink\" title=\"3.1 setup 函数\"></a>3.1 setup 函数</h2><ol>\n<li>Vue3.0 中一个新的配置项，值为一个函数</li>\n<li>setup 是所有 Composition API（组合API）“ 表演的舞台 ”</li>\n<li><strong>组件中所用到的：数据、方法等等，均要配置在 setup 中</strong></li>\n<li>setup 函数的两种返回值：<ol>\n<li><strong>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用</strong></li>\n<li>若返回一个渲染函数：则可以自定义渲染内容</li>\n</ol>\n</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;info&quot;&gt;个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; import &#123;h&#125; from &#39;vue&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; &quot;张三&quot;\n    let age &#x3D; 18\n\n    &#x2F;&#x2F; 方法\n    function info() &#123;\n      alert(&#96;我叫$&#123;name&#125;, 年龄$&#123;age&#125;岁&#96;)\n    &#125;\n\n    &#x2F;&#x2F; 返回一个对象（常用）\n    return &#123;\n      name,\n      age,\n      info\n    &#125;\n    &#x2F;&#x2F;返回一个函数（渲染函数），需要导入 h\n    &#x2F;&#x2F; return ()&#x3D;&gt; h(&#39;h1&#39;,&#39;渲染&#39;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100029.png\"></p>\n<p><strong>1、尽量不要与 Vue2.x 配置混用</strong></p>\n<ul>\n<li>Vue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法</li>\n<li>但<strong>在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）</strong></li>\n<li>如果有重名，setup 优先</li>\n</ul>\n<p><strong>2、setup 不能是一个 async 函数，因为 async 的返回值不再是 return 的对象，而是被 promise 包起来的，模板看不到 return 对象中的属性</strong>（也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）</p>\n<h2 id=\"3-2-ref-函数\"><a href=\"#3-2-ref-函数\" class=\"headerlink\" title=\"3.2 ref 函数\"></a>3.2 ref 函数</h2><p>如下，通过函数修改个人信息</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; &quot;李四&quot;\n    let age &#x3D; 18\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      name &#x3D; &quot;张三&quot;\n      age &#x3D; 20\n      console.log(name + age);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>发现实际值已经修改了，但页面并没有响应改变</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100041.png\"></p>\n<p><strong>此时需要使用 ref 函数来定义响应的数据</strong></p>\n<ul>\n<li>作用：<strong>定义一个响应式的数据</strong></li>\n<li>语法：<code>const xxx = ref(initValue) </code><ul>\n<li>创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）</li>\n<li>JS 中操作数据： <code>xxx.value</code></li>\n<li>模板中读取数据: 不需要 <code>.value</code>，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code>，vue3 自动解析了</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; ref(&#39;李四&#39;)\n    let age &#x3D; ref(18)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      name.value &#x3D; &quot;张三&quot;\n      age.value &#x3D; 20\n      console.log(name, age);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>使用了 ref 函数的对象已经是一个 RefImpl 对象（Reference Implement）</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100054.png\"></p>\n<p>假如是对象类型的数据，此时 RefImpl 对象的 value 是一个 Proxy 对象</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; ref(&#39;李四&#39;)\n    let age &#x3D; ref(18)\n    let job &#x3D; ref(&#123;\n      type: &#39;开发&#39;,\n      salary: &#39;20k&#39;\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      job.value.type &#x3D; &#39;设计&#39;\n      job.value.salary &#x3D; &#39;25k&#39;\n      console.log(job);\n      console.log(job.value);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      job,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100111.png\"></p>\n<p>注意：</p>\n<ol>\n<li>接收的数据可以是：基本类型、也可以是对象类型</li>\n<li>基本类型的数据：响应式依然是靠 <code>Object.defineProperty()</code> 的 get 与 set 完成的</li>\n<li>对象类型的数据：内部 “ 求助 ” 了 Vue3.0 中的一个新函数—— reactive 函数</li>\n</ol>\n<h2 id=\"3-3-reactive-函数\"><a href=\"#3-3-reactive-函数\" class=\"headerlink\" title=\"3.3 reactive 函数\"></a>3.3 reactive 函数</h2><ul>\n<li>作用：定义一个对象类型的响应式数据（基本类型不要用它，要用 ref 函数）</li>\n<li>语法：<code>const 代理对象 = reactive(源对象)</code>，接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 Proxy 对象）</li>\n<li>reactive 定义的响应式数据是“深层次的”</li>\n<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作</li>\n</ul>\n<p>将 3.2 的对象类型示例修改一下，使用 reactive 来定义对象类型数据，如下：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;姓名：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; ref(&#39;李四&#39;)\n    let age &#x3D; ref(18)\n    &#x2F;&#x2F; let job &#x3D; ref(&#123;\n    &#x2F;&#x2F;   type: &#39;开发&#39;,\n    &#x2F;&#x2F;   salary: &#39;20k&#39;\n    &#x2F;&#x2F; &#125;)\n    let job &#x3D; reactive(&#123;\n      type: &#39;开发&#39;,\n      salary: &#39;20k&#39;\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      &#x2F;&#x2F; job.value.type &#x3D; &#39;设计&#39;\n      &#x2F;&#x2F; job.value.salary &#x3D; &#39;25k&#39;\n      job.type &#x3D; &#39;设计&#39;\n      job.salary &#x3D; &#39;25k&#39;\n      console.log(job);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      job,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100122.png\"></p>\n<p>同时还可以响应数组类型以及进行深层次的响应</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;person.job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;person.job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h1&gt;爱好：&#123;&#123;person.hobby&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;李四&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;20k&#39;\n      &#125;,\n      hobby: [&#39;看剧&#39;, &#39;听歌&#39;]\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      person.name &#x3D; &#39;张三&#39;\n      person.age &#x3D; 20\n      person.job.type &#x3D; &#39;设计&#39;\n      person.job.salary &#x3D; &#39;25k&#39;\n      person.hobby[0] &#x3D; &#39;学习&#39;\n    &#125;\n\n    return &#123;\n      person,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100136.png\"></p>\n<h2 id=\"3-4-Vue3-0-中的响应式原理\"><a href=\"#3-4-Vue3-0-中的响应式原理\" class=\"headerlink\" title=\"3.4 Vue3.0 中的响应式原理\"></a>3.4 Vue3.0 中的响应式原理</h2><h3 id=\"3-4-1-Vue2-x-的响应式\"><a href=\"#3-4-1-Vue2-x-的响应式\" class=\"headerlink\" title=\"3.4.1 Vue2.x 的响应式\"></a>3.4.1 Vue2.x 的响应式</h3><p>实现原理：</p>\n<ul>\n<li>对象类型：通过 <code>Object.defineProperty()</code> 对属性的读取、修改进行拦截（数据劫持），但对新增和删除无法响应式的改变<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.defineProperty(data, &#39;count&#39;, &#123;\n\tconfigurable: true, &#x2F;&#x2F; 可配置，即可删除属性\n    get () &#123; return ... &#125;, \n    set () &#123; 响应... &#125;\n&#125;)</code></pre></li>\n<li>数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹）</li>\n</ul>\n<p>存在问题：</p>\n<ul>\n<li>直接新增属性、删除属性，界面不会更新，需要调用对应的函数（set、delete）<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">methods: &#123;\n  addSex()&#123;\n    this.person.sex &#x3D; &#39;女&#39;; &#x2F;&#x2F; 不生效\n    this.$set(this.person, &#39;sex&#39;, &#39;女&#39;)\n    Vue.set(this.person, &#39;sex&#39;, &#39;女&#39;)\n  &#125;,\n  deleteName()&#123;\n    this.$delete(this.person, &#39;name&#39;, &#39;张三&#39;)\n    Vue.delete(this.person, &#39;name&#39;, &#39;张三&#39;)\n  &#125;\n&#125;,</code></pre></li>\n<li>直接通过下标修改数组，界面不会自动更新，同样可通过上面的方式修改，还可直接变更数组来修改<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">methods: &#123;\n\tupdateHobby()&#123;\n\t\tthis.person.hobby[0] &#x3D; &#39;学习&#39;; &#x2F;&#x2F; 不生效\n\t\tthis.$set(this.person.hobby, 0, &#39;学习&#39;)\n\t\tVue.delete(this.person.hobby, 0, &#39;学习&#39;)\n\t\tthis.person.hobby.splice(0, 1, &#39;学习&#39;)\n\t&#125;\n&#125;,</code></pre></li>\n</ul>\n<h3 id=\"3-4-2-Vue3-0-的响应式\"><a href=\"#3-4-2-Vue3-0-的响应式\" class=\"headerlink\" title=\"3.4.2 Vue3.0 的响应式\"></a>3.4.2 Vue3.0 的响应式</h3><p>实现原理:</p>\n<ul>\n<li><p>通过Proxy（代理）：拦截对象中任意属性的变化，包括属性值的读写、属性的添加、属性的删除等</p>\n</li>\n<li><p>通过Reflect（反射）：对源对象的属性进行操作</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let person &#x3D; &#123;\n      name: &#39;张三&#39;,\n      age: 18\n    &#125;\n\n    &#x2F;&#x2F; 模拟 Vue3中实现响应式\n    const p &#x3D; new Proxy(person, &#123;\n      &#x2F;&#x2F; 读取时调用\n      get(target, prop) &#123;\n        console.log(target, prop);\n        return target[prop]\n      &#125;,\n      &#x2F;&#x2F; 修改或新增时调用\n      set(target, prop, value) &#123;\n        console.log(target, prop, value);\n        target[prop] &#x3D; value;\n      &#125;,\n      &#x2F;&#x2F; 删除时调用\n      deleteProperty(target, prop) &#123;\n        console.log(target, prop);\n        return delete target[prop];\n      &#125;\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<p>对原对象的代理对象进行操作，而代理对象操作原对象</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100149.png\"></p>\n<p>可以把上述操作交给 Reflect 去执行</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">new Proxy(data, &#123;\n\t&#x2F;&#x2F; 拦截读取属性值\n    get (target, prop) &#123;\n    \treturn Reflect.get(target, prop)\n    &#125;,\n    &#x2F;&#x2F; 拦截设置属性值或添加新属性\n    set (target, prop, value) &#123;\n    \treturn Reflect.set(target, prop, value)\n    &#125;,\n    &#x2F;&#x2F; 拦截删除属性\n    deleteProperty (target, prop) &#123;\n    \treturn Reflect.deleteProperty(target, prop)\n    &#125;\n&#125;)\n\nproxy.name &#x3D; &#39;tom&#39;  </code></pre></li>\n<li><p>MDN 文档中描述的 Proxy 与 Reflect：</p>\n<ul>\n<li>Proxy：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Proxy</a></li>\n<li>Reflect：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Reflect</a></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1 v-show&#x3D;&quot;person.sex&quot;&gt;性别：&#123;&#123;person.sex&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;person.job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;person.job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;李四&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;20k&#39;\n      &#125;,\n      hobby: [&#39;看剧&#39;, &#39;听歌&#39;]\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      person.sex &#x3D; &#39;男&#39;\n      delete person.name\n      person.hobby[0] &#x3D; &#39;学习&#39;\n    &#125;\n\n    return &#123;\n      person,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100248.png\"></p>\n<h2 id=\"3-5-reactive-对比-ref\"><a href=\"#3-5-reactive-对比-ref\" class=\"headerlink\" title=\"3.5 reactive 对比 ref\"></a>3.5 reactive 对比 ref</h2><p><strong>1、 从定义数据角度对比</strong></p>\n<ul>\n<li>ref 用来定义：基本类型数据</li>\n<li>reactive 用来定义：对象（或数组）类型数据</li>\n<li>备注：ref 也可以用来定义对象（或数组）类型数据，它内部会自动通过 reactive 转为代理对象</li>\n</ul>\n<p><strong>2、从原理角度对比</strong></p>\n<ul>\n<li>ref 通过 <code>Object.defineProperty()</code> 的 get 与 set 来实现响应式（数据劫持）</li>\n<li>reactive 通过使用 Proxy 来实现响应式（数据劫持），并通过 Reflect 操作源对象内部的数据</li>\n</ul>\n<p><strong>3、从使用角度对比</strong></p>\n<ul>\n<li>ref 定义的数据：操作数据需要 <code>.value</code>，读取数据时模板中直接读取不需要 <code>.value</code></li>\n<li>reactive 定义的数据：操作数据与读取数据：均不需要 <code>.value</code></li>\n</ul>\n<h2 id=\"3-6-setup-的两个注意点\"><a href=\"#3-6-setup-的两个注意点\" class=\"headerlink\" title=\"3.6 setup 的两个注意点\"></a>3.6 setup 的两个注意点</h2><h3 id=\"3-6-1-setup-执行的时机\"><a href=\"#3-6-1-setup-执行的时机\" class=\"headerlink\" title=\"3.6.1 setup 执行的时机\"></a>3.6.1 setup 执行的时机</h3><p>在 beforeCreate 之前执行一次，this 是 undefined</p>\n<h3 id=\"3-6-2-setup-的参数\"><a href=\"#3-6-2-setup-的参数\" class=\"headerlink\" title=\"3.6.2 setup 的参数\"></a>3.6.2 setup 的参数</h3><ul>\n<li><p>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性<br>App.vue 组件，传值进 Demo.vue</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;Demo\n    msg&#x3D;&quot;你好&quot;\n    school&#x3D;&quot;无&quot;\n  &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Demo from &#39;.&#x2F;components&#x2F;Demo.vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Demo\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>Demo.vue 组件，接收 App.vue 传进来的值</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;个人信息&lt;&#x2F;h1&gt;\n  &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h2&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  props: [&#39;msg&#39;, &#39;school&#39;],\n  setup(props) &#123;\n    console.log(props);\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18\n    &#125;)\n\n    return &#123;\n      person\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100259.png\"></p>\n</li>\n<li><p>context：上下文对象</p>\n<ul>\n<li>attrs：值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 <code>this.$attrs</code></li>\n<li>slots：收到的插槽内容, 相当于 <code>this.$slots</code></li>\n<li>emit：分发自定义事件的函数, 相当于 <code>this.$emit</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>App.vue，传值进 Demo.vue，同时传入自定义事件以及插槽</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;Demo\n    msg&#x3D;&quot;你好&quot;\n    school&#x3D;&quot;无&quot;\n    @hello&#x3D;&quot;showMsg&quot;\n  &gt;\n    &lt;template v-slot:te&gt;\n      &lt;span&gt;测试&lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;Demo&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Demo from &#39;.&#x2F;components&#x2F;Demo.vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    function showMsg(value) &#123;\n      alert(&#96;触发，参数是$&#123;value&#125;&#96;)\n    &#125;\n\n    return &#123;\n      showMsg\n    &#125;\n  &#125;,\n  components: &#123;\n    Demo\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>Demo.vue 组件，props 接收 App.vue 传进来的值，未接收的值在 attrs 里，emits 接收自定义事件，假如未写接收会报警告，但不影响使用，emit 触发 App.vue 里的自定义事件。插槽直接使用</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;个人信息&lt;&#x2F;h1&gt;\n  &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;hello&quot;&gt;测试触发事件&lt;&#x2F;button&gt;\n  &lt;slot name&#x3D;&quot;te&quot;&gt;&lt;&#x2F;slot&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  props: [&#39;msg&#39;],\n  emits: [&#39;hello&#39;],\n  setup(props, context) &#123;\n    console.log(props);\n    console.log(context.attrs);\n    console.log(context.emit);\n    console.log(context.slots);\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18\n    &#125;)\n    &#x2F;&#x2F; 方法\n    function hello() &#123;\n      context.emit(&#39;hello&#39;, 666);\n    &#125;\n\n    return &#123;\n      person,\n      hello\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100310.png\"></p>\n<h2 id=\"3-7-计算属性与监视\"><a href=\"#3-7-计算属性与监视\" class=\"headerlink\" title=\"3.7 计算属性与监视\"></a>3.7 计算属性与监视</h2><h3 id=\"3-7-1-computed-函数（计算属性）\"><a href=\"#3-7-1-computed-函数（计算属性）\" class=\"headerlink\" title=\"3.7.1 computed 函数（计算属性）\"></a>3.7.1 computed 函数（计算属性）</h3><p><strong>第一种写法：与 Vue2.x 中 computed 配置功能一致</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\nimport &#123; reactive, computed &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  computed: &#123;\n    fullName() &#123;\n      return this.person.firstName + &#39;-&#39; + this.person.lastName;\n    &#125;\n  &#125;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      firstName: &#39;张&#39;,\n      lastName: &#39;三&#39;,\n    &#125;)\n\n    return &#123;\n      person,\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>第二种写法，如下：</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;个人信息&lt;&#x2F;h1&gt;\n  姓：&lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;person.firstName&quot;\n  &#x2F;&gt; &lt;br&gt;\n  名：&lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;person.lastName&quot;\n  &#x2F;&gt; &lt;br&gt;\n  &lt;span&gt;全名： &#123;&#123;person.fullName&#125;&#125; &lt;&#x2F;span&gt; &lt;br&gt;\n  全名：&lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;person.fullName&quot;\n  &gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, computed &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      firstName: &#39;张&#39;,\n      lastName: &#39;三&#39;,\n    &#125;)\n    &#x2F;&#x2F; 计算属性-简写（只读，不考虑计算属性被修改的情况）\n    person.fullName &#x3D; computed(() &#x3D;&gt; &#123;\n      return person.firstName + &#39;-&#39; + person.lastName;\n    &#125;)\n\n    &#x2F;&#x2F; 计算属性-完整写法（考虑读和写）\n    person.fullName &#x3D; computed(&#123;\n      get() &#123;\n        return person.firstName + &#39;-&#39; + person.lastName;\n      &#125;,\n      set(value) &#123;\n        let nameArr &#x3D; value.split(&#39;-&#39;);\n        person.firstName &#x3D; nameArr[0]\n        person.lastName &#x3D; nameArr[1]\n      &#125;\n    &#125;)\n\n    return &#123;\n      person,\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100320.png\"></p>\n<h3 id=\"3-7-2-watch-函数（监视）\"><a href=\"#3-7-2-watch-函数（监视）\" class=\"headerlink\" title=\"3.7.2 watch 函数（监视）\"></a>3.7.2 watch 函数（监视）</h3><p><strong>第一种写法：与 Vue2.x 中 computed 配置功能一致</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  watch: &#123;\n    sum(newValue, oldValue) &#123;\n      console.log(&#39;sum 的值变化了&#39;, newValue, oldValue);\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; watch: &#123;\n  &#x2F;&#x2F;   sum: &#123;\n  &#x2F;&#x2F;     immediate: true, &#x2F;&#x2F; 立即监视，一进来就会监视一下\n  &#x2F;&#x2F;     deep: true,\n  &#x2F;&#x2F;     handler(newValue, oldValue) &#123;\n  &#x2F;&#x2F;       console.log(&#39;sum 的值变化了&#39;, newValue, oldValue);\n  &#x2F;&#x2F;     &#125;\n  &#x2F;&#x2F;   &#125;\n  &#x2F;&#x2F; &#125;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let sum &#x3D; ref(0)\n\n    return &#123;\n      sum,\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100329.png\"></p>\n<p><strong>第二种写法，如下：</strong></p>\n<p><strong>1、监视 ref 定义的数据</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;当前求和为：&#123;&#123;sum&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;sum++&quot;&gt;点击 + 1&lt;&#x2F;button&gt;\n  &lt;hr&gt;\n  &lt;h1&gt;当前信息为：&#123;&#123;msg&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;msg +&#x3D; &#39;!&#39;&quot;&gt;修改信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref, watch &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let sum &#x3D; ref(0)\n    let msg &#x3D; ref(&#39;你好&#39;)\n\n    &#x2F;&#x2F; 情况一，监视 ref 所定义的一个响应式数据\n    &#x2F;&#x2F; watch(sum, (newValue, oldValue) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(&#39;sum 变了&#39;, newValue, oldValue);\n    &#x2F;&#x2F; &#125;, &#123;immediate: true, deep: true&#125;)\n\n    &#x2F;&#x2F; 情况二，监视 ref 所定义的多个响应式数据\n    watch([sum, msg], (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(newValue, oldValue);\n    &#125;, &#123; immediate: true, deep: true &#125;)\n\n    return &#123;\n      sum,\n      msg\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100338.png\"></p>\n<p><strong>2、监视 reactive 定义的数据</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;当前姓名为：&#123;&#123;person.name&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;person.name +&#x3D; &#39;~&#39;&quot;&gt;修改姓名&lt;&#x2F;button&gt;\n  &lt;hr&gt;\n  &lt;h1&gt;当前年龄为：&#123;&#123;person.age&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;person.age ++&quot;&gt;修改年龄&lt;&#x2F;button&gt;\n  &lt;hr&gt;\n  &lt;h2&gt;职业：&#123;&#123;person.job.type&#125;&#125; &lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪酬：&#123;&#123;person.job.salary&#125;&#125; &lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;person.job.type +&#x3D; &#39;!&#39;&quot;&gt;修改职业&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, watch &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;25k&#39;\n      &#125;\n    &#125;)\n\n    &#x2F;&#x2F; 情况一，监视 reactive 所定义的一个响应式数据的全部属性\n    &#x2F;&#x2F;      watch 监视的是 reactive 定义的响应式数据，则无法正确获得 oldValue！！\n    &#x2F;&#x2F;      若watch 监视的是 reactive 定义的响应式数据，则强制开启了深度监视（deep 配置无效）\n    &#x2F;&#x2F; watch(person, (newValue, oldValue) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(&#39;person变化&#39;, newValue, oldValue);\n    &#x2F;&#x2F; &#125;, &#123; deep: false &#125;)\n\n    &#x2F;&#x2F; 情况二：监视 reactive 所定义的一个响应式数据的某个属性\n    &#x2F;&#x2F; watch(() &#x3D;&gt; person.age, (newValue, oldValue) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(&#39;person 的age 变化了&#39;, newValue, oldValue);\n    &#x2F;&#x2F; &#125;)\n\n    &#x2F;&#x2F; 情况三：监视 reactive 所定义的一个响应式数据的某些属性\n    watch([() &#x3D;&gt; person.age, () &#x3D;&gt; person.name], (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(&#39;person 的age 变化了&#39;, newValue, oldValue);\n    &#125;)\n\n    &#x2F;&#x2F; 特殊情况：监视的是 reactive 定义的属性中的某个对象属性，所以 deep 配置有效\n    watch(() &#x3D;&gt; person.job, (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(&#39;person 的age 变化了&#39;, newValue, oldValue);\n    &#125;, &#123; deep: true &#125;)\n\n\n    return &#123;\n      person\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100349.png\"></p>\n<h3 id=\"3-7-2-watchEffect-函数\"><a href=\"#3-7-2-watchEffect-函数\" class=\"headerlink\" title=\"3.7.2 watchEffect 函数\"></a>3.7.2 watchEffect 函数</h3><ul>\n<li>watch 的套路是：既要指明监视的属性，也要指明监视的回调</li>\n<li>watchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性</li>\n<li>watchEffect 有点像 computed：<ul>\n<li>但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值</li>\n<li>而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\nimport &#123; reactive, watchEffect &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let sum &#x3D; ref(0)\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;25k&#39;\n      &#125;\n    &#125;)\n\n    &#x2F;&#x2F; watchEffect 所指定的回调中用到的数据只要发生变化，则直接重新执行回调\n    watchEffect(() &#x3D;&gt; &#123;\n      const x1 &#x3D; person.name\n      const x2 &#x3D; person.job.type\n      console.log(&#39;watchEffect 配置的回调执行了&#39;);\n    &#125;)\n\n    return &#123;\n      person\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"3-8-生命周期\"><a href=\"#3-8-生命周期\" class=\"headerlink\" title=\"3.8 生命周期\"></a>3.8 生命周期</h2><p><img src=\"http://img.fan223.cn/2023/04/20230419100358.png\"></p>\n<p>Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有两个被更名：</p>\n<ul>\n<li>beforeDestroy 改名为 beforeUnmount</li>\n<li>destroyed 改名为 unmounted</li>\n</ul>\n<p><strong>App.vue</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;button @click&#x3D;&quot;isShowDemo &#x3D; !isShowDemo&quot;&gt;显示&#x2F;隐藏Demo&lt;&#x2F;button&gt;\n  &lt;Demo v-if&#x3D;&quot;isShowDemo&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Demo from &#39;.&#x2F;components&#x2F;Demo.vue&#39;;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    let isShowDemo &#x3D; ref(true)\n\n    return &#123;\n      isShowDemo\n    &#125;\n  &#125;,\n  components: &#123;\n    Demo\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>Demo.vue</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;Demo&lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  beforeCreate() &#123;\n    console.log(&#39;---beforeCreate---&#39;);\n  &#125;,\n  created() &#123;\n    console.log(&#39;---created---&#39;);\n  &#125;,\n  beforeMount() &#123;\n    console.log(&#39;---beforeMount---&#39;);\n  &#125;,\n  mounted() &#123;\n    console.log(&#39;---mounted---&#39;);\n  &#125;,\n  beforeUnmount() &#123;\n    console.log(&#39;---beforeUnmount---&#39;);\n  &#125;,\n  unmounted() &#123;\n    console.log(&#39;---unmounted--&#39;);\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100415.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100424.png\"></p>\n<p>Vue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：</p>\n<ul>\n<li>beforeCreate &#x3D;&#x3D;&#x3D;&gt; <code>setup()</code></li>\n<li>created &#x3D;&#x3D;&#x3D;&gt; <code>setup()</code></li>\n<li>beforeMount &#x3D;&#x3D;&#x3D;&gt; onBeforeMount</li>\n<li>mounted &#x3D;&#x3D;&#x3D;&gt; onMounted</li>\n<li>beforeUpdate &#x3D;&#x3D;&#x3D;&gt; onBeforeUpdate</li>\n<li>updated &#x3D;&#x3D;&#x3D;&gt; onUpdated</li>\n<li>beforeUnmount &#x3D;&#x3D;&gt; onBeforeUnmount</li>\n<li>unmounted &#x3D;&#x3D;&#x3D;&gt; onUnmounted</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;Demo&lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    console.log(&#39;---setup()---&#39;);\n\n    onBeforeMount(() &#x3D;&gt; &#123;\n      console.log(&#39;---onBeforeMount---&#39;)\n    &#125;)\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;---onMounted---&#39;);\n    &#125;)\n    onBeforeUpdate(() &#x3D;&gt; &#123;\n      console.log(&#39;---onBeforeUpdate---&#39;);\n    &#125;)\n    onUpdated(() &#x3D;&gt; &#123;\n      console.log(&#39;---onUpdated---&#39;);\n    &#125;)\n    onBeforeUnmount(() &#x3D;&gt; &#123;\n      console.log(&#39;---onBeforeUnmount---&#39;);\n    &#125;)\n    onUnmounted(() &#x3D;&gt; &#123;\n      console.log(&#39;---onUnmounted---&#39;);\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100439.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100450.png\"></p>\n<h2 id=\"3-9-自定义-hook-函数\"><a href=\"#3-9-自定义-hook-函数\" class=\"headerlink\" title=\"3.9 自定义 hook 函数\"></a>3.9 自定义 hook 函数</h2><p>hook 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。类似于 Vue2.x中的 mixin。可以复用代码，让 setup 中的逻辑更清楚易懂</p>\n<p>如下，获取当前鼠标的位置</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;当前点击时鼠标的坐标为：X：&#123;&#123;point.x&#125;&#125;，y：&#123;&#123;point.y&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, onMounted &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let point &#x3D; reactive(&#123;\n      x: 0,\n      y: 0\n    &#125;)\n\n    onMounted(() &#x3D;&gt; &#123;\n      window.addEventListener(&#39;click&#39;, (event) &#x3D;&gt; &#123;\n        point.x &#x3D; event.pageX\n        point.y &#x3D; event.pageY\n      &#125;)\n    &#125;)\n\n    return &#123;\n      point\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100702.png\"></p>\n<p>此时给 window 加了一个点击事件，只要点击页面就会获取页面的鼠标位置给 point，假如该组件卸载了，也还是会触发</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100715.png\"></p>\n<p>可以在组件卸载后，移除该点击事件。移除事件时需要传入移除的是哪个事件，所以将该点击事件单独写成一个函数</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\nimport &#123; reactive, onMounted, onBeforeUnmount &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let point &#x3D; reactive(&#123;\n      x: 0,\n      y: 0\n    &#125;)\n\n    function savePoint(event) &#123;\n      point.x &#x3D; event.pageX\n      point.y &#x3D; event.pageY\n\n      console.log(point.x, point.y);\n    &#125;\n\n    onMounted(() &#x3D;&gt; &#123;\n      window.addEventListener(&#39;click&#39;, savePoint)\n    &#125;)\n    onBeforeUnmount(() &#x3D;&gt; &#123;\n      window.removeEventListener(&#39;click&#39;, savePoint)\n    &#125;)\n\n    return &#123;\n      point\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>假如有另一个组件也想用该功能，复用这块代码，就可以将该功能相关的数据和函数抽离出来，形成一个 hook 函数</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100729.png\"></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; reactive, onMounted, onBeforeUnmount&#125; from &#39;vue&#39;;\n\nexport default function() &#123;\n  let point &#x3D; reactive(&#123;\n    x: 0,\n    y: 0\n  &#125;)\n\n  function savePoint(event) &#123;\n    point.x &#x3D; event.pageX\n    point.y &#x3D; event.pageY\n\n    console.log(point.x, point.y);\n  &#125;\n\n  onMounted(() &#x3D;&gt; &#123;\n    window.addEventListener(&#39;click&#39;, savePoint)\n  &#125;)\n  onBeforeUnmount(() &#x3D;&gt; &#123;\n    window.removeEventListener(&#39;click&#39;, savePoint)\n  &#125;)\n\n  return point\n&#125;</code></pre>\n\n<p>使用时引入即可</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;当前点击时鼠标的坐标为：X：&#123;&#123;point.x&#125;&#125;，y：&#123;&#123;point.y&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport usePoint from &#39;..&#x2F;hooks&#x2F;usePoint&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let point &#x3D; usePoint()\n\n    return &#123;\n      point\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100742.png\"></p>\n<h2 id=\"3-10-toRef\"><a href=\"#3-10-toRef\" class=\"headerlink\" title=\"3.10 toRef\"></a>3.10 toRef</h2><p>创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。</p>\n<ul>\n<li>语法：<code>const name = toRef(person, &#39;name&#39;)</code></li>\n</ul>\n<p>用于要将响应式对象中的某个属性单独提供给外部使用时，如下，将 person 对象里的name、age 等属性单独提供给外部使用</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;姓名： &#123;&#123;name&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄： &#123;&#123;age&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;h1&gt;薪资： &#123;&#123;salary&#125;&#125; &lt;&#x2F;h1&gt;\n\n  &lt;button @click&#x3D;&quot;name +&#x3D; &#39;~&#39;&quot;&gt;修改姓名&lt;&#x2F;button&gt;\n  &lt;button @click&#x3D;&quot;age ++&quot;&gt;修改年龄&lt;&#x2F;button&gt;\n  &lt;button @click&#x3D;&quot;salary ++&quot;&gt;修改薪资&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, toRef &#125; from &#39;@vue&#x2F;reactivity&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18,\n      job: &#123;\n        j1: &#123;\n          salary: 20\n        &#125;\n      &#125;\n    &#125;)\n\n    return &#123;\n      &#x2F;&#x2F; name: ref(person, &#39;name&#39;)\n      name: toRef(person, &#39;name&#39;),\n      age: toRef(person, &#39;age&#39;),\n      salary: toRef(person.job.j1, &#39;salary&#39;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100752.png\"></p>\n<p>具有响应式效果，且此时 toRef 这里操纵的数据，就是原先的 person对象里的数据，修改即同步修改 person 对象里的对应的值</p>\n<p>假如直接使用 ref 来转换，如：<code>ref(person.name)</code>，操纵的是这个用 person 对象的 name 属性值新建的 ref 对象，而不再与原本的 person 对象的 name 有联系</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100810.png\"></p>\n<p>toRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，即把整个对象都抛出去，语法：<code>toRefs(person)</code>，但只能定位到第外层的属性</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;h1&gt;姓名： &#123;&#123;name&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;h1&gt;年龄： &#123;&#123;age&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;h1&gt;薪资： &#123;&#123;job.j1.salary&#125;&#125; &lt;&#x2F;h1&gt;\n  \n...toRefs(person)\n&#x2F;&#x2F; name: toRef(person, &#39;name&#39;),\n&#x2F;&#x2F; age: toRef(person, &#39;age&#39;),\n&#x2F;&#x2F; salary: toRef(person.job.j1, &#39;salary&#39;)</code></pre>\n\n<h1 id=\"4-其它-Composition-API\"><a href=\"#4-其它-Composition-API\" class=\"headerlink\" title=\"4. 其它 Composition API\"></a>4. 其它 Composition API</h1><h2 id=\"4-1-shallowReactive-与-shallowRef\"><a href=\"#4-1-shallowReactive-与-shallowRef\" class=\"headerlink\" title=\"4.1 shallowReactive 与 shallowRef\"></a>4.1 shallowReactive 与 shallowRef</h2><ul>\n<li><strong>shallowReactive：只处理对象最外层属性的响应式（浅响应式）</strong></li>\n<li><strong>shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理</strong></li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let person &#x3D; shallowReactive (&#123;\n\tname: &#39;张三&#39;,\n\tage: 18,\n\tjob: &#123;\n\t\tj1: &#123;\n\t\t\tsalary: 20\n\t\t&#125;\n\t&#125;\n&#125;)</code></pre>\n\n<p>什么时候使用?</p>\n<ul>\n<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive</li>\n<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef</li>\n</ul>\n<h2 id=\"4-2-readonly-与-shallowReadonly\"><a href=\"#4-2-readonly-与-shallowReadonly\" class=\"headerlink\" title=\"4.2 readonly 与 shallowReadonly\"></a>4.2 readonly 与 shallowReadonly</h2><ul>\n<li>readonly：让一个响应式数据变为只读的（深只读）</li>\n<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">let person &#x3D; reactive (&#123;\n\tname: &#39;张三&#39;,\n\tage: 18,\n\tjob: &#123;\n\t\tj1: &#123;\n\t\t\tsalary: 20\n\t\t&#125;\n\t&#125;\n&#125;)\n\nperson &#x3D; readonly(person)</code></pre>\n\n<p>应用于不希望数据被修改时</p>\n<h2 id=\"4-3-toRaw-与-markRaw\"><a href=\"#4-3-toRaw-与-markRaw\" class=\"headerlink\" title=\"4.3 toRaw 与 markRaw\"></a>4.3 toRaw 与 markRaw</h2><p><strong>toRaw</strong></p>\n<ul>\n<li>作用：将一个由 reactive 生成的响应式对象转为普通对象</li>\n</ul>\n<p>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const p &#x3D; toRaw(person)</code></pre>\n\n<p><strong>markRaw</strong></p>\n<ul>\n<li>作用：标记一个对象，使其永远不会再成为响应式对象</li>\n</ul>\n<p>应用场景：</p>\n<ol>\n<li>有些值不应被设置为响应式的，例如复杂的第三方类库等</li>\n<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">person.car &#x3D; markRaw(person)</code></pre>\n\n<h2 id=\"4-4-customRef\"><a href=\"#4-4-customRef\" class=\"headerlink\" title=\"4.4 customRef\"></a>4.4 customRef</h2><p>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制<br>如下例，实现防抖效果</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;keyWord&quot;\n  &#x2F;&gt;\n  &lt;h1&gt; &#123;&#123;keyWord&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; customRef &#125; from &#39;vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 自定义一个 ref\n    function myRef(value, delay) &#123;\n      let timer;\n\n      return customRef((track, trigger) &#x3D;&gt; &#123;\n        return &#123;\n          get() &#123;\n            &#x2F;&#x2F; 通知 Vue 追踪数据变化（提前约定）\n            track();\n            return value;\n          &#125;,\n          set(newValue) &#123;\n            value &#x3D; newValue;\n            clearTimeout(timer);\n\n            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n              &#x2F;&#x2F; 通知 Vue 去重新解析模板（调用一下 get() 方法）\n              trigger();\n            &#125;, delay);\n          &#125;\n        &#125;\n      &#125;)\n    &#125;\n\n    &#x2F;&#x2F; let keyWord &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F; 使用 Vue 提供的 ref\n    let keyWord &#x3D; myRef(&#39;hello&#39;, &#39;500&#39;) &#x2F;&#x2F; 使用自定义的 ref\n\n    return &#123;\n      keyWord,\n      myRef\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100827.png\"></p>\n<h2 id=\"4-5-provide-与-inject\"><a href=\"#4-5-provide-与-inject\" class=\"headerlink\" title=\"4.5 provide 与 inject\"></a>4.5 provide 与 inject</h2><p><img src=\"http://img.fan223.cn/2023/04/20230419100839.png\"></p>\n<p><strong>实现祖与后代组件间通信</strong>，父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据</p>\n<p><strong>如下，祖组件 App.vue</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖），&#123;&#123;name&#125;&#125;---&#123;&#123;price&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;Child &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, toRefs &#125; from &#39;@vue&#x2F;reactivity&#39;\nimport Child from &#39;.&#x2F;components&#x2F;Child.vue&#39;\nimport &#123; provide &#125; from &#39;@vue&#x2F;runtime-core&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    let car &#x3D; reactive(&#123;\n      name: &#39;奔驰&#39;,\n      price: &#39;40w&#39;\n    &#125;)\n\n    provide(&#39;car&#39;, car)\n\n    return &#123;\n      ...toRefs(car)\n    &#125;\n  &#125;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>子组件，Child.vue</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;child&quot;&gt;\n    &lt;h1&gt; Child组件（子）&lt;&#x2F;h1&gt;\n    &lt;Son &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Son from &#39;.&#x2F;Son.vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Child&#39;,\n  components: &#123;\n    Son\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>孙组件，Son.vue</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;son&quot;&gt;\n    &lt;h1&gt; Son组件（孙），&#123;&#123;car.name&#125;&#125;---&#123;&#123;car.price&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; inject &#125; from &#39;@vue&#x2F;runtime-core&#39;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Son&#39;,\n  setup() &#123;\n    let car &#x3D; inject(&#39;car&#39;)\n\n    return &#123;\n      car\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100856.png\"></p>\n<h2 id=\"4-6-响应式数据的判断\"><a href=\"#4-6-响应式数据的判断\" class=\"headerlink\" title=\"4.6 响应式数据的判断\"></a>4.6 响应式数据的判断</h2><ul>\n<li><strong>isRef</strong>：检查一个值是否为一个 ref 对象</li>\n<li><strong>isReactive</strong>：检查一个对象是否是由 reactive 创建的响应式代理</li>\n<li><strong>isReadonly</strong>：检查一个对象是否是由 readonly 创建的只读代理</li>\n<li><strong>isProxy</strong>：检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let car &#x3D; reactive(&#123;name: &#39;奔驰&#39;, price: &#39;40w&#39;&#125;)\nlet sum &#x3D; ref(0)\nlet car2 &#x3D; readonly(car)\n\nconsole.log(isReactive(car))\nconsole.log(isRef(sum))\nconsole.log(isReadonly(car2))\nconsole.log(isReadonly(isProxy))</code></pre>\n\n<h1 id=\"5-Composition-API-的优势\"><a href=\"#5-Composition-API-的优势\" class=\"headerlink\" title=\"5. Composition API 的优势\"></a>5. Composition API 的优势</h1><h2 id=\"5-1-Options-API-存在的问题\"><a href=\"#5-1-Options-API-存在的问题\" class=\"headerlink\" title=\"5.1 Options API 存在的问题\"></a>5.1 Options API 存在的问题</h2><p>Vue2 使用的传统 Options API 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100866.gif\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100868.gif\"></p>\n<h2 id=\"5-2-Composition-API-的优势\"><a href=\"#5-2-Composition-API-的优势\" class=\"headerlink\" title=\"5.2 Composition API 的优势\"></a>5.2 Composition API 的优势</h2><p>可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100872.gif\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100875.gif\"></p>\n<h1 id=\"6-新的组件\"><a href=\"#6-新的组件\" class=\"headerlink\" title=\"6. 新的组件\"></a>6. 新的组件</h1><h2 id=\"6-1-Fragment\"><a href=\"#6-1-Fragment\" class=\"headerlink\" title=\"6.1 Fragment\"></a>6.1 Fragment</h2><p>在 Vue2 中：组件必须有一个根标签。在 Vue3 中：组件可以没有根标签，内部会将多个标签包含在一个 Fragment 虚拟元素中，可以减少标签层级, 减小内存占用</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;h1&gt;111&lt;&#x2F;h1&gt;\n  &lt;h1&gt;222&lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419101251.png\"></p>\n<h2 id=\"6-2-Teleport\"><a href=\"#6-2-Teleport\" class=\"headerlink\" title=\"6.2 Teleport\"></a>6.2 Teleport</h2><p><strong>能够将组件 html 结构移动到指定位置</strong><br>如下，直接打开弹窗会撑开组件及其父组件的高度</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419101300.png\"></p>\n<p><strong>组件 Son.vue</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;son&quot;&gt;\n    &lt;h1&gt; Son 组件（孙）&lt;&#x2F;h1&gt;\n    &lt;Dialog &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Dialog from &#39;.&#x2F;Dialog.vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Son&#39;,\n  components: &#123;\n    Dialog\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><strong>组件 Dialog.vue</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;button @click&#x3D;&quot;isShow &#x3D; true&quot;&gt; 点击弹窗 &lt;&#x2F;button&gt;\n  &lt;div\n    v-if&#x3D;&quot;isShow&quot;\n    class&#x3D;&quot;dialog&quot;\n  &gt;\n    &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n    &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n    &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n    &lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;@vue&#x2F;reactivity&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Dialog&#39;,\n  setup() &#123;\n    let isShow &#x3D; ref(false);\n\n    return &#123;\n      isShow\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>利用 Teleport 将弹窗移动到 body 上</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;button @click&#x3D;&quot;isShow &#x3D; true&quot;&gt; 点击弹窗 &lt;&#x2F;button&gt;\n  &lt;teleport to&#x3D;&#39;body&#39;&gt;\n    &lt;div\n      v-if&#x3D;&quot;isShow&quot;\n      class&#x3D;&quot;mask&quot;\n    &gt;\n      &lt;div class&#x3D;&quot;dialog&quot;&gt;\n        &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n        &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n        &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n        &lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;teleport&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;@vue&#x2F;reactivity&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Dialog&#39;,\n  setup() &#123;\n    let isShow &#x3D; ref(false);\n\n    return &#123;\n      isShow\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.mask &#123;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n&#125;\n.dialog &#123;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  text-align: center;\n  background-color: green;\n  width: 300px;\n  height: 300px;\n&#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419101317.png\"></p>\n<h2 id=\"6-3-Suspense\"><a href=\"#6-3-Suspense\" class=\"headerlink\" title=\"6.3 Suspense\"></a>6.3 Suspense</h2><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验<br><strong>静态引入</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖）&lt;&#x2F;h1&gt;\n    &lt;Child &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Child from &#39;.&#x2F;components&#x2F;Child.vue&#39; &#x2F;&#x2F; 静态引入\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>将网速调慢，祖组件和后代组件是一起出来的</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100879.gif\"></p>\n<p><strong>异步引入</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖）&lt;&#x2F;h1&gt;\n    &lt;Child &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; import Child from &#39;.&#x2F;components&#x2F;Child.vue&#39; &#x2F;&#x2F;静态引入\nimport &#123; defineAsyncComponent &#125; from &#39;@vue&#x2F;runtime-core&#39; &#x2F;&#x2F; 静态引入\nconst Child &#x3D; defineAsyncComponent(() &#x3D;&gt; import(&#39;.&#x2F;components&#x2F;Child.vue&#39;)) &#x2F;&#x2F; 异步引入\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>网速慢的情况下，会先出现祖组件，再出现后代组件</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100880.gif\"></p>\n<p>此时有个问题，假如 Child 组件没有加载出来，其所在的位置是空的，并不知道到底有没有内容。使用 Suspense 解决如下：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖）&lt;&#x2F;h1&gt;\n    &lt;Suspense&gt;\n      &lt;template v-slot:default&gt;\n        &lt;Child &#x2F;&gt;\n      &lt;&#x2F;template&gt;\n      &lt;template v-slot:fallback&gt;\n        &lt;h3&gt;稍等，加载中...&lt;&#x2F;h3&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Suspense&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; import Child from &#39;.&#x2F;components&#x2F;Child.vue&#39; &#x2F;&#x2F;静态引入\nimport &#123; defineAsyncComponent &#125; from &#39;@vue&#x2F;runtime-core&#39; &#x2F;&#x2F; 静态引入\nconst Child &#x3D; defineAsyncComponent(() &#x3D;&gt; import(&#39;.&#x2F;components&#x2F;Child.vue&#39;)) &#x2F;&#x2F; 异步引入\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100883.gif\"></p>\n<p>使用了异步引入后，该组件是一个异步组件，则 <code>setup()</code> 可以用 async 修一个异步函数</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Child&#39;,\n  async setup() &#123;\n    let sum &#x3D; ref(0)\n\n    let p &#x3D; new Promise((resove, reject) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        resove(sum)\n      &#125;, 3000);\n    &#125;)\n\n    return await p;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>之前是通过把网速调慢来实现等待 Child 组件出现的效果，使用异步函数之后，网速正常也能让 Child 组件等待后才出现</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419100887.gif\"></p>\n<h1 id=\"7-其他变化\"><a href=\"#7-其他变化\" class=\"headerlink\" title=\"7. 其他变化\"></a>7. 其他变化</h1><h2 id=\"7-1-全局-API-的转移\"><a href=\"#7-1-全局-API-的转移\" class=\"headerlink\" title=\"7.1 全局 API 的转移\"></a>7.1 全局 API 的转移</h2><p>Vue 2.x 有许多全局 API 和配置，例如：注册全局组件、注册全局指令等</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;注册全局组件\nVue.component(&#39;MyButton&#39;, &#123;\n  data: () &#x3D;&gt; (&#123;\n    count: 0\n  &#125;),\n  template: &#39;&lt;button @click&#x3D;&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;&#x2F;button&gt;&#39;\n&#125;)\n\n&#x2F;&#x2F;注册全局指令\nVue.directive(&#39;focus&#39;, &#123;\n  inserted: el &#x3D;&gt; el.focus()\n&#125;</code></pre>\n\n<p>Vue3.0 中对这些 API 做出了调整，将全局的 API，即：Vue.xxx 调整到应用实例（app）上</p>\n<table>\n<thead>\n<tr>\n<th>2.x 全局 API（Vue）</th>\n<th>3.x 实例 API (app)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>app.config.xxxx</td>\n<td>app.config.xxxx</td>\n</tr>\n<tr>\n<td>Vue.config.productionTip</td>\n<td>移除</td>\n</tr>\n<tr>\n<td>Vue.component</td>\n<td>app.component</td>\n</tr>\n<tr>\n<td>Vue.directive</td>\n<td>app.directive</td>\n</tr>\n<tr>\n<td>Vue.mixin</td>\n<td>app.mixin</td>\n</tr>\n<tr>\n<td>Vue.use</td>\n<td>app.use</td>\n</tr>\n<tr>\n<td>Vue.prototype</td>\n<td>app.config.globalProperties</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-2-其他改变\"><a href=\"#7-2-其他改变\" class=\"headerlink\" title=\"7.2 其他改变\"></a>7.2 其他改变</h2><ul>\n<li><strong>data 选项应始终被声明为一个函数</strong><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; data &#123; &#125; \ndata() &#123; &#125;</code></pre></li>\n<li><strong>过度类名的更改：</strong><ul>\n<li>Vue2.x 写法<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.v-enter,\n.v-leave-to &#123;\n  opacity: 0;\n&#125;\n.v-leave,\n.v-enter-to &#123;\n  opacity: 1;\n&#125;</code></pre></li>\n<li>Vue3.x 写法<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.v-enter-from,\n.v-leave-to &#123;\n  opacity: 0;\n&#125;\n\n.v-leave-from,\n.v-enter-to &#123;\n  opacity: 1;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><strong>移除 keyCode 作为 v-on 的修饰符，同时也不再支持 config.keyCodes</strong><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; @keyup.13\n&#x2F;&#x2F; Vue.config.keyCodes.enter &#x3D; 13</code></pre></li>\n<li><strong>移除 v-on.native 修饰符</strong>，给组件传递事件时，Vue2 会将 click 事件也认为是自定义事件，需要加 native 来表示是原生事件。Vue3 则用 emit 来指定自定义事件，没有指定的就是原生事件<ul>\n<li>父组件中绑定事件<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;my-component\n  v-on:close&#x3D;&quot;handleComponentEvent&quot;\n  v-on:click&#x3D;&quot;handleNativeClickEvent&quot;\n&#x2F;&gt;</code></pre></li>\n<li>子组件中声明自定义事件<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&lt;script&gt;\n  export default &#123;\n    emits: [&#39;close&#39;]\n  &#125;\n&lt;&#x2F;script&gt;</code></pre></li>\n</ul>\n</li>\n<li><strong>移除过滤器（filter）</strong><br>过滤器虽然看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器</li>\n<li>……</li>\n</ul>\n","feature":false,"text":"Vue2 基础见：Vue2 总结（基础）_凡 223 的博客 Vue2 开发见：Vue2 总结（开发）_凡 223 的博客 1. 简介 性能的提升 打包大小减少41% 初次渲染快55%，更新渲染快133% 内存减少54%…… 源码的升级 使用Proxy代替defineProper...","link":"","photos":[],"count_time":{"symbolsCount":"42k","symbolsTime":"38 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1. 简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2. 创建使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E4%BD%BF%E7%94%A8-vue-cli-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">2.1 使用 vue-cli 创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E4%BD%BF%E7%94%A8-vite-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">2.2 使用 vite 创建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-main-js-%E6%94%B9%E5%8A%A8\"><span class=\"toc-text\">2.3 main.js 改动</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-App-vue-%E6%94%B9%E5%8A%A8\"><span class=\"toc-text\">2.4 App.vue 改动</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-Vue3-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">2.5 Vue3 开发者工具</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E7%94%A8-Composition-API\"><span class=\"toc-text\">3. 常用 Composition API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-setup-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.1 setup 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-ref-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.2 ref 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-reactive-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.3 reactive 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-Vue3-0-%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">3.4 Vue3.0 中的响应式原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-1-Vue2-x-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F\"><span class=\"toc-text\">3.4.1 Vue2.x 的响应式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-2-Vue3-0-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F\"><span class=\"toc-text\">3.4.2 Vue3.0 的响应式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-reactive-%E5%AF%B9%E6%AF%94-ref\"><span class=\"toc-text\">3.5 reactive 对比 ref</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-setup-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">3.6 setup 的两个注意点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-1-setup-%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">3.6.1 setup 执行的时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-2-setup-%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">3.6.2 setup 的参数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86\"><span class=\"toc-text\">3.7 计算属性与监视</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-1-computed-%E5%87%BD%E6%95%B0%EF%BC%88%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">3.7.1 computed 函数（计算属性）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-2-watch-%E5%87%BD%E6%95%B0%EF%BC%88%E7%9B%91%E8%A7%86%EF%BC%89\"><span class=\"toc-text\">3.7.2 watch 函数（监视）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-2-watchEffect-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.7.2 watchEffect 函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-8-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">3.8 生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-9-%E8%87%AA%E5%AE%9A%E4%B9%89-hook-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">3.9 自定义 hook 函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-10-toRef\"><span class=\"toc-text\">3.10 toRef</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E5%85%B6%E5%AE%83-Composition-API\"><span class=\"toc-text\">4. 其它 Composition API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-shallowReactive-%E4%B8%8E-shallowRef\"><span class=\"toc-text\">4.1 shallowReactive 与 shallowRef</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-readonly-%E4%B8%8E-shallowReadonly\"><span class=\"toc-text\">4.2 readonly 与 shallowReadonly</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-toRaw-%E4%B8%8E-markRaw\"><span class=\"toc-text\">4.3 toRaw 与 markRaw</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-customRef\"><span class=\"toc-text\">4.4 customRef</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-provide-%E4%B8%8E-inject\"><span class=\"toc-text\">4.5 provide 与 inject</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">4.6 响应式数据的判断</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Composition-API-%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">5. Composition API 的优势</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-Options-API-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5.1 Options API 存在的问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-Composition-API-%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">5.2 Composition API 的优势</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">6. 新的组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-Fragment\"><span class=\"toc-text\">6.1 Fragment</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-Teleport\"><span class=\"toc-text\">6.2 Teleport</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-Suspense\"><span class=\"toc-text\">6.3 Suspense</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E5%85%B6%E4%BB%96%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">7. 其他变化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E5%85%A8%E5%B1%80-API-%E7%9A%84%E8%BD%AC%E7%A7%BB\"><span class=\"toc-text\">7.1 全局 API 的转移</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98\"><span class=\"toc-text\">7.2 其他改变</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Java实用总结","uid":"b3f4e6999373a71edd44de21348d01f5","slug":"BlogRepository/Java/Java实用总结","date":"2022-11-08T02:22:55.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Java/Java实用总结.json","keywords":null,"cover":"https://cover.png","text":"1. 时间时区转换1.1 UTC 转 LocalDateTime将 UTC 时间（格林威治实际标准时间）转换为北京时间（UTC-东八区时间）。即将带有 T、Z 的日期字符串类型转为 LocalDateTime 类型。LocalDateTime 是没有时区的 date 时间，如果想...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":5,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":12,"path":"api/tags/Java.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"设计模式之美总结（创建型篇）","uid":"b576af472086ff634c008c948f90fb9b","slug":"BlogRepository/设计模式/设计模式之美总结（创建型篇）","date":"2022-11-03T05:58:36.000Z","updated":"2023-04-20T13:57:44.632Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（创建型篇）.json","keywords":null,"cover":"https://cover.png","text":"前三篇见： 设计模式之美总结（面向对象篇）_凡 223 的博客 设计模式之美总结（设计原则篇）_凡 223 的博客 设计模式之美总结（重构篇）_凡 223 的博客 1. 单例模式（Singleton Design Pattern）1.1 为什么要使用单例？单例设计模式（Singl...","link":"","photos":[],"count_time":{"symbolsCount":"61k","symbolsTime":"55 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}