{"title":"Spring Security 总结","uid":"84bebe9cd32f64471707a2ec9d7cecfe","slug":"BlogRepository/Spring/Spring Security 总结","date":"2022-03-15T09:18:25.000Z","updated":"2023-03-13T19:13:04.940Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring Security 总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-概要\"><a href=\"#1-概要\" class=\"headerlink\" title=\"1. 概要\"></a>1. 概要</h1><h2 id=\"1-1-名词概念\"><a href=\"#1-1-名词概念\" class=\"headerlink\" title=\"1.1 名词概念\"></a>1.1 名词概念</h2><h3 id=\"1-1-1-主体（principal）\"><a href=\"#1-1-1-主体（principal）\" class=\"headerlink\" title=\"1.1.1 主体（principal）\"></a>1.1.1 主体（principal）</h3><p>使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体</p>\n<h3 id=\"1-1-2-认证（authentication）\"><a href=\"#1-1-2-认证（authentication）\" class=\"headerlink\" title=\"1.1.2 认证（authentication）\"></a>1.1.2 认证（authentication）</h3><p>权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。笼统的认为就是以前所做的登录操作</p>\n<h3 id=\"1-1-3-授权（authorization）\"><a href=\"#1-1-3-授权（authorization）\" class=\"headerlink\" title=\"1.1.3 授权（authorization）\"></a>1.1.3 授权（authorization）</h3><p>将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的能力。所以简单来说，授权就是给用户分配权限</p>\n<h2 id=\"1-2-简介\"><a href=\"#1-2-简介\" class=\"headerlink\" title=\"1.2 简介\"></a>1.2 简介</h2><p>关于安全方面的两个主要区域是“认证”和“授权”（或者访问控制），一般来说，Web 应用的安全性包括<strong>用户认证（Authentication）和用户授权（Authorization）</strong> 两个部分，这两点也是 Spring Security 重要核心功能</p>\n<ol>\n<li><strong>用户认证：</strong> <strong>验证某个用户是否为系统中的合法主体</strong>，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<strong>通俗点说就是系统认为用户是否能登录</strong></li>\n<li><strong>用户授权：</strong> <strong>验证某个用户是否有权限执行某个操作</strong>。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。<strong>通俗点讲就是系统判断用户是否有权限去做某些事情</strong></li>\n</ol>\n<h3 id=\"1-2-1-SpringSecurity-特点\"><a href=\"#1-2-1-SpringSecurity-特点\" class=\"headerlink\" title=\"1.2.1 SpringSecurity 特点\"></a>1.2.1 SpringSecurity 特点</h3><ul>\n<li>和 Spring 无缝整合</li>\n<li>全面的权限控制</li>\n<li>专门为 Web 开发而设计<ul>\n<li>旧版本不能脱离 Web 环境使用</li>\n<li>新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独引入核心模块就可以脱离 Web 环境</li>\n</ul>\n</li>\n<li><strong>重量级，shiro 是轻量级的</strong></li>\n</ul>\n<h3 id=\"1-2-2-模块划分\"><a href=\"#1-2-2-模块划分\" class=\"headerlink\" title=\"1.2.2 模块划分\"></a>1.2.2 模块划分</h3><p><img src=\"https://img-blog.csdnimg.cn/737dc38958214de294396f10088744af.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"2-过滤器\"><a href=\"#2-过滤器\" class=\"headerlink\" title=\"2. 过滤器\"></a>2. 过滤器</h1><p><strong>Spring Security 采用的是责任链的设计模式，它有一条很长的过滤器链（15个），只有当前过滤器通过，才能进入下一个过滤器</strong></p>\n<p>Spring Security 的过滤器链是配置在 SpringMVC 的核心组件 DispatcherServlet 运行之前。也就是说，<strong>请求通过 Spring Security 的所有过滤器，不意味着能够正常访问资源，该请求还需要通过 SpringMVC 的拦截器链</strong><br><img src=\"https://img-blog.csdnimg.cn/c80da35889694a02943690e2b7a44b7e.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter\norg.springframework.security.web.context.SecurityContextPersistenceFilter \norg.springframework.security.web.header.HeaderWriterFilter\norg.springframework.security.web.csrf.CsrfFilter\norg.springframework.security.web.authentication.logout.LogoutFilter \norg.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter \norg.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter \norg.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter\norg.springframework.security.web.authentication.www.BasicAuthenticationFilter\norg.springframework.security.web.savedrequest.RequestCacheAwareFilter\norg.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter\norg.springframework.security.web.authentication.AnonymousAuthenticationFilter \norg.springframework.security.web.session.SessionManagementFilter \norg.springframework.security.web.access.ExceptionTranslationFilter \norg.springframework.security.web.access.intercept.FilterSecurityInterceptor</code></pre>\n\n<h2 id=\"OncePerRequestFilter\"><a href=\"#OncePerRequestFilter\" class=\"headerlink\" title=\"OncePerRequestFilter\"></a>OncePerRequestFilter</h2><p>在 Spring中，Filter 默认继承OncePerRequestFilter，作用是兼容各种请求，保证每次执行一个Filter<br><img src=\"https://img-blog.csdnimg.cn/cbc0701ca0d8493183ea9047e24b5012.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-1-WebAsyncManagerIntegrationFilter\"><a href=\"#2-1-WebAsyncManagerIntegrationFilter\" class=\"headerlink\" title=\"2.1 WebAsyncManagerIntegrationFilter\"></a>2.1 WebAsyncManagerIntegrationFilter</h2><p>将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成</p>\n<h2 id=\"2-2-SecurityContextPersistenceFilter\"><a href=\"#2-2-SecurityContextPersistenceFilter\" class=\"headerlink\" title=\"2.2 SecurityContextPersistenceFilter\"></a>2.2 SecurityContextPersistenceFilter</h2><h3 id=\"2-2-1-SecurityContextRepository\"><a href=\"#2-2-1-SecurityContextRepository\" class=\"headerlink\" title=\"2.2.1 SecurityContextRepository\"></a>2.2.1 SecurityContextRepository</h3><p>用于在请求之间保持 SecurityContext 的策略。 SecurityContextPersistenceFilter 使用它来获取应该用于当前执行线程的上下文，并在上下文从线程本地存储中删除并且请求完成后存储该上下文。使用的持久性机制将取决于实现，但最常见的是 HttpSession 将用于存储上下文</p>\n<h3 id=\"2-2-2-概念\"><a href=\"#2-2-2-概念\" class=\"headerlink\" title=\"2.2.2 概念\"></a>2.2.2 概念</h3><p>在请求开始时从配置好的 SecurityContextRepository  中<strong>获取该请求相关的安全上下文信息 SecurityContext，然后加载到 SecurityContextHolder 中</strong>。然后在该次请求处理完成之后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时<strong>清除 SecurityContextHolder 所持有的 SecurityContext</strong></p>\n<h2 id=\"2-3-HeaderWriterFilter\"><a href=\"#2-3-HeaderWriterFilter\" class=\"headerlink\" title=\"2.3 HeaderWriterFilter\"></a>2.3 HeaderWriterFilter</h2><p>向请求的 Header 中添加相应的信息，将头信息加入响应中，可在 http 标签内部使用 security:headers 来控制</p>\n<h2 id=\"2-4-CsrfFilter\"><a href=\"#2-4-CsrfFilter\" class=\"headerlink\" title=\"2.4 CsrfFilter\"></a>2.4 CsrfFilter</h2><p>用于处理跨站请求伪造，Spring Security会对 PATCH，POST，PUT 和 DELETE 方法进行防护，验证请求是否包含系统生成的 csrf 的 Token 信息，如果不包含，则报错</p>\n<h2 id=\"2-5-LogoutFilter\"><a href=\"#2-5-LogoutFilter\" class=\"headerlink\" title=\"2.5 LogoutFilter\"></a>2.5 LogoutFilter</h2><p>默认匹配 URL 为 &#x2F;logout 的请求，实现用户注销，清除认证信息</p>\n<h2 id=\"2-6-UsernamePasswordAuthenticationFilter（重要）\"><a href=\"#2-6-UsernamePasswordAuthenticationFilter（重要）\" class=\"headerlink\" title=\"2.6 UsernamePasswordAuthenticationFilter（重要）\"></a>2.6 UsernamePasswordAuthenticationFilter（重要）</h2><p><strong>进行认证操作</strong>。用于处理基于表单的登录请求，<strong>默认会拦截前端提交的 URL 为 &#x2F;login 且必须为 POST 方式的登录表单请求，并进行身份认证</strong>，校验表单中用户名，密码。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的 usernameParameter 和 passwordParameter 两个参数的值进行修改。该过滤器的 doFilter() 方法实现在其抽象父类 AbstractAuthenticationProcessingFilter 中</p>\n<h2 id=\"2-7-DefaultLoginPageGeneratingFilter\"><a href=\"#2-7-DefaultLoginPageGeneratingFilter\" class=\"headerlink\" title=\"2.7 DefaultLoginPageGeneratingFilter\"></a>2.7 DefaultLoginPageGeneratingFilter</h2><p>如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录认证时生成一个登录表单页面</p>\n<h2 id=\"2-8-DefaultLogoutPageGeneratingFilter\"><a href=\"#2-8-DefaultLogoutPageGeneratingFilter\" class=\"headerlink\" title=\"2.8 DefaultLogoutPageGeneratingFilter\"></a>2.8 DefaultLogoutPageGeneratingFilter</h2><p>生成默认的注销页面</p>\n<h2 id=\"2-9-BasicAuthenticationFilter\"><a href=\"#2-9-BasicAuthenticationFilter\" class=\"headerlink\" title=\"2.9 BasicAuthenticationFilter\"></a>2.9 BasicAuthenticationFilter</h2><p>此过滤器会自动解析 HTTP 请求中头部名字为 Authentication，且以 Basic 开头的头信息，检测和处理 HTTP Basic 认证</p>\n<h2 id=\"2-10-RequestCacheAwareFilter\"><a href=\"#2-10-RequestCacheAwareFilter\" class=\"headerlink\" title=\"2.10 RequestCacheAwareFilter\"></a>2.10 RequestCacheAwareFilter</h2><p>通过 HttpSessionRequestCache 内部维护了一个 RequestCache，用于缓存 HttpServletRequest，处理请求的缓存</p>\n<h2 id=\"2-11-SecurityContextHolderAwareRequestFilter\"><a href=\"#2-11-SecurityContextHolderAwareRequestFilter\" class=\"headerlink\" title=\"2.11 SecurityContextHolderAwareRequestFilter\"></a>2.11 SecurityContextHolderAwareRequestFilter</h2><p>针对 ServletRequest 进行了—次包装，使得 request 具有更加丰富的API</p>\n<h2 id=\"2-12-AnonymousAuthenticationFilter\"><a href=\"#2-12-AnonymousAuthenticationFilter\" class=\"headerlink\" title=\"2.12 AnonymousAuthenticationFilter\"></a>2.12 AnonymousAuthenticationFilter</h2><p>当 SecurityContextHolder 中 Authentication 对象（认证信息）为空,则会创建一个匿名用户存入到 SecurityContextHolder 中。Spring Security 为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份</p>\n<h2 id=\"2-13-SessionManagementFilter\"><a href=\"#2-13-SessionManagementFilter\" class=\"headerlink\" title=\"2.13 SessionManagementFilter\"></a>2.13 SessionManagementFilter</h2><p>管理 Session 的过滤器，SecurityContextRepository 限制同一用户开启多个会话的数量</p>\n<h2 id=\"2-14-ExceptionTranslationFilter（重要）\"><a href=\"#2-14-ExceptionTranslationFilter（重要）\" class=\"headerlink\" title=\"2.14 ExceptionTranslationFilter（重要）\"></a>2.14 ExceptionTranslationFilter（重要）</h2><p>异常过滤器，处理 AccessDeniedException 和 AuthenticationException 异常，该过滤器不需要配置，对于前端提交的请求会直接放行，捕获后续抛出的异常并进行处理（如：权限访问限制）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ExceptionTranslationFilter extends GenericFilterBean &#123;\n\n\t&#x2F;&#x2F; ~ Instance fields\n\t&#x2F;&#x2F; ~ Methods\n\n\tpublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;\n\t\tHttpServletRequest request &#x3D; (HttpServletRequest) req;\n\t\tHttpServletResponse response &#x3D; (HttpServletResponse) res;\n\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 1. 对应前端提交的请求会直接放行，不进行拦截\n\t\t\tchain.doFilter(request, response);\n\n\t\t\tlogger.debug(&quot;Chain processed normally&quot;);\n\t\t&#125;\n\t\tcatch (IOException ex) &#123;\n\t\t\tthrow ex;\n\t\t&#125;\n\t\tcatch (Exception ex) &#123;\n\t\t\t&#x2F;&#x2F; Try to extract a SpringSecurityException from the stacktrace\n\t\t\t&#x2F;&#x2F; 2. 捕获后续出现的异常进行处理\n\t\t\tThrowable[] causeChain &#x3D; throwableAnalyzer.determineCauseChain(ex);\n\t\t\t&#x2F;&#x2F; 3. 访问需要认证的资源，但当前请求未认证所抛出的异常\n\t\t\tRuntimeException ase &#x3D; (AuthenticationException) throwableAnalyzer\n\t\t\t\t\t.getFirstThrowableOfType(AuthenticationException.class, causeChain);\n\n\t\t\tif (ase &#x3D;&#x3D; null) &#123;\n\t\t\t\t&#x2F;&#x2F; 访问权限受限的资源所抛出的异常\n\t\t\t\tase &#x3D; (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain);\n\t\t\t&#125;\n\n\t\t\tif (ase !&#x3D; null) &#123;\n\t\t\t\tif (response.isCommitted()) &#123;\n\t\t\t\t\tthrow new ServletException(&quot;Unable to handle the Spring Security Exception because the response is already committed.&quot;, ex);\n\t\t\t\t&#125;\n\t\t\t\thandleSpringSecurityException(request, response, chain, ase);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\t&#x2F;&#x2F; Rethrow ServletExceptions and RuntimeExceptions as-is\n\t\t\t\tif (ex instanceof ServletException) &#123;\n\t\t\t\t\tthrow (ServletException) ex;\n\t\t\t\t&#125;\n\t\t\t\telse if (ex instanceof RuntimeException) &#123;\n\t\t\t\t\tthrow (RuntimeException) ex;\n\t\t\t\t&#125;\n\n\t\t\t\t&#x2F;&#x2F; Wrap other Exceptions. This shouldn&#39;t actually happen\n\t\t\t\t&#x2F;&#x2F; as we&#39;ve already covered all the possibilities for doFilter\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;</code></pre>\n\n<h2 id=\"2-15-FilterSecurityInterceptor（重要）\"><a href=\"#2-15-FilterSecurityInterceptor（重要）\" class=\"headerlink\" title=\"2.15 FilterSecurityInterceptor（重要）\"></a>2.15 FilterSecurityInterceptor（重要）</h2><p>该过滤器是过滤器链的最后一个过滤器，前面解决了认证问题，接下来是是否可访问指定资源的问题，<strong>FilterSecurityInterceptor 用了 AccessDecisionManager 来进行鉴权</strong>。获取所配置资源访问的授权信息，根据 SecurityContextHolder 中存储的用户信息来判断当前请求是否有权限访问对应的资源。如果访问受限会抛出相关异常，最终所抛出的异常会由前一个过滤器 ExceptionTranslationFilter 过滤器进行捕获和处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123;\n\t&#x2F;&#x2F; ~ Static fields&#x2F;initializers\n\t&#x2F;&#x2F; ~ Instance fields\n\t&#x2F;&#x2F; ~ Methods\n\n\t&#x2F;&#x2F; 过滤器的 doFilter() 方法\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n\t\tFilterInvocation fi &#x3D; new FilterInvocation(request, response, chain);\n\t\t&#x2F;&#x2F; 调用 invoke() 方法\n\t\tinvoke(fi);\n\t&#125;\n\n\tpublic void invoke(FilterInvocation fi) throws IOException, ServletException &#123;\n\t\tif ((fi.getRequest() !&#x3D; null)\n\t\t\t\t&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) !&#x3D; null)\n\t\t\t\t&amp;&amp; observeOncePerRequest) &#123;\n\t\t\t&#x2F;&#x2F; filter already applied to this request and user wants us to observe\n\t\t\t&#x2F;&#x2F; once-per-request handling, so don&#39;t re-do security checking\n\t\t\tfi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n\t\t&#125;\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F; first time this request being called, so perform security checking\n\t\t\tif (fi.getRequest() !&#x3D; null &amp;&amp; observeOncePerRequest) &#123;\n\t\t\t\tfi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);\n\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; 1. 根据资源权限配置来判断当前请求是否有权限访问对应的资源，如果不能访问，则抛出响应的异常\n\t\t\tInterceptorStatusToken token &#x3D; super.beforeInvocation(fi);\n\n\t\t\ttry &#123;\n\t\t\t\t&#x2F;&#x2F; 2. 访问相关资源，通过 SpringMVC 的核心组件 DispatcherServlet 进行访问\n\t\t\t\tfi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n\t\t\t&#125;\n\t\t\tfinally &#123;\n\t\t\t\tsuper.finallyInvocation(token);\n\t\t\t&#125;\n\n\t\t\tsuper.afterInvocation(token, null);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"RememberMeAuthenticationFilter\"><a href=\"#RememberMeAuthenticationFilter\" class=\"headerlink\" title=\"RememberMeAuthenticationFilter\"></a>RememberMeAuthenticationFilter</h2><p>当用户没有登录而直接访问资源时, 从 Cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的 Remember Me Cookie, 用户将不必填写用户名和密码，而是直接登录进入系统，该过滤器默认不开启</p>\n<h2 id=\"执行流程图\"><a href=\"#执行流程图\" class=\"headerlink\" title=\"执行流程图\"></a>执行流程图</h2><p><img src=\"https://img-blog.csdnimg.cn/963482152ca94ab2ba953a7ac9e765c9.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-工作流程\"><a href=\"#3-工作流程\" class=\"headerlink\" title=\"3. 工作流程\"></a>3. 工作流程</h1><p><strong>登录校验流程：</strong><br><img src=\"https://img-blog.csdnimg.cn/83c3b3875a2540938d2cbfe76954273b.png\" alt=\"在这里插入图片描述\"><br><strong>类之间关系：</strong><br><img src=\"https://img-blog.csdnimg.cn/e5bc8547fdaa475383f0b7f535d1b697.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/da2e66e2551b4434927ea052837d77d7.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-1-认证流程\"><a href=\"#3-1-认证流程\" class=\"headerlink\" title=\"3.1 认证流程\"></a>3.1 认证流程</h2><p><img src=\"https://img-blog.csdnimg.cn/3fa4e9e939c946b391e6bba793675316.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-1-AbstractAuthenticationProcessingFilter\"><a href=\"#3-1-1-AbstractAuthenticationProcessingFilter\" class=\"headerlink\" title=\"3.1.1 AbstractAuthenticationProcessingFilter\"></a>3.1.1 AbstractAuthenticationProcessingFilter</h3><ol>\n<li>基于浏览器的基于 HTTP 的身份验证请求的抽象处理器。需要 AuthenticationManager 来处理由实现类创建的身份验证请求令牌</li>\n<li>如果身份验证成功，生成的 Authentication 对象将被放入当前线程的 SecurityContext 中。然后将调用配置的 AuthenticationSuccessHandler 以在成功登录后重定向到适当的目的地。默认行为在 SavedRequestAwareAuthenticationSuccessHandler 中实现，它将利用 ExceptionTranslationFilter 设置的任何 DefaultSavedRequest 并将用户重定向到其中包含的 URL<br><img src=\"https://img-blog.csdnimg.cn/a0bb28b93e704fc0a2ef62f22f741ed0.png\" alt=\"在这里插入图片描述\"></li>\n<li>如果身份验证失败，它将委托给配置的 AuthenticationFailureHandler 以允许将失败信息传达给客户端。默认实现是 SimpleUrlAuthenticationFailureHandler ，它向客户端发送 401 错误代码。它也可以配置一个失败的 URL 作为替代<br><img src=\"https://img-blog.csdnimg.cn/2e642c61844f402f8f0910821d30e0e7.png\" alt=\"在这里插入图片描述\"></li>\n<li>如果身份验证成功，将通过应用程序上下文发布一个 InteractiveAuthenticationSuccessEvent。如果身份验证不成功，则不会发布任何事件，因为这通常会通过 AuthenticationManager 特定的应用程序事件进行记录</li>\n<li>该类有一个可选的 SessionAuthenticationStrategy，它将在成功调用 attemptAuthentication() 后立即被调用。可以注入不同的实现来启用会话固定攻击预防或控制主体可能拥有的同时会话的数量</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware &#123;\n\n    &#x2F;&#x2F; 过滤器 doFilter() 方法\n\tpublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;\n\n\t\tHttpServletRequest request &#x3D; (HttpServletRequest) req;\n\t\tHttpServletResponse response &#x3D; (HttpServletResponse) res;\n\n\t\t&#x2F;&#x2F; 1. 判断该请求是否为 POST 方式的登录表单提交请求，如果不是则直接放行，进入下一个过滤器\n\t\tif (!requiresAuthentication(request, response)) &#123;\n\t\t\tchain.doFilter(request, response);\n\t\t\treturn;\n\t\t&#125;\n\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Request is to process authentication&quot;);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Authentication 是用来存储用户认证信息的类\n\t\tAuthentication authResult;\n\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 2. 调用子类 UsernamePasswordAuthenticationFilter 重写的方法进行身份认证\n\t\t\t&#x2F;&#x2F; 返回的 authResult 对象封装认证后的用户信息\n\t\t\tauthResult &#x3D; attemptAuthentication(request, response);\n\t\t\tif (authResult &#x3D;&#x3D; null) &#123;\n\t\t\t\t&#x2F;&#x2F; return immediately as subclass has indicated that it hasn&#39;t completed\n\t\t\t\t&#x2F;&#x2F; authentication\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; 3. Session 策略处理（如果配置了用户 Session 最大并发数，就是在此处进行判断并处理）\n\t\t\tsessionStrategy.onAuthentication(authResult, request, response);\n\t\t&#125;\n\t\tcatch (InternalAuthenticationServiceException failed) &#123;\n\t\t\tlogger.error(\n\t\t\t\t\t&quot;An internal error occurred while trying to authenticate the user.&quot;,\n\t\t\t\t\tfailed);\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\n\t\t\treturn;\n\t\t&#125;\n\t\tcatch (AuthenticationException failed) &#123;\n\t\t\t&#x2F;&#x2F; Authentication failed，4. 认证失败，调用认证失败的处理器\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\n\t\t\treturn;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Authentication success，4. 认证成功的处理\n\t\tif (continueChainBeforeSuccessfulAuthentication) &#123;\n\t\t\t&#x2F;&#x2F; 默认的 continueChainBeforeSuccessfulAuthentication 为 false，所以认证成功后不进入下一个过滤器\n\t\t\tchain.doFilter(request, response);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 调用认证成功的处理器\n\t\tsuccessfulAuthentication(request, response, chain, authResult);\n\t&#125;\n\n\t&#x2F;&#x2F; 认证成功后的处理\n\tprotected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;\n\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Authentication success. Updating SecurityContextHolder to contain: &quot; + authResult);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 1. 将认证成功的用户信息对象 Authentication 封装进 SecurityContext 对象中，并存入 SecurityContextHolder\n\t\t&#x2F;&#x2F; SecurityContextHolder 是对 ThreadLocal 的一个封装\n\t\tSecurityContextHolder.getContext().setAuthentication(authResult);\n\n\t\t&#x2F;&#x2F; 2. rememberMe 的处理\n\t\trememberMeServices.loginSuccess(request, response, authResult);\n\n\t\t&#x2F;&#x2F; Fire event\n\t\tif (this.eventPublisher !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; 3. 发布认证成功的事件\n\t\t\teventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 4. 调用认证成功处理器\n\t\tsuccessHandler.onAuthenticationSuccess(request, response, authResult);\n\t&#125;\n\t&#x2F;&#x2F; 认证失败后的处理\n\tprotected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;\n\t\t&#x2F;&#x2F; 1. 清除该线程在 SecurityContextHolder 中对应的 SecurityContext 对象\n\t\tSecurityContextHolder.clearContext();\n\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Authentication request failed: &quot; + failed.toString(), failed);\n\t\t\tlogger.debug(&quot;Updated SecurityContextHolder to contain null Authentication&quot;);\n\t\t\tlogger.debug(&quot;Delegating to authentication failure handler &quot; + failureHandler);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 2. rememberMe 的处理\n\t\trememberMeServices.loginFail(request, response);\n\n\t\t&#x2F;&#x2F; 3. 调用认证失败处理器\n\t\tfailureHandler.onAuthenticationFailure(request, response, failed);\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>上面第二步调用了 UsernamePasswordAuthenticationFilter 的 attemptAuthentication() 方法，见 3.1.2</strong></p>\n<h3 id=\"3-1-2-UsernamePasswordAuthenticationFilter\"><a href=\"#3-1-2-UsernamePasswordAuthenticationFilter\" class=\"headerlink\" title=\"3.1.2 UsernamePasswordAuthenticationFilter\"></a>3.1.2 UsernamePasswordAuthenticationFilter</h3><p><strong>进行认证操作</strong>。用于处理身份验证表单提交，<strong>默认会拦截前端提交的 URL 为 &#x2F;login 且必须为 POST 方式的登录表单请求，并进行身份认证</strong>，校验表单中用户名和密码。从表单中获取用户名和密码时，登录表单必须向此过滤器提供两个参数：username 和 password。要使用的默认参数名称在静态字段中进行了定义。参数名称也可以通过设置 usernameParameter 和 passwordParameter 属性来更改。。<strong>该过滤器的 doFilter() 方法实现在 3.1.1 其抽象父类 AbstractAuthenticationProcessingFilter 中</strong><br><img src=\"https://img-blog.csdnimg.cn/8ec6254a15de4c76864815f3e0c80311.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;\n\n\tpublic static final String SPRING_SECURITY_FORM_USERNAME_KEY &#x3D; &quot;username&quot;;\n\tpublic static final String SPRING_SECURITY_FORM_PASSWORD_KEY &#x3D; &quot;password&quot;;\n\n\t&#x2F;&#x2F;  默认表单用户名参数为 username\n\tprivate String usernameParameter &#x3D; SPRING_SECURITY_FORM_USERNAME_KEY;\n\t&#x2F;&#x2F;  默认表单密码参数为 password\n\tprivate String passwordParameter &#x3D; SPRING_SECURITY_FORM_PASSWORD_KEY;\n\t&#x2F;&#x2F; 默认请求方式只能为 POST\n\tprivate boolean postOnly &#x3D; true;\n\n\tpublic UsernamePasswordAuthenticationFilter() &#123;\n\t\t&#x2F;&#x2F; 默认登录表单提交路径为 &#x2F;login，POST 方式请求\n\t\tsuper(new AntPathRequestMatcher(&quot;&#x2F;login&quot;, &quot;POST&quot;));\n\t&#125;\n\n\t&#x2F;&#x2F; 上面的 doFilter() 方法调用此 attemptAuthentication() 进行身份认证\n\tpublic Authentication attemptAuthentication(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws AuthenticationException &#123;\n\t\tif (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;\n\t\t\t&#x2F;&#x2F; 1. 默认情况下，如果请求方式不是 POST，会抛出异常\n\t\t\tthrow new AuthenticationServiceException(\n\t\t\t\t\t&quot;Authentication method not supported: &quot; + request.getMethod());\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 2. 获取请求携带的 username 和 password\n\t\tString username &#x3D; obtainUsername(request);\n\t\tString password &#x3D; obtainPassword(request);\n\n\t\tif (username &#x3D;&#x3D; null) &#123;\n\t\t\tusername &#x3D; &quot;&quot;;\n\t\t&#125;\n\n\t\tif (password &#x3D;&#x3D; null) &#123;\n\t\t\tpassword &#x3D; &quot;&quot;;\n\t\t&#125;\n\n\t\tusername &#x3D; username.trim();\n\n\t\t&#x2F;&#x2F; 3. 使用前端传入的 username、password 构造 Authentication 对象，其中 authenticated 属性初始化默认为 false(也就还没通过身份验证)\n\t\tUsernamePasswordAuthenticationToken authRequest &#x3D; new UsernamePasswordAuthenticationToken(username, password);\n\n\t\t&#x2F;&#x2F; Allow subclasses to set the &quot;details&quot; property\n\t\t&#x2F;&#x2F; 4. 将请求中有关身份验证的其他属性信息设置到 Authentication 对象中，如 IP 地址、证书序列号等\n\t\tsetDetails(request, authRequest);\n\n\t\t&#x2F;&#x2F; 5. 调用 AuthenticationManager 的 authenticate() 方法进行身份认证\n\t\treturn this.getAuthenticationManager().authenticate(authRequest);\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>上面第三步创建的 UsernamePasswordAuthenticationToken 是 Authentication 接口的实现类，见 3.1.4</strong><br><img src=\"https://img-blog.csdnimg.cn/9104823fcae544a8b4322ca2a86765e5.png\" alt=\"在这里插入图片描述\"><br><strong>上面第五步将未认证的 Authentication 对象传入 AuthenticationManager 的 authenticate() 方法进行身份认证，见 3.1.5</strong></p>\n<h3 id=\"3-1-3-Authentication\"><a href=\"#3-1-3-Authentication\" class=\"headerlink\" title=\"3.1.3 Authentication\"></a>3.1.3 Authentication</h3><p>Spring Security 的认证主体，在Spring Security 中 Authentication 用来表示当前用户是谁，可以看作 authentication 就是一组用户名密码信息。接口定义如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Authentication extends Principal, Serializable &#123;\n\n\t&#x2F;&#x2F; 获取用户权限集合\n\tCollection&lt;? extends GrantedAuthority&gt; getAuthorities();\n\n\t&#x2F;&#x2F; 获取用户认证信息，通常是密码等信息\n\tObject getCredentials();\n\n\t&#x2F;&#x2F; 存储有关身份验证请求的其他详细信息。如 IP 地址、证书序列号等\n\tObject getDetails();\n\n\t&#x2F;&#x2F; 获取用户的身份信息，未认证时获取到的是前端请求传入的用户名\n\t&#x2F;&#x2F; 认证成功后为封装用户信息的 UserDetails 对象\n\tObject getPrincipal();\n\n\t&#x2F;&#x2F; 获取当前 Authentication 是否已认证\n\tboolean isAuthenticated();\n\n\t&#x2F;&#x2F; 设置当前 Authentication 是否已认证\n\tvoid setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;\n&#125;</code></pre>\n\n<p>获取当前登录用户信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 已登录，获取用户信息\nAuthentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication();\n\nString username &#x3D; authentication.getName(); &#x2F;&#x2F; 获取登录的用户名\nCollection&lt;? extends GrantedAuthority&gt; authorities &#x3D; authentication.getAuthorities(); &#x2F;&#x2F; 用户的所有权限\n&#x2F;&#x2F; 获取封装用户信息的 UserDetails 对象\nUser user &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</code></pre>\n\n<h3 id=\"3-1-4-UsernamePasswordAuthenticationToken\"><a href=\"#3-1-4-UsernamePasswordAuthenticationToken\" class=\"headerlink\" title=\"3.1.4 UsernamePasswordAuthenticationToken\"></a>3.1.4 UsernamePasswordAuthenticationToken</h3><p>Authentication 的实现类，旨在简单地显示用户名和密码。principal 和 credentials 应设置为通过其 Object.toString() 方法提供相应属性的对象。最简单的此类对象是字符串</p>\n<ul>\n<li>该类有两个构造器，<strong>一个用于封装前端请求传入的未认证的用户信息，一个用于封装认证成功后的用户信息</strong></li>\n<li>该类实现的 <strong>eraseCredentials() 方法，该方法实现在 3.1.8 其父类 AbstractAuthenticationToken 中</strong></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123;\n\n\tprivate static final long serialVersionUID &#x3D; SpringSecurityCoreVersion.SERIAL_VERSION_UID;\n\tprivate final Object principal;\n\tprivate Object credentials;\n\n\t&#x2F;&#x2F; 用于封装前端请求传入的未认证的用户信息，前面的 authRequest 对象就是调用该构造器进行构造的\n\tpublic UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123;\n\t\tsuper(null); &#x2F;&#x2F; 用户权限为 null\n\t\tthis.principal &#x3D; principal; &#x2F;&#x2F; 前端传入的用户名\n\t\tthis.credentials &#x3D; credentials; &#x2F;&#x2F; 前端传入的密码\n\t\tsetAuthenticated(false); &#x2F;&#x2F; 标记未认证\n\t&#125;\n\n\t&#x2F;&#x2F; 用户封装认证成功后的用户信息\n\tpublic UsernamePasswordAuthenticationToken(Object principal, Object credentials,\n\t\t\tCollection&lt;? extends GrantedAuthority&gt; authorities) &#123;\n\t\tsuper(authorities); &#x2F;&#x2F; 用户权限集合\n\t\tthis.principal &#x3D; principal; &#x2F;&#x2F; 封装认证用户信息的 UserDetails 对象，不再是用户名\n\t\tthis.credentials &#x3D; credentials; &#x2F;&#x2F; 前端传入的密码\n\t\tsuper.setAuthenticated(true); &#x2F;&#x2F; must use super, as we override，标记认证成功\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;</code></pre>\n\n<h3 id=\"3-1-5-AuthenticationManager\"><a href=\"#3-1-5-AuthenticationManager\" class=\"headerlink\" title=\"3.1.5 AuthenticationManager\"></a>3.1.5 AuthenticationManager</h3><p>校验 Authentication，<strong>该接口是认证相关的核心接口，也是认证的入口</strong>。在实际开发中，可能有多种不同的认证方式，例如：用户名+密码、邮箱+密码、手机号+验证码等，而这些认证方式的入口始终只有一个，那就是 AuthenticationManager</p>\n<p>如果验证失败会抛出 AuthenticationException 异常。AuthenticationException 是一个抽象类，因此代码逻辑并不能实例化一个 AuthenticationException 异常并抛出，实际上抛出的异常通常是其实现类，如 DisabledException、LockedException、BadCredentialsException 等。接口定义如下，其中可以包含多个 AuthenticationProvider，<strong>见 3.1.11 和 3.1.12</strong>。通常使用其实现类 ProviderManager</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface AuthenticationManager &#123;\n    Authentication authenticate(Authentication var1) throws AuthenticationException;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/0a22e45fe20b4559b820c3ea6f11a473.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-6-ProviderManager\"><a href=\"#3-1-6-ProviderManager\" class=\"headerlink\" title=\"3.1.6 ProviderManager\"></a>3.1.6 ProviderManager</h3><p>ProviderManager 是 AuthenticationManager 接口的实现类<br><img src=\"https://img-blog.csdnimg.cn/71d87c859347421a87d9100f55e1cbe9.png\" alt=\"在这里插入图片描述\"><br>在 AuthenticationManager 接口的常用实现类 ProviderManager 内部会维护一个 List&lt;AuthenticationProvider&gt; 列表，存放多种认证方式，实际上这是委托者模式（Delegate）的应用。每种认证方式对应着一个 AuthenticationProvider，AuthenticationManager 根据认证方式的不同（根据传入的 Authentication 类型判断）委托对应的 AuthenticationProvider 进行用户认证</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProviderManager implements AuthenticationManager, MessageSourceAware,\n\t\tInitializingBean &#123;\n\t&#x2F;&#x2F; ~ Static fields&#x2F;initializers\n\t&#x2F;&#x2F; ~ Instance fields\n\n\t&#x2F;&#x2F; 传入未认证的 Authentication 对象\n\tpublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;\n\t\t&#x2F;&#x2F; 1. 获取传入的 Authentication 类型，即 UsernamePasswordAuthenticationToken.class\n\t\tClass&lt;? extends Authentication&gt; toTest &#x3D; authentication.getClass();\n\t\tAuthenticationException lastException &#x3D; null;\n\t\tAuthenticationException parentException &#x3D; null;\n\t\tAuthentication result &#x3D; null;\n\t\tAuthentication parentResult &#x3D; null;\n\t\tboolean debug &#x3D; logger.isDebugEnabled();\n\n\t\t&#x2F;&#x2F; 2. 循环遍历认证方式列表 \n\t\tfor (AuthenticationProvider provider : getProviders()) &#123;\n\t\t\t&#x2F;&#x2F; 3. 判断当前 AuthenticationProvider 是否适用 UsernamePasswordAuthenticationToken.class 类型的 Authentication\n\t\t\tif (!provider.supports(toTest)) &#123;\n\t\t\t\tcontinue;\n\t\t\t&#125;\n\n\t\t\tif (debug) &#123;\n\t\t\t\tlogger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName());\n\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; 成功找到适配当前认证方式的 AuthenticationProvider ，此处为 DaoAuthenticationProvider\n\t\t\ttry &#123;\n\t\t\t\t&#x2F;&#x2F; 4. 调用 DaoAuthenticationProvider 的 authenticate() 方法进行认证\n\t\t\t\t&#x2F;&#x2F; 如果认证成功，会返回一个标记已认证的 Authentication 对象\n\t\t\t\tresult &#x3D; provider.authenticate(authentication);\n\n\t\t\t\tif (result !&#x3D; null) &#123;\n\t\t\t\t\t&#x2F;&#x2F; 5. 认证成功后，将传入的 Authentication 对象中的 details 信息拷贝到已认证的 Authentication 对象中\n\t\t\t\t\tcopyDetails(authentication, result);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tcatch (AccountStatusException | InternalAuthenticationServiceException e) &#123;\n\t\t\t\tprepareException(e, authentication);\n\t\t\t\t&#x2F;&#x2F; SEC-546: Avoid polling additional providers if auth failure is due to\n\t\t\t\t&#x2F;&#x2F; invalid account status\n\t\t\t\tthrow e;\n\t\t\t&#125; catch (AuthenticationException e) &#123;\n\t\t\t\tlastException &#x3D; e;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (result &#x3D;&#x3D; null &amp;&amp; parent !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; Allow the parent to try.\n\t\t\ttry &#123;\n\t\t\t\t&#x2F;&#x2F; 5. 认证失败，使用父类型 AuthenticationManager 进行验证\n\t\t\t\tresult &#x3D; parentResult &#x3D; parent.authenticate(authentication);\n\t\t\t&#125;\n\t\t\tcatch (ProviderNotFoundException e) &#123;\n\t\t\t\t&#x2F;&#x2F; ignore as we will throw below if no other exception occurred prior to\n\t\t\t\t&#x2F;&#x2F; calling parent and the parent\n\t\t\t\t&#x2F;&#x2F; may throw ProviderNotFound even though a provider in the child already\n\t\t\t\t&#x2F;&#x2F; handled the request\n\t\t\t&#125;\n\t\t\tcatch (AuthenticationException e) &#123;\n\t\t\t\tlastException &#x3D; parentException &#x3D; e;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (result !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; 6. 认证成功之后，去除 result 中的敏感信息，要求相关类实现 CredentialsContainer 接口\n\t\t\tif (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123;\n\t\t\t\t&#x2F;&#x2F; Authentication is complete. Remove credentials and other secret data\n\t\t\t\t&#x2F;&#x2F; from authentication\n\t\t\t\t&#x2F;&#x2F; 去除过程就是调用 CredentialsContainer 接口的 eraseCredentials() 方法\n\t\t\t\t((CredentialsContainer) result).eraseCredentials();\n\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; If the parent AuthenticationManager was attempted and successful than it will publish an AuthenticationSuccessEvent\n\t\t\t&#x2F;&#x2F; This check prevents a duplicate AuthenticationSuccessEvent if the parent AuthenticationManager already published it\n\t\t\t&#x2F;&#x2F; 7. 发布认证成功的事件\n\t\t\tif (parentResult &#x3D;&#x3D; null) &#123;\n\t\t\t\teventPublisher.publishAuthenticationSuccess(result);\n\t\t\t&#125;\n\t\t\treturn result;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Parent was null, or didn&#39;t authenticate (or throw an exception).\n\t\t&#x2F;&#x2F; 8. 认证失败之后，抛出失败的异常信息\n\t\tif (lastException &#x3D;&#x3D; null) &#123;\n\t\t\tlastException &#x3D; new ProviderNotFoundException(messages.getMessage(\n\t\t\t\t\t&quot;ProviderManager.providerNotFound&quot;,\n\t\t\t\t\tnew Object[] &#123; toTest.getName() &#125;,\n\t\t\t\t\t&quot;No AuthenticationProvider found for &#123;0&#125;&quot;));\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; If the parent AuthenticationManager was attempted and failed than it will publish an AbstractAuthenticationFailureEvent\n\t\t&#x2F;&#x2F; This check prevents a duplicate AbstractAuthenticationFailureEvent if the parent AuthenticationManager already published it\n\t\tif (parentException &#x3D;&#x3D; null) &#123;\n\t\t\tprepareException(lastException, authentication);\n\t\t&#125;\n\n\t\tthrow lastException;\n\t&#125;\n\t&#x2F;&#x2F; ~ Methods\n&#125;</code></pre>\n\n<p><strong>上面认证成功之后的第六步，调用 CredentialsContainer 接口定义的 eraseCredentials() 方法去除敏感信息，见 3.1.7</strong></p>\n<h3 id=\"3-1-7-CredentialsContainer\"><a href=\"#3-1-7-CredentialsContainer\" class=\"headerlink\" title=\"3.1.7 CredentialsContainer\"></a>3.1.7 CredentialsContainer</h3><p>表示实现对象包含敏感数据，可以使用 eraseCredentials 方法擦除这些数据。实现应该调用任何内部对象上的方法，这些对象也可以实现这个接口，仅供内部框架使用。编写自己的 AuthenticationProvider 实现的用户应该在那里创建并返回适当的 Authentication 对象，减去任何敏感数据，而不是使用此接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface CredentialsContainer &#123;\n\tvoid eraseCredentials();\n&#125;</code></pre>\n\n<p><strong>实现类：</strong><br><img src=\"https://img-blog.csdnimg.cn/6a14cc38fb664d37a113071554a28c5d.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-8-AbstractAuthenticationToken\"><a href=\"#3-1-8-AbstractAuthenticationToken\" class=\"headerlink\" title=\"3.1.8 AbstractAuthenticationToken\"></a>3.1.8 AbstractAuthenticationToken</h3><p>身份验证对象的基类。使用此类的实现应该是不可变的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer &#123;\n\t&#x2F;&#x2F; ~ Instance fields\n\t&#x2F;&#x2F; ~ Constructors\n\n\tpublic void eraseCredentials() &#123;\n\t\t&#x2F;&#x2F; credentials（前端传入的密码）会置为 null\n\t\teraseSecret(getCredentials());\n\t\t&#x2F;&#x2F; principal 在已认证的 Authentication 中是 UserDetails 的实现类，如果该实现类想要去除敏感信息，需要实现\n\t\t&#x2F;&#x2F; CredentialsContainer 的 eraseCredentials() 方法，由于自定义的 User 类没有实现该接口，所以不进行任何操作\n\t\teraseSecret(getPrincipal());\n\t\teraseSecret(details);\n\t&#125;\n\n\tprivate void eraseSecret(Object secret) &#123;\n\t\tif (secret instanceof CredentialsContainer) &#123;\n\t\t\t((CredentialsContainer) secret).eraseCredentials();\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;</code></pre>\n\n<p><strong>3.1.4 的 UsernamePasswordAuthenticationToken 是 AbstractAuthenticationToken 的子类，其 eraseCredentials 方法继承自 AbstractAuthenticationToken</strong><br><img src=\"https://img-blog.csdnimg.cn/619ac50fe89e4a09a7a6829801712470.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-9-UserDetailsService\"><a href=\"#3-1-9-UserDetailsService\" class=\"headerlink\" title=\"3.1.9 UserDetailsService\"></a>3.1.9 UserDetailsService</h3><p>加载用户特定数据的核心接口。它在整个框架中用作用户 DAO，并且是 DaoAuthenticationProvider 使用的策略。该接口只需要一种只读方法，这简化了对新数据访问策略的支持</p>\n<p>当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。要自定义逻辑，需要自定义一个实现类实现 UserDetailsService 接口，让 Spring Security 使用我们的 UserDetailsService 。我们自己的 UserDetailsService 可以从数据库中查询用户名和密码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.springframework.security.core.userdetails;\n\npublic interface UserDetailsService &#123;\n    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;\n&#125;</code></pre>\n\n<h4 id=\"3-1-9-1-UserDetails\"><a href=\"#3-1-9-1-UserDetails\" class=\"headerlink\" title=\"3.1.9.1 UserDetails\"></a>3.1.9.1 UserDetails</h4><p>上面 loadUserByUsername() 方法的返回值 UserDetails，这个类是系统默认的用户“主体”。提供核心用户信息。出于安全目的，Spring Security 不直接使用实现。它们只是存储用户信息，这些信息随后被封装到 Authentication 对象中。这允许将非安全相关的用户信息（例如电子邮件地址、电话号码等）存储在方便的位置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n\treturn new UserDetails() &#123;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示获取登录用户所有权限\n\t\tpublic Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示获取密码\n\t\tpublic String getPassword() &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示获取用户名\n\t\tpublic String getUsername() &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示判断账户是否过期\n\t\tpublic boolean isAccountNonExpired() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示判断账户是否被锁定\n\t\tpublic boolean isAccountNonLocked() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示凭证&#123;密码&#125;是否过期\n\t\tpublic boolean isCredentialsNonExpired() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示当前用户是否可用\n\t\tpublic boolean isEnabled() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;;\n&#125;</code></pre>\n\n<h4 id=\"3-1-9-2-User\"><a href=\"#3-1-9-2-User\" class=\"headerlink\" title=\"3.1.9.2 User\"></a>3.1.9.2 User</h4><ol>\n<li>UserDetails 实现类，对 UserDetailsService 检索的核心用户信息进行建模。可以直接使用这个类，或者自定义一个类实现 UserDetails</li>\n<li>equals 和 hashcode 实现仅基于 username 属性，因为其目的是查找相同的用户主体对象（例如，在用户注册表中）将匹配对象代表相同用户的位置，而不仅仅是当所有属性 (权限，例如密码）是相同的</li>\n<li>此实现不是一成不变的。实现了 CredentialsContainer 接口，以允许在身份验证后删除密码。如果将实例存储在内存中并重用它们，可能会导致副作用。如果是这样，要确保每次调用 UserDetailsService 时都返回一个副本<br><img src=\"https://img-blog.csdnimg.cn/5f5a97a0efb64eee944868a88d9dd895.png\" alt=\"在这里插入图片描述\"><br>可以使用 User 这个实现类返回用户名、密码和权限<br><img src=\"https://img-blog.csdnimg.cn/6937bbb44e3048a9a2f6d92c00e7bd07.png\" alt=\"在这里插入图片描述\"><br>方法参数 <strong>username</strong>，表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 username，否则无法接收</li>\n</ol>\n<h3 id=\"3-1-10-PasswordEncoder-接口\"><a href=\"#3-1-10-PasswordEncoder-接口\" class=\"headerlink\" title=\"3.1.10 PasswordEncoder 接口\"></a>3.1.10 PasswordEncoder 接口</h3><p>用于编码密码的服务接口，首选实现是 BCryptPasswordEncoder</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.springframework.security.crypto.password;\n\npublic interface PasswordEncoder &#123;\n\t&#x2F;&#x2F; 表示把参数按照特定的解析规则进行解析\n    String encode(CharSequence rawPassword);\n\n\t&#x2F;* 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；\n\t如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。 *&#x2F;\n    boolean matches(CharSequence rawPassword, String encodedPassword);\n\n\t&#x2F;&#x2F; 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\n    default boolean upgradeEncoding(String encodedPassword) &#123;\n        return false;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>接口实现类：</strong><br><img src=\"https://img-blog.csdnimg.cn/c729ef68ae1b447cbfa2620d08be3e32.png\" alt=\"在这里插入图片描述\"><br>BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\nBCryptPasswordEncoder bCryptPasswordEncoder &#x3D; new BCryptPasswordEncoder();\n&#x2F;&#x2F; 对密码进行加密\nString fan &#x3D; bCryptPasswordEncoder.encode(&quot;fan&quot;);\n&#x2F;&#x2F; 打印加密之后的数据\nSystem.out.println(&quot;加密之后数据：\\t&quot; + fan);\n&#x2F;&#x2F;判断原字符加密后和加密之前是否匹配\nboolean result &#x3D; bCryptPasswordEncoder.matches(&quot;fan&quot;, fan);\n&#x2F;&#x2F; 打印比较结果\nSystem.out.println(&quot;比较结果：\\t&quot;+result);</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/d4fc150821e5408abe2c886680ed9487.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-11-AbstractUserDetailsAuthenticationProvider\"><a href=\"#3-1-11-AbstractUserDetailsAuthenticationProvider\" class=\"headerlink\" title=\"3.1.11 AbstractUserDetailsAuthenticationProvider\"></a>3.1.11 AbstractUserDetailsAuthenticationProvider</h3><ol>\n<li>一个基本的 AuthenticationProvider，它允许子类覆盖和使用 UserDetails 对象。该类旨在响应 UsernamePasswordAuthenticationToken 身份验证请求</li>\n<li>成功验证后，将创建一个 UsernamePasswordAuthenticationToken 并将其返回给调用者。Token 将包括作为其主体的用户名的字符串表示形式或从身份验证存储库返回的 UserDetails</li>\n<li>如果正在使用容器适配器，则适合使用 String ，因为它需要 String 表示用户名。如果需要访问经过身份验证的用户的其他属性，例如电子邮件地址、人性化名称等，则适合使用 UserDetails。由于不建议使用容器适配器，并且 UserDetails 实现提供了额外的灵活性，默认情况下会返回 UserDetails。要覆盖此默认值，可以将 setForcePrincipalAsString 设置为 true</li>\n<li>通过存储放置在 UserCache 中的 UserDetails 对象来处理缓存。这确保了可以验证具有相同用户名的后续请求，而无需查询 UserDetailsService。但需要注意的是，如果用户出现密码错误，将查询 UserDetailsService 以确认是否使用了最新密码进行比较。只有无状态应用程序才可能需要缓存。例如，在普通的 Web 应用程序中，SecurityContext 存储在用户的会话中，并且用户不会在每个请求上重新进行身份验证。因此，默认缓存实现是 NullUserCache</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware &#123;\n\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;\n        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,\n                messages.getMessage(\n                        &quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;,\n                        &quot;Only UsernamePasswordAuthenticationToken is supported&quot;));\n\n        &#x2F;&#x2F; Determine username\n        String username &#x3D; (authentication.getPrincipal() &#x3D;&#x3D; null) ? &quot;NONE_PROVIDED&quot; : authentication.getName();\n\n        boolean cacheWasUsed &#x3D; true;\n\n        &#x2F;&#x2F; 1. 默认从缓存中获取 UserDetails 信息\n        UserDetails user &#x3D; this.userCache.getUserFromCache(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            cacheWasUsed &#x3D; false;\n\n            try &#123;\n                &#x2F;&#x2F; 2. 缓存中拿不到就从数据库中获取 UserDetails 信息 默认实现是 DaoAuthenticationProvider 的 retrieveUser方法\n                user &#x3D; retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);\n            &#125;\n            catch (UsernameNotFoundException notFound) &#123;\n                logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;);\n\n                if (hideUserNotFoundExceptions) &#123;\n                    throw new BadCredentialsException(messages.getMessage(\n                            &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,\n                            &quot;Bad credentials&quot;));\n                &#125;\n                else &#123;\n                    throw notFound;\n                &#125;\n            &#125;\n\n            Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;);\n        &#125;\n\n        try &#123;\n            &#x2F;&#x2F; 3. 检查 User 的各种状态, 用户过期, 密码过期等\n            preAuthenticationChecks.check(user);\n            &#x2F;&#x2F; 4. 密码匹配校验, 调用加密类 PasswordEncoder (可以自己定义)\n            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);\n        &#125;\n        catch (AuthenticationException exception) &#123;\n            if (cacheWasUsed) &#123;\n                &#x2F;&#x2F; There was a problem, so try again after checking\n                &#x2F;&#x2F; we&#39;re using latest data (i.e. not from the cache)\n                cacheWasUsed &#x3D; false;\n                user &#x3D; retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);\n                preAuthenticationChecks.check(user);\n                additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);\n            &#125;\n            else &#123;\n                throw exception;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 5. 检查一下一些数据是否过期\n        postAuthenticationChecks.check(user);\n\n        if (!cacheWasUsed) &#123;\n            &#x2F;&#x2F; 6. 将 UserDetails 放入缓存\n            this.userCache.putUserInCache(user);\n        &#125;\n\n        Object principalToReturn &#x3D; user;\n\n        if (forcePrincipalAsString) &#123;\n            principalToReturn &#x3D; user.getUsername();\n        &#125;\n\n        &#x2F;&#x2F; 7. 将用户所有的所有合法角色放入 Token 中的 authorities 中 并且 authenticated 设置为true 表示验证通过了\n        return createSuccessAuthentication(principalToReturn, authentication, user);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>上面第二步，从数据库中获取 UserDetails 信息，默认实现是 DaoAuthenticationProvider 的 retrieveUser方法，见 3.1.12</strong><br><img src=\"https://img-blog.csdnimg.cn/7b4de9a070eb4543a300df967a985c91.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-12-DaoAuthenticationProvider\"><a href=\"#3-1-12-DaoAuthenticationProvider\" class=\"headerlink\" title=\"3.1.12 DaoAuthenticationProvider\"></a>3.1.12 DaoAuthenticationProvider</h3><p>从 UserDetailsService 检索用户详细信息的 AuthenticationProvider 实现，提供利用数据库进行身份验证的一个类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider &#123;\n\n    protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;\n        prepareTimingAttackProtection();\n        try &#123;\n\n            &#x2F;&#x2F; 重要方法 调用自定义 UserDetailsService 的 loadUserByUsername 方法\n            UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);\n            if (loadedUser &#x3D;&#x3D; null) &#123;\n                throw new InternalAuthenticationServiceException(\n                        &quot;UserDetailsService returned null, which is an interface contract violation&quot;);\n            &#125;\n            return loadedUser;\n        &#125;\n        catch (UsernameNotFoundException ex) &#123;\n            mitigateAgainstTimingAttack(authentication);\n            throw ex;\n        &#125;\n        catch (InternalAuthenticationServiceException ex) &#123;\n            throw ex;\n        &#125;\n        catch (Exception ex) &#123;\n            throw new InternalAuthenticationServiceException(ex.getMessage(), ex);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-1-13-AuthenticationEntryPoint-和-AccessDeniedHandler\"><a href=\"#3-1-13-AuthenticationEntryPoint-和-AccessDeniedHandler\" class=\"headerlink\" title=\"3.1.13 AuthenticationEntryPoint 和 AccessDeniedHandler\"></a>3.1.13 AuthenticationEntryPoint 和 AccessDeniedHandler</h3><p>在 Spring Security 中，如果在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到。在 ExceptionTranslationFilter 中会去判断是认证失败还是授权失败出现的异常</p>\n<ul>\n<li>如果是<strong>认证过程中出现的异常</strong>会被封装成 AuthenticationExceptio，然后调用 <strong>AuthenticationEntryPoint</strong> 对象的方法去进行异常处理</li>\n<li>如果是<strong>授权过程中出现的异常</strong>会被封装成 AccessDeniedExceptio，然后调用 <strong>AccessDeniedHandler</strong> 对象的方法去进行异常处理</li>\n</ul>\n<p>所以如果需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint 和 AccessDeniedHandler，然后配置给 Spring Security 即可<br><strong>AuthenticationEntryPoint 实现类：</strong><br><img src=\"https://img-blog.csdnimg.cn/fa1a0f31e1864010b620bd1e8a1386d6.png\" alt=\"在这里插入图片描述\"><br><strong>AccessDeniedHandler 实现类：</strong><br><img src=\"https://img-blog.csdnimg.cn/6105ac58527040b1817337a83694b47c.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-1-14-LoginUrlAuthenticationEntryPoint\"><a href=\"#3-1-14-LoginUrlAuthenticationEntryPoint\" class=\"headerlink\" title=\"3.1.14 LoginUrlAuthenticationEntryPoint\"></a>3.1.14 LoginUrlAuthenticationEntryPoint</h3><ol>\n<li>由 ExceptionTranslationFilter 用于通过 UsernamePasswordAuthenticationFilter 开始表单登录身份验证。<strong>在 loginFormUrl 属性中保存登录表单的位置，并使用它来构建到登录页面的重定向 URL，从而开始一个认证流程。</strong> 或者可以在此属性中设置绝对 URL，并将其专门使用</li>\n<li>使用相对 URL 时，可以将 forceHttps 属性设置为 true，以强制用于登录表单的协议为 HTTPS，即使原始截获的资源请求使用 HTTP 协议也是如此。发生这种情况时，在成功登录（通过 HTTPS）后，原始资源仍将通过原始请求 URL 作为 HTTP 访问。要使强制 HTTPS 功能正常工作，要咨询 PortMapper 以确定 HTTP:HTTPS 对。如果使用绝对 URL，则 forceHttps 的值将不起作用</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LoginUrlAuthenticationEntryPoint implements AuthenticationEntryPoint, InitializingBean &#123;\n\n\tprivate static final Log logger &#x3D; LogFactory.getLog(LoginUrlAuthenticationEntryPoint.class);\n\tprivate PortMapper portMapper &#x3D; new PortMapperImpl();\n\tprivate PortResolver portResolver &#x3D; new PortResolverImpl();\n\tprivate String loginFormUrl;\n\n\t&#x2F;&#x2F; 是否强制使用 HTTPS 进行登录认证，默认 false\n\tprivate boolean forceHttps &#x3D; false;\n\n\t&#x2F;&#x2F; 指定是否要使用 forward，默认 false， \n\tprivate boolean useForward &#x3D; false;\n\n\t&#x2F;&#x2F; 跳转到登录页面的重定向策略\n\tprivate final RedirectStrategy redirectStrategy &#x3D; new DefaultRedirectStrategy();\n\n\t&#x2F;&#x2F; loginFormUrl 登录页面的url。使用相对路径（web-app context path 应用上下文路径，包括前缀 &#123;@code &#x2F;&#125;）或绝对 URL\n\tpublic LoginUrlAuthenticationEntryPoint(String loginFormUrl) &#123;\n\t\tAssert.notNull(loginFormUrl, &quot;loginFormUrl cannot be null&quot;);\n\t\tthis.loginFormUrl &#x3D; loginFormUrl;\n\t&#125;\n\n\t&#x2F;&#x2F; InitializingBean 接口定义的方法，在该bean创建后初始化阶段会调用该方法，主要是对属性 loginFormUrl进行格式检查和断言\n\t@Override\n\tpublic void afterPropertiesSet() &#123;\n\t\tAssert.isTrue(StringUtils.hasText(this.loginFormUrl) &amp;&amp; UrlUtils.isValidRedirectUrl(this.loginFormUrl), &quot;loginFormUrl must be specified and must be a valid redirect URL&quot;);\n\t\tAssert.isTrue(!this.useForward || !UrlUtils.isAbsoluteUrl(this.loginFormUrl), &quot;useForward must be false if using an absolute loginFormURL&quot;);\n\t\tAssert.notNull(this.portMapper, &quot;portMapper must be specified&quot;);\n\t\tAssert.notNull(this.portResolver, &quot;portResolver must be specified&quot;);\n\t&#125;\n\n\t&#x2F;&#x2F; Allows subclasses to modify the login form URL that should be applicable for a given request\n\t&#x2F;&#x2F; 确定登录页面的 URL，子类可以覆盖实现该方法修改最终要应用的 URL\n\tprotected String determineUrlToUseForThisRequest(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) &#123;\n\t\treturn getLoginFormUrl();\n\t&#125;\n\n\t&#x2F;&#x2F; Performs the redirect (or forward) to the login form URL.\n\t&#x2F;&#x2F; 执行到 login 表单 URL 的重定向（或转发）\n    @Override\n\tpublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;\n\t\t&#x2F;&#x2F; 是否使用 forward，默认值为 false，取非则为 true，所以不走转发而是重定向\n\t\tif (!this.useForward) &#123;\n\t\t\t&#x2F;&#x2F; redirect to login page. Use https if forceHttps true\n\t\t\t&#x2F;&#x2F; 重定向到 login 页面。如果 forceHttps 为真，则使用 https\n\t\t\tString redirectUrl &#x3D; buildRedirectUrlToLoginPage(request, response, authException);\n\t\t\t&#x2F;&#x2F; 使用 response.sendRedirect(redirectUrl);\n\t\t\tthis.redirectStrategy.sendRedirect(request, response, redirectUrl);\n\t\t\treturn;\n\t\t&#125;\n\t\tString redirectUrl &#x3D; null;\n\t\tif (this.forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) &#123;\n\t\t\t&#x2F;&#x2F; First redirect the current request to HTTPS. When that request is received,\n\t\t\t&#x2F;&#x2F; the forward to the login page will be used.\n\t\t\tredirectUrl &#x3D; buildHttpsRedirectUrlForRequest(request);\n\t\t&#125;\n\t\tif (redirectUrl !&#x3D; null) &#123;\n\t\t\tthis.redirectStrategy.sendRedirect(request, response, redirectUrl);\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 转发\n\t\tString loginForm &#x3D; determineUrlToUseForThisRequest(request, response, authException);\n\t\tlogger.debug(LogMessage.format(&quot;Server side forward to: %s&quot;, loginForm));\n\t\tRequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(loginForm);\n\t\tdispatcher.forward(request, response);\n\t\treturn;\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"3-2-授权流程\"><a href=\"#3-2-授权流程\" class=\"headerlink\" title=\"3.2 授权流程\"></a>3.2 授权流程</h2><h3 id=\"3-2-1-FilterSecurityInterceptor\"><a href=\"#3-2-1-FilterSecurityInterceptor\" class=\"headerlink\" title=\"3.2.1 FilterSecurityInterceptor\"></a>3.2.1 FilterSecurityInterceptor</h3><p>FilterSecurityInterceptor 是针对某个请求的层级进行拦截和安全检查，是比较常用的。还有支持方法层级的、AspectJ 层级的(更细的方法层级)。继承自AbstractSecurityInterceptor<br><img src=\"https://img-blog.csdnimg.cn/71db351716f4475f93d0cf06f73c96e0.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123;\n  \n    &#x2F;&#x2F; 权限鉴定入口，由 filter 链进行调用\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n        FilterInvocation fi &#x3D; new FilterInvocation(request, response, chain);\n        &#x2F;&#x2F; 调用开始\n        invoke(fi);\n    &#125;\n  \n    public void invoke(FilterInvocation fi) throws IOException, ServletException &#123;\n  \n        &#x2F;&#x2F; fi.getRequest()一定不为null，observeOncePerRequest 默认为 true\n        &#x2F;&#x2F; getAttribute(FILTER_APPLIED)第一次进来没有值\n        if ((fi.getRequest() !&#x3D; null)\n                &amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) !&#x3D; null)\n                &amp;&amp; observeOncePerRequest) &#123;\n            &#x2F;&#x2F; 进来这里表示已经处理过一次请求了，不需要重新做安全检查\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; 进到这里表示第一次请求，需要进行安全检查\n            if (fi.getRequest() !&#x3D; null &amp;&amp; observeOncePerRequest) &#123;\n                &#x2F;&#x2F;将FILTER_APPLIED标识放入request中\n                fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);\n            &#125;\n\n            InterceptorStatusToken token &#x3D; super.beforeInvocation(fi);\n\n            try &#123;\n                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n            &#125;\n            finally &#123;\n                super.finallyInvocation(token);\n            &#125;\n\n            super.afterInvocation(token, null);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-2-2-FilterInvocation\"><a href=\"#3-2-2-FilterInvocation\" class=\"headerlink\" title=\"3.2.2 FilterInvocation\"></a>3.2.2 FilterInvocation</h3><p>保存与 HTTP 过滤器关联的对象，保证请求对象和响应对象是 HttpServletRequest 的实例和 HttpServletResponse 的实例，并且没有 null 对象。为了 Security 框架内的类才能获得对过滤器环境的访问权，以及请求和响应</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FilterInvocation &#123;\n  \n    public FilterInvocation(ServletRequest request, ServletResponse response,\n            FilterChain chain) &#123;\n        &#x2F;&#x2F; 保证获取到非 null 的 request 和 response\n        if ((request &#x3D;&#x3D; null) || (response &#x3D;&#x3D; null) || (chain &#x3D;&#x3D; null)) &#123;\n            throw new IllegalArgumentException(&quot;Cannot pass null values to constructor&quot;);\n        &#125;\n\n        this.request &#x3D; (HttpServletRequest) request;\n        this.response &#x3D; (HttpServletResponse) response;\n        this.chain &#x3D; chain;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-2-3-AbstractSecurityInterceptor\"><a href=\"#3-2-3-AbstractSecurityInterceptor\" class=\"headerlink\" title=\"3.2.3 AbstractSecurityInterceptor\"></a>3.2.3 AbstractSecurityInterceptor</h3><ol>\n<li>为安全对象实现安全拦截的抽象类。 AbstractSecurityInterceptor 将确保安全拦截器的正确启动配置。它还将实现对安全对象调用的正确处理，即： 从 SecurityContextHolder 中获取 Authentication 对象。通过针对 SecurityMetadataSource 查找安全对象请求来确定请求是与安全调用还是公共调用相关</li>\n<li>对于受保护的调用（有一个用于安全对象调用的 ConfigAttributes 列表）：如果 Authentication.isAuthenticated() 返回 false，或者 alwaysReauthenticate 为 true，则根据配置的 AuthenticationManager 验证请求</li>\n<li>通过身份验证后，将 SecurityContextHolder 上的 Authentication 对象替换为返回的值。根据配置的 AccessDecisionManager 授权请求。通过配置的 RunAsManager 执行任何运行方式替换。将控制权交还给具体的子类，该子类实际上将继续执行对象。返回一个 InterceptorStatusToken，以便在子类完成执行对象后，其 finally 子句可以确保重新调用 AbstractSecurityInterceptor 并使用 finallyInvocation(InterceptorStatusToken) 正确整理</li>\n<li>具体子类将通过 afterInvocation(InterceptorStatusToken, Object) 方法重新调用 AbstractSecurityInterceptor。如果 RunAsManager 替换了 Authentication 对象，则将 SecurityContextHolder 返回到调用 AuthenticationManager 后存在的对象。如果定义了 AfterInvocationManager，则调用调用管理器并允许它替换因返回给调用者的对象。对于公开的调用（安全对象调用没有 ConfigAttributes）：如上所述，具体子类将返回一个 InterceptorStatusToken，随后在执行安全对象后将其重新呈现给 AbstractSecurityInterceptor。当调用其 afterInvocation(InterceptorStatusToken, Object) 时，AbstractSecurityInterceptor 不会采取进一步的行动。控制再次返回到具体的子类，连同应该返回给调用者的对象。然后子类将该结果或异常返回给原始调用者</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractSecurityInterceptor implements InitializingBean,ApplicationEventPublisherAware, MessageSourceAware &#123;\n\n\t&#x2F;&#x2F; object为 FilterInvocation\n    protected InterceptorStatusToken beforeInvocation(Object object) &#123;\n        &#x2F;&#x2F; 省略次要代码\n\n        &#x2F;&#x2F; 在此处获取ConfigAttribute集合,是通过调用SecurityMetadataSource的getAttributes方法获取的,\n        &#x2F;&#x2F; 可以使用的自定义的 FilterInvocationSecurityMetadataSource\n        Collection&lt;ConfigAttribute&gt; attributes &#x3D; this.obtainSecurityMetadataSource().getAttributes(object);\n\n        &#x2F;&#x2F; 第一次进来会会获取到 AnonymousAuthenticationToken，是在 AnonymousAuthenticationFilter 中初始化的，也就是匿名请求\n        if (SecurityContextHolder.getContext().getAuthentication() &#x3D;&#x3D; null) &#123;\n            credentialsNotFound(messages.getMessage(\n                    &quot;AbstractSecurityInterceptor.authenticationNotFound&quot;,\n                    &quot;An Authentication object was not found in the SecurityContext&quot;),\n                    object, attributes);\n        &#125;\n\n        &#x2F;&#x2F; 判断是否检查当前身份,验证 Token，并返回 Authentication 对象\n        &#x2F;&#x2F; 第一次进去不符合条件直接返回匿名Token 对象\n        Authentication authenticated &#x3D; authenticateIfRequired();\n\n        &#x2F;&#x2F; 尝试进行授权\n        try &#123;\n            &#x2F;&#x2F; 真正进行鉴定权限的地方通过的方法是在 AccessDecisionManager中的，可以自定义实现类进行使用\n            &#x2F;&#x2F; 第一次进来是匿名Token对象,角色也是 &quot;ROLE_anonymous&quot; 没有一定会抛异常\n            this.accessDecisionManager.decide(authenticated, object, attributes);\n        &#125;\n        catch (AccessDeniedException accessDeniedException) &#123;\n            publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated, accessDeniedException));\n\n            throw accessDeniedException;\n        &#125;\n\n        if (debug) &#123;\n            logger.debug(&quot;Authorization successful&quot;);\n        &#125;\n\n        if (publishAuthorizationSuccess) &#123;\n            publishEvent(new AuthorizedEvent(object, attributes, authenticated));\n        &#125;\n\n        &#x2F;&#x2F; Attempt to run as a different user\n        Authentication runAs &#x3D; this.runAsManager.buildRunAs(authenticated, object, attributes);\n\n        if (runAs &#x3D;&#x3D; null) &#123;\n            if (debug) &#123;\n                logger.debug(&quot;RunAsManager did not change Authentication object&quot;);\n            &#125;\n\n            &#x2F;&#x2F; no further work post-invocation\n            return new InterceptorStatusToken(SecurityContextHolder.getContext(), false, attributes, object);\n        &#125;\n        else &#123;\n            if (debug) &#123;\n                logger.debug(&quot;Switching to RunAs Authentication: &quot; + runAs);\n            &#125;\n\n            SecurityContext origCtx &#x3D; SecurityContextHolder.getContext();\n            SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());\n            SecurityContextHolder.getContext().setAuthentication(runAs);\n\n            &#x2F;&#x2F; need to revert to token.Authenticated post-invocation\n            return new InterceptorStatusToken(origCtx, true, attributes, object);\n        &#125;\n        this.logger.trace(&quot;Did not switch RunAs authentication since RunAsManager returned null&quot;);\n\t\t&#x2F;&#x2F; no further work post-invocation\n\t\treturn new InterceptorStatusToken(SecurityContextHolder.getContext(), false, attributes, object);\n    &#125;\n\n\t&#x2F;** 在安全对象调用完成后完成 AbstractSecurityInterceptor 的工作。\n\tParams：token - 由 beforeInvocation(Object) 方法返回 returnedObject - 从安全对象调用返回的任何对象（可能为 null） \n\tReturns：安全对象调用最终应返回给其调用者的对象（可能为 null）\n\t*&#x2F;\n\tprotected Object afterInvocation(InterceptorStatusToken token, Object returnedObject) &#123;\n\t\tif (token &#x3D;&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; public object\n\t\t\treturn returnedObject;\n\t\t&#125;\n\t\tfinallyInvocation(token); &#x2F;&#x2F; continue to clean in this method for passivity\n\t\tif (this.afterInvocationManager !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; Attempt after invocation handling\n\t\t\ttry &#123;\n\t\t\t\treturnedObject &#x3D; this.afterInvocationManager.decide(token.getSecurityContext().getAuthentication(),\n\t\t\t\t\t\ttoken.getSecureObject(), token.getAttributes(), returnedObject);\n\t\t\t&#125;\n\t\t\tcatch (AccessDeniedException ex) &#123;\n\t\t\t\tpublishEvent(new AuthorizationFailureEvent(token.getSecureObject(), token.getAttributes(),\n\t\t\t\t\t\ttoken.getSecurityContext().getAuthentication(), ex));\n\t\t\t\tthrow ex;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn returnedObject;\n\t&#125;\n\n\t&#x2F;**\n    如果 Authentication.isAuthenticated() 返回 false 或属性 alwaysReauthenticate 已设置为 true，\n    则检查当前身份验证令牌并将其传递给 AuthenticationManager。返回经过身份验证的 Authentication 对象。\n    *&#x2F;\n\tprivate Authentication authenticateIfRequired() &#123;\n\t\tAuthentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication();\n\t\tif (authentication.isAuthenticated() &amp;&amp; !this.alwaysReauthenticate) &#123;\n\t\t\tif (this.logger.isTraceEnabled()) &#123;\n\t\t\t\tthis.logger.trace(LogMessage.format(&quot;Did not re-authenticate %s before authorizing&quot;, authentication));\n\t\t\t&#125;\n\t\t\treturn authentication;\n\t\t&#125;\n\t\tauthentication &#x3D; this.authenticationManager.authenticate(authentication);\n\t\t&#x2F;&#x2F; Don&#39;t authenticated.setAuthentication(true) because each provider does that\n\t\tif (this.logger.isDebugEnabled()) &#123;\n\t\t\tthis.logger.debug(LogMessage.format(&quot;Re-authenticated %s before authorizing&quot;, authentication));\n\t\t&#125;\n\t\tSecurityContext context &#x3D; SecurityContextHolder.createEmptyContext();\n\t\tcontext.setAuthentication(authentication);\n\t\tSecurityContextHolder.setContext(context);\n\t\treturn authentication;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"3-2-4-SecurityMetadataSource\"><a href=\"#3-2-4-SecurityMetadataSource\" class=\"headerlink\" title=\"3.2.4 SecurityMetadataSource\"></a>3.2.4 SecurityMetadataSource</h3><p>由存储并可以识别应用于给定安全对象调用的 ConfigAttributes 的类实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface SecurityMetadataSource extends AopInfrastructureBean &#123;\n\n\t&#x2F;&#x2F; 访问适用于给定安全对象的 ConfigAttributes\n\tCollection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException;\n\n\t&#x2F;&#x2F; 如果可用，则返回实现类定义的所有 ConfigAttributes\n\t&#x2F;&#x2F; AbstractSecurityInterceptor 使用它来执行针对它配置的每个 ConfigAttribute 的启动时间验证\n\tCollection&lt;ConfigAttribute&gt; getAllConfigAttributes();\n\n\t&#x2F;&#x2F; 指示 SecurityMetadataSource 实现是否能够为指示的安全对象类型提供 ConfigAttributes\n\tboolean supports(Class&lt;?&gt; clazz);\n\n&#125;</code></pre>\n\n<p><strong>继承关系：</strong><br><img src=\"https://img-blog.csdnimg.cn/fc2b7cba53a543a78ea5a9d176ba1ba6.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-2-5-FilterInvocationSecurityMetadataSource\"><a href=\"#3-2-5-FilterInvocationSecurityMetadataSource\" class=\"headerlink\" title=\"3.2.5 FilterInvocationSecurityMetadataSource\"></a>3.2.5 FilterInvocationSecurityMetadataSource</h3><p>继承 SecurityMetadataSource 接口，旨在执行在 FilterInvocations 上键入的查找</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface FilterInvocationSecurityMetadataSource extends SecurityMetadataSource &#123;\n\n&#125;</code></pre>\n\n<p><strong>自定义实现类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 自定义认证数据源\n@Service\npublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123;\n\n    &#x2F;&#x2F; ant风格的URL匹配\n    AntPathMatcher antPathMatcher &#x3D; new AntPathMatcher();\n\n    @Autowired\n    MenuMapper menuMapper;\n\n    &#x2F;**\n     * @param object  一个FilterInvocation\n     * @return  Collection&lt;ConfigAttribute&gt; 当前请求URL所需的角色\n     * @throws IllegalArgumentException\n     *&#x2F;\n    @Override\n    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;\n        &#x2F;&#x2F; 从FilterInvocation中获取当前请求的URL\n        String requestUrl &#x3D; ((FilterInvocation) object).getRequestUrl();\n        &#x2F;&#x2F; 从数据库中获取所有的资源(角色和menu都查询)信息,可以缓存\n        List&lt;Menu&gt; allMenus &#x3D; menuMapper.getAllMenus();\n        &#x2F;&#x2F; 遍历获取当前请求的URL所需要的角色信息\n        for (Menu menu : allMenus) &#123;\n            if (antPathMatcher.match(menu.getPattern(), requestUrl)) &#123;\n                List&lt;Role&gt; roles &#x3D; menu.getRoles();\n                String[] roleArr &#x3D; new String[roles.size()];\n                for (int i &#x3D; 0; i &lt; roleArr.length; i++) &#123;\n                    roleArr[i] &#x3D; roles.get(i).getName();\n                &#125;\n                return SecurityConfig.createList(roleArr);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 假设不存在URL对应的角色,则登录后即可访问\n        return SecurityConfig.createList(&quot;ROLE_LOGIN&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 获取所有定义好的权限资源\n    @Override\n    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 返回类对象是否支持校验\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) &#123;\n        return FilterInvocation.class.isAssignableFrom(clazz);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"3-2-6-ConfigAttribute\"><a href=\"#3-2-6-ConfigAttribute\" class=\"headerlink\" title=\"3.2.6 ConfigAttribute\"></a>3.2.6 ConfigAttribute</h3><p>存储与安全系统相关的配置属性。设置 org.springframework.security.access.intercept.AbstractSecurityInterceptor 时，会为安全对象模式定义配置属性列表。这些配置属性对 RunAsManager、AccessDecisionManager 或 AccessDecisionManager 的继承类具有特殊意义。在运行时与同一安全对象目标的其他 ConfigAttributes 一起存储。对于AccessDecisionManager 可以用这个列表进行决定访问的对象是否符合安全样式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ConfigAttribute extends Serializable &#123;\n\t&#x2F;** 如果 ConfigAttribute 可以表示为字符串，并且该字符串的精度足以被 RunAsManager、AccessDecisionManager 或 AccessDecisionManager 的继承类作为配置参数依赖，\n\t则此方法应返回这样的字符串。如果 ConfigAttribute 不能以足够的精度表示为字符串，则应返回 null。\n\t返回 null 将需要任何依赖类专门支持 ConfigAttribute 实现，因此除非确实需要，否则应避免返回 null。\n\t*&#x2F;\n    String getAttribute();\n&#125;</code></pre>\n\n<h3 id=\"3-2-7-SecurityConfig\"><a href=\"#3-2-7-SecurityConfig\" class=\"headerlink\" title=\"3.2.7 SecurityConfig\"></a>3.2.7 SecurityConfig</h3><p><strong>将 ConfigAttribute 存储为字符串</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SecurityConfig implements ConfigAttribute &#123;\n\n\tprivate final String attrib;\n\n\tpublic SecurityConfig(String config) &#123;\n\t\tAssert.hasText(config, &quot;You must provide a configuration attribute&quot;);\n\t\tthis.attrib &#x3D; config;\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;</code></pre>\n\n<h3 id=\"3-2-8-AccessDecisionManager\"><a href=\"#3-2-8-AccessDecisionManager\" class=\"headerlink\" title=\"3.2.8 AccessDecisionManager\"></a>3.2.8 AccessDecisionManager</h3><p>进行最终的访问控制（授权）决定。当一个请求走完 FilterInvocationSecurityMetadataSource 中的 getAttributes 方法后就会到 AccessDecisionManager 中进行角色信息的对比</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface AccessDecisionManager &#123;\n\n\t&#x2F;&#x2F; Resolves an access control decision for the passed parameters.\n\t&#x2F;&#x2F; 解决传递参数的访问控制决策。\n\tvoid decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException;\n\n\t&#x2F;&#x2F; 指示此 AccessDecisionManager 是否能够处理使用传递的 ConfigAttribute 呈现的授权请求\n\t&#x2F;&#x2F; 这允许 AbstractSecurityInterceptor 检查每个配置属性可以被配置的 AccessDecisionManager and&#x2F;or RunAsManager and&#x2F;or AfterInvocationManager 使用\n\tboolean supports(ConfigAttribute attribute);\n\n\t&#x2F;&#x2F; 指示 AccessDecisionManager 实现是否能够为指示的安全对象类型提供访问控制决策\n\tboolean supports(Class&lt;?&gt; clazz);\n&#125;</code></pre>\n\n<p><strong>自定义实现类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class CustomAccessDecisionManager implements AccessDecisionManager &#123;\n\n\n    &#x2F;* 取当前用户的权限与这次请求的这个url需要的权限作对比，决定是否放行\n     * auth 包含了当前的用户信息，包括拥有的权限,即之前UserDetailsService登录时候存储的用户对象\n     * object 就是FilterInvocation对象，可以得到request等web资源。\n     * configAttributes 是本次访问需要的权限。即上一步的 MyFilterInvocationSecurityMetadataSource 中查询核对得到的权限列表 \n     *&#x2F;\n    @Override\n    public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123;\n        for (ConfigAttribute configAttribute : configAttributes) &#123;\n            if (authentication &#x3D;&#x3D; null)&#123;\n                throw new AccessDeniedException(&quot;当前访问没有权限&quot;);\n            &#125;\n            &#x2F;&#x2F; 当前请求需要的权限\n            String needRole &#x3D; configAttribute.getAttribute();\n            if (&quot;ROLE_LOGIN&quot;.equals(needRole))&#123;\n                if (authentication instanceof AnonymousAuthenticationToken)&#123;\n                    throw new  BadCredentialsException(&quot;未登录&quot;);\n                &#125;\n                return;\n            &#125;\n            &#x2F;&#x2F; 当前用户所具有的权限\n            Collection&lt;? extends GrantedAuthority&gt; authorities &#x3D; authentication.getAuthorities();\n            for (GrantedAuthority authority : authorities) &#123;\n                if (authority.getAuthority().equals(needRole))&#123;\n                    return;\n                &#125;\n            &#125;\n        &#125;\n        throw new AccessDeniedException(&quot;权限不足&quot;);\n    &#125;\n\n    @Override\n    public boolean supports(ConfigAttribute attribute) &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) &#123;\n        return true;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"3-3-整体流程\"><a href=\"#3-3-整体流程\" class=\"headerlink\" title=\"3.3 整体流程\"></a>3.3 整体流程</h2><p><img src=\"https://img-blog.csdnimg.cn/652f25a506ef4592ac0f79f538847c4d.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>查看 SecurityContext 接口及其实现类 SecurityContextImpl ， 该类其实就是 对Authentication 的封装</li>\n<li>查看 SecurityContextHolder 类 ，该类其实是对 ThreadLocal 的封装 ， 存储 SecurityContext 对象</li>\n</ul>\n<p>在 UsernamePasswordAuthenticationFilter 过滤器认证成功之后，会在认证成功的处理方法中将已认证的用户信息对象 Authentication 封装进 SecurityContext，并存入 SecurityContextHolder。之后，响应会通过 SecurityContextPersistenceFilter 过滤器，将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository（<strong>一般用 HttpSession 进行存储</strong>），同时清除 SecurityContextHolder 所持有的 SecurityContext</p>\n<p>认证成功的响应通过 SecurityContextPersistenceFilter 过滤器时，从配置好的 SecurityContextRepository 中获取该请求相关的安全上下文信息 SecurityContext，然后加载到 SecurityContextHolder 中。当请求再次到来时，请求首先经过该过滤器，该过滤器会判断当前请求是否存有 SecurityContext 对象，如果有则将该对象取出再次放入 SecurityContextHolder 中，之后该请求所在的线程获得认证用户信息，后续的资源访问不需要进行身份认证；当响应再次返回时，该过滤器同样将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository（<strong>一般用 HttpSession 进行存储</strong>），同时清除 SecurityContextHolder 所持有的 SecurityContext</p>\n<h3 id=\"3-3-1-SecurityContext\"><a href=\"#3-3-1-SecurityContext\" class=\"headerlink\" title=\"3.3.1 SecurityContext\"></a>3.3.1 SecurityContext</h3><p>安全上下文，用户通过 Spring Security 的校验之后，验证信息 Authentication 存储在 SecurityContext 中，SecurityContext 存储在 SecurityContextHolder 中。接口定义如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface SecurityContext extends Serializable &#123;\n    &#x2F;&#x2F; 获取当前经过身份验证的主体，或身份验证请求令牌\n    Authentication getAuthentication();\n\n\t&#x2F;&#x2F; 更改当前经过身份验证的主体，或删除身份验证信息\n    void setAuthentication(Authentication var1);\n&#125;</code></pre>\n\n<p>这里只定义了两个方法，主要都是用来获取或修改认证信息（Authentication），Authentication 是用来存储着认证用户的信息，所以这个接口可以间接获取到用户的认证信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SecurityContext securityContext &#x3D; SecurityContextHolder.getContext();\nAuthentication authentication &#x3D; securityContext.getAuthentication();\nUser user &#x3D; (User) authentication.getPrincipal();</code></pre>\n\n<p><strong>实现类：</strong><br><img src=\"https://img-blog.csdnimg.cn/756badcec5b546999f231710eea588c7.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-3-2-SecurityContextHolder\"><a href=\"#3-3-2-SecurityContextHolder\" class=\"headerlink\" title=\"3.3.2 SecurityContextHolder\"></a>3.3.2 SecurityContextHolder</h3><ol>\n<li>将给定的 SecurityContext 与当前执行线程相关联。此类提供了一系列委托给 SecurityContextHolderStrategy 实例的静态方法。该类的目的是提供一种方便的方法来指定应该用于给定 JVM 的策略。这是 JVM 范围的设置，因为此类中的所有内容都是静态的，以便于调用代码时使用。</li>\n<li>要指定应使用哪种策略，必须提供模式设置。模式设置是定义为静态最终字段的三个有效 MODE_ 设置之一，或者是提供公共无参数构造函数的 SecurityContextHolderStrategy 具体实现的完全限定类名。</li>\n<li>有两种方法可以指定所需的策略模式字符串。第一种是通过在 SYSTEM_PROPERTY 上键入的系统属性来指定它。第二种是在使用类之前调用 setStrategyName(String)。如果这两种方法都没有使用，则该类将默认使用 MODE_THREADLOCAL，它向后兼容，具有较少的 JVM 不兼容性并且适用于服务器（而 MODE_GLOBAL 绝对不适合服务器使用）</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SecurityContextHolder &#123;\n\n\tpublic static final String MODE_THREADLOCAL &#x3D; &quot;MODE_THREADLOCAL&quot;;\n\n\tpublic static final String MODE_INHERITABLETHREADLOCAL &#x3D; &quot;MODE_INHERITABLETHREADLOCAL&quot;;\n\n\tpublic static final String MODE_GLOBAL &#x3D; &quot;MODE_GLOBAL&quot;;\n\n\tprivate static final String MODE_PRE_INITIALIZED &#x3D; &quot;MODE_PRE_INITIALIZED&quot;;\n\n\tpublic static final String SYSTEM_PROPERTY &#x3D; &quot;spring.security.strategy&quot;;\n\n\tprivate static String strategyName &#x3D; System.getProperty(SYSTEM_PROPERTY);\n\n\tprivate static SecurityContextHolderStrategy strategy;\n\n\tprivate static int initializeCount &#x3D; 0;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;</code></pre>\n\n<p>在典型的 Web 应用程序中，用户登录一次，然后由其会话ID标识。服务器缓存持续时间会话的主体信息。但是在 Spring Security 中，在请求之间存储 SecurityContext 的责任落在 SecurityContextPersistenceFilter 上，默认情况下，该过滤器将上下文存储为HTTP请求之间的 HttpSession 属性。请求访问时它会为每个请求恢复上下文 SecurityContextHolder，并且最重要的是，在请求完成时清除 SecurityContextHolder<br><img src=\"https://img-blog.csdnimg.cn/bae97403cf504205a4d3064041dbe11f.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"4-SpringSecurity-Web-权限\"><a href=\"#4-SpringSecurity-Web-权限\" class=\"headerlink\" title=\"4. SpringSecurity Web 权限\"></a>4. SpringSecurity Web 权限</h1><p><font color=\"red\"><strong>Spring Security 的核心配置类是 WebSecurityConfigurerAdapter 抽象类，这是权限管理启动的入口</strong></font></p>\n<p><strong>在 Spring Security 5.7.1 或 SpringBoot 2.7.0 之后，该类被弃用了，改动见 4.8</strong></p>\n<h2 id=\"4-1-设置登录系统的账号、密码\"><a href=\"#4-1-设置登录系统的账号、密码\" class=\"headerlink\" title=\"4.1 设置登录系统的账号、密码\"></a>4.1 设置登录系统的账号、密码</h2><h3 id=\"4-1-1-YML\"><a href=\"#4-1-1-YML\" class=\"headerlink\" title=\"4.1.1 YML\"></a>4.1.1 YML</h3><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  security:\n    user:\n      name: fan\n      password: fan</code></pre>\n\n<h3 id=\"4-1-2-配置基于内存的角色授权和认证信息\"><a href=\"#4-1-2-配置基于内存的角色授权和认证信息\" class=\"headerlink\" title=\"4.1.2 配置基于内存的角色授权和认证信息\"></a>4.1.2 配置基于内存的角色授权和认证信息</h3><p>继承 WebSecurityConfigurerAdapter，重写 configure(AuthenticationManagerBuilder auth) 方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        BCryptPasswordEncoder bCryptPasswordEncoder &#x3D; new BCryptPasswordEncoder();\n        &#x2F;&#x2F; 对密码进行加密\n        String encode &#x3D; bCryptPasswordEncoder.encode(&quot;fan223&quot;);\n        &#x2F;&#x2F; 设置用户名、加密后的密码、权限\n        auth.inMemoryAuthentication().withUser(&quot;fan223&quot;).password(encode).roles(&quot;admin&quot;);\n    &#125;\n\n\t&#x2F;&#x2F; 需要注入一个 PasswordEncoder 的 Bean，不然会报错，找不到 PasswordEncoder\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        &#x2F;&#x2F; return new BCryptPasswordEncoder();\n        return new PasswordEncoder() &#123;\n            @Override\n            public String encode(CharSequence charSequence) &#123;\n            \t&#x2F;&#x2F; 加密\n                return charSequence.toString();\n            &#125;\n\n            @Override\n            public boolean matches(CharSequence charSequence, String s) &#123;\n            \t&#x2F;&#x2F; 比对\n                return Objects.equals(charSequence.toString(), s);\n            &#125;\n        &#125;;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-1-3-配置基于数据库的认证信息和角色授权\"><a href=\"#4-1-3-配置基于数据库的认证信息和角色授权\" class=\"headerlink\" title=\"4.1.3 配置基于数据库的认证信息和角色授权\"></a>4.1.3 配置基于数据库的认证信息和角色授权</h3><p><strong>1、编写实现类</strong>，实现 UserDetailsService 接口，实现其 loadUserByUsername(String username) 方法，返回一个 UserDetails 接口的实现类 User 对象，包括用户名、密码、权限<br><strong>2、配置类里将实现类注入进入</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 实现类\n@Service\npublic class MyUserDetailsServiceImpl implements UserDetailsService &#123;\n    @Resource\n    private UserDAO userDAO;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F; 通过用户名从数据库查询用户信息\n        fan.springsecuritytest.entity.User selectOne &#x3D; userDAO.selectOne(new QueryWrapper&lt;fan.springsecuritytest.entity.User&gt;().eq(&quot;username&quot;, username));\n        if (ObjectUtils.isEmpty(selectOne))&#123;\n            throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F; 权限列表，应从数据库中查\n        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role, ROLE_sale&quot;);\n        &#x2F;&#x2F; 给用户设置权限和角色\n        return new User(selectOne.getUsername(), new BCryptPasswordEncoder().encode(selectOne.getPassword()), authorities);\n    &#125;\n&#125;\n&#x2F;&#x2F; 配置类，注入 UserDetailsServiceImpl\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n\t&#x2F;&#x2F; 注入 PasswordEncoder 类到 Spring 容器中，用来对密码进行加密\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"4-2-自定义表单认证登录（重要）\"><a href=\"#4-2-自定义表单认证登录（重要）\" class=\"headerlink\" title=\"4.2 自定义表单认证登录（重要）\"></a>4.2 自定义表单认证登录（重要）</h2><h3 id=\"4-2-1-配置类\"><a href=\"#4-2-1-配置类\" class=\"headerlink\" title=\"4.2.1 配置类\"></a>4.2.1 配置类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 配置类\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl; &#x2F;&#x2F; UserDetailsService 实现类\n\n\t@Resource\n    private AuthenticationSuccessHandler loginSuccessHandler; &#x2F;&#x2F; 认证成功结果处理器\n    &#x2F;&#x2F; 或 private LoginSuccessHandler loginSuccessHandler;\n    @Resource\n    private AuthenticationFailureHandler loginFailureHandler; &#x2F;&#x2F; 认证失败结果处理器\n    &#x2F;&#x2F; 或 private LoginFailureHandler loginFailureHandler;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n\t&#x2F;&#x2F; 注入 PasswordEncoder 类到 Spring 容器中，用来对密码进行加密\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.csrf().disable() &#x2F;&#x2F; 关闭跨站 csrf 攻击防护\n            &#x2F;&#x2F; 1.配置权限认证\n            .authorizeRequests()\n                &#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n                .antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;login&quot;, &quot;&#x2F;user&#x2F;login&quot;).permitAll()\n                &#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要 admin 权限才能访问该路径\n                .antMatchers(&quot;&#x2F;web&#x2F;admin&#x2F;**&quot;).hasAnyAuthority(&quot;admin&quot;)\n                .anyRequest() &#x2F;&#x2F; 任何其他请求\n                .authenticated(); &#x2F;&#x2F; 都需要认证\n                .and()\n            &#x2F;&#x2F; 2. 配置登录表单认证方式\n            .formLogin()\n                &#x2F;* 用户未登录时，访问任何资源都跳转到该路径，即登录页面，需要将这个地址设置为不认证也可以访问。如果不这样设置，\n                页面会提示“重定向次数过多”。因为登录的时候会访问 &quot;login&quot; 路径，设置新的登录地址后，一直来访问新的这个地址，\n                但是这个地址必须登录才可以访问，所以一直循环这样调用，就会出现重定向次数过多。需要在 Controller 中映射。 *&#x2F;\n                .loginPage(&quot;&#x2F;login&quot;)\n                &#x2F;&#x2F; 登录表单 form 中 action 的地址，也就是处理认证请求的路径，这个路径也需要放开，但不需要在 Controller 中映射\n                .loginProcessingUrl(&quot;&#x2F;user&#x2F;login&quot;)\n                &#x2F;&#x2F; 登录表单 form 中用户名输入框 input 的 name 名， 不改的话默认是 username\n                .usernameParameter(&quot;uname&quot;)\n                &#x2F;&#x2F; form 中密码输入框 input 的 name 名，不改默认是 password\n                .passwordParameter(&quot;pword&quot;)\n                &#x2F;&#x2F; .defaultSuccessUrl(&quot;&#x2F;success&quot;) &#x2F;&#x2F;登录认证成功后默认转跳的路径，与 successForwardUrl同效果\n                &#x2F;&#x2F; 登录成功跳转路径，假如不是直接访问 &#x2F;login，而是其他请求被拦截跳转到 &#x2F;login，则登录成功会转发到拦截的请求路径，不会跳转到该路径\n                .successForwardUrl(&quot;&#x2F;success&quot;)\n                .failureForwardUrl(&quot;&#x2F;error&quot;) &#x2F;&#x2F; 登录失败跳转路径，假如不设置就默认跳转到登录页\n                 &#x2F;&#x2F; 使用自定义的登录成功结果处理器\n                .successHandler(loginSuccessHandler)\n                &#x2F;&#x2F; 使用自定义登录失败的结果处理器\n                .failureHandler(loginFailureHandler)\n                .and()\n            &#x2F;&#x2F; 3. 注销\n            .logout()\n                .logoutUrl(&quot;&#x2F;logout&quot;) &#x2F;&#x2F; 配置注销登录请求URL为 &quot;&#x2F;logout&quot;（默认也就是 &#x2F;logout）\n                &#x2F;&#x2F; 使用自定义的注销成功结果处理器（优先级高）\n                .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n                &#x2F;&#x2F; 退出成功后跳转的路径\n                .logoutSuccessUrl(&quot;&#x2F;login&quot;)\n                .clearAuthentication(true) &#x2F;&#x2F; 清除身份认证信息\n                .invalidateHttpSession(true) &#x2F;&#x2F;使Http会话无效\n                .permitAll() &#x2F;&#x2F; 允许访问登录表单、登录接口\n                .and()\n            &#x2F;&#x2F; 4. session管理\n            .sessionManagement()\n                .invalidSessionUrl(&quot;&#x2F;login&quot;) &#x2F;&#x2F;失效后跳转到登陆页面\n                &#x2F;&#x2F;单用户登录，如果有一个登录了，同一个用户在其他地方登录将前一个剔除下线\n                &#x2F;&#x2F;.maximumSessions(1).expiredSessionStrategy(expiredSessionStrategy())\n                &#x2F;&#x2F;单用户登录，如果有一个登录了，同一个用户在其他地方不能登录\n                &#x2F;&#x2F;.maximumSessions(1).maxSessionsPreventsLogin(true);\n\t\thttp.headers().frameOptions().disable(); &#x2F;&#x2F; 开启运行iframe嵌套页面\n    &#125;\n  \n\t@Override\n\tpublic void configure(WebSecurity web) throws Exception &#123;\n\t\t&#x2F;&#x2F; 不进行认证的路径，可以直接访问，可以配置静态资源路径\n        web.ignoring().antMatchers(&quot;&#x2F;static&#x2F;**&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"4-2-2-配置静态资源\"><a href=\"#4-2-2-配置静态资源\" class=\"headerlink\" title=\"4.2.2 配置静态资源\"></a>4.2.2 配置静态资源</h3><p>仅仅通过 Spring Security 配置是不够的，还需要去重写 addResourceHandlers 方法去映射静态资源。写一个类 WebMvcConfig 继承 WebMvcConfigurationSupport</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport &#123;\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        registry.addResourceHandler(&quot;&#x2F;static&#x2F;**&quot;)\n                .addResourceLocations(&quot;classpath:&#x2F;static&#x2F;&quot;);\n        super.addResourceHandlers(registry);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-2-3-配置错误页面（非必要）\"><a href=\"#4-2-3-配置错误页面（非必要）\" class=\"headerlink\" title=\"4.2.3 配置错误页面（非必要）\"></a>4.2.3 配置错误页面（非必要）</h3><p>可以不进行配置，只需对应错误页面放在 &#x2F;error 文件夹下即可<br><img src=\"https://img-blog.csdnimg.cn/9f1fa3ababcc47028bd4515f6f5efc6f.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class ErrorPageConfig &#123;\n\n    @Bean\n    public WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer() &#123;\n        WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer &#x3D; new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123;\n            @Override\n            public void customize(ConfigurableWebServerFactory factory) &#123;\n                ErrorPage[] errorPages &#x3D; new ErrorPage[] &#123;\n                        new ErrorPage(HttpStatus.FORBIDDEN, &quot;&#x2F;403&quot;),\n                        new ErrorPage(HttpStatus.NOT_FOUND, &quot;&#x2F;404&quot;),\n                        new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;&#x2F;500&quot;),\n                &#125;;\n                factory.addErrorPages(errorPages);\n            &#125;\n        &#125;;\n        return webServerFactoryCustomizer;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-2-4-Controller\"><a href=\"#4-2-4-Controller\" class=\"headerlink\" title=\"4.2.4 Controller\"></a>4.2.4 Controller</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Controller\n@Controller\npublic class TestController &#123;\n    @GetMapping(&quot;&#x2F;login&quot;) &#x2F;&#x2F; 登录页面映射 .loginPage(&quot;&#x2F;login&quot;)\n    public String login()&#123;\n        return &quot;login&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;error&quot;) &#x2F;&#x2F; 错误页面映射 .failureForwardUrl(&quot;&#x2F;error&quot;) &#x2F;&#x2F; 登录失败跳转路径\n    public String error()&#123;\n        return &quot;error&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;success&quot;) &#x2F;&#x2F; 成功页面映射 .successForwardUrl(&quot;&#x2F;success&quot;) &#x2F;&#x2F; 登录成功跳转路径\n    public String success()&#123;\n        return &quot;success&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;hello&quot;) &#x2F;&#x2F; 不需要认证即可访问页面映射\n    public String hello()&#123;\n        return &quot;&#x2F;hello&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;test&quot;) &#x2F;&#x2F; 需要认证才可访问，访问该路径会自动跳转到 &#x2F;login，登录成功后才会转发到该路径\n    @ResponseBody\n    public String test()&#123;\n        return &quot;test 请求&quot;;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-2-5-自定义权限决策管理器\"><a href=\"#4-2-5-自定义权限决策管理器\" class=\"headerlink\" title=\"4.2.5 自定义权限决策管理器\"></a>4.2.5 自定义权限决策管理器</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class CustomAccessDecisionManager implements AccessDecisionManager &#123;\n\n    &#x2F;* 取当前用户的权限与这次请求的这个url需要的权限作对比，决定是否放行\n     * auth 包含了当前的用户信息，包括拥有的权限,即之前UserDetailsService登录时候存储的用户对象\n     * object 就是FilterInvocation对象，可以得到request等web资源。\n     * configAttributes 是本次访问需要的权限。即上一步的 MyFilterInvocationSecurityMetadataSource 中查询核对得到的权限列表 \n     *&#x2F;\n    @Override\n    public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123;\n        for (ConfigAttribute configAttribute : configAttributes) &#123;\n            if (authentication &#x3D;&#x3D; null)&#123;\n                throw new AccessDeniedException(&quot;当前访问没有权限&quot;);\n            &#125;\n            &#x2F;&#x2F; 当前请求需要的权限\n            String needRole &#x3D; configAttribute.getAttribute();\n            if (&quot;ROLE_LOGIN&quot;.equals(needRole))&#123;\n                if (authentication instanceof AnonymousAuthenticationToken)&#123;\n                    throw new  BadCredentialsException(&quot;未登录&quot;);\n                &#125;\n                return;\n            &#125;\n            &#x2F;&#x2F; 当前用户所具有的权限\n            Collection&lt;? extends GrantedAuthority&gt; authorities &#x3D; authentication.getAuthorities();\n            for (GrantedAuthority authority : authorities) &#123;\n                if (authority.getAuthority().equals(needRole))&#123;\n                    return;\n                &#125;\n            &#125;\n        &#125;\n        throw new AccessDeniedException(&quot;权限不足&quot;);\n    &#125;\n\n    @Override\n    public boolean supports(ConfigAttribute attribute) &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) &#123;\n        return true;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-2-6-登录认证成功处理器\"><a href=\"#4-2-6-登录认证成功处理器\" class=\"headerlink\" title=\"4.2.6 登录认证成功处理器\"></a>4.2.6 登录认证成功处理器</h3><p>在 UsernamePasswordAuthenticationFilter 进行登录认证的时候，如果登录成功了会调用 AuthenticationSuccessHandler 的方法进行认证成功后的处理。AuthenticationSuccessHandler 就是登录成功处理器<br><img src=\"https://img-blog.csdnimg.cn/d45ebeb2e3af4c0b8b4be7f7ecd1ee69.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\n&#x2F;&#x2F; 继承实现类 public class LoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler &#123;\n&#x2F;&#x2F; 实现接口\npublic class LoginSuccessHandler implements AuthenticationSuccessHandler &#123;\n    @Resource\n    private ObjectMapper objectMapper;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;\n        &#x2F;&#x2F; 获取前端传到后端的全部参数\n        Enumeration&lt;String&gt; parameterNames &#x3D; request.getParameterNames();\n        while (parameterNames.hasMoreElements()) &#123;\n            String paraName &#x3D; parameterNames.nextElement();\n            System.out.println(&quot;参数- &quot; + paraName + &quot; : &quot; + request.getParameter(paraName));\n        &#125;\n        &#x2F;&#x2F; 这里写登录成功后的逻辑，可以验证其他信息，如验证码等。\n&#x2F;&#x2F;        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);\n&#x2F;&#x2F;        JSONObject jsonObject &#x3D; new JSONObject();\n&#x2F;&#x2F;        jsonObject.putOnce(&quot;code&quot;, HttpStatus.OK.value());\n&#x2F;&#x2F;        jsonObject.putOnce(&quot;msg&quot;,&quot;登录成功&quot;);\n&#x2F;&#x2F;        jsonObject.putOnce(&quot;authentication&quot;,objectMapper.writeValueAsString(authentication));\n\t\t&#x2F;&#x2F; 返回响应信息\n&#x2F;&#x2F;\t\tresponse.getWriter().write(jsonObject.toString());\n        try &#123;\n        \t&#x2F;&#x2F; 重定向，等同于 .successForwardUrl(&quot;&#x2F;success&quot;)\n            this.getRedirectStrategy().sendRedirect(request, response, &quot;&#x2F;success&quot;);\n        &#125; catch (JsonProcessingException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/6bc552118eec4a0db4005429832cc414.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-2-7-登录认证失败处理器\"><a href=\"#4-2-7-登录认证失败处理器\" class=\"headerlink\" title=\"4.2.7 登录认证失败处理器\"></a>4.2.7 登录认证失败处理器</h3><p>在 UsernamePasswordAuthenticationFilter 进行登录认证的时候，如果认证失败了会调用 AuthenticationFailureHandler 的方法进行认证失败后的处理。AuthenticationFailureHandler 就是登录失败处理器<br><img src=\"https://img-blog.csdnimg.cn/5c9bdd15ee0b4318b4d57c3b46228c25.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\n&#x2F;&#x2F; public class LoginFailureHandler extends SimpleUrlAuthenticationFailureHandler &#123;\npublic class LoginFailureHandler implements AuthenticationFailureHandler &#123;\n\n\t@Resource\n    private ObjectMapper objectMapper;\n\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) &#123;\n        this.saveException(request, exception);\n&#x2F;&#x2F;        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);\n        &#x2F;&#x2F; 这里写登录失败后的逻辑，可加验证码验证等\n&#x2F;&#x2F;        String errorInfo &#x3D; &quot;&quot;;\n&#x2F;&#x2F;        if (exception instanceof BadCredentialsException ||\n&#x2F;&#x2F;                exception instanceof UsernameNotFoundException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户名或者密码输入错误!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof LockedException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户被锁定，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof CredentialsExpiredException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;密码过期，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof AccountExpiredException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户过期，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof DisabledException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户被禁用，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;登录失败!&quot;;\n&#x2F;&#x2F;        &#125;\n        &#x2F;&#x2F; ajax请求认证方式\n&#x2F;&#x2F;        JSONObject resultObj &#x3D; new JSONObject();\n&#x2F;&#x2F;        resultObj.putOnce(&quot;code&quot;, HttpStatus.UNAUTHORIZED.value());\n&#x2F;&#x2F;        resultObj.putOnce(&quot;msg&quot;,errorInfo);\n&#x2F;&#x2F;        resultObj.putOnce(&quot;exception&quot;,objectMapper.writeValueAsString(exception));\n&#x2F;&#x2F;        response.getWriter().write(resultObj.toString());\n        try &#123;\n            this.getRedirectStrategy().sendRedirect(request, response, &quot;&#x2F;login&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/658afb94dabf44dab67ea6184196e94d.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-2-8-注销成功处理器\"><a href=\"#4-2-8-注销成功处理器\" class=\"headerlink\" title=\"4.2.8 注销成功处理器\"></a>4.2.8 注销成功处理器</h3><p><img src=\"https://img-blog.csdnimg.cn/19cb4dfacede4f7690d1fe39c414a319.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CustomLogoutSuccessHandler implements LogoutSuccessHandler &#123;\n\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication) &#123;\n        &#x2F;&#x2F; 返回响应信息\n        response.setStatus(HttpStatus.OK.value());\n        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);\n        try &#123;\n            response.getWriter().write(&quot;注销成功!&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/4300ad58a81c4e6e98f67567f049802e.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-2-9-登录页面的-Form-表单\"><a href=\"#4-2-9-登录页面的-Form-表单\" class=\"headerlink\" title=\"4.2.9 登录页面的 Form 表单\"></a>4.2.9 登录页面的 Form 表单</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form action&#x3D;&quot;&#x2F;user&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt; &lt;!-- action 与配置类的 loginProcessingUrl 对应 --&gt;\n\t&lt;!-- name 与配置类设置的 usernameParameter 对应，不设置默认为 username --&gt;\n\t用户名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;uname&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n\t&lt;!-- name 与配置类设置的 passwordParameter 对应，不设置默认为 password --&gt;\n\t密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pword&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n\t&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<h2 id=\"4-3-基于角色或权限进行访问控制\"><a href=\"#4-3-基于角色或权限进行访问控制\" class=\"headerlink\" title=\"4.3 基于角色或权限进行访问控制\"></a>4.3 基于角色或权限进行访问控制</h2><h3 id=\"4-3-1-hasAuthority-方法\"><a href=\"#4-3-1-hasAuthority-方法\" class=\"headerlink\" title=\"4.3.1 hasAuthority() 方法\"></a>4.3.1 hasAuthority() 方法</h3><p>如果当前的主体具有指定的权限，则返回 true，否则返回 false</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体带有 admin 权限才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasAuthority(&quot;admin&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;\n&#x2F;&#x2F; 实现类\n@Service\npublic class MyUserDetailsServiceImpl implements UserDetailsService &#123;\n    @Resource\n    private UserDAO userDAO;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        fan.springsecuritytest.entity.User selectOne &#x3D; userDAO.selectOne(new QueryWrapper&lt;fan.springsecuritytest.entity.User&gt;().eq(&quot;username&quot;, username));\n        if (ObjectUtils.isEmpty(selectOne))&#123;\n            throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F; 设置权限，为 role，不可访问需要 admin 权限的路径\n        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;);\n        return new User(selectOne.getUsername(), new BCryptPasswordEncoder().encode(selectOne.getPassword()), authorities);\n    &#125;\n&#125;</code></pre>\n\n<p>无权限访问， Forbidden 403<br><img src=\"https://img-blog.csdnimg.cn/72bbf878b0a349ddb1dc0340f71a7d73.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-3-2-hasAnyAuthority-方法\"><a href=\"#4-3-2-hasAnyAuthority-方法\" class=\"headerlink\" title=\"4.3.2 hasAnyAuthority() 方法\"></a>4.3.2 hasAnyAuthority() 方法</h3><p>如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回 true</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体带有 admin或role 权限才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasAnyAuthority(&quot;admin&quot;, &quot;role&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/78341697395a4ed79539c1f3ea441235.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-3-3-hasRole-方法\"><a href=\"#4-3-3-hasRole-方法\" class=\"headerlink\" title=\"4.3.3 hasRole() 方法\"></a>4.3.3 hasRole() 方法</h3><p>如果用户具备给定角色就允许访问，否则出现 403。如果当前主体具有指定的角色，则返回 true<br><img src=\"https://img-blog.csdnimg.cn/30c82600bbb8488dbf6f4c17d6a2a9d9.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/324908570eeb49c3a4d697e26cf163c4.png\" alt=\"在这里插入图片描述\"><br>由于底层源码给设定的 role 加上了前缀 “ROLE_”，所以给主体设定角色时，也要加上前缀</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体为 sale 角色才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasRole(&quot;sale&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;\n&#x2F;&#x2F; 实现类\n@Service\npublic class MyUserDetailsServiceImpl implements UserDetailsService &#123;\n    @Resource\n    private UserDAO userDAO;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        fan.springsecuritytest.entity.User selectOne &#x3D; userDAO.selectOne(new QueryWrapper&lt;fan.springsecuritytest.entity.User&gt;().eq(&quot;username&quot;, username));\n        if (ObjectUtils.isEmpty(selectOne))&#123;\n            throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F; 角色加上前缀\n        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role, ROLE_sale&quot;);\n        return new User(selectOne.getUsername(), new BCryptPasswordEncoder().encode(selectOne.getPassword()), authorities);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-3-4-hasAnyRole-方法\"><a href=\"#4-3-4-hasAnyRole-方法\" class=\"headerlink\" title=\"4.3.4 hasAnyRole() 方法\"></a>4.3.4 hasAnyRole() 方法</h3><p>表示用户具备任何一个角色都可以访问</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体为 sale或sale1 角色才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasAnyRole(&quot;sale&quot;, &quot;sale1&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;</code></pre>\n\n<h3 id=\"3-3-5-自定义没有权限访问页面（非必要）\"><a href=\"#3-3-5-自定义没有权限访问页面（非必要）\" class=\"headerlink\" title=\"3.3.5 自定义没有权限访问页面（非必要）\"></a>3.3.5 自定义没有权限访问页面（非必要）</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\t&#x2F;&#x2F; 没有权限访问跳转到该路径\n\thttp.exceptionHandling().accessDeniedPage(&quot;&#x2F;forbidden&quot;);\n&#125;</code></pre>\n\n<h2 id=\"4-4-注解使用\"><a href=\"#4-4-注解使用\" class=\"headerlink\" title=\"4.4 注解使用\"></a>4.4 注解使用</h2><h3 id=\"4-4-1-Secured\"><a href=\"#4-4-1-Secured\" class=\"headerlink\" title=\"4.4.1 @Secured\"></a>4.4.1 @Secured</h3><p><strong>开启注解</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>@EnableGlobalMethodSecurity(securedEnabled&#x3D;true)</p></blockquote>\n<p>可以加在启动类上，也可以在配置类上<br><img src=\"https://img-blog.csdnimg.cn/507323f6d6fd44758f50af333a344a3b.png\" alt=\"在这里插入图片描述\"><br>@Secured 判断是否具有角色，只有具有该角色才可以进行访问，这里匹配的字符串需要添加前缀 “ROLE_“</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Controller 方法\n@GetMapping(&quot;&#x2F;demo01&quot;)\n@ResponseBody\n@Secured(value &#x3D; &#123;&quot;ROLE_sale&quot;, &quot;ROLE_sale1&quot;&#125;) &#x2F;&#x2F; 加上注解\npublic String demo01()&#123;\n\treturn &quot;demo01 请求&quot;;\n&#125;</code></pre>\n\n<h3 id=\"4-4-2-PreAuthorize\"><a href=\"#4-4-2-PreAuthorize\" class=\"headerlink\" title=\"4.4.2 @PreAuthorize\"></a>4.4.2 @PreAuthorize</h3><p>进入方法前的权限验证， @PreAuthorize 可以将登录用户的 roles&#x2F;permissions 参数传到方法中</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Controller 方法\n@GetMapping(&quot;&#x2F;demo01&quot;)\n@ResponseBody\n@PreAuthorize(&quot;hasAnyAuthority(&#39;role&#39;)&quot;)\npublic String demo01()&#123;\n\treturn &quot;demo01 请求&quot;;\n&#125;</code></pre>\n\n<h3 id=\"4-4-3-PostAuthorize\"><a href=\"#4-4-3-PostAuthorize\" class=\"headerlink\" title=\"4.4.3 @PostAuthorize\"></a>4.4.3 @PostAuthorize</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)</p></blockquote>\n<p>@PostAuthorize 注解使用并不多，在方法执行后再进行权限验证，<strong>适合验证带有返回值的权限</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;demo02&quot;)\n@ResponseBody\n@PostAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;)&quot;)\npublic String demo02()&#123;\n\tSystem.out.println(&quot;返回前执行的方法！&quot;);\n\treturn &quot;demo02 请求&quot;;\n&#125;</code></pre>\n\n<h3 id=\"4-4-4-PreFilter\"><a href=\"#4-4-4-PreFilter\" class=\"headerlink\" title=\"4.4.4 @PreFilter\"></a>4.4.4 @PreFilter</h3><p>进入控制器之前对数据进行过滤，假如值取模 2 为 0，则输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;getTestPreFilter&quot;)\n@PreAuthorize(&quot;hasRole(&#39;ROLE_管理员&#39;)&quot;)\n@PreFilter(value &#x3D; &quot;filterObject.id%2&#x3D;&#x3D;0&quot;)\n@ResponseBody\npublic List&lt;UserInfo&gt; getTestPreFilter(@RequestBody List&lt;UserInfo&gt; list)&#123;\n\tlist.forEach(t -&gt; &#123;\n\t\tSystem.out.println(t.getId() + &quot;\\t&quot; + t.getUsername());\n\t&#125;);\n\treturn list;\n&#125;</code></pre>\n\n<h3 id=\"4-4-5-PostFilter\"><a href=\"#4-4-5-PostFilter\" class=\"headerlink\" title=\"4.4.5 @PostFilter\"></a>4.4.5 @PostFilter</h3><p>权限验证之后对数据进行过滤 留下用户名是 admin1 的数据，表达式中的 filterObject 引用的是方法返回值 List 中的某一个元素</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;demo01&quot;)\n@PreAuthorize(&quot;hasRole(&#39;ROLE_sale&#39;)&quot;)\n@PostFilter(&quot;filterObject.username &#x3D;&#x3D; &#39;admin1&#39;&quot;)\n@ResponseBody\npublic List&lt;UserInfo&gt; getAllUser()&#123;\n\tArrayList&lt;UserInfo&gt; list &#x3D; new ArrayList&lt;&gt;();\n\tlist.add(new UserInfo(1l,&quot;admin1&quot;,&quot;6666&quot;));\n\tlist.add(new UserInfo(2l,&quot;admin2&quot;,&quot;888&quot;));\n\treturn list;\n&#125;</code></pre>\n\n<h2 id=\"4-5-基于数据库的记住我\"><a href=\"#4-5-基于数据库的记住我\" class=\"headerlink\" title=\"4.5 基于数据库的记住我\"></a>4.5 基于数据库的记住我</h2><p><img src=\"https://img-blog.csdnimg.cn/e7d228f698104bc48550ad80f8eebee0.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"4-5-1-SQL\"><a href=\"#4-5-1-SQL\" class=\"headerlink\" title=\"4.5.1 SQL\"></a>4.5.1 SQL</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>jdbcTokenRepository.setCreateTableOnStartup(true);</p></blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/5cd77c0cfc114fb5b70d848c01320d05.png\" alt=\"在这里插入图片描述\"><br>该语句会自动在数据库中创建一个存放 Token 及相关信息的一个表，表名为 persistent_logins，也可以手动创建该表，不执行该语句。只有数据库中不存在该表需要创建表才执行。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;persistent_logins&#96; (\n  &#96;username&#96; varchar(64) NOT NULL,\n  &#96;series&#96; varchar(64) NOT NULL,\n  &#96;token&#96; varchar(64) NOT NULL,\n  &#96;last_used&#96; timestamp NOT NULL,\n  PRIMARY KEY (&#96;series&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</code></pre>\n\n<h3 id=\"4-5-2-添加记住我功能\"><a href=\"#4-5-2-添加记住我功能\" class=\"headerlink\" title=\"4.5.2 添加记住我功能\"></a>4.5.2 添加记住我功能</h3><p><img src=\"https://img-blog.csdnimg.cn/4fa5056a6458494cb18a51781dd3dd30.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl;\n\n\t&#x2F;&#x2F; 注入数据源\n    @Resource\n    private DataSource dataSource;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n\t@Bean\n    public PersistentTokenRepository persistentTokenRepository()&#123;\n        JdbcTokenRepositoryImpl jdbcTokenRepository &#x3D; new JdbcTokenRepositoryImpl();\n        &#x2F;&#x2F; 赋值数据源\n        jdbcTokenRepository.setDataSource(dataSource);\n        &#x2F;&#x2F; 自动创建表, 第一次执行会创建，以后要执行就要删除掉！\n        jdbcTokenRepository.setCreateTableOnStartup(true);\n        return jdbcTokenRepository;\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n    \t&#x2F;&#x2F; 开启记住我功能\n        http.rememberMe()\n\t        .userDetailsService(myUserDetailsServiceImpl)\n\t        .tokenRepository(persistentTokenRepository());\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-5-3-登录页面\"><a href=\"#4-5-3-登录页面\" class=\"headerlink\" title=\"4.5.3 登录页面\"></a>4.5.3 登录页面</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form action&#x3D;&quot;&#x2F;user&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt;\n  用户名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;uname&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n  密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pword&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n  &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;\n  &lt;!-- 设置 name 为 remeber-me --&gt;\n  记住我：&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;remember-me&quot; title&#x3D;&quot;记住密码&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<h3 id=\"4-5-4-设置有效期\"><a href=\"#4-5-4-设置有效期\" class=\"headerlink\" title=\"4.5.4 设置有效期\"></a>4.5.4 设置有效期</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\t&#x2F;&#x2F; 开启记住我功能\n\thttp.rememberMe()\n\t\t.userDetailsService(myUserDetailsServiceImpl)\n\t\t.tokenRepository(persistentTokenRepository())\n\t\t.tokenValiditySeconds(100); &#x2F;&#x2F; 设置过期时间为 100 秒，单位为秒\n&#125;</code></pre>\n\n<h2 id=\"4-6-用户注销\"><a href=\"#4-6-用户注销\" class=\"headerlink\" title=\"4.6 用户注销\"></a>4.6 用户注销</h2><h3 id=\"4-6-1-退出链接\"><a href=\"#4-6-1-退出链接\" class=\"headerlink\" title=\"4.6.1 退出链接\"></a>4.6.1 退出链接</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 与配置类的 .logoutUrl(&quot;&#x2F;logout&quot;) 对应 --&gt;\n&lt;a href&#x3D;&quot;&#x2F;logout&quot;&gt;退出&lt;&#x2F;a&gt;</code></pre>\n\n<h3 id=\"4-6-2-配置类\"><a href=\"#4-6-2-配置类\" class=\"headerlink\" title=\"4.6.2 配置类\"></a>4.6.2 配置类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl;\n  \n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n    \t&#x2F;&#x2F; 添加退出映射地址\n        http.logout()\n\t\t\t.logoutUrl(&quot;&#x2F;logout&quot;) &#x2F;&#x2F; 与退出链接对应\n\t\t\t&#x2F;&#x2F; 退出成功后跳转的地址，可以使用自定义退出成功处理器\n\t\t\t.logoutSuccessUrl(&quot;&#x2F;login&quot;).permitAll();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"4-7-CSRF\"><a href=\"#4-7-CSRF\" class=\"headerlink\" title=\"4.7 CSRF\"></a>4.7 CSRF</h2><h3 id=\"4-7-1-概念\"><a href=\"#4-7-1-概念\" class=\"headerlink\" title=\"4.7.1 概念\"></a>4.7.1 概念</h3><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任</p>\n<p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</p>\n<p>从 Spring Security 4.0 开始，默认情况下会启用 CSRF 保护，以防止 CSRF 攻击应用程序，<strong>Spring Security CSRF 会针对 PATCH，POST，PUT 和 DELETE 方法进行防护</strong></p>\n<h3 id=\"4-7-2-Spring-Security-防御机制\"><a href=\"#4-7-2-Spring-Security-防御机制\" class=\"headerlink\" title=\"4.7.2 Spring Security 防御机制\"></a>4.7.2 Spring Security 防御机制</h3><h4 id=\"4-7-2-1-Csrf-Token\"><a href=\"#4-7-2-1-Csrf-Token\" class=\"headerlink\" title=\"4.7.2.1 Csrf Token\"></a>4.7.2.1 Csrf Token</h4><p>用户登录时，系统发放一个 CsrfToken 值，用户携带该 CsrfToken 值与用户名、密码等参数完成登录。系统记录该会话的 CsrfToken 值，之后在用户的任何请求中，都必须带上该 CsrfToken 值，并由系统进行校验</p>\n<h4 id=\"4-7-2-2-SpringSecurity-中使用-Csrf-Token\"><a href=\"#4-7-2-2-SpringSecurity-中使用-Csrf-Token\" class=\"headerlink\" title=\"4.7.2.2 SpringSecurity 中使用 Csrf Token\"></a>4.7.2.2 SpringSecurity 中使用 Csrf Token</h4><p>Spring Security 通过注册一个 CsrfFilter 来专门处理 CSRF 攻击，在 Spring Security 中，CsrfToken 是一个用于描述 Token 值，以及验证时应当获取哪个请求参数或请求头字段的接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface CsrfToken extends Serializable &#123;\n\t&#x2F;&#x2F; 获取 _csrf 参数的 key\n    String getHeaderName();\n    String getParameterName();\n\n\t&#x2F;&#x2F; 获取 _csrf 参数的 value\n    String getToken();\n&#125;\npublic interface CsrfTokenRepository &#123;\n\t&#x2F;&#x2F; CsrfToken 的生成过程\n    CsrfToken generateToken(HttpServletRequest request);\n\n\t&#x2F;&#x2F; 保存 CsrfToken\n    void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response);\n\n\t&#x2F;&#x2F; 如何加载 CsrfToken\n    CsrfToken loadToken(HttpServletRequest request);\n&#125;</code></pre>\n\n<p><strong>实现类：</strong><br>默认使用的是 DefaultCsrfToken<br><img src=\"https://img-blog.csdnimg.cn/9605673b7cfc4704928e5bd007c58855.png\" alt=\"在这里插入图片描述\"><br>默认使用的是 HttpSessionCsrfTokenRepository<br><img src=\"https://img-blog.csdnimg.cn/e6adf336877b4a688edef9e14785b4dc.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"4-7-2-3-HttpSessionCsrfTokenRepository\"><a href=\"#4-7-2-3-HttpSessionCsrfTokenRepository\" class=\"headerlink\" title=\"4.7.2.3 HttpSessionCsrfTokenRepository\"></a>4.7.2.3 HttpSessionCsrfTokenRepository</h4><p>在默认情况下，Spring Security 加载的是一个HttpSessionCsrfTokenRepository，将 CsrfToken 值存储在 HttpSession 中，并指定前端把 CsrfToken 值放在名为 “_csrf” 的请求参数或名为 “X-CSRF-TOKEN” 的请求头字段里（可以调用相应的设置方法来重新设定）。校验时，通过对比 HttpSession 内存储的 CsrfToken 值与前端携带的 CsrfToken 值是否一致，便能断定本次请求是否为 CSRF 攻击</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class HttpSessionCsrfTokenRepository implements CsrfTokenRepository &#123;\n    private static final String DEFAULT_CSRF_PARAMETER_NAME &#x3D; &quot;_csrf&quot;;\n    private static final String DEFAULT_CSRF_HEADER_NAME &#x3D; &quot;X-CSRF-TOKEN&quot;;\n    private static final String DEFAULT_CSRF_TOKEN_ATTR_NAME &#x3D; HttpSessionCsrfTokenRepository.class.getName().concat(&quot;.CSRF_TOKEN&quot;);\n    private String parameterName &#x3D; &quot;_csrf&quot;;\n    private String headerName &#x3D; &quot;X-CSRF-TOKEN&quot;;\n    private String sessionAttributeName;\n\n    public HttpSessionCsrfTokenRepository() &#123;\n        this.sessionAttributeName &#x3D; DEFAULT_CSRF_TOKEN_ATTR_NAME;\n    &#125;\n\n    public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) &#123;\n        HttpSession session;\n        if (token &#x3D;&#x3D; null) &#123;\n            session &#x3D; request.getSession(false);\n            if (session !&#x3D; null) &#123;\n                session.removeAttribute(this.sessionAttributeName);\n            &#125;\n        &#125; else &#123;\n            session &#x3D; request.getSession();\n            session.setAttribute(this.sessionAttributeName, token);\n        &#125;\n\n    &#125;\n\n    public CsrfToken loadToken(HttpServletRequest request) &#123;\n        HttpSession session &#x3D; request.getSession(false);\n        return session &#x3D;&#x3D; null ? null : (CsrfToken)session.getAttribute(this.sessionAttributeName);\n    &#125;\n\n    public CsrfToken generateToken(HttpServletRequest request) &#123;\n        return new DefaultCsrfToken(this.headerName, this.parameterName, this.createNewToken());\n    &#125;\n\n    public void setParameterName(String parameterName) &#123;\n        Assert.hasLength(parameterName, &quot;parameterName cannot be null or empty&quot;);\n        this.parameterName &#x3D; parameterName;\n    &#125;\n\n    public void setHeaderName(String headerName) &#123;\n        Assert.hasLength(headerName, &quot;headerName cannot be null or empty&quot;);\n        this.headerName &#x3D; headerName;\n    &#125;\n\n    public void setSessionAttributeName(String sessionAttributeName) &#123;\n        Assert.hasLength(sessionAttributeName, &quot;sessionAttributename cannot be null or empty&quot;);\n        this.sessionAttributeName &#x3D; sessionAttributeName;\n    &#125;\n\n    private String createNewToken() &#123;\n        return UUID.randomUUID().toString();\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li>saveToken 方法将 CsrfToken 保存在 HttpSession 中，将来再从 HttpSession 中取出和前端传来的参数做比较</li>\n<li>loadToken 方法当然就是从 HttpSession 中读取 CsrfToken 出来</li>\n<li>generateToken 是生成 CsrfToken 的过程，可以看到，生成的默认载体就是 DefaultCsrfToken，而 CsrfToken 的值则通过 createNewToken 方法生成，是一个 UUID 字符串</li>\n<li>在构造 DefaultCsrfToken 是还有两个参数 headerName 和 parameterName，这两个参数是前端保存参数的 key</li>\n</ol>\n<p><strong>适用于前后端不分离的开发</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;input type&#x3D;&quot;hidden&quot; th:if&#x3D;&quot;$&#123;_csrf&#125;!&#x3D;null&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; name&#x3D;&quot;_csrf&quot;&#x2F;&gt;\n或者&lt;input type&#x3D;&quot;hidden&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; th:name&#x3D;&quot;$&#123;_csrf.parameterName&#125;&quot;&gt; </code></pre>\n\n<h4 id=\"4-7-2-4-CookieCsrfTokenRepository\"><a href=\"#4-7-2-4-CookieCsrfTokenRepository\" class=\"headerlink\" title=\"4.7.2.4 CookieCsrfTokenRepository\"></a>4.7.2.4 CookieCsrfTokenRepository</h4><p>前后端分离开发需要 CsrfTokenRepository 的另一个实现类 CookieCsrfTokenRepository ，是一种更加灵活可行的方案，它将 CsrfToken 值存储在用户的 cookie 内。减少了服务器 HttpSession 存储的内存消耗，并且当用 cookie 存储 CsrfToken 值时，前端可以用 JavaScript 读取（需要设置该 cookie 的 httpOnly 属性为 false），而不需要服务器注入参数，在使用方式上更加灵活</p>\n<p>存储在 cookie 中是不会被 CSRF 利用的，cookie 只有在同域的情况下才能被读取，所以杜绝了第三方站点跨域获取 CsrfToken 值的可能。同时 CSRF 攻击本身是不知道 cookie 内容的，只是利用了当请求自动携带 cookie 时可以通过身份验证的漏洞。<strong>但服务器对 CsrfToken 值的校验并非取自 cookie，而是需要前端从 Cookie 中自己提取出来 _csrf 参数，然后拼接成参数传递给后端，单纯的将 Cookie 中的数据传到服务端是没用的</strong></p>\n<ol>\n<li><p><strong>配置的时候通过 withHttpOnlyFalse 方法获取 CookieCsrfTokenRepository 的实例，该方法会设置 Cookie 中的 HttpOnly 属性为 false，也就是允许前端通过 JS 操作 Cookie（否则就没有办法获取到 _csrf)</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">@Override \nprotected void configure(HttpSecurity http) throws Exception &#123; \n    http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); \n&#125; </code></pre></li>\n<li><p><strong>可以采用 header 或者 param 的方式添加 csrf_token，下面示范从 cookie 中获取 token</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form action&#x3D;&quot;&#x2F;executeLogin&quot; method&#x3D;&quot;post&quot;&gt;\n\t&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_csrf&quot;&gt;\n\t用户名&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; class&#x3D;&quot;lowin-input&quot;&gt;\n\t密码&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;lowin-input&quot;&gt;\n\t记住我&lt;input name&#x3D;&quot;remember-me&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n\t&lt;input class&#x3D;&quot;lowin-btn login-btn&quot; type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n&lt;script&gt;\n    $(function () &#123;\n        var aCookie &#x3D; document.cookie.split(&quot;; &quot;);\n        console.log(aCookie);\n        for (var i&#x3D;0; i &lt; aCookie.length; i++)&#123;\n            var aCrumb &#x3D; aCookie[i].split(&quot;&#x3D;&quot;);\n            if (&quot;XSRF-TOKEN&quot; &#x3D;&#x3D; aCrumb[0])\n                $(&quot;input[name&#x3D;&#39;_csrf&#39;]&quot;).val(aCrumb[1]);\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;</code></pre></li>\n</ol>\n<h4 id=\"4-7-2-5-LazyCsrfTokenRepository\"><a href=\"#4-7-2-5-LazyCsrfTokenRepository\" class=\"headerlink\" title=\"4.7.2.5 LazyCsrfTokenRepository\"></a>4.7.2.5 LazyCsrfTokenRepository</h4><p>对于常见的 GET 请求实际上是不需要 CSRF 攻击校验的，但是，每当 GET 请求到来时，下面这段代码都会执行：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (missingToken) &#123;\n     csrfToken &#x3D; this.tokenRepository.generateToken(request);\n     this.tokenRepository.saveToken(csrfToken, request, response);\n&#125;</code></pre>\n\n<p>生成 CsrfToken 并保存，但实际上却没什么用，因为 GET 请求不需要 CSRF 攻击校验。所以，Spring Security 官方又推出了 LazyCsrfTokenRepository</p>\n<p>LazyCsrfTokenRepository 实际上不能算是一个真正的 CsrfTokenRepository，它是一个代理，可以用来增强 HttpSessionCsrfTokenRepository 或者 CookieCsrfTokenRepository 的功能：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class LazyCsrfTokenRepository implements CsrfTokenRepository &#123;\n    private static final String HTTP_RESPONSE_ATTR &#x3D; HttpServletResponse.class.getName();\n    private final CsrfTokenRepository delegate;\n\n    public LazyCsrfTokenRepository(CsrfTokenRepository delegate) &#123;\n        Assert.notNull(delegate, &quot;delegate cannot be null&quot;);\n        this.delegate &#x3D; delegate;\n    &#125;\n\n    public CsrfToken generateToken(HttpServletRequest request) &#123;\n        return this.wrap(request, this.delegate.generateToken(request));\n    &#125;\n\n    public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) &#123;\n        if (token &#x3D;&#x3D; null) &#123;\n            this.delegate.saveToken(token, request, response);\n        &#125;\n\n    &#125;\n\n    public CsrfToken loadToken(HttpServletRequest request) &#123;\n        return this.delegate.loadToken(request);\n    &#125;\n\n    private CsrfToken wrap(HttpServletRequest request, CsrfToken token) &#123;\n        HttpServletResponse response &#x3D; this.getResponse(request);\n        return new LazyCsrfTokenRepository.SaveOnAccessCsrfToken(this.delegate, request, response, token);\n    &#125;\n\n    private HttpServletResponse getResponse(HttpServletRequest request) &#123;\n        HttpServletResponse response &#x3D; (HttpServletResponse)request.getAttribute(HTTP_RESPONSE_ATTR);\n        Assert.notNull(response, () -&gt; &#123;\n            return &quot;The HttpServletRequest attribute must contain an HttpServletResponse for the attribute &quot; + HTTP_RESPONSE_ATTR;\n        &#125;);\n        return response;\n    &#125;\n\n    private static final class SaveOnAccessCsrfToken implements CsrfToken &#123;\n        private transient CsrfTokenRepository tokenRepository;\n        private transient HttpServletRequest request;\n        private transient HttpServletResponse response;\n        private final CsrfToken delegate;\n\n        SaveOnAccessCsrfToken(CsrfTokenRepository tokenRepository, HttpServletRequest request, HttpServletResponse response, CsrfToken delegate) &#123;\n            this.tokenRepository &#x3D; tokenRepository;\n            this.request &#x3D; request;\n            this.response &#x3D; response;\n            this.delegate &#x3D; delegate;\n        &#125;\n\n        public String getHeaderName() &#123;\n            return this.delegate.getHeaderName();\n        &#125;\n\n        public String getParameterName() &#123;\n            return this.delegate.getParameterName();\n        &#125;\n\n        public String getToken() &#123;\n            this.saveTokenIfNecessary();\n            return this.delegate.getToken();\n        &#125;\n\n        public boolean equals(Object obj) &#123;\n            if (this &#x3D;&#x3D; obj) &#123;\n                return true;\n            &#125; else if (obj !&#x3D; null &amp;&amp; this.getClass() &#x3D;&#x3D; obj.getClass()) &#123;\n                LazyCsrfTokenRepository.SaveOnAccessCsrfToken other &#x3D; (LazyCsrfTokenRepository.SaveOnAccessCsrfToken)obj;\n                if (this.delegate &#x3D;&#x3D; null) &#123;\n                    if (other.delegate !&#x3D; null) &#123;\n                        return false;\n                    &#125;\n                &#125; else if (!this.delegate.equals(other.delegate)) &#123;\n                    return false;\n                &#125;\n\n                return true;\n            &#125; else &#123;\n                return false;\n            &#125;\n        &#125;\n\n        public int hashCode() &#123;\n            int prime &#x3D; true;\n            int result &#x3D; 1;\n            int result &#x3D; 31 * result + (this.delegate &#x3D;&#x3D; null ? 0 : this.delegate.hashCode());\n            return result;\n        &#125;\n\n        public String toString() &#123;\n            return &quot;SaveOnAccessCsrfToken [delegate&#x3D;&quot; + this.delegate + &quot;]&quot;;\n        &#125;\n\n        private void saveTokenIfNecessary() &#123;\n            if (this.tokenRepository !&#x3D; null) &#123;\n                synchronized(this) &#123;\n                    if (this.tokenRepository !&#x3D; null) &#123;\n                        this.tokenRepository.saveToken(this.delegate, this.request, this.response);\n                        this.tokenRepository &#x3D; null;\n                        this.request &#x3D; null;\n                        this.response &#x3D; null;\n                    &#125;\n\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li>generateToken 方法，该方法用来生成 CsrfToken，默认 CsrfToken 的载体是 DefaultCsrfToken，现在换成了 SaveOnAccessCsrfToken</li>\n<li>SaveOnAccessCsrfToken 和 DefaultCsrfToken 并没有太大区别，主要是 getToken 方法有区别，在 SaveOnAccessCsrfToken 中，当开发者调用 getToken 想要去获取 csrfToken 时，才会去对 csrfToken 做保存操作（调用 HttpSessionCsrfTokenRepository 或者 CookieCsrfTokenRepository 的 saveToken 方法）</li>\n<li>LazyCsrfTokenRepository 自己的 saveToken 则做了修改，相当于放弃了 saveToken 的功能，调用该方法并不会做保存操作</li>\n</ol>\n<p>在使用 Spring Security 时，如果对 csrf 不做任何配置，默认其实就是 LazyCsrfTokenRepository + HttpSessionCsrfTokenRepository 组合</p>\n<h3 id=\"4-7-3-参数校验\"><a href=\"#4-7-3-参数校验\" class=\"headerlink\" title=\"4.7.3 参数校验\"></a>4.7.3 参数校验</h3><p>校验主要是通过 CsrfFilter 过滤器来进行，核心为 doFilterInternal() 方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n        request.setAttribute(HttpServletResponse.class.getName(), response);\n        CsrfToken csrfToken &#x3D; this.tokenRepository.loadToken(request);\n        boolean missingToken &#x3D; csrfToken &#x3D;&#x3D; null;\n        if (missingToken) &#123;\n            csrfToken &#x3D; this.tokenRepository.generateToken(request);\n            this.tokenRepository.saveToken(csrfToken, request, response);\n        &#125;\n\n        request.setAttribute(CsrfToken.class.getName(), csrfToken);\n        request.setAttribute(csrfToken.getParameterName(), csrfToken);\n        if (!this.requireCsrfProtectionMatcher.matches(request)) &#123;\n            if (this.logger.isTraceEnabled()) &#123;\n                this.logger.trace(&quot;Did not protect against CSRF since request did not match &quot; + this.requireCsrfProtectionMatcher);\n            &#125;\n\n            filterChain.doFilter(request, response);\n        &#125; else &#123;\n            String actualToken &#x3D; request.getHeader(csrfToken.getHeaderName());\n            if (actualToken &#x3D;&#x3D; null) &#123;\n                actualToken &#x3D; request.getParameter(csrfToken.getParameterName());\n            &#125;\n\n            if (!equalsConstantTime(csrfToken.getToken(), actualToken)) &#123;\n                this.logger.debug(LogMessage.of(() -&gt; &#123;\n                    return &quot;Invalid CSRF token found for &quot; + UrlUtils.buildFullRequestUrl(request);\n                &#125;));\n                AccessDeniedException exception &#x3D; !missingToken ? new InvalidCsrfTokenException(csrfToken, actualToken) : new MissingCsrfTokenException(actualToken);\n                this.accessDeniedHandler.handle(request, response, (AccessDeniedException)exception);\n            &#125; else &#123;\n                filterChain.doFilter(request, response);\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<ol>\n<li>首先调用 tokenRepository.loadToken 方法读取 CsrfToken 出来，这个 tokenRepository 就是配置的 CsrfTokenRepository 实例，CsrfToken 存在 HttpSession 中，这里就从 HttpSession 中读取，CsrfToken 存在 Cookie 中，这里就从 Cookie 中读取</li>\n<li>如果调用 tokenRepository.loadToken 方法没有加载到 CsrfToken，那说明这个请求可能是第一次发起，则调用 tokenRepository.generateToken 方法生成 CsrfToken ，并调用 tokenRepository.saveToken 方法保存 CsrfToken</li>\n<li>这里还调用 request.setAttribute 方法存了一些值进去，这就是默认情况下，通过 JSP 或者 Thymeleaf 标签渲染 _csrf 的数据来源</li>\n<li>requireCsrfProtectionMatcher.matches() 方法则使用用来判断哪些请求方法需要做校验，默认情况下，”GET”, “HEAD”, “TRACE”, “OPTIONS” 方法是不需要校验的</li>\n<li>接下来获取请求中传递来的 CSRF 参数，先从请求头中获取，获取不到再从请求参数中获取</li>\n<li>获取到请求传来的 CSRF 参数之后，再和一开始加载到的 csrfToken 做比较，如果不同的话，就抛出异常</li>\n</ol>\n<h3 id=\"4-7-4-CSRF-注销\"><a href=\"#4-7-4-CSRF-注销\" class=\"headerlink\" title=\"4.7.4 CSRF 注销\"></a>4.7.4 CSRF 注销</h3><p>开启 CSRF 后，不仅登录受到保护，注销也同样受到保护，因此同样需要带上 CsrfToken</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form action&#x3D;&quot;&#x2F;logout&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type&#x3D;&quot;hidden&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; name&#x3D;&quot;_csrf&quot;&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;退出&quot;&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<h2 id=\"4-8-新版本-WebSecurityConfigurerAdapter-被弃用\"><a href=\"#4-8-新版本-WebSecurityConfigurerAdapter-被弃用\" class=\"headerlink\" title=\"4.8 新版本 WebSecurityConfigurerAdapter 被弃用\"></a>4.8 新版本 WebSecurityConfigurerAdapter 被弃用</h2><p><strong>官方地址：<a href=\"https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter\">Spring Security without the WebSecurityConfigurerAdapter</a></strong></p>\n<p>原写法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n            .authorizeHttpRequests((authz) -&gt; authz\n                .anyRequest().authenticated()\n            )\n            .httpBasic(withDefaults());\n    &#125;\n\n    @Override\n    public void configure(WebSecurity web) &#123;\n        web.ignoring().antMatchers(&quot;&#x2F;ignore1&quot;, &quot;&#x2F;ignore2&quot;);\n    &#125;\n\n    @Bean\n    public DataSource dataSource() &#123;\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    &#125;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        UserDetails user &#x3D; User.withDefaultPasswordEncoder()\n            .username(&quot;user&quot;)\n            .password(&quot;password&quot;)\n            .roles(&quot;USER&quot;)\n            .build();\n        auth.jdbcAuthentication()\n            .withDefaultSchema()\n            .dataSource(dataSource())\n            .withUser(user);\n    &#125;\n&#125;</code></pre>\n\n<p>改动后写法，由重写改为注入 Bean：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SecurityConfiguration &#123;\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;\n        http\n            .authorizeHttpRequests((authz) -&gt; authz\n                .anyRequest().authenticated()\n            )\n            .httpBasic(withDefaults());\n        return http.build();\n    &#125;\n\n    @Bean\n    public WebSecurityCustomizer webSecurityCustomizer() &#123;\n        return (web) -&gt; web.ignoring().antMatchers(&quot;&#x2F;ignore1&quot;, &quot;&#x2F;ignore2&quot;);\n    &#125;\n\n    @Bean\n    public DataSource dataSource() &#123;\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)\n            .build();\n    &#125;\n\n    @Bean\n    public UserDetailsManager users(DataSource dataSource) &#123;\n        UserDetails user &#x3D; User.withDefaultPasswordEncoder()\n            .username(&quot;user&quot;)\n            .password(&quot;password&quot;)\n            .roles(&quot;USER&quot;)\n            .build();\n        JdbcUserDetailsManager users &#x3D; new JdbcUserDetailsManager(dataSource);\n        users.createUser(user);\n        return users;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>具体详见官方文档示例</strong></p>\n<h1 id=\"5-Spring-Security-微服务权限方案\"><a href=\"#5-Spring-Security-微服务权限方案\" class=\"headerlink\" title=\"5. Spring Security 微服务权限方案\"></a>5. Spring Security 微服务权限方案</h1><p>微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。<strong>微服务的目的是有效的拆分应用，实现敏捷开发和部署</strong></p>\n<h2 id=\"5-1-认证授权过程分析\"><a href=\"#5-1-认证授权过程分析\" class=\"headerlink\" title=\"5.1 认证授权过程分析\"></a>5.1 认证授权过程分析</h2><p>1、如果是基于 Session，那么 Spring Security 会对 cookie 里的 sessionid 进行解析，找到服务器存储的 session 信息，然后判断当前用户是否符合请求的要求</p>\n<p>2、如果是 token，则是解析出 token，然后将当前请求加入到 Spring Security 管理的权限信息中去</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bce28749fd3e4921aadf3e42de09392c.png\" alt=\"在这里插入图片描述\"></p>\n<p>如果系统的模块众多，每个模块都需要进行授权与认证，所以选择基于 token 的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为 key，权限列表为 value 的形式存入 redis 缓存中，根据用户名相关信息生成 token 返回，浏览器将 token 记录到 cookie 中，每次调用 api 接口都默认将 token 携带到 header 请求头中，Spring Security 解析 header 头获取 token 信息，解析 token 获取当前用户名，根据用户名就可以从 redis 中获取权限列表，这样 Spring Security 就能够判断当前请求是否有权限访问</p>\n<h2 id=\"5-2-RBAC-模型和权限\"><a href=\"#5-2-RBAC-模型和权限\" class=\"headerlink\" title=\"5.2 RBAC 模型和权限\"></a>5.2 RBAC 模型和权限</h2><h3 id=\"5-2-1-RBAC\"><a href=\"#5-2-1-RBAC\" class=\"headerlink\" title=\"5.2.1 RBAC\"></a>5.2.1 RBAC</h3><p>这里的权限管理使用的是 RBAC（Role-Based Access Control）模型，基于角色的访问控制，现在主流的权限管理系统的权限设计都是 RBAC 模型，或者是 RBAC 模型的变形</p>\n<p>主要通过用户关联角色，角色关联权限，来间接的为用户赋予权限，用户不直接关联权限</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0ec5c06ea65543c5a92e21dec7d6bcb3.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>为什么要增加角色这一层关系呢？直接用户关联权限不可以吗？</strong></p>\n<p>假如有一些用户具有相同的权限，增加时需要为这些用户增加相同的权限，修改时同样也要全部修改相应的权限，管理起来十分复杂。这时候通过引入角色这一概念，给角色赋予对应的权限，然后再直接给用户分配角色，通过角色来管理权限，增加时只需要为用户绑定角色就行，修改时只需要修改这一个角色就行，大大简化了权限的管理，同时这也符合现实生活中的场景</p>\n<p>RBAC 模型又分为 RBAC0、RBAC1、RBAC2、RBAC3</p>\n<p><strong>1、RBAC0 模型</strong></p>\n<p>最简单的用户、角色、权限模型。这里面包含两种：</p>\n<ul>\n<li>用户和角色是多对一关系。即：一个用户只对应一个角色，一个角色可以对应多个用户</li>\n<li>用户和角色是多对多关系。即：一个用户可以对应多个角色，一个角色可以对应多个用户</li>\n</ul>\n<p>如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。一般来说尽量使用多对多的权限体系，保证系统的可扩展性，如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限</p>\n<p><strong>2、RBAC1 模型</strong></p>\n<p>在 RBAC0 的基础上引入了<strong>角色继承</strong>的概念。即：子角色可以继承父角色的所有权限</p>\n<p>如某个业务部门，有经理、主管、专员，专员的权限不能大于主管，主管的权限不能大于经理。如果采用 RBAC0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况</p>\n<p>而 RBAC1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限</p>\n<p><strong>3、RBAC2 模型</strong></p>\n<p>基于 RBAC0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等</p>\n<ul>\n<li><strong>角色互斥</strong> ：同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。如：财务系统中一个用户不能同时被指派给会计角色和审计员角色</li>\n<li><strong>基数约束</strong> ：一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 CEO 创建的，那这个角色的数量是有限的</li>\n<li><strong>先决条件角色</strong> ：指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限</li>\n<li><strong>运行时互斥</strong> ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色</li>\n</ul>\n<p><strong>4、RBAC3 模型</strong></p>\n<p>称为统一模型，它包含了 RBAC1 和 RBAC2，利用传递性，也把 RBAC0 包括在内。即综合了 RBAC0、RBAC1 和 RBAC2 的所有特点</p>\n<h3 id=\"5-2-2-用户组\"><a href=\"#5-2-2-用户组\" class=\"headerlink\" title=\"5.2.2 用户组\"></a>5.2.2 用户组</h3><p>当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候就可以引入一个概念“用户组”，就是将相同属性的用户归类到一起</p>\n<p>例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量</p>\n<p>同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限</p>\n<p>用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分</p>\n<p>除了减少工作量，还有更便于理解。比如按部门建立用户组的例子。一位用户从 A 部门异动到了 B 部门，这是实际发生的情况。如果没有用户组，那么我们要拿掉 A 部门的所有角色，换上 B 部门的所有角色。这种操作的本质没有区别，但是与实际情况的表现形式就有些差别了，不容易理解。加上用户组之后，只需要操作用户离开 A 组而加入 B 组就行了。这与实际情况很贴近</p>\n<h3 id=\"5-2-3-权限\"><a href=\"#5-2-3-权限\" class=\"headerlink\" title=\"5.2.3 权限\"></a>5.2.3 权限</h3><p>权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，一般来说可以将权限分为：<strong>页面权限、操作权限和数据权限</strong></p>\n<ul>\n<li><strong>页面权限</strong> ：所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限</li>\n<li><strong>操作权限</strong> ：用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等</li>\n<li><strong>数据权限</strong> ：一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。比如京东广东地区的负责人，他可以看到广东地区的仓库信息，但他看不到北京地区的仓库信息，因为这不是他的数据权限范围</li>\n</ul>\n<h2 id=\"5-3-具体实现\"><a href=\"#5-3-具体实现\" class=\"headerlink\" title=\"5.3 具体实现\"></a>5.3 具体实现</h2><p><strong>详见：<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/124464590\">https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;124464590</a></strong></p>\n<h3 id=\"5-3-1-自定义-UsernamePasswordAuthenticationFilter\"><a href=\"#5-3-1-自定义-UsernamePasswordAuthenticationFilter\" class=\"headerlink\" title=\"5.3.1 自定义 UsernamePasswordAuthenticationFilter\"></a>5.3.1 自定义 UsernamePasswordAuthenticationFilter</h3><p>可以使用 Spring Security 默认的 UsernamePasswordAuthenticationFilter。假如需要在里面自定义认证逻辑的话，可以自定义类继承该过滤器</p>\n<p>通过 AuthenticationManager 的 authenticate 方法来进行用户认证，所以需要把 AuthenticationManager 注入容器或者直接传入 authenticationManager() 方法。jwtAuthenticationFilter 为 JWT 过滤器</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>http.addFilter(new TokenLoginFilter(authenticationManager(), jwtAuthenticationFilter , redisTemplate);</p></blockquote>\n<p>认证成功的话生成一个 JWT 并返回。同时将 JWT 存入 Redis</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123;\n\n    private JWTUtil jwtUtil; &#x2F;&#x2F; JWT 工具类\n    private RedisTemplate redisTemplate;\n    private AuthenticationManager authenticationManager; &#x2F;&#x2F; 用来认证\n\n    public TokenLoginFilter(AuthenticationManager authenticationManager, JwtAuthenticationFilter  jwtAuthenticationFilter , RedisTemplate redisTemplate) &#123;\n        this.authenticationManager &#x3D; authenticationManager;\n        this.jwtAuthenticationFilter &#x3D; jwtAuthenticationFilter ;\n        this.redisTemplate &#x3D; redisTemplate;\n        this.setPostOnly(false);\n        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;&#x2F;hrms&#x2F;login&quot;,&quot;POST&quot;));\n    &#125;\n\n    &#x2F;&#x2F; 1. 获取表单提交用户名和密码\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;\n        try &#123;\n        \t&#x2F;&#x2F; 获取表单提交的数据\n            User user &#x3D; new ObjectMapper().readValue(request.getInputStream(), User.class);\n            &#x2F;&#x2F; 将用户名和密码传给 UserDetailsService 进行认证，认证成功返回认证信息 Authentication \n            Authentication authenticate &#x3D; authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;()));\n            return authenticate;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace(); throw new RuntimeException();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 2. 认证成功之后调用的方法\n    @Override\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;\n        &#x2F;&#x2F; 认证成功，得到认证成功之后的用户信息\n        SecurityUser user &#x3D; (SecurityUser)authResult.getPrincipal();\n        &#x2F;&#x2F; 根据用户名生成 jwt\n  \n        &#x2F;&#x2F; 把用户名称和用户权限列表放到 Redis\n  \n        &#x2F;&#x2F; 返回 jwt\n  \n    &#125;\n\n    &#x2F;&#x2F; 3. 认证失败调用的方法\n    @Override\n    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;\n  \n    &#125;\n&#125;</code></pre>\n","feature":true,"text":"1. 概要1.1 名词概念1.1.1 主体（principal）使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体 1.1.2 认证（authentication）权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。笼...","link":"","photos":[],"count_time":{"symbolsCount":"108k","symbolsTime":"1:38"},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%A6%81\"><span class=\"toc-text\">1. 概要</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%90%8D%E8%AF%8D%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 名词概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E4%B8%BB%E4%BD%93%EF%BC%88principal%EF%BC%89\"><span class=\"toc-text\">1.1.1 主体（principal）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E8%AE%A4%E8%AF%81%EF%BC%88authentication%EF%BC%89\"><span class=\"toc-text\">1.1.2 认证（authentication）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-3-%E6%8E%88%E6%9D%83%EF%BC%88authorization%EF%BC%89\"><span class=\"toc-text\">1.1.3 授权（authorization）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1.2 简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-SpringSecurity-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.2.1 SpringSecurity 特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86\"><span class=\"toc-text\">1.2.2 模块划分</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">2. 过滤器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OncePerRequestFilter\"><span class=\"toc-text\">OncePerRequestFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-WebAsyncManagerIntegrationFilter\"><span class=\"toc-text\">2.1 WebAsyncManagerIntegrationFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-SecurityContextPersistenceFilter\"><span class=\"toc-text\">2.2 SecurityContextPersistenceFilter</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-SecurityContextRepository\"><span class=\"toc-text\">2.2.1 SecurityContextRepository</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.2.2 概念</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-HeaderWriterFilter\"><span class=\"toc-text\">2.3 HeaderWriterFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-CsrfFilter\"><span class=\"toc-text\">2.4 CsrfFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-LogoutFilter\"><span class=\"toc-text\">2.5 LogoutFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-UsernamePasswordAuthenticationFilter%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">2.6 UsernamePasswordAuthenticationFilter（重要）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-DefaultLoginPageGeneratingFilter\"><span class=\"toc-text\">2.7 DefaultLoginPageGeneratingFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-DefaultLogoutPageGeneratingFilter\"><span class=\"toc-text\">2.8 DefaultLogoutPageGeneratingFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-9-BasicAuthenticationFilter\"><span class=\"toc-text\">2.9 BasicAuthenticationFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-10-RequestCacheAwareFilter\"><span class=\"toc-text\">2.10 RequestCacheAwareFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-11-SecurityContextHolderAwareRequestFilter\"><span class=\"toc-text\">2.11 SecurityContextHolderAwareRequestFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-12-AnonymousAuthenticationFilter\"><span class=\"toc-text\">2.12 AnonymousAuthenticationFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-13-SessionManagementFilter\"><span class=\"toc-text\">2.13 SessionManagementFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-14-ExceptionTranslationFilter%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">2.14 ExceptionTranslationFilter（重要）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-15-FilterSecurityInterceptor%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">2.15 FilterSecurityInterceptor（重要）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RememberMeAuthenticationFilter\"><span class=\"toc-text\">RememberMeAuthenticationFilter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE\"><span class=\"toc-text\">执行流程图</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3. 工作流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3.1 认证流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-AbstractAuthenticationProcessingFilter\"><span class=\"toc-text\">3.1.1 AbstractAuthenticationProcessingFilter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-UsernamePasswordAuthenticationFilter\"><span class=\"toc-text\">3.1.2 UsernamePasswordAuthenticationFilter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-3-Authentication\"><span class=\"toc-text\">3.1.3 Authentication</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-4-UsernamePasswordAuthenticationToken\"><span class=\"toc-text\">3.1.4 UsernamePasswordAuthenticationToken</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-5-AuthenticationManager\"><span class=\"toc-text\">3.1.5 AuthenticationManager</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-6-ProviderManager\"><span class=\"toc-text\">3.1.6 ProviderManager</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-7-CredentialsContainer\"><span class=\"toc-text\">3.1.7 CredentialsContainer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-8-AbstractAuthenticationToken\"><span class=\"toc-text\">3.1.8 AbstractAuthenticationToken</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-9-UserDetailsService\"><span class=\"toc-text\">3.1.9 UserDetailsService</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-9-1-UserDetails\"><span class=\"toc-text\">3.1.9.1 UserDetails</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-9-2-User\"><span class=\"toc-text\">3.1.9.2 User</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-10-PasswordEncoder-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">3.1.10 PasswordEncoder 接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-11-AbstractUserDetailsAuthenticationProvider\"><span class=\"toc-text\">3.1.11 AbstractUserDetailsAuthenticationProvider</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-12-DaoAuthenticationProvider\"><span class=\"toc-text\">3.1.12 DaoAuthenticationProvider</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-13-AuthenticationEntryPoint-%E5%92%8C-AccessDeniedHandler\"><span class=\"toc-text\">3.1.13 AuthenticationEntryPoint 和 AccessDeniedHandler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-14-LoginUrlAuthenticationEntryPoint\"><span class=\"toc-text\">3.1.14 LoginUrlAuthenticationEntryPoint</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3.2 授权流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-FilterSecurityInterceptor\"><span class=\"toc-text\">3.2.1 FilterSecurityInterceptor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-FilterInvocation\"><span class=\"toc-text\">3.2.2 FilterInvocation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-AbstractSecurityInterceptor\"><span class=\"toc-text\">3.2.3 AbstractSecurityInterceptor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-4-SecurityMetadataSource\"><span class=\"toc-text\">3.2.4 SecurityMetadataSource</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-5-FilterInvocationSecurityMetadataSource\"><span class=\"toc-text\">3.2.5 FilterInvocationSecurityMetadataSource</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-6-ConfigAttribute\"><span class=\"toc-text\">3.2.6 ConfigAttribute</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-7-SecurityConfig\"><span class=\"toc-text\">3.2.7 SecurityConfig</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-8-AccessDecisionManager\"><span class=\"toc-text\">3.2.8 AccessDecisionManager</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3.3 整体流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-SecurityContext\"><span class=\"toc-text\">3.3.1 SecurityContext</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-SecurityContextHolder\"><span class=\"toc-text\">3.3.2 SecurityContextHolder</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-SpringSecurity-Web-%E6%9D%83%E9%99%90\"><span class=\"toc-text\">4. SpringSecurity Web 权限</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E8%AE%BE%E7%BD%AE%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B4%A6%E5%8F%B7%E3%80%81%E5%AF%86%E7%A0%81\"><span class=\"toc-text\">4.1 设置登录系统的账号、密码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-1-YML\"><span class=\"toc-text\">4.1.1 YML</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-2-%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E8%A7%92%E8%89%B2%E6%8E%88%E6%9D%83%E5%92%8C%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">4.1.2 配置基于内存的角色授权和认证信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-3-%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%E5%92%8C%E8%A7%92%E8%89%B2%E6%8E%88%E6%9D%83\"><span class=\"toc-text\">4.1.3 配置基于数据库的认证信息和角色授权</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E8%AE%A4%E8%AF%81%E7%99%BB%E5%BD%95%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">4.2 自定义表单认证登录（重要）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-1-%E9%85%8D%E7%BD%AE%E7%B1%BB\"><span class=\"toc-text\">4.2.1 配置类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-2-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">4.2.2 配置静态资源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-3-%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2%EF%BC%88%E9%9D%9E%E5%BF%85%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">4.2.3 配置错误页面（非必要）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-4-Controller\"><span class=\"toc-text\">4.2.4 Controller</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%83%E9%99%90%E5%86%B3%E7%AD%96%E7%AE%A1%E7%90%86%E5%99%A8\"><span class=\"toc-text\">4.2.5 自定义权限决策管理器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-6-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%88%90%E5%8A%9F%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">4.2.6 登录认证成功处理器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-7-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">4.2.7 登录认证失败处理器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-8-%E6%B3%A8%E9%94%80%E6%88%90%E5%8A%9F%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">4.2.8 注销成功处理器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-9-%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E7%9A%84-Form-%E8%A1%A8%E5%8D%95\"><span class=\"toc-text\">4.2.9 登录页面的 Form 表单</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E6%88%96%E6%9D%83%E9%99%90%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">4.3 基于角色或权限进行访问控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-1-hasAuthority-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.3.1 hasAuthority() 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-2-hasAnyAuthority-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.3.2 hasAnyAuthority() 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-3-hasRole-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.3.3 hasRole() 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-4-hasAnyRole-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.3.4 hasAnyRole() 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%EF%BC%88%E9%9D%9E%E5%BF%85%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">3.3.5 自定义没有权限访问页面（非必要）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">4.4 注解使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-1-Secured\"><span class=\"toc-text\">4.4.1 @Secured</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-2-PreAuthorize\"><span class=\"toc-text\">4.4.2 @PreAuthorize</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-3-PostAuthorize\"><span class=\"toc-text\">4.4.3 @PostAuthorize</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-4-PreFilter\"><span class=\"toc-text\">4.4.4 @PreFilter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-5-PostFilter\"><span class=\"toc-text\">4.4.5 @PostFilter</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%B0%E4%BD%8F%E6%88%91\"><span class=\"toc-text\">4.5 基于数据库的记住我</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-1-SQL\"><span class=\"toc-text\">4.5.1 SQL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-2-%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">4.5.2 添加记住我功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-3-%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">4.5.3 登录页面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-4-%E8%AE%BE%E7%BD%AE%E6%9C%89%E6%95%88%E6%9C%9F\"><span class=\"toc-text\">4.5.4 设置有效期</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-%E7%94%A8%E6%88%B7%E6%B3%A8%E9%94%80\"><span class=\"toc-text\">4.6 用户注销</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-1-%E9%80%80%E5%87%BA%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">4.6.1 退出链接</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-2-%E9%85%8D%E7%BD%AE%E7%B1%BB\"><span class=\"toc-text\">4.6.2 配置类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-CSRF\"><span class=\"toc-text\">4.7 CSRF</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.7.1 概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-2-Spring-Security-%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">4.7.2 Spring Security 防御机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-2-1-Csrf-Token\"><span class=\"toc-text\">4.7.2.1 Csrf Token</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-2-2-SpringSecurity-%E4%B8%AD%E4%BD%BF%E7%94%A8-Csrf-Token\"><span class=\"toc-text\">4.7.2.2 SpringSecurity 中使用 Csrf Token</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-2-3-HttpSessionCsrfTokenRepository\"><span class=\"toc-text\">4.7.2.3 HttpSessionCsrfTokenRepository</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-2-4-CookieCsrfTokenRepository\"><span class=\"toc-text\">4.7.2.4 CookieCsrfTokenRepository</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-2-5-LazyCsrfTokenRepository\"><span class=\"toc-text\">4.7.2.5 LazyCsrfTokenRepository</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-3-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C\"><span class=\"toc-text\">4.7.3 参数校验</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-4-CSRF-%E6%B3%A8%E9%94%80\"><span class=\"toc-text\">4.7.4 CSRF 注销</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-8-%E6%96%B0%E7%89%88%E6%9C%AC-WebSecurityConfigurerAdapter-%E8%A2%AB%E5%BC%83%E7%94%A8\"><span class=\"toc-text\">4.8 新版本 WebSecurityConfigurerAdapter 被弃用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Spring-Security-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">5. Spring Security 微服务权限方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">5.1 认证授权过程分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-RBAC-%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9D%83%E9%99%90\"><span class=\"toc-text\">5.2 RBAC 模型和权限</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-1-RBAC\"><span class=\"toc-text\">5.2.1 RBAC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-2-%E7%94%A8%E6%88%B7%E7%BB%84\"><span class=\"toc-text\">5.2.2 用户组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-3-%E6%9D%83%E9%99%90\"><span class=\"toc-text\">5.2.3 权限</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">5.3 具体实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-1-%E8%87%AA%E5%AE%9A%E4%B9%89-UsernamePasswordAuthenticationFilter\"><span class=\"toc-text\">5.3.1 自定义 UsernamePasswordAuthenticationFilter</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"BlogRepository/README","date":"2023-03-13T19:13:04.933Z","updated":"2023-03-13T19:13:04.933Z","comments":true,"path":"api/articles/BlogRepository/README.json","keywords":null,"cover":null,"text":"BlogRepository个人博客文档存储 ","link":"","photos":[],"count_time":{"symbolsCount":23,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{"title":"Java进阶使用记录","uid":"9f7419bdbcee20c9483c8a0576ef5202","slug":"BlogRepository/Java/Java进阶使用记录","date":"2022-03-08T16:26:17.000Z","updated":"2023-03-13T19:13:04.933Z","comments":true,"path":"api/articles/BlogRepository/Java/Java进阶使用记录.json","keywords":null,"cover":"https://cover.png","text":"1. Asset 断言用于对值进行判断，为真则运行，否则报错，多用于调试 Assert.isNull(null, &quot;是否为空&quot;); &#x2F;&#x2F; 为空则运行 Assert.notNull(&quot;&quot;, &quot;是否不为空&quot...","link":"","photos":[],"count_time":{"symbolsCount":"45k","symbolsTime":"40 mins."},"categories":[{"name":"Java","slug":"Java","count":4,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true}}