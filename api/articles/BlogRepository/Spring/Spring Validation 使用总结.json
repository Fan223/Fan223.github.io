{"title":"Spring Validation 使用总结","uid":"e080051a012a1ddc507e547da7a01efc","slug":"BlogRepository/Spring/Spring Validation 使用总结","date":"2022-10-12T09:35:57.000Z","updated":"2023-03-13T19:13:04.940Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring Validation 使用总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-概述及常用注解\"><a href=\"#1-概述及常用注解\" class=\"headerlink\" title=\"1. 概述及常用注解\"></a>1. 概述及常用注解</h1><p>数据的校验是交互式网站一个不可或缺的功能，前端的 JS 校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用 HTTP 工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落到数据库中</p>\n<p><strong>常用校验</strong></p>\n<p><strong>1、SR303&#x2F;JSR-349</strong></p>\n<p>JSR303 是一项标准，只提供规范不提供实现，规定一些校验规范即校验注解，如 @Null，@Pattern，位于 javax.validation.constraints 包下。JSR-349 是其的升级版本，添加了一些新特性</p>\n<ul>\n<li>@Null：被注释的元素必须为 null</li>\n<li>@NotNull ：被注释的元素必须不为 null</li>\n<li>@AssertTrue：被注释的元素必须为 true</li>\n<li>@AssertFalse：被注释的元素必须为 false</li>\n<li>@Min(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>\n<li>@Max(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>\n<li>@DecimalMin(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>\n<li>@DecimalMax(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>\n<li>@Size(max, min)：被注释的元素的大小必须在指定的范围内</li>\n<li>@Digits (integer, fraction)：被注释的元素必须是一个数字，其值必须在可接受的范围内</li>\n<li>@Past：被注释的元素必须是一个过去的日期</li>\n<li>@Future：被注释的元素必须是一个将来的日期</li>\n<li>@Pattern(value)：被注释的元素必须符合指定的正则表达式</li>\n</ul>\n<p><strong>2、Hibernate Validation</strong></p>\n<p>Hibernate Validation 是对这个规范的实现，并增加了一些其他校验注解，如 @Email，@Length，@Range 等等</p>\n<ul>\n<li>@Email：被注释的元素必须是电子邮箱地址</li>\n<li>@Length：被注释的字符串的大小必须在指定的范围内</li>\n<li>@NotEmpty：被注释的字符串的必须非空</li>\n<li>@Range：被注释的元素必须在合适的范围内</li>\n</ul>\n<p><strong>3、Spring Validation</strong></p>\n<p>Spring Validation 对Hibernate Validation 进行了二次封装，在 SpringMVC 模块中添加了自动校验，并将校验信息封装进了特定的类中</p>\n<table border=\"1px\">\n    <th colspan=\"2\"> 注解 </th> <th> 含义 </th>\n    <tr>\n        <td rowspan=\"4\"> 空值判断 </td> <td> @Null </td> <td> 验证对象是否为NULL </td>\n    </tr>\n    <tr>\n        <td> @NotNull </td> <td> 验证对象是否不为NULL，但可以为 EMPTY(\"\", \" \", \"  \")，无法查检长度为 0 的字符串 </td>\n    </tr>\n    <tr>\n        <td> @NotBlank </td> <td> 验证String 对象是否不为 NULL，还有被 Trim 的长度是否大于 0，只能用在 String 字符串类型上，且会去掉前后空格 </td>\n    </tr>\n    <tr>\n        <td> @NotEmpty </td> <td> 验证对象是否不为NULL 或者是 EMPTY(\"\")，长度必须大于 0 (\" \", \"  \") </td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\"> 布尔检查 </td> <td> @AssertTrue </td> <td> 验证 Boolean 对象是否为 True </td>\n    </tr>\n    <tr>\n        <td> @AssertFalse </td> <td> 验证 Boolean 对象是否为 False </td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\"> 长度检查 </td> <td> @Size(min, max) </td> <td> 验证对象（Array, Collection , Map, String）长度是否在给定的范围之内 </td>\n    </tr>\n    <tr>\n        <td> @Length(min, max) </td> <td> 验证字符串长度是否介于 min 和 max 之间 </td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\"> 日期检查 </td> <td> @Past </td> <td> 验证 Date 和 Calendar 对象是否在当前时间之前，即过去的日期 </td>\n    </tr>\n    <tr>\n        <td> @Future </td> <td> 验证 Date 和 Calendar 对象是否在当前时间之前，即过去的日期 </td>\n    </tr>\n    <tr>\n        <td > 正则检查 </td> <td> @Pattern(regexp, flags) </td>\n        <td>\n            验证 String 对象是否符合正则表达式的规则\n            <ul>\n                <Li> regexp：正则表达式 </Li>\n                <li> flags：指定 Pattern.Flag 的数组，表示正则表达式的相关选项 </li>\n            </ul>\n        </td>\n    </tr>\n    <tr>\n        <td rowspan=\"12\"> 数值检查 <br>\n            （建议使用在 String，Integer 类型<br>不建议使用在 int 类型上<br>\n            因为表单值为 \"\" 时无法转换为 int<br>但可以转换为 String 为 \"\"<br>Integer 为 NULL）\n        </td>\n        <td> @Min(val) </td> <td> 验证 Number 和 String 对象是否大等于指定的值 </td>\n    </tr>\n    <tr>\n        <td> @Max(val) </td> <td> 验证 Number 和 String 对象是否小等于指定的值 </td>\n    </tr>\n    <tr>\n        <td> @DecimalMax(val) </td> <td> 被标注的值必须不大于约束中指定的最大值，这个约束的参数是一个通过 BigDecimal 定义的最大值的字符串表示 .小数 存在精度 </td>\n    </tr>\n    <tr>\n        <td> @DecimalMin(val) </td> <td> 被标注的值必须不小于约束中指定的最小值，这个约束的参数是一个通过 BigDecimal 定义的最小值的字符串表示 .小数 存在精度 </td>\n    </tr>\n    <tr>\n        <td> @Digits </td> <td> 验证 Number 和 String 的构成是否合法 </td>\n    </tr>\n    <tr>\n        <td> @Digits(integer, fraction) </td> <td> 验证字符串是否是符合指定格式的数字，integer 指定整数精度，fraction 指定小数精度 </td>\n    </tr>\n    <tr>\n        <td> @Range(min, max) </td> <td> 被指定的元素必须在合适的范围内 </td>\n    </tr>\n    <tr>\n        <td> @Email </td> <td> 验证是否是邮件地址，如果为 NULL，不进行验证，算通过验证 </td>\n    </tr>\n    <tr>\n        <td> @CreditCardNumber </td> <td> 信用卡验证 </td>\n    </tr>\n    <tr>\n        <td> @ScriptAssert(lang, script, alias) </td>\n    </tr>\n    <tr>\n        <td> @URL(protocol, host, port, regexp, flags) </td>\n    </tr>\n    <tr>\n        <td> @Valid </td> <td> 递归的对关联对象进行校验, 如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个 Map，则对其中的值部分进行校验.(是否进行递归验证) </td>\n    </tr>\n</table>\n\n<h1 id=\"2-Valid-和-Validated-注解\"><a href=\"#2-Valid-和-Validated-注解\" class=\"headerlink\" title=\"2. @Valid 和 @Validated 注解\"></a>2. @Valid 和 @Validated 注解</h1><p>@Valid、@Validated 注解都可以实现数据的验证，表示开启数据验证</p>\n<p><strong>1、包位置不同</strong></p>\n<ul>\n<li>@Valid：位于 <code>javax.validation.Valid</code></li>\n<li>@Validated：位于 <code>org.springframework.validation.annotation.Validated</code>，是 @Valid 的一次封装，Spring 提供的校验机制使用</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/5a7213a76d5c403fbe9a31093222d3ef.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>2、Spring Validation 验证框架提供了 @Validated 注解对参数进行验证，符合 Spring’s JSR-303 规范；而 @Valid 注解是 javax 提供的，符合标准的 JSR-303 规范</strong></p>\n<p><strong>3、当使用仅是注解字段属性并验证规范，@Validated 和 @Valid 注解的功能是相同的</strong></p>\n<p><strong>4、@Validated 注解可以用于方法、构造函数、方法参数上；而 @Valid 还可以用于成员属性（字段）之上</strong></p>\n<p><strong>5、@Validated 注解可以使用分组校验的功能，为同一个对象属性提供不同分组，并根据分组来校验属性参数；而 @Valid 注解不支持分组验证</strong></p>\n<p><strong>6、@Valid 注解支持嵌套验证，当类的属性是一个复杂对象时，可以使用 @Valid 对该属性对象中的属性同时进行校验；@Validated 并不支持在属性上使用</strong></p>\n<h1 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h1><h2 id=\"3-1-POM\"><a href=\"#3-1-POM\" class=\"headerlink\" title=\"3.1 POM\"></a>3.1 POM</h2><p>导入依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h2 id=\"3-2-简单参数校验\"><a href=\"#3-2-简单参数校验\" class=\"headerlink\" title=\"3.2 简单参数校验\"></a>3.2 简单参数校验</h2><p>服务接口接收单个简单参数时，可以在方法参数中直接使用校验注解。单参数校验时，还需要在 Controller 层控制器类中使用 @Validated 标注才会生效</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@Validated\npublic class ValidateController &#123;\n\n    @PostMapping(&quot;&#x2F;simple&quot;)\n    public Result simple(@RequestParam(&quot;validate&quot;) @NotBlank(message &#x3D; &quot;用户编码不能为空&quot;) String validate) &#123;\n        System.out.println(validate + &quot;参数值&quot;);\n\n        return Result.success(&quot;成功&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/46d0d49d134f49d692512e14507d5c8b.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/3f0a598520df4948b06c3fa31e38767c.png\" alt=\"在这里插入图片描述\"></p>\n<p>传入多个单参数为空时：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@Validated\npublic class ValidateController &#123;\n\n    @PostMapping(&quot;&#x2F;simple&quot;)\n    public Result simple(@RequestParam(&quot;validate&quot;) @NotBlank(message &#x3D; &quot;用户编码不能为空&quot;) String validate,\n                         @RequestParam(&quot;id&quot;) @NotBlank(message &#x3D; &quot;ID 不能为空&quot;) String id) &#123;\n        System.out.println(validate + &quot;参数值&quot; + id);\n\n        return Result.success(&quot;成功&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/69f89543886c459ead26fc85e80713bc.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/73ebfd834bbd4edba189f19fa93df7d4.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-3-实体类校验\"><a href=\"#3-3-实体类校验\" class=\"headerlink\" title=\"3.3 实体类校验\"></a>3.3 实体类校验</h2><p>在实体类中使用校验注解标注需要校验的字段后，还需要在请求层接收参数时开启参数校验，只需要在 Controller 接口层的参数中使用 @Validated 标注，在接口接收到请求参数时会自动进行校验</p>\n<p>校验时可以使用 BindingResult 返回错误信息（注：<strong>添加了 BindingResult 就不会报错了</strong>），<strong>需配合 <code>@RequestBody</code> 或 <code>RequestPart</code> 一起使用，同时请求参数要在请求体里（重点是这个），否则会报 IllegalStateException 异常</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4c0e6eb1b44e4a61aaf8f9275be79c88.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\npublic class ValidateController &#123;\n\n    @PostMapping(&quot;&#x2F;getUser&quot;)\n    public Result getUser(@Validated @RequestBody User user, BindingResult result) &#123;\n\n        if (result.hasErrors()) &#123;\n            return Result.fail(&quot;校验失败&quot; + result.getFieldError().getDefaultMessage());\n        &#125;\n        return Result.success(&quot;success&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>实体类得加上 @Data 注解，即 getter&#x2F;setter 方法，不然校验不到</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n\n    @NotNull(message &#x3D; &quot;id 不能为空&quot;)\n    private Integer id;\n\n    @NotBlank(message &#x3D; &quot;姓名不能为空&quot;)\n    private String name;\n\n    private String gender;\n\n    @Pattern(regexp &#x3D; &quot;^((?:19[2-9]\\\\d&#123;1&#125;)|(?:20(?:(?:0[0-9])|(?:1[0-8]))))\\\\-((?:0?[1-9])|(?:1[0-2]))\\\\-((?:0?[1-9])|(?:[1-2][0-9])|30|31)$&quot;)\n    private String birthday;\n\n    @DecimalMin(&quot;0&quot;)\n    private BigDecimal balance;\n\n    @Valid\n    private List&lt;Pet&gt; pets;\n&#125;\n\n@Data\nclass Pet &#123;\n\n    @Min(0)\n    private double weight;\n\n    private String name;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/4c309ffb65e344168a3784b7338cf72c.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0d3ccc7a90724b3080293af35560d537.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-4-全局异常\"><a href=\"#3-4-全局异常\" class=\"headerlink\" title=\"3.4 全局异常\"></a>3.4 全局异常</h2><p>使用 Validation 校验异常后，当参数发生异常时，会抛出 MethodArgumentNotValidException 类型的异常，为了程序报错更通俗易懂以及方便，无需在每个接口都手动返回异常信息，可以定义全局异常来捕获该类型的异常，并统一返回结果信息</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0e1a60a94dfb4ac2b4e9f52dcb2b0892.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestControllerAdvice\n&#x2F;&#x2F;@ControllerAdvice\n@Slf4j\npublic class GlobalExceptionHandler &#123;\n\n    &#x2F;&#x2F;    @ResponseBody\n    @ExceptionHandler(value &#x3D; MethodArgumentNotValidException.class)\n    public Result notValidException(MethodArgumentNotValidException exception) &#123;\n        String message &#x3D; exception.getBindingResult().getFieldError().getDefaultMessage();\n        log.error(&quot;参数校验异常: &#123;&#125;&quot;, message);\n\n        return Result.fail(message);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/9860f74625614479b09162d0fcd6e954.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ddcdce08676741a89d58d014ee4371f6.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>当参数传递异常时，可能还会出现 BindingException，使用简单参数校验时，会出现  ConstraintViolationException，可根据实际情况定义全局异常</strong></p>\n","feature":false,"text":"1. 概述及常用注解数据的校验是交互式网站一个不可或缺的功能，前端的 JS 校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用 HTTP 工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">1. 概述及常用注解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Valid-%E5%92%8C-Validated-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">2. @Valid 和 @Validated 注解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3. 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-POM\"><span class=\"toc-text\">3.1 POM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C\"><span class=\"toc-text\">3.2 简单参数校验</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%AE%9E%E4%BD%93%E7%B1%BB%E6%A0%A1%E9%AA%8C\"><span class=\"toc-text\">3.3 实体类校验</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">3.4 全局异常</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Easy Excel 使用总结","uid":"4d007a7b93e6f215777cd8e4cac0925d","slug":"BlogRepository/开发技术及框架/Easy Excel 使用总结","date":"2022-10-14T09:33:57.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/Easy Excel 使用总结.json","keywords":null,"cover":"https://cover.png","text":"1. 概述官网地址：EasyExcel 官方文档 - 基于 Java 的 Excel 处理工具 | Easy Excel (alibaba.com) EasyExcel 是一个基于 Java 的、快速、简洁、解决大文件内存溢出的 Excel 处理工具。他能让你在不用考虑性能、内存...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":8,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"Excel","slug":"Excel","count":1,"path":"api/tags/Excel.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"设计模式之美总结（面向对象篇）","uid":"ffaf8c18c9c334b55a0bf75e7c8818f0","slug":"BlogRepository/设计模式/设计模式之美总结（面向对象篇）","date":"2022-10-11T09:02:54.000Z","updated":"2023-03-13T19:13:04.973Z","comments":true,"path":"api/articles/BlogRepository/设计模式/设计模式之美总结（面向对象篇）.json","keywords":null,"cover":"https://cover.png","text":"1. 代码质量的好坏下面这些几乎涵盖我们所能听到的描述代码质量的所有常用词汇，这些描述方法语义更丰富、更专业、更细化 灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（...","link":"","photos":[],"count_time":{"symbolsCount":"75k","symbolsTime":"1:08"},"categories":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":8,"path":"api/tags/设计模式.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}