{"title":"SpringMVC 总结","uid":"153deb9c806beaeb0b25c611326c4f25","slug":"BlogRepository/Spring/SpringMVC 总结","date":"2022-06-10T18:22:45.000Z","updated":"2023-03-13T19:13:04.944Z","comments":true,"path":"api/articles/BlogRepository/Spring/SpringMVC 总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-配置\"><a href=\"#1-配置\" class=\"headerlink\" title=\"1. 配置\"></a>1. 配置</h1><h2 id=\"1-1-MVC-概念\"><a href=\"#1-1-MVC-概念\" class=\"headerlink\" title=\"1.1 MVC 概念\"></a>1.1 MVC 概念</h2><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p>\n<ul>\n<li><strong>M：Model，模型层，指工程中的 JavaBean，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）</strong><br>JavaBean 分为两类：<ul>\n<li><strong>一类称为实体类 Bean：专门存储业务数据的，如 Student、User 等</strong></li>\n<li><strong>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问</strong></li>\n</ul>\n</li>\n<li>V：<strong>View，视图层，指工程中的 HTML 或 JSP 等页面，负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能</strong></li>\n<li>C：<strong>Controller，控制层，指工程中的 Servlet，负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端</strong></li>\n</ul>\n<p><strong>MVC 的工作流程：</strong></p>\n<ol>\n<li>用户通过视图层发送请求到服务器，在服务器中请求被 Controller 接收</li>\n<li>Controller 调用相应的 Model 层处理请求，处理完毕将结果返回到 Controller</li>\n<li>Controller 再根据请求处理的结果找到相应的 View 视图，渲染数据后最终响应给浏览器</li>\n</ol>\n<h2 id=\"1-2-SpringMVC-概念\"><a href=\"#1-2-SpringMVC-概念\" class=\"headerlink\" title=\"1.2 SpringMVC 概念\"></a>1.2 SpringMVC 概念</h2><ul>\n<li>SpringMVC是Spring的一个后续产品，是 Spring 的一个子项目</li>\n<li>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC 作为 Java EE 项目表述层开发的首选方案</li>\n</ul>\n<p><strong>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 Servlet</strong></p>\n<h2 id=\"1-3-SpringMVC的特点\"><a href=\"#1-3-SpringMVC的特点\" class=\"headerlink\" title=\"1.3 SpringMVC的特点\"></a>1.3 SpringMVC的特点</h2><ul>\n<li>Spring 家族原生产品，与 IOC 容器等基础设施无缝对接</li>\n<li>基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理</li>\n<li>表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案</li>\n<li>代码清新简洁，大幅度提升开发效率</li>\n<li>内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可</li>\n<li>性能卓著，尤其适合现代大型、超大型互联网项目要求</li>\n</ul>\n<h2 id=\"1-4-配置-web-xml\"><a href=\"#1-4-配置-web-xml\" class=\"headerlink\" title=\"1.4 配置 web.xml\"></a>1.4 配置 web.xml</h2><ol>\n<li><strong>默认配置方式</strong>此配置作用下，SpringMVC 的配置文件默认位于 WEB-INF 下，默认名称为 <code>&lt;servlet-name&gt;-servlet.xml</code>，例如，以下配置所对应 SpringMVC 的配置文件位于 WEB-INF 下，文件名为 springMVC-servlet.xml<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;web-app&gt;\n  &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;\n  &lt;!-- 配置 SpringMVC 的前端控制器，对浏览器发送的请求统一进行处理 --&gt;\n\t&lt;servlet&gt;\n\t\t&lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n\t\t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet\u0002class&gt;\n\t&lt;&#x2F;servlet&gt;\n\n\t&lt;servlet-mapping&gt;\n\t\t&lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n\t\t&lt;!--\n\t\t\t设置 springMVC 的核心控制器所能处理的请求的请求路径\n\t\t\t&#x2F; 所匹配的请求可以是 &#x2F;login 或 .html 或 .js 或 .css 方式的请求路径\n\t\t\t但是 &#x2F; 不能匹配 .jsp 请求路径的请求\n\t\t--&gt;\n\t\t&lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n\t&lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;</code></pre></li>\n<li><strong>扩展配置方式</strong>可通过 <code>init-param</code> 标签设置 SpringMVC 配置文件的位置和名称，通过 <code>load-on-startup</code> 标签设置 SpringMVC 前端控制器 DispatcherServlet 的初始化时间<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 配置 SpringMVC 的前端控制器，对浏览器发送的请求统一进行处理 --&gt;\n&lt;servlet&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;!-- 通过初始化参数指定 SpringMVC 配置文件的位置和名称 --&gt;\n    &lt;init-param&gt;\n        &lt;!-- contextConfigLocation 为固定值 --&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;!-- 使用 classpath: 表示从类路径查找配置文件，例如 Maven 工程中的src&#x2F;main&#x2F;resources --&gt;\n        &lt;param-value&gt;classpath:springMVC.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n&lt;&#x2F;servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;</code></pre>\n\n<strong><code>&lt;url-pattern&gt;</code> 标签中使用 <code>/</code> 和 <code>/* </code>的区别：</strong>* <code>/</code> 所匹配的请求可以是 &#x2F;login 或 .html 或 .js 或 .css 方式的请求路径，但是 &#x2F; 不能匹配 .jsp 请求路径的请求。因此就可以避免在访问 JSP 页面时，该请求被 DispatcherServlet 处理，从而找不到相应的页面<ul>\n<li><code>/*</code> 则能够匹配所有请求，在使用过滤器时，若需要对所有请求进行过滤，就需要使用 &#x2F;* 的写法</li>\n</ul>\n</li>\n<li><strong>完整配置：</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app version&#x3D;&quot;3.0&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee\n\thttp:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;&gt;\n\n  &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;\n\n   &lt;!-- 配置统一编码格式 --&gt;\n  &lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;forceResponseEncoding&lt;&#x2F;param-name&gt;\n      &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n  &lt;&#x2F;filter&gt;\n  &lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;filter-mapping&gt;\n\n\t&lt;!-- 配置 HiddenHttpMethodFilter，实现 RestFul --&gt;\n  &lt;filter&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;&#x2F;filter-class&gt;\n  &lt;&#x2F;filter&gt;\n  &lt;filter-mapping&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;filter-mapping&gt;\n\n  &lt;!-- 配置 SpringMVC 的前端控制器，对浏览器发送的请求统一进行处理 --&gt;\n  &lt;servlet&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;!-- 通过初始化参数指定 SpringMVC 配置文件的位置和名称 --&gt;\n    &lt;init-param&gt;\n      &lt;!-- contextConfigLocation 为固定值 --&gt;\n      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n      &lt;!-- 使用 classpath: 表示从类路径查找配置文件，例如 Maven 工程中的src&#x2F;main&#x2F;resources --&gt;\n      &lt;param-value&gt;classpath:springmvc-config.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;!--\n        作为框架的核心组件，在启动过程中有大量的初始化操作要做\n        而这些操作放在第一次请求时才执行会严重影响访问速度\n        因此需要通过此标签将启动控制 DispatcherServlet 的初始化时间提前到服务器启动时\n    --&gt;\n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n  &lt;&#x2F;servlet&gt;\n  &lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;!--\n        设置 springMVC 的核心控制器所能处理的请求的请求路径\n        &#x2F; 所匹配的请求可以是 &#x2F;login 或 .html 或 .js 或 .css 方式的请求路径\n        但是 &#x2F; 不能匹配 .jsp 请求路径的请求\n   --&gt;\n    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;</code></pre></li>\n</ol>\n<h2 id=\"1-5-配置-springmvc-config-xml\"><a href=\"#1-5-配置-springmvc-config-xml\" class=\"headerlink\" title=\"1.5 配置 springmvc-config.xml\"></a>1.5 配置 springmvc-config.xml</h2><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 开启注解扫描，自动扫描包 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;fan&quot; &#x2F;&gt;\n\n&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;\n\t&lt;property name&#x3D;&quot;order&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n\t&lt;property name&#x3D;&quot;characterEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n\t&lt;property name&#x3D;&quot;templateEngine&quot;&gt;\n\t\t&lt;bean class&#x3D;&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;\n\t\t\t&lt;property name&#x3D;&quot;templateResolver&quot;&gt;\n\t\t\t\t&lt;bean class&#x3D;&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;\n\t\t\t\t\t&lt;!-- 视图前缀 --&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;templates&#x2F;&quot;&#x2F;&gt;\n\t\t\t\t\t&lt;!-- 视图后缀 --&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.html&quot;&#x2F;&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;templateMode&quot; value&#x3D;&quot;HTML5&quot;&#x2F;&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;characterEncoding&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\t\t\t\t&lt;&#x2F;bean&gt;\n\t\t\t&lt;&#x2F;property&gt;\n\t\t&lt;&#x2F;bean&gt;\n\t&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 处理静态资源，例如 html、js、css、jpg\n  若只设置该标签，则只能访问静态资源，其他请求则无法访问\n  此时必须设置&lt;mvc:annotation-driven&#x2F;&gt;解决问题 --&gt;\n&lt;mvc:default-servlet-handler&#x2F;&gt;\n&lt;!-- 开启 mvc 注解驱动 --&gt;\n&lt;mvc:annotation-driven&gt;\n\t&lt;mvc:message-converters&gt;\n\t\t&lt;!-- 处理响应中文内容乱码 --&gt;\n\t\t&lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;\n\t\t\t&lt;property name&#x3D;&quot;defaultCharset&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\t\t\t&lt;property name&#x3D;&quot;supportedMediaTypes&quot;&gt;\n\t\t\t\t&lt;list&gt;\n\t\t\t\t\t&lt;value&gt;text&#x2F;html&lt;&#x2F;value&gt;\n\t\t\t\t\t&lt;value&gt;application&#x2F;json&lt;&#x2F;value&gt;\n\t\t\t\t&lt;&#x2F;list&gt;\n\t\t\t&lt;&#x2F;property&gt;\n\t\t&lt;&#x2F;bean&gt;\n\t&lt;&#x2F;mvc:message-converters&gt;\n&lt;&#x2F;mvc:annotation-driven&gt;</code></pre>\n\n<h2 id=\"1-6-控制器\"><a href=\"#1-6-控制器\" class=\"headerlink\" title=\"1.6 控制器\"></a>1.6 控制器</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\npublic class TestController &#123;\n    @RequestMapping(&quot;&#x2F;index&quot;)\n    public String index()&#123;\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;target&quot;)\n    public String toTarget()&#123;\n        return &quot;target&quot;;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"1-7-Thymeleaf-页面\"><a href=\"#1-7-Thymeleaf-页面\" class=\"headerlink\" title=\"1.7 Thymeleaf 页面\"></a>1.7 Thymeleaf 页面</h2><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t首页\n\t&lt;a th:href&#x3D;&quot;@&#123;&#x2F;target&#125;&quot;&gt;hello&lt;&#x2F;a&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<h2 id=\"1-8-工作流程小结\"><a href=\"#1-8-工作流程小结\" class=\"headerlink\" title=\"1.8 工作流程小结\"></a>1.8 工作流程小结</h2><p>浏览器发送请求，若请求地址符合前端控制器的 url-pattern，该请求就会被前端控制器 DispatcherServlet处理。前端控制器会读取 SpringMVC 的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中 @RequestMapping 注解的 value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过 Thymeleaf 对视图进行渲染，最终转发到视图所对应页面。</p>\n<h1 id=\"2-视图解析器-ViewResolver\"><a href=\"#2-视图解析器-ViewResolver\" class=\"headerlink\" title=\"2. 视图解析器 ViewResolver\"></a>2. 视图解析器 ViewResolver</h1><p><strong>视图解析器（ViewResolver）是 Spring MVC 的重要组成部分，负责将逻辑视图名解析为具体的视图对象。</strong> Spring MVC 提供了很多视图解析类，其中每一项都对应 Java Web 应用中特定的某些视图技术。常用的视图解析类如下</p>\n<h2 id=\"2-1-URLBasedViewResolver\"><a href=\"#2-1-URLBasedViewResolver\" class=\"headerlink\" title=\"2.1 URLBasedViewResolver\"></a>2.1 URLBasedViewResolver</h2><ol>\n<li><strong>UrlBasedViewResolver 是对 ViewResolver 的一种简单实现，主要提供了一种拼接 URL 的方式来解析视图</strong></li>\n<li>通过 prefix 属性指定前缀，suffix 属性指定后缀。当 ModelAndView 对象返回具体的 View 名称时，它会将前缀 prefix 和后缀 suffix 与具体的视图名称拼接，得到一个视图资源文件的具体加载路径，从而加载真正的视图文件并反馈给用户</li>\n<li><strong>使用 UrlBasedViewResolver 除了要配置前缀和后缀属性之外，还需要配置“viewClass”，表示解析成哪种视图。</strong> 示例代码如下：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt;          \n  &lt;!--不能省略--&gt;  \n  &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&#x2F;&gt; \n    &lt;!--前缀--&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n    &lt;!--后缀--&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;  \n&lt;&#x2F;bean&gt;</code></pre>\n\n<h2 id=\"2-2-InternalResourceViewResolver\"><a href=\"#2-2-InternalResourceViewResolver\" class=\"headerlink\" title=\"2.2 InternalResourceViewResolver\"></a>2.2 InternalResourceViewResolver</h2><ol>\n<li><strong>InternalResourceViewResolver 为“内部资源视图解析器”，是日常开发中最常用的视图解析器类型。它是 URLBasedViewResolver 的子类，拥有 URLBasedViewResolver 的一切特性</strong></li>\n<li>InternalResourceViewResolver 能自动将返回的视图名称解析为 InternalResourceView 类型的对象。InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL</li>\n<li><strong>也就是说，使用 InternalResourceViewResolver 视图解析时，无需再单独指定 viewClass 属性。</strong> 示例代码如下：</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n  &lt;!--可以省略--&gt;  \n  &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&#x2F;&gt;\n    &lt;!--前缀--&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n    &lt;!--后缀--&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;  \n&lt;&#x2F;bean&gt;</code></pre>\n\n<h2 id=\"2-3-FreeMarkerViewResolver\"><a href=\"#2-3-FreeMarkerViewResolver\" class=\"headerlink\" title=\"2.3 FreeMarkerViewResolver\"></a>2.3 FreeMarkerViewResolver</h2><ol>\n<li><strong>FreeMarkerViewResolver 是 UrlBasedViewResolver 的子类，可以通过 prefix 属性指定前缀，通过 suffix 属性指定后缀</strong></li>\n<li><strong>FreeMarkerViewResolver 最终会解析逻辑视图配置，返回 freemarker 模板。不需要指定 viewClass 属性</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;fm_&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.ftl&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><strong>下面指定 FreeMarkerView 类型最终生成的实体视图（模板文件）的路径以及其他配置。需要给 FreeMarkerViewResolver 设置一个 FreeMarkerConfig 的 bean 对象来定义 FreeMarker 的配置信息</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;\n    &lt;property name&#x3D;&quot;templateLoaderPath&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;ftl&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li>定义了 templateLoaderPath 属性后，Spring 可以通过该属性找到 FreeMarker 模板文件的具体位置。当有模板位于不同的路径时，可以配置 templateLoaderPath 属性，来指定多个资源路径</li>\n<li>然后定义一个 Controller，让其返回 ModelAndView，同时定义一些返回参数和视图信息：<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\n@RequestMapping(&quot;viewtest&quot;)\npublic class ViewController &#123;\n    @RequestMapping(&quot;freemarker&quot;)\n    public ModelAndView freemarker() &#123;\n        ModelAndView mv &#x3D; new ModelAndView();\n        mv.addObject(&quot;username&quot;, &quot;BianChengBang&quot;);\n        mv.setViewName(&quot;freemarker&quot;);\n        return mv;\n    &#125;\n&#125;</code></pre></li>\n<li><strong>当 FreeMarkerViewResolver 解析逻辑视图信息时，会生成一个 URL 为“前缀+视图名+后缀”（这里即“fm_freemarker.ftl”）的 FreeMarkerView 对象，然后通过 FreeMarkerConfigurer 的配置找到 templateLoaderPath 对应文本文件的路径，在该路径下找到该文本文件，从而 FreeMarkerView 就可以利用该模板文件进行视图的渲染，并将 model 数据封装到即将要显示的页面上，最终展示给用户</strong></li>\n<li><strong>在 &#x2F;WEB-INF&#x2F;ftl 文件夹下创建 fm_freemarker.ftl，代码如下：</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;FreeMarker&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;b&gt;Welcome!&lt;&#x2F;b&gt;\n    &lt;i&gt;$&#123;username &#125;&lt;&#x2F;i&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre></li>\n</ol>\n<h1 id=\"3-Spring-MVC-执行流程\"><a href=\"#3-Spring-MVC-执行流程\" class=\"headerlink\" title=\"3.Spring MVC 执行流程\"></a>3.Spring MVC 执行流程</h1><p><img src=\"https://img-blog.csdnimg.cn/bda5fd59afb64e99bb2bf9546918aca9.png\" alt=\"在这里插入图片描述\"><br><strong>SpringMVC 的执行流程如下：</strong></p>\n<ol>\n<li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）</li>\n<li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）</li>\n<li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）</li>\n<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）</li>\n<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li>\n<li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet</li>\n<li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析</li>\n<li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet</li>\n<li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）</li>\n<li>视图负责将结果显示到浏览器（客户端）</li>\n</ol>\n<h2 id=\"3-1-Spring-MVC-常用组件\"><a href=\"#3-1-Spring-MVC-常用组件\" class=\"headerlink\" title=\"3.1 Spring MVC 常用组件\"></a>3.1 Spring MVC 常用组件</h2><p>Spring MVC 涉及到的组件有 <strong>DispatcherServlet（前端控制器）、HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、Handler（处理器）、ViewResolver（视图解析器）和 View（视图）</strong></p>\n<h3 id=\"3-1-1-前端控制器-DispatcherServlet\"><a href=\"#3-1-1-前端控制器-DispatcherServlet\" class=\"headerlink\" title=\"3.1.1 前端控制器 DispatcherServlet\"></a>3.1.1 前端控制器 DispatcherServlet</h3><p><strong>Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发</strong><br>DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。</p>\n<h3 id=\"3-1-2-处理器映射器-HandlerMapping\"><a href=\"#3-1-2-处理器映射器-HandlerMapping\" class=\"headerlink\" title=\"3.1.2 处理器映射器 HandlerMapping\"></a>3.1.2 处理器映射器 HandlerMapping</h3><p>根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息</p>\n<h3 id=\"3-1-3-处理器适配器-HandlerAdapter\"><a href=\"#3-1-3-处理器适配器-HandlerAdapter\" class=\"headerlink\" title=\"3.1.3 处理器适配器 HandlerAdapter\"></a>3.1.3 处理器适配器 HandlerAdapter</h3><p>根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）</p>\n<h3 id=\"3-1-4-处理器-Handler\"><a href=\"#3-1-4-处理器-Handler\" class=\"headerlink\" title=\"3.1.4 处理器 Handler\"></a>3.1.4 处理器 Handler</h3><p>与 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中</p>\n<h3 id=\"3-1-5-视图解析器-View-Resolver\"><a href=\"#3-1-5-视图解析器-View-Resolver\" class=\"headerlink\" title=\"3.1.5 视图解析器 View Resolver\"></a>3.1.5 视图解析器 View Resolver</h3><p>进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）</p>\n<h3 id=\"3-1-6-视图-View\"><a href=\"#3-1-6-视图-View\" class=\"headerlink\" title=\"3.1.6 视图 View\"></a>3.1.6 视图 View</h3><p>本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）</p>\n<p><strong>以上组件中，需要开发人员进行开发的是处理器（Handler，常称Controller）和视图（View）。通俗的说，要开发处理该请求的具体代码逻辑，以及最终展示给用户的界面。</strong></p>\n<h2 id=\"3-2-DispatcherServlet-初始化过程\"><a href=\"#3-2-DispatcherServlet-初始化过程\" class=\"headerlink\" title=\"3.2 DispatcherServlet 初始化过程\"></a>3.2 DispatcherServlet 初始化过程</h2><p><strong>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</strong><br><img src=\"https://img-blog.csdnimg.cn/198d9b82b4ce4933ab7d712fe1db8268.png\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li><strong>a&gt;初始化WebApplicationContext</strong><br>所在类：org.springframework.web.servlet.Framework<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected WebApplicationContext initWebApplicationContext() &#123;\n    WebApplicationContext rootContext &#x3D;\n\n WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac &#x3D; null;\n     if (this.webApplicationContext !&#x3D; null) &#123;\n        &#x2F;&#x2F; A context instance was injected at construction time -&gt; use it\n        wac &#x3D; this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) &#123;\n            ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) &#123;\n                &#x2F;&#x2F; The context has not yet been refreshed -&gt; provide services such as\n                &#x2F;&#x2F; setting the parent context, setting the application context id, etc\n                if (cwac.getParent() &#x3D;&#x3D; null) &#123;\n                    &#x2F;&#x2F; The context instance was injected without an explicit parent -&gt; set\n                    &#x2F;&#x2F; the root application context (if any; may be null) as the parent\n                    cwac.setParent(rootContext);\n                &#125;\n                configureAndRefreshWebApplicationContext(cwac);\n            &#125;\n        &#125;\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; No context instance was injected at construction time -&gt; see if one\n        &#x2F;&#x2F; has been registered in the servlet context. If one exists, it is assumed\n        &#x2F;&#x2F; that the parent context (if any) has already been set and that the\n        &#x2F;&#x2F; user has performed any initialization such as setting the context id\n        wac &#x3D; findWebApplicationContext();\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; No context instance is defined for this servlet -&gt; create a local one\n        &#x2F;&#x2F; 创建WebApplicationContext\n        wac &#x3D; createWebApplicationContext(rootContext);\n    &#125;\n    if (!this.refreshEventReceived) &#123;\n        &#x2F;&#x2F; Either the context is not a ConfigurableApplicationContext with \nrefresh\n        &#x2F;&#x2F; support or the context injected at construction time had already been\n        &#x2F;&#x2F; refreshed -&gt; trigger initial onRefresh manually here.\n        synchronized (this.onRefreshMonitor) &#123;\n            &#x2F;&#x2F; 刷新WebApplicationContext\n            onRefresh(wac);\n        &#125;\n    &#125;\n    if (this.publishContext) &#123;\n        &#x2F;&#x2F; Publish the context as a servlet context attribute.\n        &#x2F;&#x2F; 将IOC容器在应用域共享\n        String attrName &#x3D; getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    &#125;\n    return wac;\n&#125;</code></pre></li>\n<li><strong>创建WebApplicationContextext</strong><br>所在类：org.springframework.web.servlet.FrameworkServlet<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123;\n    Class&lt;?&gt; contextClass &#x3D; getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;\n        throw new ApplicationContextException(\n            &quot;Fatal initialization error in servlet with name &#39;&quot; + getServletName() +\n            &quot;&#39;: custom WebApplicationContext class [&quot; + contextClass.getName() +\n            &quot;] is not of type ConfigurableWebApplicationContext&quot;);\n    &#125;\n    &#x2F;&#x2F; 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac &#x3D; (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n    wac.setEnvironment(getEnvironment());\n    &#x2F;&#x2F; 设置父容器\n    wac.setParent(parent);\n    String configLocation &#x3D; getContextConfigLocation();\n    if (configLocation !&#x3D; null) &#123;\n        wac.setConfigLocation(configLocation);\n    &#125;\n    configureAndRefreshWebApplicationContext(wac);\n    return wac;\n&#125;</code></pre></li>\n<li><strong>DispatcherServlet初始化策略</strong><br><strong>FrameworkServlet 创建 WebApplicationContext 后，刷新容器，调用 onRefresh(wac)，此方法在 DispatcherServlet 中进行了重写，调用了 initStrategies(context) 方法，初始化策略，即初始化 DispatcherServlet 的各个组件</strong><br>所在类：org.springframework.web.servlet.DispatcherServlet<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void initStrategies(ApplicationContext context) &#123;\n   initMultipartResolver(context);\n   initLocaleResolver(context);\n   initThemeResolver(context);\n   initHandlerMappings(context);\n   initHandlerAdapters(context);\n   initHandlerExceptionResolvers(context);\n   initRequestToViewNameTranslator(context);\n   initViewResolvers(context);\n   initFlashMapManager(context);\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"3-3-SpringMVC-的执行流程\"><a href=\"#3-3-SpringMVC-的执行流程\" class=\"headerlink\" title=\"3.3 SpringMVC 的执行流程\"></a>3.3 SpringMVC 的执行流程</h2><ol>\n<li>用户向服务器发送请求，请求被 SpringMVC 前端控制器 DispatcherServlet 捕获</li>\n<li>DispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI），判断请求 URI 对应的映射：<ul>\n<li>不存在<ul>\n<li>再判断是否配置了 mvc:default-servlet-handler</li>\n<li>如果没配置，则控制台报映射查找不到，客户端展示 404 错误</li>\n<li>如果有配置，则访问目标资源（一般为静态资源，如：JS, CSS, HTML），找不到客户端也会展示 404 错误</li>\n</ul>\n</li>\n<li>存在则执行下面的流程</li>\n</ul>\n</li>\n<li>根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 执行链对象的形式返回</li>\n<li>DispatcherServlet 根据获得的 Handler，选择一个合适的 HandlerAdapter</li>\n<li>如果成功获得 HandlerAdapter，此时将开始执行拦截器的 preHandler(…) 方法【正向】</li>\n<li>提取 Request 中的模型数据，填充 Handler 入参，开始执行 Handler（Controller) 方法，处理请求。在填充 Handler 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ul>\n<li>HttpMessageConveter： 将请求消息（如 Json、XML 等数据）转换成一个对象，将对象转换为指定的响应信息</li>\n<li>数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等</li>\n<li>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li>\n<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中</li>\n</ul>\n</li>\n<li>Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象</li>\n<li>此时将开始执行拦截器的 postHandle(…) 方法【逆向】</li>\n<li>根据返回的 ModelAndView（此时会判断是否存在异常：如果存在异常，则执行 HandlerExceptionResolver 进行异常处理）选择一个适合的 ViewResolver 进行视图解析，根据 Model 和 View，来渲染视图</li>\n<li>渲染视图完毕执行拦截器的 afterCompletion(…) 方法【逆向】</li>\n<li>将渲染结果返回给客户</li>\n</ol>\n<h1 id=\"4-RequestMapping-注解\"><a href=\"#4-RequestMapping-注解\" class=\"headerlink\" title=\"4. RequestMapping 注解\"></a>4. RequestMapping 注解</h1><h2 id=\"4-1-RequestMapping-注解的功能\"><a href=\"#4-1-RequestMapping-注解的功能\" class=\"headerlink\" title=\"4.1 @RequestMapping 注解的功能\"></a>4.1 @RequestMapping 注解的功能</h2><p><strong>将请求和处理请求的控制器方法关联起来，建立映射关系。SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</strong></p>\n<h2 id=\"4-2-RequestMapping-注解的位置\"><a href=\"#4-2-RequestMapping-注解的位置\" class=\"headerlink\" title=\"4.2 @RequestMapping 注解的位置\"></a>4.2 @RequestMapping 注解的位置</h2><ul>\n<li><strong>@RequestMapping 标识一个类：设置映射请求的请求路径的初始信息</strong></li>\n<li><strong>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</strong></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\n@RequestMapping(&quot;&#x2F;test&quot;)\npublic class RequestMappingController &#123;\n    &#x2F;&#x2F; 此时请求映射所映射的请求的请求路径为：&#x2F;test&#x2F;testRequestMapping\n    @RequestMapping(&quot;&#x2F;testRequestMapping&quot;)\n    public String testRequestMapping()&#123;\n        return &quot;success&quot;;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"4-3-value-属性\"><a href=\"#4-3-value-属性\" class=\"headerlink\" title=\"4.3 value 属性\"></a>4.3 value 属性</h2><ol>\n<li><strong>通过请求的请求地址匹配请求映射，注解的 value 属性必须设置，至少通过请求地址匹配请求映射</strong></li>\n<li>value 属性是 @RequestMapping 注解的默认属性，因此如果只有 value 属性时，可以省略该属性名，如果有其它属性，则必须写上 value 属性名称</li>\n<li><strong>@RequestMapping 注解的 value 属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</strong></li>\n<li><strong>value 属性支持通配符匹配</strong>，如 <code>@RequestMapping(value=&quot;toUser/*&quot;)</code> 表示 <code>http://localhost:8080/toUser/1</code> 或 <code>http://localhost:8080/toUser/hahaha</code> 都能够正常访问</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;a th:href&#x3D;&quot;@&#123;&#x2F;testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;&#x2F;testRequestMapping&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;&#x2F;test&lt;&#x2F;a&gt;&lt;br&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &#123;&quot;&#x2F;testRequestMapping&quot;, &quot;&#x2F;test&quot;&#125;)\n&#x2F;&#x2F; @RequestMapping(&quot;&#x2F;test&quot;)\npublic String testRequestMapping()&#123;\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"4-4-path-属性\"><a href=\"#4-4-path-属性\" class=\"headerlink\" title=\"4.4 path 属性\"></a>4.4 path 属性</h2><ul>\n<li><strong>path 属性和 value 属性都用来作为映射使用。</strong><br>即 <code>@RequestMapping(value=&quot;toUser&quot;)</code> 和 <code>@RequestMapping(path=&quot;toUser&quot;)</code> 都能访问 toUser() 方法</li>\n<li><strong>path 属性支持通配符匹配</strong>，如 <code>@RequestMapping(path=&quot;toUser/*&quot;)</code> 表示 <code>http://localhost:8080/toUser/1</code> 或 <code>http://localhost:8080/toUser/hahaha</code> 都能够正常访问</li>\n</ul>\n<h2 id=\"4-5-name-属性\"><a href=\"#4-5-name-属性\" class=\"headerlink\" title=\"4.5 name 属性\"></a>4.5 name 属性</h2><p>name 属性相当于方法的注释，使方法更易理解。如 <code>@RequestMapping(value =&quot;toUser&quot;, name = &quot;获取用户信息&quot;)</code></p>\n<h2 id=\"4-6-method-属性\"><a href=\"#4-6-method-属性\" class=\"headerlink\" title=\"4.6 method 属性\"></a>4.6 method 属性</h2><ul>\n<li><strong>method 属性用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求</strong></li>\n<li>@RequestMapping 注解的 method 属性通过请求的请求方式（get 或 post）匹配请求映射</li>\n<li><strong>@RequestMapping 注解的 method 属性是一个 RequestMethod 类型的数组，表示该请求映射能够匹配多种请求方式的请求</strong></li>\n</ul>\n<p><strong>若当前请求的请求地址满足请求映射的 value 属性，但是请求方式不满足 method 属性，则浏览器报错 405：<code>Request method &#39;POST&#39; not supported</code></strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;a th:href&#x3D;&quot;@&#123;&#x2F;test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;&#x2F;test&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;test&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(\n\tvalue &#x3D; &#123;&quot;&#x2F;testRequestMapping&quot;, &quot;&#x2F;test&quot;&#125;,\n\tmethod &#x3D; &#123;RequestMethod.GET, RequestMethod.POST&#125;\n)\npublic String testRequestMapping()&#123;\n\treturn &quot;success&quot;;\n&#125;</code></pre>\n\n<p><strong>对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</strong></p>\n<ul>\n<li><strong>处理 GET 请求的映射，查询 –&gt; @GetMapping</strong></li>\n<li><strong>处理 POST 请求的映射，新增 –&gt; @PostMapping</strong></li>\n<li><strong>处理 PUT 请求的映射，修改 –&gt; @PutMapping</strong></li>\n<li><strong>处理 DELETE请求的映射，删除 –&gt; @DeleteMapping</strong></li>\n</ul>\n<p>常用的请求方式有 GET，POST，PUT，DELETE。但是<strong>目前浏览器只支持 GET 和 POST</strong>，若在 Form 表单提交时，为 method 设置了其他请求方式的字符串（PUT 或 DELETE），则按照默认的请求方式 GET 处理，<strong>若要发送 PUT 和 DELETE 请求，则需要通过 Spring 提供的过滤器 HiddenHttpMethodFilter</strong></p>\n<h2 id=\"4-7-params-属性\"><a href=\"#4-7-params-属性\" class=\"headerlink\" title=\"4.7 params 属性\"></a>4.7 params 属性</h2><p><strong>@RequestMapping 注解的 params 属性通过请求的请求参数匹配请求映射</strong><br><strong>@RequestMapping 注解的 params 属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系：</strong></p>\n<ul>\n<li><code>&quot;param&quot;</code>：要求请求映射所匹配的请求必须携带 param 请求参数</li>\n<li><code>&quot;!param&quot;</code>：要求请求映射所匹配的请求必须不能携带 param 请求参数</li>\n<li><code>&quot;param=value&quot;</code>：要求请求映射所匹配的请求必须携带 param 请求参数且param&#x3D;value</li>\n<li><code>&quot;param!=value&quot;</code>：要求请求映射所匹配的请求必须携带 param 请求参数但param!&#x3D;value</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;a th:href&#x3D;&quot;@&#123;&#x2F;test(username&#x3D;&#39;admin&#39;,password&#x3D;123456)&quot;&gt;测试@RequestMapping的params属性--&gt;&#x2F;test&lt;&#x2F;a&gt;&lt;br&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(\n        value &#x3D; &#123;&quot;&#x2F;testRequestMapping&quot;, &quot;&#x2F;test&quot;&#125;\n        ,method &#x3D; &#123;RequestMethod.GET, RequestMethod.POST&#125;\n        ,params &#x3D; &#123;&quot;username&quot;,&quot;password!&#x3D;123456&quot;&#125;\n)\npublic String testRequestMapping()&#123;\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<p><strong>若当前请求满足 @RequestMapping 注解的 value 和 method 属性，但是不满足 params 属性，此时页面会报错400</strong>：<code>Parameter conditions &quot;username, password!=123456&quot; not met for actual request parameters: username=&#123;admin&#125;, password=&#123;123456&#125;</code></p>\n<h2 id=\"4-8-headers-属性\"><a href=\"#4-8-headers-属性\" class=\"headerlink\" title=\"4.8 headers 属性\"></a>4.8 headers 属性</h2><p><strong>@RequestMapping 注解的 headers 属性通过请求的请求头信息匹配请求映射</strong><br>@RequestMapping 注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系：</p>\n<ul>\n<li><code>&quot;header&quot;</code>：要求请求映射所匹配的请求必须携带header请求头信息</li>\n<li><code>&quot;!header&quot;</code>：要求请求映射所匹配的请求必须不能携带header请求头信息</li>\n<li><code>&quot;header=value&quot;</code>：要求请求映射所匹配的请求必须携带header请求头信息且header&#x3D;value</li>\n<li><code>&quot;header!=value&quot;</code>：要求请求映射所匹配的请求必须携带header请求头信息且header!&#x3D;value</li>\n</ul>\n<p><strong>若当前请求满足 @RequestMapping 注解的 value 和 method 属性，但是不满足 headers 属性，此时页面显示404错误，即资源未找到。</strong></p>\n<h2 id=\"4-9-consumers-属性\"><a href=\"#4-9-consumers-属性\" class=\"headerlink\" title=\"4.9 consumers 属性\"></a>4.9 consumers 属性</h2><p><strong>consumers 属性用于指定处理请求的提交内容类型（Content-Type）</strong>，例如 <code>application/json</code>、<code>text/html</code><br><strong>如: <code>@RequestMapping(value = &quot;toUser&quot;,consumes = &quot;application/json&quot;)</code></strong></p>\n<h2 id=\"4-10-produces-属性\"><a href=\"#4-10-produces-属性\" class=\"headerlink\" title=\"4.10 produces 属性\"></a>4.10 produces 属性</h2><p><strong>produces 属性用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型。</strong> 如：<code>@RequestMapping(value = &quot;toUser&quot;, produces = &quot;application/json&quot;)</code><br><strong>除此之外，produces 属性还可以指定返回值的编码。</strong> 如： <code>@RequestMapping(value = &quot;toUser&quot;, produces = &quot;application/json, charset=utf-8&quot;)</code>，表示返回 UTF-8 编码。</p>\n<h2 id=\"4-11-SpringMVC支持ant风格的路径\"><a href=\"#4-11-SpringMVC支持ant风格的路径\" class=\"headerlink\" title=\"4.11 SpringMVC支持ant风格的路径\"></a>4.11 SpringMVC支持ant风格的路径</h2><ul>\n<li><strong><code>？</code>：表示任意的单个字符，?，&#x2F; 两个特殊字符不行</strong></li>\n<li><strong><code>*</code>：表示任意的 0 个或多个字符</strong></li>\n<li><strong><code>**</code>：表示任意的一层或多层目录</strong></li>\n</ul>\n<p><strong>注：在使用 <code>**</code> 时，只能使用 <code>/**/xxx</code> 的方式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;a?a&#x2F;target&quot;)\n&#x2F;&#x2F; @RequestMapping(&quot;&#x2F;**&#x2F;target&quot;)\npublic String toTarget()&#123;\n\treturn &quot;target&quot;;\n&#125;</code></pre>\n\n<h2 id=\"4-12-SpringMVC-支持路径中的占位符\"><a href=\"#4-12-SpringMVC-支持路径中的占位符\" class=\"headerlink\" title=\"4.12 SpringMVC 支持路径中的占位符\"></a>4.12 SpringMVC 支持路径中的占位符</h2><ul>\n<li><strong>原始方式：<code>/deleteUser?id=1</code></strong></li>\n<li><strong>REST 方式：<code>/deleteUser/1</code></strong></li>\n</ul>\n<p>SpringMVC 路径中的占位符常用于 RESTful 风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的 @RequestMapping 注解的 value 属性中<strong>通过占位符 <code>&#123;xxx&#125;</code> 表示传输的数据，再通过 @PathVariable 注解，将占位符所表示的数据赋值给控制器方法的形参</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;a th:href&#x3D;&quot;@&#123;&#x2F;testRest&#x2F;1&#x2F;admin&#125;&quot;&gt;测试路径中的占位符--&gt;&#x2F;testRest&lt;&#x2F;a&gt;&lt;br&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testRest&#x2F;&#123;id&#125;&#x2F;&#123;username&#125;&quot;)\npublic String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) \nString username)&#123;\n    System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username);\n    return &quot;success&quot;;\n&#125;\n&#x2F;&#x2F; 最终输出的内容为--&gt;id:1,username:adm</code></pre>\n\n<h1 id=\"5-SpringMVC-获取请求参数\"><a href=\"#5-SpringMVC-获取请求参数\" class=\"headerlink\" title=\"5. SpringMVC 获取请求参数\"></a>5. SpringMVC 获取请求参数</h1><h2 id=\"5-1-原生-ServletAPI-获取\"><a href=\"#5-1-原生-ServletAPI-获取\" class=\"headerlink\" title=\"5.1 原生 ServletAPI 获取\"></a>5.1 原生 ServletAPI 获取</h2><p><strong>将 HttpServletRequest 作为控制器方法的形参，此时 HttpServletRequest 类型的参数表示封装了当前请求的请求报文的对象</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;a th:href&#x3D;&quot;@&#123;&#x2F;param(username &#x3D; &#39;张三&#39;, password &#x3D; 123)&#125;&quot;&gt;111&lt;&#x2F;a&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;param&quot;)\npublic String param(HttpServletRequest request)&#123;\n\tString username &#x3D; request.getParameter(&quot;username&quot;);\n\tString password &#x3D; request.getParameter(&quot;password&quot;);\n\tSystem.out.println(&quot;username:&quot; + username + &quot;password:&quot; + password);\n\treturn &quot;param&quot;;\n&#125;</code></pre>\n\n<h2 id=\"5-2-通过控制器方法的形参获取请求参数\"><a href=\"#5-2-通过控制器方法的形参获取请求参数\" class=\"headerlink\" title=\"5.2 通过控制器方法的形参获取请求参数\"></a>5.2 通过控制器方法的形参获取请求参数</h2><p><strong>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在 DispatcherServlet 中就会将请求参数赋值给相应的形参</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;a th:href&#x3D;&quot;@&#123;&#x2F;testParam(username&#x3D;&#39;admin&#39;,password&#x3D;123456)&#125;&quot;&gt;测试获取请求参数--&gt;&#x2F;testParam&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;testParam&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;password&quot;&gt;&lt;br&gt;\n    爱好：&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;a&quot;&gt;a\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;b&quot;&gt;b\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;c&quot;&gt;c&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testParam&quot;)\npublic String param(String username, String password, String[] hobby)&#123;\n\tSystem.out.println(&quot;username:&quot; + username + &quot;,password:&quot; + password + &quot;,hobby&quot; + Arrays.toString(hobby));\n\treturn &quot;success&quot;;\n&#125;</code></pre>\n\n<ul>\n<li>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</li>\n<li>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</li>\n<li>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</li>\n</ul>\n<h2 id=\"5-3-RequestParam\"><a href=\"#5-3-RequestParam\" class=\"headerlink\" title=\"5.3 @RequestParam\"></a>5.3 @RequestParam</h2><p><strong>@RequestParam 是将请求参数和控制器方法的形参创建映射关系</strong>，一共有三个属性：</p>\n<ul>\n<li><strong>value：指定为形参赋值的请求参数的参数名</strong></li>\n<li><strong>required：设置是否必须传输此请求参数，默认值为 true</strong><br>若设置为 true 时，则当前请求必须传 value 所指定的请求参数，<strong>若没有传输该请求参数，且没有设置 defaultValue 属性，则页面报错400：<code>Required String parameter &#39;xxx&#39; is not present</code></strong><br>若设置为 false，则当前请求不是必须传 value 所指定的请求参数，<strong>若没有传输，则注解所标识的形参的值为 null</strong></li>\n<li><strong>defaultValue：不管 required 属性值为 true 或 false，当 value 所指定的请求参数没有传输或传输的值为 “” 时，则使用默认值为形参赋值</strong></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testParam&quot;)\npublic String param(@RequestParam(value &#x3D; &quot;username&quot;, required &#x3D; false, defaultValue &#x3D; &quot;hehe&quot;) String username, \n                    @RequestParam(&quot;password&quot;) String password, \n                    @RequestParam(&quot;hobby&quot;) String[] hobby)&#123;\n\tSystem.out.println(&quot;username:&quot; + username + &quot;,password:&quot; + password + &quot;,hobby&quot; + Arrays.toString(hobby));\n\treturn &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"5-4-RequestHeader\"><a href=\"#5-4-RequestHeader\" class=\"headerlink\" title=\"5.4 @RequestHeader\"></a>5.4 @RequestHeader</h2><p><strong>@RequestHeader 是将请求头信息和控制器方法的形参创建映射关系</strong><br><strong>@RequestHeader 注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</strong></p>\n<h2 id=\"5-5-CookieValue\"><a href=\"#5-5-CookieValue\" class=\"headerlink\" title=\"5.5 @CookieValue\"></a>5.5 @CookieValue</h2><p><strong>@CookieValue 是将 Cookie 数据和控制器方法的形参创建映射关系<br>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</strong></p>\n<h2 id=\"5-6-通过-POJO-获取请求参数\"><a href=\"#5-6-通过-POJO-获取请求参数\" class=\"headerlink\" title=\"5.6 通过 POJO 获取请求参数\"></a>5.6 通过 POJO 获取请求参数</h2><p><strong>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testParam&quot;)\npublic String testParam(User user)&#123;\n\tSystem.out.println(user);\n\treturn &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"5-7-ModelAttribute\"><a href=\"#5-7-ModelAttribute\" class=\"headerlink\" title=\"5.7 @ModelAttribute\"></a>5.7 @ModelAttribute</h2><ul>\n<li>@ModelAttribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用</li>\n<li>而 “通过实体 Bean 接收请求参数” 中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据）</li>\n</ul>\n<p><strong>通过 @ModelAttribute 注解接收请求参数适用于 GET 和 POST 提交请求方式</strong>，示例代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;login&quot;)\npublic String login(@ModelAttribute(&quot;user&quot;) User user, Model model) &#123;\n   \n    if (&quot;bianchengbang&quot;.equals(name)\n            &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123;\n     \n        model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;);\n        return &quot;main&quot;; &#x2F;&#x2F; 登录成功，跳转到 main.jsp\n    &#125; else &#123;\n        model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;);\n        return &quot;login&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>因为模型对象要先于 Controller 方法之前创建，所以被 @ModelAttribute 注解的方法会在 Controller 每个方法执行之前都执行。因此一个 Controller 映射多个 URL 时，要谨慎使用。</strong></p>\n<h2 id=\"5-8-获取请求参数乱码问题\"><a href=\"#5-8-获取请求参数乱码问题\" class=\"headerlink\" title=\"5.8 获取请求参数乱码问题\"></a>5.8 获取请求参数乱码问题</h2><p><strong>解决获取请求参数的乱码问题，可以使用 SpringMVC 提供的编码过滤器CharacterEncodingFilter，但是必须在 web.xml 中进行注册</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &#x2F;&#x2F; 设置请求编码\n      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;forceResponseEncoding&lt;&#x2F;param-name&gt; &#x2F;&#x2F; 设置响应编码\n      &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/70c4ffc666244f93b3ad3403d0f607b2.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/6a91ac96b89f46c0bd9af257a10fcfcf.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/d14e46580fe642928359b2832a29815a.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"6-域共享数据\"><a href=\"#6-域共享数据\" class=\"headerlink\" title=\"6. 域共享数据\"></a>6. 域共享数据</h1><h2 id=\"6-1-使用-ServletAPI-向-request-域对象共享数据\"><a href=\"#6-1-使用-ServletAPI-向-request-域对象共享数据\" class=\"headerlink\" title=\"6.1 使用 ServletAPI 向 request 域对象共享数据\"></a>6.1 使用 ServletAPI 向 request 域对象共享数据</h2><p><strong>请求域（request scope），仅限于当前请求过程，包括转发（forward）或被包含（include）的情况</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testServletAPI&quot;)\npublic String testServletAPI(HttpServletRequest request)&#123;\n    request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;);\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"6-2-使用-ModelAndView-向-request-域对象共享数据\"><a href=\"#6-2-使用-ModelAndView-向-request-域对象共享数据\" class=\"headerlink\" title=\"6.2 使用 ModelAndView 向 request 域对象共享数据\"></a>6.2 使用 ModelAndView 向 request 域对象共享数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testModelAndView&quot;)\npublic ModelAndView testModelAndView()&#123;\n    &#x2F;**\n     * ModelAndView有Model和View的功能\n     * Model主要用于向请求域共享数据\n     * View主要用于设置视图，实现页面跳转\n     *&#x2F;\n    ModelAndView mav &#x3D; new ModelAndView();\n    &#x2F;&#x2F;向请求域共享数据\n    mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;);\n    &#x2F;&#x2F;设置视图，实现页面跳转\n    mav.setViewName(&quot;success&quot;);\n    return mav;\n&#125;</code></pre>\n\n<h2 id=\"6-3-使用-Model-向-request-域对象共享数据\"><a href=\"#6-3-使用-Model-向-request-域对象共享数据\" class=\"headerlink\" title=\"6.3 使用 Model 向 request 域对象共享数据\"></a>6.3 使用 Model 向 request 域对象共享数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testModel&quot;)\npublic String testModel(Model model)&#123;\n    model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;);\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"6-4-使用-map-向-request-域对象共享数据\"><a href=\"#6-4-使用-map-向-request-域对象共享数据\" class=\"headerlink\" title=\"6.4 使用 map 向 request 域对象共享数据\"></a>6.4 使用 map 向 request 域对象共享数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testMap&quot;)\npublic String testMap(Map&lt;String, Object&gt; map)&#123;\n    map.put(&quot;testScope&quot;, &quot;hello,Map&quot;);\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"6-5-使用-ModelMap-向-request-域对象共享数据\"><a href=\"#6-5-使用-ModelMap-向-request-域对象共享数据\" class=\"headerlink\" title=\"6.5 使用 ModelMap 向 request 域对象共享数据\"></a>6.5 使用 ModelMap 向 request 域对象共享数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testModelMap&quot;)\npublic String testModelMap(ModelMap modelMap)&#123;\n    modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;);\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"6-6-Model、ModelMap、Map-的关系\"><a href=\"#6-6-Model、ModelMap、Map-的关系\" class=\"headerlink\" title=\"6.6 Model、ModelMap、Map 的关系\"></a>6.6 Model、ModelMap、Map 的关系</h2><p><strong>Model、ModelMap、Map 类型的参数其实本质上都是 BindingAwareModelMap 类型的</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Model&#123;&#125;\npublic class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;\npublic class ExtendedModelMap extends ModelMap implements Model &#123;&#125;\npublic class BindingAwareModelMap extends ExtendedModelMapP &#123;&#125;</code></pre>\n\n<h2 id=\"6-7-向-session-域共享数据\"><a href=\"#6-7-向-session-域共享数据\" class=\"headerlink\" title=\"6.7 向 session 域共享数据\"></a>6.7 向 session 域共享数据</h2><p><strong>会话域（session scope），限于当前会话，即当前服务器与客户端连接期间，当关闭浏览器或者退出浏览器时，当前会话则失效</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testSession&quot;)\npublic String testSession(HttpSession session)&#123;\n    session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;);\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"6-8-向-application（应用）域共享数据\"><a href=\"#6-8-向-application（应用）域共享数据\" class=\"headerlink\" title=\"6.8 向 application（应用）域共享数据\"></a>6.8 向 application（应用）域共享数据</h2><p><strong>应用域（application scope），有效于整个服务器启动期间，关闭浏览器或退出都不会失效，在服务器关闭时失效</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testApplication&quot;)\npublic String testApplication(HttpSession session)&#123;\n    ServletContext application &#x3D; session.getServletContext();\n    application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;);\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h1 id=\"7-视图（转发与重定向）\"><a href=\"#7-视图（转发与重定向）\" class=\"headerlink\" title=\"7. 视图（转发与重定向）\"></a>7. 视图（转发与重定向）</h1><ul>\n<li><strong>SpringMVC 中的视图是 View 接口，视图的作用渲染数据，将模型 Model 中的数据展示给用户</strong></li>\n<li>SpringMVC 视图的种类很多，默认有<strong>转发视图（forward:）和重定向视图（redirect:）</strong></li>\n<li>当工程引入 jstl 的依赖，转发视图会自动转换为 JstlView</li>\n<li>若使用的视图技术为 Thymeleaf，在 SpringMVC 的配置文件中配置了 Thymeleaf 的视图解析器，由此视图解析器解析之后所得到的是 ThymeleafView</li>\n</ul>\n<h2 id=\"7-1-ThymeleafView\"><a href=\"#7-1-ThymeleafView\" class=\"headerlink\" title=\"7.1 ThymeleafView\"></a>7.1 ThymeleafView</h2><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视<strong>图名称会被SpringMVC 配置文件中所配置的视图解析器解析</strong>，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。<strong>控制器类中处理方法的 return 语句默认就是转发实现，只不过实现的是转发到视图。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testHello&quot;)\npublic String testHello()&#123;\n    return &quot;hello&quot;;\n&#125;</code></pre>\n\n<p><strong>处理当前结果：</strong><br><img src=\"https://img-blog.csdnimg.cn/90b170b72dc140e3bb13db063e73d71f.png\" alt=\"在这里插入图片描述\"><br><strong>渲染视图：</strong><br><img src=\"https://img-blog.csdnimg.cn/ee985388fe2744b794336325ce706ab4.png\" alt=\"在这里插入图片描述\"><br><strong>获取当前视图：</strong><br><img src=\"https://img-blog.csdnimg.cn/4f4355a60f8c42268f2cc2dd013c9cce.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/fb2b0836f2304f8e82b6061689be4d2e.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"7-2-转发视图\"><a href=\"#7-2-转发视图\" class=\"headerlink\" title=\"7.2 转发视图\"></a>7.2 转发视图</h2><p><strong>SpringMVC中默认的转发视图是InternalResourceView</strong></p>\n<ul>\n<li>转发过程：<br>客户浏览器发送 HTTP 请求，Web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户。在这里<strong>转发的路径必须是同一个 Web 容器下的 URL，其不能转向到其他的 Web 路径上，中间传递的是自己的容器内的 request</strong></li>\n<li>SpringMVC 中创建转发视图的情况：<br>当控制器方法中所设置的视图名称以 <code>&quot;forward:&quot;</code> 为前缀时，创建InternalResourceView 视图，<strong>此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>&quot;forward:&quot;</code> 去掉，剩余部分作为最终路径通过转发的方式实现跳转</strong></li>\n<li><strong>浏览器发送一次请求，地址不变，发生在服务器内部，不能跨域</strong></li>\n</ul>\n<p><strong>例如：<code>&quot;forward:/&quot;</code>，<code>&quot;forward:/employe</code></strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;test&quot;)\npublic String test()&#123;\n\treturn &quot;forward:toSuccess&quot;;\n&#125;\n@RequestMapping(&quot;toSuccess&quot;)\npublic String toSuccess(Model model)&#123;\n\tmodel.addAttribute(&quot;test&quot;,&quot;testModel&quot;);\n\treturn &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"7-3-重定向视图\"><a href=\"#7-3-重定向视图\" class=\"headerlink\" title=\"7.3 重定向视图\"></a>7.3 重定向视图</h2><p><strong>SpringMVC中默认的重定向视图是RedirectView</strong></p>\n<ul>\n<li>重定向过程：<br>客户浏览器发送 HTTP 请求，<strong>Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 HTTP 请求，请求 URL 是新的 location 地址</strong>，服务器根据此请求寻找资源并发送给客户</li>\n<li>SpringMVC 中创建重定向视图的情况：<br>当控制器方法中所设置的视图名称以 <code>&quot;redirect:&quot;</code> 为前缀时，创建 RedirectView 视图，此时的<strong>视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>&quot;redirect:&quot;</code> 去掉，剩余部分作为最终路径通过重定向的方式实现跳转</strong></li>\n<li><strong>浏览器发送两次请求，地址改变，WEB-INF目录下内容不能被重定向，具有安全性，可以跨域</strong></li>\n</ul>\n<p><strong>例如：<code>&quot;redirect:/&quot;</code>，<code>&quot;redirect:/employee&quot;</code></strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;test&quot;)\npublic String test()&#123;\n\treturn &quot;redirect:toSuccess&quot;;\n&#125;\n@RequestMapping(&quot;toSuccess&quot;)\npublic String toSuccess(Model model)&#123;\n\tmodel.addAttribute(&quot;test&quot;,&quot;testModel&quot;);\n\treturn &quot;success&quot;;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/a3e513280d324e48ba4eb0367c51e5ef.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"7-4-视图控制器\"><a href=\"#7-4-视图控制器\" class=\"headerlink\" title=\"7.4 视图控制器\"></a>7.4 视图控制器</h2><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用 <code>view-controller</code> 标签进行表示。</p>\n<p><strong>当 SpringMVC 中设置任何一个 view-controller 时，其他控制器中的请求映射将全部失效，此时需要在 SpringMVC 的核心配置文件中设置开启 MVC 注解驱动的标签：<code>&lt;mvc:annotation-driven /&gt;</code></strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--\n    path：设置处理的请求地址\n    view-name：设置请求地址所对应的视图名称\n--&gt;\n&lt;mvc:view-controller path&#x3D;&quot;&#x2F;index&quot; view-name&#x3D;&quot;index&quot; &#x2F;&gt;\n&lt;mvc:annotation-driven &#x2F;&gt;</code></pre>\n\n<p><strong>在 Spring MVC 框架中，不管是重定向或转发，都需要符合视图解析器的配置，如果直接转发到一个不需要 DispatcherServlet 的资源，则需要配置静态资源路径</strong></p>\n<h1 id=\"8-RESTful\"><a href=\"#8-RESTful\" class=\"headerlink\" title=\"8. RESTful\"></a>8. RESTful</h1><h2 id=\"8-1-RESTful-简介\"><a href=\"#8-1-RESTful-简介\" class=\"headerlink\" title=\"8.1 RESTful 简介\"></a>8.1 RESTful 简介</h2><p><strong>REST：Representational State Transfer，表现层资源状态转移</strong></p>\n<ul>\n<li><strong>资源****资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念</strong><br>因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解<br><strong>与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词</strong><br><strong>一个资源可以由一个或多个 URI 来标识。URI 既是资源的名称，也是资源在 Web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 与其进行交互</strong></li>\n<li><strong>资源的表述****资源的表述是一段对于资源在某个特定时刻的状态的描述，可以在客户端-服务器端之间转移（交换）</strong><br>资源的表述可以有多种格式，例如 HTML&#x2F;XML&#x2F;JSON&#x2F;纯文本&#x2F;图片&#x2F;视频&#x2F;音频等等。<strong>资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式</strong></li>\n<li><strong>状态转移</strong><br><strong>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的</strong></li>\n</ul>\n<h2 id=\"8-2-RESTful-的实现\"><a href=\"#8-2-RESTful-的实现\" class=\"headerlink\" title=\"8.2 RESTful 的实现\"></a>8.2 RESTful 的实现</h2><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。分别对应四种基本操作：<strong>GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE用来删除资源</strong></p>\n<p><strong>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性</strong><br><img src=\"https://img-blog.csdnimg.cn/d3c1ae97589f4a218630ea6b4daab50c.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"8-3-HiddenHttpMethodFilter\"><a href=\"#8-3-HiddenHttpMethodFilter\" class=\"headerlink\" title=\"8.3 HiddenHttpMethodFilter\"></a>8.3 HiddenHttpMethodFilter</h2><p><strong>由于浏览器只支持发送 GET 和 POST 方式的请求，SpringMVC 提供了 HiddenHttpMethodFilter 将 POST 请求转换为 DELETE 或 PUT 请求</strong></p>\n<p><strong>HiddenHttpMethodFilter 处理 PUT 和 DELETE 请求的条件：</strong></p>\n<ul>\n<li><strong>当前请求的请求方式必须为 POST</strong></li>\n<li><strong>当前请求必须传输请求参数 _method</strong></li>\n</ul>\n<p>满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数 _method 的值，因此<strong>请求参数 _method 的值才是最终的请求方式</strong></p>\n<p><strong>在 web.xml 中注册 HiddenHttpMethodFilte</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;filter&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;, method &#x3D; RequestMethod.PUT)\npublic String user(String username, String password)&#123;\n    System.out.println(&quot;username&quot; + username + &quot;,password&quot; + password);\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form method&#x3D;&quot;post&quot;&gt; &#x2F;&#x2F; post 请求\n    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;put&quot;&gt; &#x2F;&#x2F; 设置_method\n \t  email:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot;&gt;&lt;br&gt;\n    gender:&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;1&quot;&gt;male\n    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;0&quot;&gt;female&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;add&quot;&gt;&lt;br&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<p><strong>目前为止，SpringMVC 中提供了两个过滤器：CharacterEncodingFilter 和 HiddenHttpMethodFilter</strong></p>\n<p><strong>在 web.xml 中注册时，必须先注册 CharacterEncodingFilter，再注册 HiddenHttpMethodFilter</strong></p>\n<p><strong>在 CharacterEncodingFilter 中通过 <code>request.setCharacterEncoding(encoding)</code> 方法设置字符集。<code>request.setCharacterEncoding(encoding)</code> 方法要求前面不能有任何获取请求参数的操作，而 HiddenHttpMethodFilter 恰恰有一个获取请求参数的操作 <code>String paramValue = request.getParameter(this.methodParam);</code></strong></p>\n<h1 id=\"9-HttpMessageConverter\"><a href=\"#9-HttpMessageConverter\" class=\"headerlink\" title=\"9. HttpMessageConverter\"></a>9. HttpMessageConverter</h1><p><strong>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</strong></p>\n<p><strong>HttpMessageConverter 提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity</strong></p>\n<h2 id=\"9-1-RequestBody\"><a href=\"#9-1-RequestBody\" class=\"headerlink\" title=\"9.1 @RequestBody\"></a>9.1 @RequestBody</h2><p><strong>@RequestBody 可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody 进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form th:action&#x3D;&quot;@&#123;&#x2F;testRequestBody&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testRequestBody&quot;)\npublic String testRequestBody(@RequestBody String requestBody)&#123;\n    System.out.println(&quot;requestBody:&quot;+requestBody);\n    return &quot;success&quot;;\n&#125;\n输出：requestBody:username&#x3D;admin&amp;password&#x3D;1234</code></pre>\n\n<h2 id=\"9-2-RequestEntity\"><a href=\"#9-2-RequestEntity\" class=\"headerlink\" title=\"9.2 RequestEntity\"></a>9.2 RequestEntity</h2><p><strong>RequestEntity 封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过 getHeaders() 获取请求头信息，通过 getBody() 获取请求体信息</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testRequestEntity&quot;)\npublic String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123;\n    System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders());\n    System.out.println(&quot;requestBody:&quot;+requestEntity.getBody());\n    return &quot;success&quot;;\n&#125;</code></pre>\n\n<h2 id=\"9-3-ResponseBody\"><a href=\"#9-3-ResponseBody\" class=\"headerlink\" title=\"9.3 @ResponseBody\"></a>9.3 @ResponseBody</h2><p><strong>@ResponseBody 用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testResponseBody&quot;)\n@ResponseBody\npublic String testResponseBody()&#123;\n    return &quot;success&quot;;\n&#125;\n&#x2F;&#x2F; 浏览器页面显示 success</code></pre>\n\n<h2 id=\"9-4-SpringMVC-处理-JSON\"><a href=\"#9-4-SpringMVC-处理-JSON\" class=\"headerlink\" title=\"9.4 SpringMVC 处理 JSON\"></a>9.4 SpringMVC 处理 JSON</h2><h3 id=\"9-4-1-JSON-概述\"><a href=\"#9-4-1-JSON-概述\" class=\"headerlink\" title=\"9.4.1 JSON 概述\"></a>9.4.1 JSON 概述</h3><p><strong>与 XML 一样，JSON 也是基于纯文本的数据格式。它有对象结构和数组结构两种数据结构</strong></p>\n<ol>\n<li><p>对象结构<br><strong>对象结构以 <code>&#123;开始、以&#125;</code> 结束，中间部分由 0 个或多个以英文,分隔的 key&#x2F;value 对构成，key 和 value 之间以英文:分隔。</strong> 对象结构的语法结构如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    key1:value1,\n    key2:value2,\n    ...\n&#125;</code></pre>\n\n<p><strong>其中，key 必须为 String 类型，value 可以是 String、Number、Object、Array 等数据类型。例如，一个 person 对象包含姓名、密码、年龄等信息，使用 JSON 的表示形式如下：</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;pname&quot;:&quot;张三&quot;,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;page&quot;:40\n&#125;</code></pre></li>\n<li><p>数组结构<br><strong>数组结构以 <code>[开始、以]</code> 结束，中间部分由 0 个或多个以英文,分隔的值的列表组成。</strong> 数组结构的语法结构如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">[\n    value1,\n    value2,\n    ...\n]</code></pre>\n\n<p><strong>上述两种（对象、数组）数据结构也可以分别组合构成更加复杂的数据结构。例如，一个 student 对象包含 sno、sname、hobby 和 college 对象，其 JSON 的表示形式如下：</strong></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;sno&quot;:&quot;201802228888&quot;,\n    &quot;sname&quot;:&quot;张三&quot;,\n    &quot;hobby&quot;:[&quot;篮球&quot;,&quot;足球&quot;]，\n    &quot;college&quot;:&#123;\n        &quot;cname&quot;:&quot;清华大学&quot;,\n        &quot;city&quot;:&quot;北京&quot;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"9-4-2-ResponseBody-处理-JSON-的步骤\"><a href=\"#9-4-2-ResponseBody-处理-JSON-的步骤\" class=\"headerlink\" title=\"9.4.2 @ResponseBody 处理 JSON 的步骤\"></a>9.4.2 @ResponseBody 处理 JSON 的步骤</h2><ol>\n<li><strong>导入 jackson 的依赖</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 开源的jackson，Spring MVC 内置的 JSON 转换工具 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- fastjson，用 Java 语言编写的高性能 JSON 处理器，由阿里巴巴公司开发。不需要依赖其它的 jar 文件，\n就能直接在 JDK 上运行。FastJson 在复杂类型的 Bean 转换 JSON 上会出现一些问题，可能会出现引用的类型，\n导致 JSON 转换出错，需要制定引用。--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.62&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre></li>\n<li><strong>在SpringMVC的核心配置文件中开启 MVC 的注解驱动，此时在 HandlerAdaptor 中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的 Java 对象转换为 JSON 格式的字符串</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;mvc:annotation-driven &#x2F;&gt;</code></pre></li>\n<li><strong>在处理器方法上使用@ResponseBody注解进行标识</strong></li>\n<li><strong>将 Java 对象直接作为控制器方法的返回值返回，就会自动转换为 JSON 格式的字符串</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testResponseUser&quot;)\n@ResponseBody\npublic User testResponseUser()&#123;\n    return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);\n&#125;\n&#x2F;&#x2F; &#123;&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;&#125;</code></pre>\n\n<h2 id=\"9-5-SpringMVC-处理-ajax\"><a href=\"#9-5-SpringMVC-处理-ajax\" class=\"headerlink\" title=\"9.5 SpringMVC 处理 ajax\"></a>9.5 SpringMVC 处理 ajax</h2><ol>\n<li><strong>请求超链接：</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;a th:href&#x3D;&quot;@&#123;&#x2F;testAjax&#125;&quot; @click&#x3D;&quot;testAjax&quot;&gt;testAjax&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;&#x2F;div&gt;</code></pre></li>\n<li><strong>通过 Vue 和 Axios 处理点击事件：</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;js&#x2F;vue.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;js&#x2F;axios.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    var vue &#x3D; new Vue(&#123;\n        el:&quot;#app&quot;,\n        methods:&#123;\n            testAjax:function (event) &#123;\n                axios(&#123;\n                    method:&quot;post&quot;,\n                    url:event.target.href,\n                    params:&#123;\n                        username:&quot;admin&quot;,\n                        password:&quot;123456&quot;\n                    &#125;\n                &#125;).then(function (response) &#123;\n                    alert(response.data);\n                &#125;);\n                event.preventDefault();\n            &#125;\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;</code></pre></li>\n<li><strong>控制器方法：</strong><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testAjax&quot;)\n@ResponseBody\npublic String testAjax(String username, String password)&#123;\n    System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password);\n    return &quot;hello,ajax&quot;;\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"9-6-RestController-注解\"><a href=\"#9-6-RestController-注解\" class=\"headerlink\" title=\"9.6 @RestController 注解\"></a>9.6 @RestController 注解</h2><p><strong>@RestController 注解是 SpringMVC 提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 @Controller 注解，并且为其中的每个方法添加了 @ResponseBody 注解</strong></p>\n<h2 id=\"9-7-ResponseEntity\"><a href=\"#9-7-ResponseEntity\" class=\"headerlink\" title=\"9.7 ResponseEntity\"></a>9.7 ResponseEntity</h2><p><strong>ResponseEntity 用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</strong></p>\n<h2 id=\"9-8-ResponseEntity-和-ResponseBody-的区别\"><a href=\"#9-8-ResponseEntity-和-ResponseBody-的区别\" class=\"headerlink\" title=\"9.8 ResponseEntity 和 ResponseBody 的区别\"></a>9.8 ResponseEntity 和 ResponseBody 的区别</h2><ol>\n<li><strong>ResponseEntity 的优先级高于 @ResponseBody</strong><br>在不是 ResponseEntity 的情况下才去检查有没有 @ResponseBody 注解。如果响应类型是 ResponseEntity 可以不写 @ResponseBody 注解，写了也没有关系。@ResponseBody 可以直接返回 JSON 结果，</li>\n<li><strong>ResponseEntity 表示整个 HTTP 响应：状态代码，标题和正文。因此，可以使用它来完全配置 HTTP 响应，它是一个对象。@ResponseEntity 不仅可以返回 JSON 结果，还可以定义返回的 HttpHeaders 和 HttpStatus</strong></li>\n</ol>\n<h1 id=\"10-文件上传和下载\"><a href=\"#10-文件上传和下载\" class=\"headerlink\" title=\"10. 文件上传和下载\"></a>10. 文件上传和下载</h1><h2 id=\"10-1-文件下载\"><a href=\"#10-1-文件下载\" class=\"headerlink\" title=\"10.1 文件下载\"></a>10.1 文件下载</h2><p><strong>使用 ResponseEntity 实现下载文件的功能：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testDown&quot;)\npublic ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123;\n    &#x2F;&#x2F;获取ServletContext对象\n    ServletContext servletContext &#x3D; session.getServletContext();\n    &#x2F;&#x2F;获取服务器中文件的真实路径\n    String realPath &#x3D; servletContext.getRealPath(&quot;&#x2F;static&#x2F;img&#x2F;1.jpg&quot;);\n    &#x2F;&#x2F;创建输入流\n    InputStream is &#x3D; new FileInputStream(realPath);\n    &#x2F;&#x2F;创建字节数组\n    byte[] bytes &#x3D; new byte[is.available()];\n    &#x2F;&#x2F;将流读到字节数组中\n    is.read(bytes);\n    &#x2F;&#x2F;创建HttpHeaders对象设置响应头信息\n    MultiValueMap&lt;String, String&gt; headers &#x3D; new HttpHeaders();\n    &#x2F;&#x2F;设置要下载方式以及下载文件的名字\n    headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;1.jpg&quot;);\n    &#x2F;&#x2F;设置响应状态码\n    HttpStatus statusCode &#x3D; HttpStatus.OK;\n    &#x2F;&#x2F;创建ResponseEntity对象\n    ResponseEntity&lt;byte[]&gt; responseEntity &#x3D; new ResponseEntity&lt;&gt;(bytes, headers, statusCode);\n    &#x2F;&#x2F;关闭输入流\n    is.close();\n    return responseEntity;\n&#125;</code></pre>\n\n<h2 id=\"10-2-文件上传\"><a href=\"#10-2-文件上传\" class=\"headerlink\" title=\"10.2 文件上传\"></a>10.2 文件上传</h2><p><strong>文件上传要求 Form 表单的请求方式必须为 POST，并且添加属 <code>enctype=&quot;multipart/form-data&quot;</code>，SpringMVC 中将上传的文件封装到 MultipartFile 对象中，通过此对象可以获取文件相关信息</strong></p>\n<ol>\n<li><p><strong>添加依赖：</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre></li>\n<li><p><strong>在 SpringMVC 的配置文件中添加配置，文件上传解析器，根据 id 获取，固定值</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\n\t\t&lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;5000000&quot; &#x2F;&gt;\n    &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p><strong>控制器方法：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;testUp&quot;)\npublic String testUp(MultipartFile photo, HttpSession session) throws IOException &#123;\n    &#x2F;&#x2F;获取上传的文件的文件名\n    String fileName &#x3D; photo.getOriginalFilename();\n    &#x2F;&#x2F;处理文件重名问题\n    String hzName &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;));\n     fileName &#x3D; UUID.randomUUID().toString() + hzName;\n    &#x2F;&#x2F;获取服务器中photo目录的路径\n    ServletContext servletContext &#x3D; session.getServletContext();\n    String photoPath &#x3D; servletContext.getRealPath(&quot;photo&quot;);\n    File file &#x3D; new File(photoPath);\n    if(!file.exists())&#123;\n        file.mkdir();\n    &#125;\n    String finalPath &#x3D; photoPath + File.separator + fileName;\n    &#x2F;&#x2F;实现上传功能\n    photo.transferTo(new File(finalPath));\n    return &quot;success&quot;;\n&#125;</code></pre></li>\n<li><p><strong>页面：</strong><br><strong>负责文件上传表单的编码类型必须是 <code>“multipart/form-data”</code> 类型，表单的 enctype 属性指定的是表单数据的编码方式</strong>，该属性有以下 3 个值：</p>\n<ul>\n<li><code>application/x-www-form-urlencoded</code>：这是默认的编码方式，它只处理表单域里的 value 属性值</li>\n<li><code>multipart/form-data</code>：该编码方式以二进制流的方式来处理表单数据，并将文件域指定文件的内容封装到请求参数里</li>\n<li><code>text/plain</code>：该编码方式只有当表单的 action 属性为 <code>“mailto：”URL</code> 的形式时才使用，主要适用于直接通过表单发送邮件的方式</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath &#125;&#x2F;fileupload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n        选择文件：&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;myfile&quot;&gt;&lt;br&gt; \n        文件描述：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;description&quot;&gt;&lt;br&gt; \n        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;</code></pre></li>\n</ol>\n<h1 id=\"11-拦截器、异常处理器\"><a href=\"#11-拦截器、异常处理器\" class=\"headerlink\" title=\"11. 拦截器、异常处理器\"></a>11. 拦截器、异常处理器</h1><h2 id=\"11-1-拦截器的配置\"><a href=\"#11-1-拦截器的配置\" class=\"headerlink\" title=\"11.1 拦截器的配置\"></a>11.1 拦截器的配置</h2><ul>\n<li>SpringMVC 中的拦截器用于拦截控制器方法的执行</li>\n<li>SpringMVC 中的拦截器需要实现 HandlerInterceptor<ul>\n<li><strong>通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类（例如 HandlerInterceptorAdapter）来定义</strong></li>\n<li><strong>通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口的实现类来定义</strong></li>\n</ul>\n</li>\n<li>SpringMVC 的拦截器必须在 SpringMVC 的配置文件中进行配置<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;mvc:interceptors&gt;\n\t&lt;bean class&#x3D;&quot;fan.FirstInterceptor&quot;&gt;&lt;&#x2F;bean&gt;\n\t&lt;ref bean&#x3D;&quot;firstInterceptor&quot;&gt;&lt;&#x2F;ref&gt;\n&lt;!-- 以上两种配置方式都是对 DispatcherServlet 所处理的所有的请求进行拦截 --&gt;\n    &lt;mvc:interceptor&gt;\n    \t&lt;!-- 配置拦截器作用的路径 &#x2F;* 表示一层目录，&#x2F;** 表示拦截所有请求 --&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;\n        &lt;!-- 配置不需要拦截作用的路径 --&gt;\n        &lt;mvc:exclude-mapping path&#x3D;&quot;&#x2F;testRequestEntity&quot;&#x2F;&gt;\n        &lt;!-- 定义 &lt;mvc:interceptor&gt; 元素中，表示匹配指定路径的请求才进行拦截 --&gt;\n        &lt;ref bean&#x3D;&quot;firstInterceptor&quot;&gt;&lt;&#x2F;ref&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n&lt;&#x2F;mvc:interceptors&gt;\n&lt;!-- \n    以上配置方式可以通过 ref 或 bean 标签设置拦截器，通过 mvc:mapping 设置需要拦截的请求，\n    通过 mvc:exclude-mapping 设置需要排除的请求，即不需要拦截的请求\n--&gt;</code></pre></li>\n</ul>\n<p><strong><code>&lt;mvc:interceptor&gt;</code> 元素的子元素必须按照 <code>&lt;mvc:mapping.../&gt;</code>、<code>&lt;mvc:exclude-mapping.../&gt;</code>、<code>&lt;bean.../&gt;</code> 的顺序配置</strong></p>\n<h2 id=\"11-2-拦截器的三个抽象方法\"><a href=\"#11-2-拦截器的三个抽象方法\" class=\"headerlink\" title=\"11.2 拦截器的三个抽象方法\"></a>11.2 拦截器的三个抽象方法</h2><p><strong>SpringMVC 中的拦截器有三个抽象方法：</strong></p>\n<ul>\n<li><strong>preHandle：</strong> 控制器方法执行之前执行 preHandle()，其 boolean 类型的返回值表示是否拦截或放行，返回 true 为放行，即调用控制器方法；返回 false 表示拦截，即不调用控制器方法</li>\n<li><strong>postHandle：</strong> 控制器方法执行之后执行 postHandle()</li>\n<li><strong>afterComplation：</strong> 处理完视图和模型数据，渲染视图完毕之后执行 afterComplation()</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/81fdd0e038d34bb191bc638ef02e5d93.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/653ee9ff9ac949979e73216e27aa6dc2.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FirstInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;preHandle...&quot;);\n        return true;\n    &#125;\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;postHandle...&quot;);\n    &#125;\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;afterCompletion...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"11-3-多个拦截器的执行顺序\"><a href=\"#11-3-多个拦截器的执行顺序\" class=\"headerlink\" title=\"11.3 多个拦截器的执行顺序\"></a>11.3 多个拦截器的执行顺序</h2><ol>\n<li><strong>若每个拦截器的 preHandle() 都返回 true</strong><br>此时多个拦截器的执行顺序和拦截器在 SpringMVC 的配置文件的配置顺序有关：<strong>preHandle() 会按照配置的顺序执行，而 postHandle() 和 afterComplation() 会按照配置的反序执行</strong></li>\n<li><strong>若某个拦截器的 preHandle() 返回了 false</strong><br><strong>preHandle() 返回 false 和它之前的拦截器的 preHandle() 都会执行，postHandle() 都不执行，返回 false 的拦截器之前的拦截器的 afterComplation() 会执行</strong></li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/fcc541b0e1d24080800fa5bc11c4d4dc.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/af1930fd68af45d199de9b1db3089e27.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/29aa511a3396439a8cd92b6c5ff2d6e9.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"11-4-基于配置的异常处理\"><a href=\"#11-4-基于配置的异常处理\" class=\"headerlink\" title=\"11.4 基于配置的异常处理\"></a>11.4 基于配置的异常处理</h2><ul>\n<li>SpringMVC 提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</li>\n<li>HandlerExceptionResolver 接口的实现类有：DefaultHandlerExceptionResolver 默认异常处理器和 SimpleMappingExceptionResolver 简单异常处理器</li>\n<li>SpringMVC 提供了自定义的异常处理器 SimpleMappingExceptionResolver</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;exceptionMappings&quot;&gt;\n        &lt;props&gt;\n            &lt;!--\n                properties的键表示处理器方法执行过程中出现的异常\n                properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面\n            --&gt;\n            &lt;prop key&#x3D;&quot;java.lang.ArithmeticException&quot;&gt;error&lt;&#x2F;prop&gt;\n        &lt;&#x2F;props&gt;\n    &lt;&#x2F;property&gt;\n    &lt;!--\n        exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --&gt;\n    &lt;property name&#x3D;&quot;exceptionAttribute&quot; value&#x3D;&quot;ex&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<h2 id=\"11-5-基于注解的异常处理\"><a href=\"#11-5-基于注解的异常处理\" class=\"headerlink\" title=\"11.5 基于注解的异常处理\"></a>11.5 基于注解的异常处理</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;@ControllerAdvice将当前类标识为异常处理的组件\n@ControllerAdvice\npublic class ExceptionController &#123;\n    &#x2F;&#x2F;@ExceptionHandler用于设置所标识方法处理的异常\n    @ExceptionHandler(value &#x3D; &#123;ArithmeticException.class, NullPointerException.class&#125;)\n    &#x2F;&#x2F;ex表示当前请求处理中出现的异常对象\n    public String testException(Exception ex, Model model)&#123;\n        model.addAttribute(&quot;ex&quot;, ex);\n        return &quot;error&quot;;\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"12-注解配置-SpringMVC\"><a href=\"#12-注解配置-SpringMVC\" class=\"headerlink\" title=\"12. 注解配置 SpringMVC\"></a>12. 注解配置 SpringMVC</h1><p><strong>使用配置类和注解代替 web.xml 和 SpringMVC 配置文件的功能</strong></p>\n<h2 id=\"12-1-创建初始化类，代替-web-xml\"><a href=\"#12-1-创建初始化类，代替-web-xml\" class=\"headerlink\" title=\"12.1 创建初始化类，代替 web.xml\"></a>12.1 创建初始化类，代替 web.xml</h2><p>在 Servlet3.0 环境中，容器会在类路径中查找实现 <code>javax.servlet.ServletContainerInitializer</code> 接口的类，如果找到的话就用它来配置 Servlet 容器。 Spring 提供了这个接口的实现，名为 <code>SpringServletContainerInitializer</code>，这个类反过来又会查找实现 <code>WebApplicationInitializer</code> 的类并将配置的任务交给它们来完成</p>\n<p>Spring3.2 引入了一个便利的 <code>WebApplicationInitializer</code> 基础实现，名为 <code>AbstractAnnotationConfigDispatcherServletInitializer</code>，当我们的类扩展了 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 并将其部署到 Servlet3.0 容器的时候，容器会自动发现它，并用它来配置 Servlet 上下文</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    &#x2F;**\n     * 指定spring的配置类\n     * @return\n     *&#x2F;\n    @Override\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[]&#123;SpringConfig.class&#125;;\n    &#125;\n    &#x2F;**\n     * 指定SpringMVC的配置类\n     * @return\n     *&#x2F;\n    @Override\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[]&#123;WebConfig.class&#125;;\n    &#125;\n    &#x2F;**\n     * 指定DispatcherServlet的映射规则，即url-pattern\n     * @return\n     *&#x2F;\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n    &#x2F;**\n     * 添加过滤器\n     * @return\n     *&#x2F;\n    @Override\n    protected Filter[] getServletFilters() &#123;\n        CharacterEncodingFilter encodingFilter &#x3D; new CharacterEncodingFilter();\n        encodingFilter.setEncoding(&quot;UTF-8&quot;);\n        encodingFilter.setForceRequestEncoding(true);\n        HiddenHttpMethodFilter hiddenHttpMethodFilter &#x3D; new HiddenHttpMethodFilter();\n        return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"10-2-创建-SpringConfig-配置类，代替-Spring-的配置文件\"><a href=\"#10-2-创建-SpringConfig-配置类，代替-Spring-的配置文件\" class=\"headerlink\" title=\"10.2 创建 SpringConfig 配置类，代替 Spring 的配置文件\"></a>10.2 创建 SpringConfig 配置类，代替 Spring 的配置文件</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SpringConfig &#123;\n    &#x2F;&#x2F; ssm整合之后，Spring 的配置信息写在此类中\n&#125;</code></pre>\n\n<h2 id=\"10-3-创建-WebConfig-配置类，代替-SpringMVC-的配置文件\"><a href=\"#10-3-创建-WebConfig-配置类，代替-SpringMVC-的配置文件\" class=\"headerlink\" title=\"10.3 创建 WebConfig 配置类，代替 SpringMVC 的配置文件\"></a>10.3 创建 WebConfig 配置类，代替 SpringMVC 的配置文件</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n&#x2F;&#x2F;扫描组件\n@ComponentScan(&quot;fan.com.controller&quot;)\n&#x2F;&#x2F;开启MVC注解驱动\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F;使用默认的servlet处理静态资源\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;\n        configurer.enable();\n    &#125;\n    &#x2F;&#x2F;配置文件上传解析器\n    @Bean\n    public CommonsMultipartResolver multipartResolver()&#123;\n        return new CommonsMultipartResolver();\n    &#125;\n    &#x2F;&#x2F;配置拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        FirstInterceptor firstInterceptor &#x3D; new FirstInterceptor();\n        registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;&#x2F;**&quot;);\n    &#125;\n  \n    &#x2F;&#x2F;配置视图控制\n  \n    &#x2F;*@Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;index&quot;);\n    &#125;*&#x2F;\n  \n    &#x2F;&#x2F;配置异常映射\n    &#x2F;*@Override\n    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;\n        SimpleMappingExceptionResolver exceptionResolver &#x3D; new SimpleMappingExceptionResolver();\n        Properties prop &#x3D; new Properties();\n        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);\n        &#x2F;&#x2F;设置异常映射\n        exceptionResolver.setExceptionMappings(prop);\n        &#x2F;&#x2F;设置共享异常信息的键\n        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);\n        resolvers.add(exceptionResolver);\n    &#125;*&#x2F;\n    &#x2F;&#x2F;配置生成模板解析器\n    @Bean\n    public ITemplateResolver templateResolver() &#123;\n        WebApplicationContext webApplicationContext &#x3D; ContextLoader.getCurrentWebApplicationContext();\n        &#x2F;&#x2F; ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得\n        ServletContextTemplateResolver templateResolver &#x3D; new ServletContextTemplateResolver(webApplicationContext.getServletContext());\n        templateResolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;templates&#x2F;&quot;);\n        templateResolver.setSuffix(&quot;.html&quot;);\n        templateResolver.setCharacterEncoding(&quot;UTF-8&quot;);\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        return templateResolver;\n    &#125;\n    &#x2F;&#x2F;生成模板引擎并为模板引擎注入模板解析器\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123;\n        SpringTemplateEngine templateEngine &#x3D; new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    &#125;\n    &#x2F;&#x2F;生成视图解析器并未解析器注入模板引擎\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123;\n        ThymeleafViewResolver viewResolver &#x3D; new ThymeleafViewResolver();\n        viewResolver.setCharacterEncoding(&quot;UTF-8&quot;);\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    &#125;\n&#125;</code></pre>\n","feature":false,"text":"1. 配置1.1 MVC 概念MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的 JavaBean，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）JavaBean 分为两类： 一类称为实体类 Bean：专门存...","link":"","photos":[],"count_time":{"symbolsCount":"58k","symbolsTime":"53 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1. 配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-MVC-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 MVC 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-SpringMVC-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.2 SpringMVC 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-SpringMVC%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.3 SpringMVC的特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E9%85%8D%E7%BD%AE-web-xml\"><span class=\"toc-text\">1.4 配置 web.xml</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E9%85%8D%E7%BD%AE-springmvc-config-xml\"><span class=\"toc-text\">1.5 配置 springmvc-config.xml</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-%E6%8E%A7%E5%88%B6%E5%99%A8\"><span class=\"toc-text\">1.6 控制器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-Thymeleaf-%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">1.7 Thymeleaf 页面</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">1.8 工作流程小结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8-ViewResolver\"><span class=\"toc-text\">2. 视图解析器 ViewResolver</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-URLBasedViewResolver\"><span class=\"toc-text\">2.1 URLBasedViewResolver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-InternalResourceViewResolver\"><span class=\"toc-text\">2.2 InternalResourceViewResolver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-FreeMarkerViewResolver\"><span class=\"toc-text\">2.3 FreeMarkerViewResolver</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Spring-MVC-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3.Spring MVC 执行流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Spring-MVC-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3.1 Spring MVC 常用组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8-DispatcherServlet\"><span class=\"toc-text\">3.1.1 前端控制器 DispatcherServlet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8-HandlerMapping\"><span class=\"toc-text\">3.1.2 处理器映射器 HandlerMapping</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-3-%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-HandlerAdapter\"><span class=\"toc-text\">3.1.3 处理器适配器 HandlerAdapter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-4-%E5%A4%84%E7%90%86%E5%99%A8-Handler\"><span class=\"toc-text\">3.1.4 处理器 Handler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-5-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8-View-Resolver\"><span class=\"toc-text\">3.1.5 视图解析器 View Resolver</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-6-%E8%A7%86%E5%9B%BE-View\"><span class=\"toc-text\">3.1.6 视图 View</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-DispatcherServlet-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">3.2 DispatcherServlet 初始化过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-SpringMVC-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3.3 SpringMVC 的执行流程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-RequestMapping-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">4. RequestMapping 注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-RequestMapping-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">4.1 @RequestMapping 注解的功能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-RequestMapping-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">4.2 @RequestMapping 注解的位置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-value-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.3 value 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-path-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.4 path 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-name-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.5 name 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-method-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.6 method 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-params-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.7 params 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-8-headers-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.8 headers 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-9-consumers-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.9 consumers 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-10-produces-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">4.10 produces 属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-11-SpringMVC%E6%94%AF%E6%8C%81ant%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">4.11 SpringMVC支持ant风格的路径</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-12-SpringMVC-%E6%94%AF%E6%8C%81%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6\"><span class=\"toc-text\">4.12 SpringMVC 支持路径中的占位符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-SpringMVC-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">5. SpringMVC 获取请求参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E5%8E%9F%E7%94%9F-ServletAPI-%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">5.1 原生 ServletAPI 获取</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">5.2 通过控制器方法的形参获取请求参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-RequestParam\"><span class=\"toc-text\">5.3 @RequestParam</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-RequestHeader\"><span class=\"toc-text\">5.4 @RequestHeader</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-CookieValue\"><span class=\"toc-text\">5.5 @CookieValue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-%E9%80%9A%E8%BF%87-POJO-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">5.6 通过 POJO 获取请求参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-7-ModelAttribute\"><span class=\"toc-text\">5.7 @ModelAttribute</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-8-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">5.8 获取请求参数乱码问题</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6. 域共享数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E4%BD%BF%E7%94%A8-ServletAPI-%E5%90%91-request-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6.1 使用 ServletAPI 向 request 域对象共享数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-%E4%BD%BF%E7%94%A8-ModelAndView-%E5%90%91-request-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6.2 使用 ModelAndView 向 request 域对象共享数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E4%BD%BF%E7%94%A8-Model-%E5%90%91-request-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6.3 使用 Model 向 request 域对象共享数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-%E4%BD%BF%E7%94%A8-map-%E5%90%91-request-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6.4 使用 map 向 request 域对象共享数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-5-%E4%BD%BF%E7%94%A8-ModelMap-%E5%90%91-request-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6.5 使用 ModelMap 向 request 域对象共享数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-6-Model%E3%80%81ModelMap%E3%80%81Map-%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">6.6 Model、ModelMap、Map 的关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-7-%E5%90%91-session-%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6.7 向 session 域共享数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-8-%E5%90%91-application%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">6.8 向 application（应用）域共享数据</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E8%A7%86%E5%9B%BE%EF%BC%88%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%89\"><span class=\"toc-text\">7. 视图（转发与重定向）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-ThymeleafView\"><span class=\"toc-text\">7.1 ThymeleafView</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E8%BD%AC%E5%8F%91%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">7.2 转发视图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E9%87%8D%E5%AE%9A%E5%90%91%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">7.3 重定向视图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8\"><span class=\"toc-text\">7.4 视图控制器</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8-RESTful\"><span class=\"toc-text\">8. RESTful</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-1-RESTful-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">8.1 RESTful 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-2-RESTful-%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">8.2 RESTful 的实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-3-HiddenHttpMethodFilter\"><span class=\"toc-text\">8.3 HiddenHttpMethodFilter</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9-HttpMessageConverter\"><span class=\"toc-text\">9. HttpMessageConverter</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-RequestBody\"><span class=\"toc-text\">9.1 @RequestBody</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-RequestEntity\"><span class=\"toc-text\">9.2 RequestEntity</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-ResponseBody\"><span class=\"toc-text\">9.3 @ResponseBody</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-4-SpringMVC-%E5%A4%84%E7%90%86-JSON\"><span class=\"toc-text\">9.4 SpringMVC 处理 JSON</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-4-1-JSON-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">9.4.1 JSON 概述</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-4-2-ResponseBody-%E5%A4%84%E7%90%86-JSON-%E7%9A%84%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">9.4.2 @ResponseBody 处理 JSON 的步骤</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-5-SpringMVC-%E5%A4%84%E7%90%86-ajax\"><span class=\"toc-text\">9.5 SpringMVC 处理 ajax</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-6-RestController-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">9.6 @RestController 注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-7-ResponseEntity\"><span class=\"toc-text\">9.7 ResponseEntity</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-8-ResponseEntity-%E5%92%8C-ResponseBody-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">9.8 ResponseEntity 和 ResponseBody 的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">10. 文件上传和下载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-1-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">10.1 文件下载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">10.2 文件上传</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11-%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">11. 拦截器、异常处理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-1-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">11.1 拦截器的配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-2-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">11.2 拦截器的三个抽象方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-3-%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">11.3 多个拦截器的执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-4-%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">11.4 基于配置的异常处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">11.5 基于注解的异常处理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#12-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE-SpringMVC\"><span class=\"toc-text\">12. 注解配置 SpringMVC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-1-%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%EF%BC%8C%E4%BB%A3%E6%9B%BF-web-xml\"><span class=\"toc-text\">12.1 创建初始化类，代替 web.xml</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-2-%E5%88%9B%E5%BB%BA-SpringConfig-%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%8C%E4%BB%A3%E6%9B%BF-Spring-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">10.2 创建 SpringConfig 配置类，代替 Spring 的配置文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-3-%E5%88%9B%E5%BB%BA-WebConfig-%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%8C%E4%BB%A3%E6%9B%BF-SpringMVC-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">10.3 创建 WebConfig 配置类，代替 SpringMVC 的配置文件</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Spring Boot 总结","uid":"2f6fa7c456d90ea78f2273a18fcc64b4","slug":"BlogRepository/Spring/Spring Boot 总结","date":"2022-06-13T18:56:36.000Z","updated":"2023-03-13T19:13:04.933Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring Boot 总结.json","keywords":null,"cover":"https://cover.png","text":"1. 概念1.1 Spring Boot 优点 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”....","link":"","photos":[],"count_time":{"symbolsCount":"131k","symbolsTime":"1:59"},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"Spring5 总结","uid":"3b3f88b9af43070e80fc66fe9324e787","slug":"BlogRepository/Spring/Spring5 总结","date":"2022-06-08T18:01:17.000Z","updated":"2023-03-13T19:13:04.940Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring5 总结.json","keywords":null,"cover":"https://cover.png","text":"1. IOC1.1 概念 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理 好处：降低耦合度 1.2 IOC 底层原理XML解析、工厂模式、反射 1.3 IOC（接口） IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 Spring 提供IOC容器两种实...","link":"","photos":[],"count_time":{"symbolsCount":"62k","symbolsTime":"56 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}