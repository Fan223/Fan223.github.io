{"title":"Spring5 总结","uid":"3b3f88b9af43070e80fc66fe9324e787","slug":"BlogRepository/Spring/Spring5 总结","date":"2022-06-08T18:01:17.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring5 总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-IOC\"><a href=\"#1-IOC\" class=\"headerlink\" title=\"1. IOC\"></a>1. IOC</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ol>\n<li>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</li>\n<li>好处：降低耦合度</li>\n</ol>\n<h2 id=\"1-2-IOC-底层原理\"><a href=\"#1-2-IOC-底层原理\" class=\"headerlink\" title=\"1.2 IOC 底层原理\"></a>1.2 IOC 底层原理</h2><p><strong>XML解析、工厂模式、反射</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201522.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201532.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201543.png\"></p>\n<h2 id=\"1-3-IOC（接口）\"><a href=\"#1-3-IOC（接口）\" class=\"headerlink\" title=\"1.3 IOC（接口）\"></a>1.3 IOC（接口）</h2><ol>\n<li><strong>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</strong></li>\n<li><strong>Spring 提供IOC容器两种实现方式：（两个接口）</strong><ol>\n<li><strong>BeanFactory：</strong> IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用<br>加载配置文件时不会创建对象，在获取对象（使用）才去创建对象</li>\n<li><strong>ApplicationContext：</strong> BeanFactory接口的子接口，提供更多强大的功能，一般由开发人员进行使用<br>加载配置文件时就会把在配置文件对象进行创建</li>\n<li><strong>ApplicationContext接口实现类</strong><br>FileSystemXMLApplicationContext：电脑盘符路径<br>ClassPathXMLApplicationContext：src下类路径</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201553.png\"></p>\n<h2 id=\"1-4-IOC-操作-Bean-管理\"><a href=\"#1-4-IOC-操作-Bean-管理\" class=\"headerlink\" title=\"1.4 IOC 操作 Bean 管理\"></a>1.4 IOC 操作 Bean 管理</h2><ul>\n<li><strong>Bean 管理指的是两个操作：</strong><ul>\n<li>创建对象</li>\n<li>注入属性</li>\n</ul>\n</li>\n<li><strong>Bean 管理操作有两种方式：</strong><ul>\n<li>基于 XML 配置文件方式实现</li>\n<li>基于注解方式实现</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-4-1-基于-XML-方式\"><a href=\"#1-4-1-基于-XML-方式\" class=\"headerlink\" title=\"1.4.1 基于 XML 方式\"></a>1.4.1 基于 XML 方式</h3><h4 id=\"1-4-1-1-基于-XML-方式创建对象\"><a href=\"#1-4-1-1-基于-XML-方式创建对象\" class=\"headerlink\" title=\"1.4.1.1 基于 XML 方式创建对象\"></a>1.4.1.1 基于 XML 方式创建对象</h4><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;&lt;&#x2F;bean&gt;</code></pre>\n\n<ul>\n<li><strong>在 Spring 配置文件里，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</strong></li>\n<li>在 bean 标签有很多属性：<ul>\n<li><strong>id 属性：唯一标识，可以不使用 id，只留全类名，此时类名作为唯一标识</strong></li>\n<li><strong>class 属性：类全路径（包类路径）</strong></li>\n<li><strong>创建对象时，默认是执行无参构造方法完成对象创建</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-4-1-2-基于-xml-方式注入属性\"><a href=\"#1-4-1-2-基于-xml-方式注入属性\" class=\"headerlink\" title=\"1.4.1.2 基于 xml 方式注入属性\"></a>1.4.1.2 基于 xml 方式注入属性</h4><p><strong>DI：依赖注入，就是注入属性</strong></p>\n<ol>\n<li><p><strong>第一种注入方式：使用 set 方法注入</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    private Integer id;\n\tprivate String name;\n\n    public void setId(Integer id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;property&gt;\n\t&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p><strong>第二种注入方式：使用有参构造注入</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    private Integer id;\n    private String name;\n\n    public void printValue()&#123;\n        System.out.println(id + &quot;:&quot; + name);\n    &#125;\n    public User(Integer id, String name) &#123;\n        this.id &#x3D; id;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;constructor-arg name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;constructor-arg&gt;\n\t&lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;constructor-arg&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p><strong>p名称空间注入（需要依赖于 set 方法）</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; &#x2F;&#x2F; 名称空间注入\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n\t\t&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot; p:id&#x3D;&quot;1&quot; p:name&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre></li>\n</ol>\n<h4 id=\"1-4-1-3-基于-XML-方式注入属性（其他类型属性）\"><a href=\"#1-4-1-3-基于-XML-方式注入属性（其他类型属性）\" class=\"headerlink\" title=\"1.4.1.3 基于 XML 方式注入属性（其他类型属性）\"></a>1.4.1.3 基于 XML 方式注入属性（其他类型属性）</h4><ol>\n<li><p><strong>字面量（前面注入的属性都是字面量）</strong>\\</p>\n<ul>\n<li>null 值<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;property name&#x3D;&quot;name&quot;&gt;\n        &lt;null&gt;&lt;&#x2F;null&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><strong>特殊符号 &lt;&gt;</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;property&gt;\n\t&lt;property name&#x3D;&quot;name&quot;&gt;\n\t\t&lt;value&gt; &lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt; &lt;&#x2F;value&gt;\n\t\t&lt;!-- &lt;&lt;南京&gt;&gt;，也可使用转义字符 &gt;⁢ --&gt;\n\t&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n</ul>\n</li>\n<li><p><strong>注入属性-外部 bean（ref）</strong><br><strong>创建两个类 service 和 dao，在 service 里调用 dao 的方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserService &#123;\n    private UserDao userDao;\n\n    public void setUserDao(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n    public void printValue()&#123;\n        System.out.println(&quot;service add...&quot;);\n        userDao.update();\n    &#125;\n&#125;\npublic class UserDao &#123;\n    public void update() &#123;\n        System.out.println(&quot;userDao update...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;fan.com.service.UserService&quot;&gt;\n\t&lt;!-- 使用ref --&gt;\n    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;fan.com.dao.UserDao&quot;&gt;&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p><strong>注入属性-内部 bean</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Dept &#123;\n    private String dname;\n\n    public void setDname(String dname) &#123;\n        this.dname &#x3D; dname;\n    &#125;\n&#125;\npublic class Emp &#123;\n    private Integer id;\n    private String name;\n    private Dept dept;\n\n    public void setId(Integer id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    public void setDept(Dept dept) &#123;\n        this.dept &#x3D; dept;\n    &#125;\n    public void printValue()&#123;\n        System.out.println(id + &quot;:&quot; + name + &quot;:&quot; + dept);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;fan.com.domain.Emp&quot;&gt;\n    &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n\n    &lt;property name&#x3D;&quot;dept&quot;&gt;\n        &lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;fan.com.domain.Dept&quot;&gt;\n            &lt;property name&#x3D;&quot;dname&quot; value&#x3D;&quot;安保部&quot; &#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p><strong>注入属性-级联赋值</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 第一种方法 --&gt;\n&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;fan.com.domain.Emp&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;dept&quot; ref&#x3D;&quot;dept&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;fan.com.domain.Dept&quot;&gt;\n\t&lt;property name&#x3D;&quot;dname&quot; value&#x3D;&quot;安保部&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 第二种方法 --&gt;\n&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;fan.com.domain.Emp&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;dept&quot; ref&#x3D;&quot;dept&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;dept.dname&quot; value&#x3D;&quot;财务部&quot; &#x2F;&gt;  &#x2F;&#x2F; 需要 get 方法，获取到dept对象\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;fan.com.domain.Dept&quot; &#x2F;&gt;</code></pre></li>\n<li><p><strong>注入属性-数组、集合、map、set</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    private int[] arrays;\n    private List&lt;String&gt; lists;\n    private Map&lt;Integer,String&gt; maps;\n    private Set&lt;String&gt; sets;\n\n    public void setArrays(int[] arrays) &#123;\n        this.arrays &#x3D; arrays;\n    &#125;\n    public void setLists(List&lt;String&gt; lists) &#123;\n        this.lists &#x3D; lists;\n    &#125;\n    public void setMaps(Map&lt;Integer, String&gt; maps) &#123;\n        this.maps &#x3D; maps;\n    &#125;\n    public void setSets(Set&lt;String&gt; sets) &#123;\n        this.sets &#x3D; sets;\n    &#125;\n\n    public void printValue()&#123;\n        System.out.println(Arrays.toString(arrays)); System.out.println(lists);\n        System.out.println(maps); System.out.println(sets);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n    &lt;property name&#x3D;&quot;arrays&quot;&gt;\n        &lt;array&gt;\n            &lt;value&gt;1&lt;&#x2F;value&gt;\n            &lt;value&gt;2&lt;&#x2F;value&gt;\n        &lt;&#x2F;array&gt;\n    &lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;lists&quot;&gt;\n        &lt;list&gt;\n            &lt;value&gt;张三&lt;&#x2F;value&gt;\n            &lt;value&gt;小张&lt;&#x2F;value&gt;\n        &lt;&#x2F;list&gt;\n    &lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;maps&quot;&gt;\n        &lt;map&gt;\n            &lt;entry key&#x3D;&quot;1&quot; value&#x3D;&quot;Map1&quot; &#x2F;&gt;\n            &lt;entry key&#x3D;&quot;2&quot; value&#x3D;&quot;Map2&quot; &#x2F;&gt;\n        &lt;&#x2F;map&gt;\n    &lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;sets&quot;&gt;\n        &lt;set&gt;\n            &lt;value&gt;MySQL&lt;&#x2F;value&gt;\n            &lt;value&gt;Redis&lt;&#x2F;value&gt;\n        &lt;&#x2F;set&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p><strong>注入多个对象属性</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    private List&lt;Course&gt; courseList;\n\n    public void setCourseList(List&lt;Course&gt; courseList) &#123;\n        this.courseList &#x3D; courseList;\n    &#125;\n    public void printValue()&#123;\n        System.out.println(courseList.toString());\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean&gt;\n\t&lt;property name&#x3D;&quot;courseList&quot;&gt;\n\t\t&lt;list&gt;\n\t\t\t&lt;ref bean&#x3D;&quot;course1&quot; &#x2F;&gt;\n\t\t\t&lt;ref bean&#x3D;&quot;course2&quot; &#x2F;&gt;\n\t\t&lt;&#x2F;list&gt;\n\t&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;course1&quot; class&#x3D;&quot;fan.com.domain.Course&quot;&gt;\n    &lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;Spring&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;course2&quot; class&#x3D;&quot;fan.com.domain.Course&quot;&gt;\n    &lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;Spring5&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p><strong>提取集合公共部分</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot; &#x2F;&#x2F; 定义util名称空间\n       xsi:schemaLocation&#x3D;\n        \t&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd&quot;&gt;\n\t &lt;util:list id&#x3D;&quot;nameList&quot;&gt;\n        &lt;value&gt;张三&lt;&#x2F;value&gt;\n        &lt;value&gt;李四&lt;&#x2F;value&gt;\n        &lt;value&gt;王五&lt;&#x2F;value&gt;\n    &lt;&#x2F;util:list&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n        &lt;property name&#x3D;&quot;lists&quot; ref&#x3D;&quot;nameList&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre></li>\n</ol>\n<h4 id=\"1-4-1-4-工厂-Bean（FactoryBean）\"><a href=\"#1-4-1-4-工厂-Bean（FactoryBean）\" class=\"headerlink\" title=\"1.4.1.4 工厂 Bean（FactoryBean）\"></a>1.4.1.4 工厂 Bean（FactoryBean）</h4><ol>\n<li>Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean (FactoryBean)</li>\n<li><strong>普通 bean：在配置文件中定义 bean 类型就是返回类型</strong></li>\n<li><strong>工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样</strong><ul>\n<li>第一步创建类，让这个类作为工厂 bean，实现接口 FactoryBean</li>\n<li>第二步实现接口里面的方法，在实现的方法中定义返回的 bean 类型</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 创建 bean --&gt;\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot; &#x2F;&gt; &#x2F;&#x2F; 创建 bean（user）</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User implements FactoryBean&lt;Course&gt; &#123;\n    @Override\n    public Course getObject() throws Exception &#123;\n        Course course &#x3D; new Course();\n        course.setCname(&quot;abc&quot;);\n        return course;\n    &#125;\n    @Override\n    public Class&lt;?&gt; getObjectType() &#123;\n        return null;\n    &#125;\n    @Override\n    public boolean isSingleton() &#123;\n        return FactoryBean.super.isSingleton();\n    &#125;\n&#125;\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n        Course course &#x3D; context.getBean(&quot;user&quot;, Course.class); &#x2F;&#x2F; 改成返回的 bean 类型（Course）\n        System.out.println(course); &#x2F;&#x2F; Course&#123;cname&#x3D;&#39;abc&#39;&#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"1-4-2-bean-作用域\"><a href=\"#1-4-2-bean-作用域\" class=\"headerlink\" title=\"1.4.2 bean 作用域\"></a>1.4.2 bean 作用域</h3><ol>\n<li><p><strong>在 Spring 里，默认情况下， bean 是单实例对象。安全的</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n        Course course &#x3D; context.getBean(&quot;course&quot;, Course.class);\n        Course course1 &#x3D; context.getBean(&quot;course&quot;, Course.class);\n        System.out.println(course);\n        System.out.println(course1);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201605.png\"></p>\n</li>\n<li><p><strong>设置为单实例还是多实例（scope）</strong></p>\n<ul>\n<li><strong>在 spring 配置文件 bean 标签里面有属性（scope），用于设置单实例还是多实例</strong></li>\n<li><strong>scope 属性值（singleton、prototype、request、session、websocket、application）</strong><ul>\n<li>第一个值默认值，singleton，表示是单实例对象，加载 spring 配置文件时就会创建单实例对象</li>\n<li>第二个值 prototype，表示是<strong>多实例对象，不是在加载 spring 配置文件时创建对象，而是在 getBean 方法时创建多实例对象</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-4-3-bean-生命周期\"><a href=\"#1-4-3-bean-生命周期\" class=\"headerlink\" title=\"1.4.3 bean 生命周期\"></a>1.4.3 bean 生命周期</h3><ol>\n<li><strong>通过构造器创建 bean 实例(无参数构造)</strong></li>\n<li><strong>为 bean 的属性设置值和对其他bean引用(调用set方法)</strong></li>\n<li><strong>把 bean 实例传递给 bean 后置处理器的方法（postProcessBeforeInitialization）</strong></li>\n<li><strong>调用 bean 的初始化的方法(需要进行配置初始化的方法)</strong></li>\n<li><strong>把 bean 实例传递给 bean 后置处理器的方法（postProcessAfterInitialization）</strong></li>\n<li><strong>bean 可以使用了(对象获取到了)</strong></li>\n<li><strong>当容器关闭时候，调用 bean 的销毁的方法(需要进行配置销毁的方法)</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Course &#123;\n    private String cname;\n\n    public Course() &#123;\n        System.out.println(&quot;第一步：执行构造器方法&quot;);\n    &#125;\n    public void setCname(String cname) &#123;\n        this.cname &#x3D; cname;\n        System.out.println(&quot;第二步：调用set方法&quot;);\n    &#125;\n    &#x2F;&#x2F; @PostConstruct\n    public void initMethod()&#123;\n        System.out.println(&quot;第三步：执行初始化方法&quot;);\n    &#125;\n    &#x2F;&#x2F; @PreDestory\n    public void destroyMethod()&#123;\n        System.out.println(&quot;第五步：执行销毁方法&quot;);\n    &#125;\n\n&#125;\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n        Course course &#x3D; context.getBean(&quot;course&quot;, Course.class);\n        System.out.println(&quot;第四步：获取创建 bean 实例对象&quot;);\n        System.out.println(course);\n        ((ClassPathXmlApplicationContext)context).close(); &#x2F;&#x2F; 调用销毁方法\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 配置初始化方法和销毁方法 --&gt;\n&lt;bean id&#x3D;&quot;course&quot; class&#x3D;&quot;fan.com.domain.Course&quot; init-method&#x3D;&quot;initMethod&quot; destroy-method&#x3D;&quot;destroyMethod&quot;&gt;\n\t&lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201617.png\"></p>\n<h3 id=\"1-4-4-后置处理器-BeanPostProcessor\"><a href=\"#1-4-4-后置处理器-BeanPostProcessor\" class=\"headerlink\" title=\"1.4.4 后置处理器 BeanPostProcessor\"></a>1.4.4 后置处理器 BeanPostProcessor</h3><ul>\n<li><strong>postProcessBeforeInitialization 在 Bean 实例化、依赖注入后，初始化前调用</strong></li>\n<li><strong>postProcessAfterInitialization 在 Bean 实例化、依赖注入、初始化都完成后调用</strong><br>当需要<strong>添加多个后置处理器实现类</strong>时，默认情况下 Spring 容器会根据后置处理器的定义顺序来依次调用。也可以通过实现 Ordered 接口的 getOrder 方法指定后置处理器的执行顺序。该方法返回值为整数，默认值为 0，值越大优先级越低</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 创建 bean --&gt;\n&lt;bean id&#x3D;&quot;coursePost&quot; class&#x3D;&quot;fan.com.domain.CoursePost&quot; &#x2F;&gt;</code></pre>\n\n<p><strong>实现 BeanPostProcessor 接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CoursePost implements BeanPostProcessor, Ordered &#123;\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;在初始化之前执行的方法&quot;);\n        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);\n    &#125;\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;在初始化之后执行的方法&quot;);\n        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);\n    &#125;\n  \n    @Override\n    public int getOrder() &#123;\n        return 5;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201626.png\"></p>\n<h3 id=\"1-4-5-XML-自动装配\"><a href=\"#1-4-5-XML-自动装配\" class=\"headerlink\" title=\"1.4.5 XML 自动装配\"></a>1.4.5 XML 自动装配</h3><p><strong>根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入。autorire 属性常用两个值：</strong></p>\n<ul>\n<li><strong>byName，根据属性名称注入，注入值 bean 的id值和类属性名称一样</strong></li>\n<li><strong>byType，根据属性类型注入，假如有两个同样的 bean 报错</strong></li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot; autowire&#x3D;&quot;byName&quot; &#x2F;&gt;\n&lt;bean id&#x3D;&quot;course&quot; class&#x3D;&quot;fan.com.domain.Course&quot;&gt;\n        &lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<h3 id=\"1-4-6-XML（引入外部属性文件）\"><a href=\"#1-4-6-XML（引入外部属性文件）\" class=\"headerlink\" title=\"1.4.6 XML（引入外部属性文件）\"></a>1.4.6 XML（引入外部属性文件）</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;\n       \t\t&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n\t\t\t\t\t http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot; &#x2F;&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n            &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;driverClass&#125;&quot; &#x2F;&gt;\n            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot; &#x2F;&gt;\n            &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;userName&#125;&quot; &#x2F;&gt;\n            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<h2 id=\"1-5-基于注解方式\"><a href=\"#1-5-基于注解方式\" class=\"headerlink\" title=\"1.5 基于注解方式\"></a>1.5 基于注解方式</h2><ol>\n<li><strong>注解是代码特殊标记，格式: <code>@注解名称(属性名称=属性值,属性名称=属性..</code></strong></li>\n<li><strong>使用注解，注解作用在类上面，方法上面，属性上面</strong></li>\n<li><strong>使用注解目的：简化 XML 配置</strong></li>\n</ol>\n<h3 id=\"1-5-1-Spring-针对-Bean-管理中创建对象提供注解\"><a href=\"#1-5-1-Spring-针对-Bean-管理中创建对象提供注解\" class=\"headerlink\" title=\"1.5.1 Spring 针对 Bean 管理中创建对象提供注解\"></a>1.5.1 Spring 针对 Bean 管理中创建对象提供注解</h3><ol>\n<li><strong><code>@Component</code>，可以使用此注解描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。</strong> 使用时只需将该注解标注在相应类上即可。</li>\n<li><strong><code>@Service</code>，通常作用在业务层（Service 层）</strong>，用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</li>\n<li><strong><code>@Controller</code>，通常作用在控制层（如 Struts2 的 Action、SpringMVC 的 Controller）</strong>，用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</li>\n<li><strong><code>@Repository</code>，用于将数据访问层（DAO层）的类标识为 Spring 中的 Bean</strong>，其功能与 @Component 相同</li>\n</ol>\n<p><strong>上面四个注解功能是一样的，都可以用来创建 bean 实例</strong></p>\n<ul>\n<li><strong><code>@Bean</code>，通常是我们在标有该注解的方法中定义产生这个 bean 的逻辑</strong>，告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。@Bean 注解比 @Component 注解的自定义性更强</li>\n</ul>\n<h3 id=\"1-5-2-基于注解方式创建对象\"><a href=\"#1-5-2-基于注解方式创建对象\" class=\"headerlink\" title=\"1.5.2 基于注解方式创建对象\"></a>1.5.2 基于注解方式创建对象</h3><ol>\n<li><p><strong>开启组件扫描，扫描多个包</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 扫描上层目录 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n&lt;!-- 逗号隔开 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;fan.com.dao, fan.com.service&quot; &#x2F;&gt;</code></pre></li>\n<li><p><strong>创建类，在类上面添加创建对象注解</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; value 可以省略不写，默认值是类名称，首字母小写\n@Service(value &#x3D; &quot;userService&quot;)\npublic class UserService &#123;\n\n&#125;</code></pre></li>\n<li><p><strong>组件扫描细节配置</strong></p>\n<ul>\n<li><strong><code>use-default-filters=&quot;false&quot;</code> 表示不适用默认 filter，自己配 filter</strong></li>\n<li><strong><code>context:include-filter</code> 设置需要扫描哪些内容</strong></li>\n<li><strong><code>context:exclude-filter</code> 设置哪些内容不需要扫描</strong></li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; use-default-filters&#x3D;&quot;false&quot;&gt;\n\t&lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n\t&lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Service&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;</code></pre></li>\n</ol>\n<h3 id=\"1-5-3-基于注解方式实现属性注入\"><a href=\"#1-5-3-基于注解方式实现属性注入\" class=\"headerlink\" title=\"1.5.3 基于注解方式实现属性注入\"></a>1.5.3 基于注解方式实现属性注入</h3><ol>\n<li><strong>@Autowired：根据属性类型进行自动装配。Spring 推荐使用</strong><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service(value &#x3D; &quot;userService&quot;)\npublic class UserService &#123;\n    @Autowired\n    private UserDao userDao;\n\n    public void add()&#123;\n        System.out.println(&quot;service add..&quot;);\n        userDao.update();\n    &#125;\n&#125;</code></pre></li>\n<li><strong>@Qualifier：根据属性名称进行注入，配合 @Autowired 进行使用，当有多个实现类时，需要根据名称注入</strong><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\n@Qualifier(value &#x3D; &quot;userDaoImpl1&quot;)\nprivate UserDao userDao;</code></pre></li>\n<li><strong>@Resource：可以根据类型注入、可以根据名称注入，位于 javax.annotation 包下。Spring 不推荐使用，JavaEE 推荐使用</strong><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Resource &#x2F;&#x2F; 根据类型注入\n&#x2F;&#x2F; @Resource(name &#x3D; &quot;userDaoImpl1&quot;) 根据名称注入\nprivate UserDao userDao;</code></pre></li>\n<li><strong>@Value：注入普通类型属性</strong><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Value(&quot;张三&quot;)\nprivate String name;</code></pre></li>\n</ol>\n<h3 id=\"1-5-4-完全注解开发（配置类）\"><a href=\"#1-5-4-完全注解开发（配置类）\" class=\"headerlink\" title=\"1.5.4 完全注解开发（配置类）\"></a>1.5.4 完全注解开发（配置类）</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n@ComponentScan(basePackages &#x3D; &#123;&quot;fan.com&quot;&#125;)\npublic class SpringConfig &#123;\n&#125;\n\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);\n        UserService userService &#x3D; context.getBean(&quot;userService&quot;, UserService.class);\n        userService.add();\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"2-AOP\"><a href=\"#2-AOP\" class=\"headerlink\" title=\"2. AOP\"></a>2. AOP</h1><h2 id=\"2-1-概念\"><a href=\"#2-1-概念\" class=\"headerlink\" title=\"2.1 概念\"></a>2.1 概念</h2><ul>\n<li><strong>面向切面（方面）编程</strong>，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</li>\n<li><strong>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</strong></li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201655.png\"></p>\n<h2 id=\"2-2-AOP-底层原理\"><a href=\"#2-2-AOP-底层原理\" class=\"headerlink\" title=\"2.2 AOP 底层原理\"></a>2.2 AOP 底层原理</h2><h3 id=\"2-2-1-AOP-底层使用动态代理\"><a href=\"#2-2-1-AOP-底层使用动态代理\" class=\"headerlink\" title=\"2.2.1 AOP 底层使用动态代理\"></a>2.2.1 AOP 底层使用动态代理</h3><p><strong>有两种情况动态代理：</strong></p>\n<ul>\n<li><p><strong>第一种：有接口情况，使用 JDK 动态代理（创建接口实现类代理对象，增强类的方法）</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420201710.png\"></p>\n</li>\n<li><p><strong>第二种：没有接口情况，使用 CGLIB 动态代理（创建当前类子类代理对象，增强类的方法）</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201719.png\"></p>\n</li>\n</ul>\n<h3 id=\"2-2-2-AOP（JDK-动态代理）\"><a href=\"#2-2-2-AOP（JDK-动态代理）\" class=\"headerlink\" title=\"2.2.2 AOP（JDK 动态代理）\"></a>2.2.2 AOP（JDK 动态代理）</h3><p><strong>使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象，</strong> 调用 newProxyInstance 方法，三个参数</p>\n<ul>\n<li><strong>第一参数，类加载器</strong></li>\n<li><strong>第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</strong></li>\n<li><strong>第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的方法</strong></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserDao &#123;\n    public int add(int a, int b);\n    public String update(String id);\n&#125;\npublic class UserDaoImpl implements UserDao &#123;\n    @Override\n    public String update(String id) &#123;\n        return id;\n    &#125;\n    @Override\n    public int add(int a, int b) &#123;\n        return a + b;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JDKProxy &#123;\n    public static void main(String[] args) &#123;\n        Class[] interfaces &#x3D; &#123;UserDao.class&#125;; &#x2F;&#x2F; 类实现接口\n        UserDaoImpl userDaoImpl &#x3D; new UserDaoImpl();\n        UserDao userDao &#x3D; (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDaoImpl));\n        int result &#x3D; userDao.add(1,2);\n        &#x2F;&#x2F; 代理对象UserDaoProxy返回的结果，add方法，返回为3，假如为update方法，返回null\n        System.out.println(result);\n    &#125;\n&#125;\nclass UserDaoProxy implements InvocationHandler&#123;\n    private Object obj;\n\n    public UserDaoProxy(Object obj) &#123;\n        this.obj &#x3D; obj;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        if (&quot;add&quot;.equals(method.getName()))&#123; &#x2F;&#x2F; 判断是哪个方法才执行\n            System.out.println(&quot;方法之前执行...&quot; + method.getName() + &quot;传递的参数：&quot; + Arrays.toString(args));\n            Object result &#x3D; method.invoke(obj,args); &#x2F;&#x2F; 方法执行，传入对象和参数\n            System.out.println(&quot;方法之后执行&quot; + obj);\n            return result;\n        &#125;else &#123;\n            return null;\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201738.png\"></p>\n<h2 id=\"2-3-AOP-术语\"><a href=\"#2-3-AOP-术语\" class=\"headerlink\" title=\"2.3 AOP 术语\"></a>2.3 AOP 术语</h2><ol>\n<li><strong>Joinpoint 连接点：那些被拦截到的点，类里面哪些方法可以被拦截到被增强，这些方法称为连接点</strong></li>\n<li><strong>Pointcut 切入点：指要对哪些 Joinpoint 进行拦截，即被拦截的连接点，实际被真正增强的方法，称为切入点</strong></li>\n<li><strong>Advice 通知（增强）：实际增强的逻辑部分称为通知（增强）</strong><ul>\n<li>前置通知 <code>@Before</code>：方法执行之前执行</li>\n<li>后置&#x2F;返回通知 <code>@AfterReturning</code>：方法返回结果之后执行</li>\n<li>环绕通知 <code>@Around</code>：方法之前和之后都执行</li>\n<li>异常通知 <code>@AfterThrowing</code>：异常时执行</li>\n<li>最终通知：<code>@After（finally）</code>：方法执行之后执行</li>\n</ul>\n</li>\n<li><strong>Aspect 切面：一个动作，把通知应用到切入点的过程</strong></li>\n<li><strong>Target 目标：指代理的目标对象</strong></li>\n<li><strong>Weaving 织入：指把增强代码应用到目标上，生成代理对象的过程</strong></li>\n<li><strong>Proxy 代理：指生成的代理对象</strong></li>\n</ol>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201759.png\"></p>\n<h2 id=\"2-4-AOP-操作\"><a href=\"#2-4-AOP-操作\" class=\"headerlink\" title=\"2.4 AOP 操作\"></a>2.4 AOP 操作</h2><ol>\n<li><strong>Spring 框架一般都是基于 AspectJ 实现 AOP 操作</strong><br>AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spring 框架一起使用， 进行 AOP 操作</li>\n<li><strong>基于 AspectJ 实现 AOP 操作</strong><ul>\n<li>基于 XML 配置文件实现</li>\n<li><strong>基于注解方式实现（实用）</strong></li>\n</ul>\n</li>\n<li><strong>切入点表达式</strong><ul>\n<li><strong>作用：知道对哪个类里面的哪个方法进行增强</strong></li>\n<li><strong>语法结构：<code>execution（[权限修饰符] [返回类型（可省略）] [类全路径] [方法名称] ([参数列表])）</code></strong><ul>\n<li>举例 1：对 fan.com.dao.BookDao 类里面的 add 进行增强<br><code>execution(*  fan.com.dao.BookDao.add(..))   // 修饰符 包名.类名.方法名(参数..)</code></li>\n<li>举例 2：对 fan.com.dao.BookDao 类里面的所有的方法进行增强<br><code>execution(*  fan.com.dao.BookDao.* (..))</code></li>\n<li>举例 3：对 fan.com.dao 包里面所有类，类里面所有方法进行增强<br><code>execution(*  fan.com.dao.*.* (..))</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-4-1-基于注解方式（抽取公共切入点）\"><a href=\"#2-4-1-基于注解方式（抽取公共切入点）\" class=\"headerlink\" title=\"2.4.1 基于注解方式（抽取公共切入点）\"></a>2.4.1 基于注解方式（抽取公共切入点）</h3><ol>\n<li><p><strong>开启注解扫描和生成代理对象：</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n    &lt;aop:aspectj-autoproxy &#x2F;&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p><strong>使用完全注解开发</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n@ComponentScan(basePackages &#x3D; &#123;&quot;fan.com&quot;&#125;)\n@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true) &#x2F;&#x2F; 开启代理对象\npublic class SpringConfig &#123;\n&#125;</code></pre></li>\n<li><p><strong>类和增强类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class User &#123;\n    public void add()&#123;\n        System.out.println(&quot;user add...&quot;);\n    &#125;\n&#125;\n\n@Component\n@Aspect\npublic class UserProxy &#123;\n    @Pointcut(value &#x3D; &quot;execution(* fan.com.domain.User.add(..))&quot;) &#x2F;&#x2F; 抽取公共切入点\n    public void pointDemo()&#123;\n\n    &#125;\n    @Before(value &#x3D; &quot;pointDemo()&quot;)\n    public void before() &#123;\n        System.out.println(&quot;前置通知before.........&quot;);\n    &#125;\n    @After(value &#x3D; &quot;pointDemo())&quot;)\n    public void after() &#123;\n        System.out.println(&quot;最终通知after.........&quot;);\n    &#125;\n    @AfterThrowing(value &#x3D; &quot;pointDemo()&quot;)\n    public void afterThrowing() &#123;\n        System.out.println(&quot;异常通知afterThrowing.........&quot;);\n    &#125;\n    @AfterReturning(value &#x3D; &quot;pointDemo()&quot;)\n    public void afterReturning() &#123;\n        System.out.println(&quot;后置通知afterReturning.........&quot;);\n    &#125;\n    @Around(value &#x3D; &quot;pointDemo()&quot;)\n    public void around(ProceedingJoinPoint joinPoint) throws Throwable&#123;\n        try &#123;\n            System.out.println(&quot;环绕前置通知&quot;); &#x2F;&#x2F;前置通知@Before\n            joinPoint.proceed(); &#x2F;&#x2F;目标方法执行\n            System.out.println(&quot;环绕返回通知&quot;); &#x2F;&#x2F;环绕返回通知@AfterReturning\n        &#125; catch (Throwable throwable) &#123;\n            System.out.println(&quot;环绕异常通知&quot;); &#x2F;&#x2F;环绕异常通知@AfterThrowing\n            throw new RuntimeException(throwable);\n        &#125; finally &#123;\n            System.out.println(&quot;环绕最终通知&quot;); &#x2F;&#x2F;最终通知@After\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>执行顺序：</strong>* <strong>正常情况：环绕前置 &#x3D;&#x3D; @Before &#x3D;&#x3D; 目标方法执行 &#x3D;&#x3D;@AfterReturning &#x3D;&#x3D; @After &#x3D;&#x3D; 环绕返回 &#x3D;&#x3D;环绕最终</strong></p>\n<ul>\n<li><strong>异常情况：环绕前置&#x3D;&#x3D; @Before &#x3D;&#x3D; 目标方法执行 &#x3D;&#x3D; @AfterThrowing &#x3D;&#x3D; @After &#x3D;&#x3D; 环绕异常 &#x3D;&#x3D; 环绕最终</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420201810.png\"></li>\n</ul>\n</li>\n<li><p><strong>多个增强类对同一个方法进行增强，设置增强类优先级</strong><br><strong>在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\n@Aspect\n@Order(1) &#x2F;&#x2F; 设置优先级\npublic class PersonProxy &#123;\n    @Pointcut(value &#x3D; &quot;execution(* fan.com.domain.User.add(..))&quot;)\n    public void pointDemo()&#123;\n    &#125;\n\n    @Before(value &#x3D; &quot;pointDemo()&quot;)\n    public void before() &#123;\n        System.out.println(&quot;person before.........&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201824.png\"></p>\n</li>\n<li><p><strong>测试类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F; ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);\n        ApplicationContext ac &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);\n        User user &#x3D; ac.getBean(&quot;user&quot;, User.class);\n        user.add();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"2-4-2-AspectJ-配置文件\"><a href=\"#2-4-2-AspectJ-配置文件\" class=\"headerlink\" title=\"2.4.2 AspectJ 配置文件\"></a>2.4.2 AspectJ 配置文件</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;book&quot; class&#x3D;&quot;fan.com.Book&quot;&gt;&lt;&#x2F;bean&gt; \n&lt;bean id&#x3D;&quot;bookProxy&quot; class&#x3D;&quot;fan.com.BookProxy&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;aop:config&gt; \n    &lt;!--切入点--&gt; \n    &lt;aop:pointcut id&#x3D;&quot;p&quot; expression&#x3D;&quot;execution(* fan.com.Book.buy(..))&quot;&#x2F;&gt; \n    &lt;!--配置切面 aop:aspect 大多用于面向切面编程，aop:advisor 大多用于事务管理--&gt; \n    &lt;aop:aspect ref&#x3D;&quot;bookProxy&quot;&gt; \n        &lt;!--增强作用在具体的方法上--&gt; \n        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;p&quot;&#x2F;&gt; \n    &lt;&#x2F;aop:aspect&gt; \n&lt;&#x2F;aop:config&gt;</code></pre>\n\n<ol>\n<li><p><strong>定义切面 <code>&lt;aop:aspect&gt;</code></strong></p>\n<ul>\n<li>该元素可以将定义好的 Bean 转换为切面 Bean，所以使用 <code>&lt;aop:aspect&gt;</code> 之前需要先定义一个普通的 Spring Bean</li>\n<li>id 用来定义该切面的唯一表示名称，ref 用于引用普通的 Spring Bean</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;aop:config&gt;\n    &lt;aop:aspect id&#x3D;&quot;myAspect&quot; ref&#x3D;&quot;aBean&quot;&gt;\n        ...\n    &lt;&#x2F;aop:aspect&gt;\n&lt;&#x2F;aop:config&gt;</code></pre></li>\n<li><p><strong>定义切入点 <code>&lt;aop:pointcut&gt;</code></strong></p>\n<ul>\n<li>当 <code>&lt;aop:pointcut&gt;</code>元素作为 <code>&lt;aop:config&gt;</code> 元素的子元素定义时，表示该切入点是全局切入点，它可被多个切面所共享</li>\n<li>当 <code>&lt;aop:pointcut&gt;</code> 元素作为 <code>&lt;aop:aspect&gt;</code> 元素的子元素时，表示该切入点只对当前切面有效</li>\n<li>id 用于指定切入点的唯一标识名称，execution 用于指定切入点关联的切入点表达式</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;aop:config&gt;\n    &lt;aop:pointcut id&#x3D;&quot;myPointCut&quot; expression&#x3D;&quot;execution(* net.biancheng.service.*.*(..))&quot;&#x2F;&gt;\n&lt;&#x2F;aop:config&gt;</code></pre></li>\n<li><p><strong>定义通知</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;aop:aspect id&#x3D;&quot;myAspect&quot; ref&#x3D;&quot;aBean&quot;&gt;\n    &lt;!-- 前置通知 --&gt;\n    &lt;aop:before pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 后置通知 --&gt;\n    &lt;aop:after-returning pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 环绕通知 --&gt;\n    &lt;aop:around pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 异常通知 --&gt;\n    &lt;aop:after-throwing pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 最终通知 --&gt;\n    &lt;aop:after pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    .... \n&lt;&#x2F;aop:aspect&gt;</code></pre></li>\n</ol>\n<h1 id=\"3-JdbcTemplate\"><a href=\"#3-JdbcTemplate\" class=\"headerlink\" title=\"3. JdbcTemplate\"></a>3. JdbcTemplate</h1><h2 id=\"3-1-配置连接属性\"><a href=\"#3-1-配置连接属性\" class=\"headerlink\" title=\"3.1 配置连接属性\"></a>3.1 配置连接属性</h2><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd &quot;&gt;\n\t&lt;!-- 注解扫描 --&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n    &lt;!-- 引入外部属性文件 --&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot; &#x2F;&gt; \n    &lt;!-- 配置数据库连接池 Druid --&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;driverClassName&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;user&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!-- 配置 JdbcTemplate 对象，注入 DataSource --&gt;\n    &lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<h2 id=\"3-2-Dao层\"><a href=\"#3-2-Dao层\" class=\"headerlink\" title=\"3.2 Dao层\"></a>3.2 Dao层</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface UserDao &#123;\n    User selectUser(int id); &#x2F;&#x2F; 按id 查询\n    List&lt;User&gt; selectAll(); &#x2F;&#x2F; 查询所有\n    int selectTotalCount(); &#x2F;&#x2F; 查询总记录条数\n    int updateUser(User user); &#x2F;&#x2F; 按id 修改\n    int insertUser(User user); &#x2F;&#x2F; 插入\n    int deleteUser(int id); &#x2F;&#x2F; 按id 删除\n    int[] batchAdd(List&lt;Object[]&gt; users); &#x2F;&#x2F; 批量插入\n&#125;\n@Component\npublic class UserDaoImpl implements UserDao &#123;\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override &#x2F;&#x2F; 按id 查询\n    public User selectUser(int id) &#123;\n        String sql &#x3D; &quot;select * from user where id &#x3D; ? &quot;;\n        User user &#x3D; jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), id);\n        return user;\n    &#125;\n    @Override &#x2F;&#x2F; 查询所有\n    public List&lt;User&gt; selectAll() &#123;\n        String sql &#x3D; &quot;select * from user&quot;;\n        List&lt;User&gt; maps &#x3D; jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class));\n        return maps;\n    &#125;\n    @Override &#x2F;&#x2F; 查询总记录条数\n    public int selectTotalCount() &#123;\n        String sql &#x3D; &quot;select count(*) from user&quot;;\n        int i &#x3D; jdbcTemplate.queryForObject(sql, Integer.class);\n        return i;\n    &#125;\n\n    @Override &#x2F;&#x2F; 按id 修改\n    public int updateUser(User user) &#123;\n        String sql &#x3D; &quot;update user set name &#x3D; ?, age &#x3D; ? where id &#x3D; ?&quot;;\n        Object[] args &#x3D; &#123;user.getName(),user.getAge(),user.getId()&#125;;\n        int update &#x3D; jdbcTemplate.update(sql, args);\n        return update;\n    &#125;\n\n    @Override &#x2F;&#x2F; 插入\n    public int insertUser(User user) &#123;\n        Object[] args &#x3D; &#123;user.getId(),user.getName(),user.getAge()&#125;;\n        String sql &#x3D; &quot;insert into user value(?,?,?)&quot;;\n        int update &#x3D; jdbcTemplate.update(sql, args);\n        return update;\n    &#125;\n    @Override &#x2F;&#x2F; 批量插入\n    public int[] batchAdd(List&lt;Object[]&gt; users) &#123;\n        String sql &#x3D; &quot;insert into user value(?,?,?)&quot;;\n        int[] ints &#x3D; jdbcTemplate.batchUpdate(sql, users);\n        return ints;\n    &#125;\n\n    @Override &#x2F;&#x2F; 按id 删除\n    public int deleteUser(int id) &#123;\n        String sql &#x3D; &quot;delete from user where id &#x3D; ?&quot;;\n        int update &#x3D; jdbcTemplate.update(sql, id);\n        return update;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"3-3-Service-层\"><a href=\"#3-3-Service-层\" class=\"headerlink\" title=\"3.3 Service 层\"></a>3.3 Service 层</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service(value &#x3D; &quot;userService&quot;)\npublic class UserService &#123;\n    @Autowired\n    private UserDao userDao;\n\n    public User selectUser(int id)&#123;\n        User user &#x3D; userDao.selectUser(id);\n        return user;\n    &#125;\n    public List&lt;User&gt; selectAll() &#123;\n        List&lt;User&gt; users &#x3D; userDao.selectAll();\n        return users;\n    &#125;\n    public int selectTotalCount() &#123;\n        int i &#x3D; userDao.selectTotalCount();\n        return i;\n    &#125;\n\n    public int updateUser(User user)&#123;\n        int i &#x3D; userDao.updateUser(user);\n        return i;\n    &#125;\n\n    public int insertUser(User user)&#123;\n        int i &#x3D; userDao.insertUser(user);\n        return i;\n    &#125;\n    public int[] batchAdd(List&lt;Object[]&gt; users) &#123;\n        int[] ints &#x3D; userDao.batchAdd(users);\n        return ints;\n    &#125;\n\n    public int deleteUser(int id)&#123;\n        int i &#x3D; userDao.deleteUser(id);\n        return i;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"3-4-测试类\"><a href=\"#3-4-测试类\" class=\"headerlink\" title=\"3.4 测试类\"></a>3.4 测试类</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);\n        UserService userService &#x3D; ac.getBean(&quot;userService&quot;, UserService.class);\n    \n        User user &#x3D; new User(2,&quot;ff&quot;,18);\n        int i &#x3D; userService.updateUser(user);\n        System.out.println(i); &#x2F;&#x2F; 1\n        List&lt;User&gt; users &#x3D; userService.selectAll();\n        System.out.println(users);\n    \n        List&lt;Object[]&gt; users &#x3D; new ArrayList&lt;&gt;();\n        Object[] user1 &#x3D; &#123;6, &quot;6&quot;, 6&#125;;\n        Object[] user2 &#x3D; &#123;7,&quot;7&quot;,8&#125;;\n        Object[] user3 &#x3D; &#123;8, &quot;7&quot;, 8&#125;;\n        users.add(user1);\n        users.add(user2);\n        users.add(user3);\n        int[] ints &#x3D; userService.batchAdd(users);\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"4-事务操作\"><a href=\"#4-事务操作\" class=\"headerlink\" title=\"4. 事务操作\"></a>4. 事务操作</h1><h2 id=\"4-1-概念\"><a href=\"#4-1-概念\" class=\"headerlink\" title=\"4.1 概念\"></a>4.1 概念</h2><p><strong>事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。典型场景：银行转账</strong></p>\n<ul>\n<li>lucy 转账 100 元 给 mary</li>\n<li>lucy 少 100，mary 多 100</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot; &#x2F;&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;driverClassName&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;user&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p><strong>Dao 层</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface PriceDao &#123;\n    public void reduce();\n    public void add();\n&#125;\n@Component\npublic class PriceDaoImpl implements PriceDao &#123;\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public void reduce() &#123;\n        String sql &#x3D; &quot;update price set price &#x3D; price - ? where name &#x3D; ?&quot;;\n        jdbcTemplate.update(sql,100,&quot;张三&quot;);\n    &#125;\n    @Override\n    public void add() &#123;\n        String sql &#x3D; &quot;update price set price &#x3D; price + ? where name &#x3D; ?&quot;;\n        jdbcTemplate.update(sql,100,&quot;李四&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>Service 层</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class PriceService &#123;\n    @Autowired\n    private PriceDao priceDao;\n\n    public void account()&#123;\n        priceDao.reduce();\n        int a &#x3D; 10 &#x2F; 0;\n        priceDao.add();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"4-2-接口\"><a href=\"#4-2-接口\" class=\"headerlink\" title=\"4.2 接口\"></a>4.2 接口</h2><p><strong>PlatformTransactionManager、TransactionDefinition 和 TransactionStatus 是事务的 3 个核心接口</strong></p>\n<h3 id=\"4-2-1-PlatformTransactionManager-接口\"><a href=\"#4-2-1-PlatformTransactionManager-接口\" class=\"headerlink\" title=\"4.2.1 PlatformTransactionManager 接口\"></a>4.2.1 PlatformTransactionManager 接口</h3><p><strong>PlatformTransactionManager 接口用于管理事务，接口定义如下：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface PlatformTransactionManager &#123;\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n    void commit(TransactionStatus status) throws TransactionException;\n    void rollback(TransactionStatus status) throws TransactionException;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201835.png\"></p>\n<h3 id=\"4-2-2-TransactionDefinition-接口\"><a href=\"#4-2-2-TransactionDefinition-接口\" class=\"headerlink\" title=\"4.2.2 TransactionDefinition 接口\"></a>4.2.2 TransactionDefinition 接口</h3><p><strong>TransactionDefinition 接口提供了获取事务相关信息的方法，接口定义如下</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface TransactionDefinition &#123;\n    int getPropagationBehavior();\n    int getIsolationLevel();\n    String getName();\n    int getTimeout();\n    boolean isReadOnly();\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201848.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201857.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201909.png\"></p>\n<h3 id=\"4-2-3-TransactionStatus-接口\"><a href=\"#4-2-3-TransactionStatus-接口\" class=\"headerlink\" title=\"4.2.3 TransactionStatus 接口\"></a>4.2.3 TransactionStatus 接口</h3><p><strong>TransactionStatus 接口提供了一些简单的方法来控制事务的执行和查询事务的状态，接口定义如下：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface TransactionStatus extends SavepointManager &#123;\n    boolean isNewTransaction();\n    boolean hasSavepoint();\n    void setRollbackOnly();\n    boolean isRollbackOnly();\n    boolean isCompleted();\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201920.png\"></p>\n<h2 id=\"4-3-Spring-事务管理介绍\"><a href=\"#4-3-Spring-事务管理介绍\" class=\"headerlink\" title=\"4.3 Spring 事务管理介绍\"></a>4.3 Spring 事务管理介绍</h2><ol>\n<li><strong>事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</strong></li>\n<li>在 Spring 进行事务管理操作有两种方式：编程式事务管理和<strong>声明式事务管理（实用）</strong></li>\n<li>声明式事务管理<ul>\n<li><strong>基于注解方式（实用）</strong></li>\n<li>基于 xml 配置文件方式</li>\n</ul>\n</li>\n<li><strong>在 Spring 进行声明式事务管理，底层使用 AOP 原理</strong></li>\n<li>Spring 事务管理 API<br>提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</li>\n</ol>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420201930.png\"></p>\n<h2 id=\"4-4-注解声明式事务管理\"><a href=\"#4-4-注解声明式事务管理\" class=\"headerlink\" title=\"4.4 注解声明式事务管理\"></a>4.4 注解声明式事务管理</h2><ol>\n<li><strong>配置事务管理器</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 创建事务管理器 --&gt;\n&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n\t&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt; &#x2F;&#x2F; 注入数据源\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><strong>开启事务注解</strong><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; &#x2F;&#x2F; 引入名称空间 tx\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd &quot;&gt;\n\t&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n\t&lt;&#x2F;bean&gt;\n\t&lt;!-- 开启事务注解 --&gt;\n\t&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; &#x2F;&gt;\n&lt;&#x2F;beans&gt;</code></pre></li>\n<li><strong>在 service 类上面（或者 service 类里面方法上面）添加事务注解</strong><ul>\n<li><strong>@Transactional，这个注解添加到类上面，也可以添加方法上面</strong></li>\n<li><strong>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</strong></li>\n<li>如果把这个注解添加方法上面，为这个方法添加事务</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-5-声明式事务管理参数配置\"><a href=\"#4-5-声明式事务管理参数配置\" class=\"headerlink\" title=\"4.5 声明式事务管理参数配置\"></a>4.5 声明式事务管理参数配置</h2><p><img src=\"http://img.fan223.cn/2023/04/20230420201939.png\"></p>\n<ol>\n<li><strong>propagation：事务传播行为：多事务方法直接进行调用，这个过程中事务 是如何进行管理</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420201948.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230420201958.png\"></li>\n<li><strong>ioslation：事务隔离级别</strong></li>\n<li><strong>timeout：超时时间</strong><ul>\n<li>事务需要在一定时间内进行提交，如果不提交进行回滚</li>\n<li>默认值是 -1 ，设置时间以秒单位进行计算</li>\n</ul>\n</li>\n<li><strong>readOnly：是否只读</strong><ul>\n<li>读：查询操作，写：添加修改删除操作</li>\n<li>readOnly 默认值 false，表示可以查询，可以添加修改删除操作</li>\n<li>设置 readOnly 值是 true，设置成 true 之后，只能查询</li>\n</ul>\n</li>\n<li><strong>rollbackFor：回滚</strong><br>设置出现哪些异常进行事务回滚</li>\n<li><strong>noRollbackFor：不回滚</strong><br>设置出现哪些异常不进行事务回滚</li>\n</ol>\n<h2 id=\"4-6-XML-声明式事务管理\"><a href=\"#4-6-XML-声明式事务管理\" class=\"headerlink\" title=\"4.6 XML 声明式事务管理\"></a>4.6 XML 声明式事务管理</h2><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--1 创建事务管理器--&gt; \n&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; \n    &lt;!--注入数据源--&gt; \n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt; \n&lt;&#x2F;bean&gt; \n \n&lt;!--2 配置通知--&gt; \n&lt;tx:advice id&#x3D;&quot;txadvice&quot;&gt; \n    &lt;!--配置事务参数--&gt; \n    &lt;tx:attributes&gt;\n        &lt;!--指定哪种规则的方法上面添加事务--&gt; \n        &lt;tx:method name&#x3D;&quot;account&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt; \n        &lt;!--&lt;tx:method name&#x3D;&quot;account*&quot;&#x2F;&gt;--&gt; \n    &lt;&#x2F;tx:attributes&gt; \n&lt;&#x2F;tx:advice&gt; \n \n&lt;!--3 配置切入点和切面--&gt; \n&lt;aop:config&gt; \n    &lt;!--配置切入点--&gt; \n    &lt;aop:pointcut id&#x3D;&quot;pt&quot; expression&#x3D;&quot;execution(* fan.com.service.PriceService.*(..))&quot;&#x2F;&gt; \n    &lt;!--配置切面 aop:advisor 大多用于事务管理，aop:aspect 大多用于面向切面编程--&gt;\n    &lt;aop:advisor advice-ref&#x3D;&quot;txadvice&quot; pointcut-ref&#x3D;&quot;pt&quot;&#x2F;&gt; \n&lt;&#x2F;aop:config&gt;</code></pre>\n\n<h2 id=\"4-7-完全注解开发声明式事务管理\"><a href=\"#4-7-完全注解开发声明式事务管理\" class=\"headerlink\" title=\"4.7 完全注解开发声明式事务管理\"></a>4.7 完全注解开发声明式事务管理</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration &#x2F;&#x2F;配置类 \n@ComponentScan(basePackages &#x3D; &quot;com.atguigu&quot;) &#x2F;&#x2F;组件扫描 \n@EnableTransactionManagement &#x2F;&#x2F;开启事务 \npublic class TxConfig &#123; \n    &#x2F;&#x2F;创建数据库连接池 \n    @Bean \n    public DruidDataSource getDruidDataSource() &#123; \n        DruidDataSource dataSource &#x3D; new DruidDataSource(); \n        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); \n        dataSource.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;user_db&quot;); \n        dataSource.setUsername(&quot;root&quot;); \n        dataSource.setPassword(&quot;root&quot;); \n        return dataSource; \n    &#125; \n    &#x2F;&#x2F;创建 JdbcTemplate 对象 \n    @Bean \n    public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123; \n        &#x2F;&#x2F;到 ioc 容器中根据类型找到 dataSource \n        JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(); \n        &#x2F;&#x2F;注入 dataSource \n        jdbcTemplate.setDataSource(dataSource); \n        return jdbcTemplate; \n    &#125; \n    &#x2F;&#x2F;创建事务管理器 \n    @Bean \n    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) &#123; \n        DataSourceTransactionManager transactionManager &#x3D; new DataSourceTransactionManager(); \n        transactionManager.setDataSource(dataSource); \n        return transactionManager; \n    &#125; \n&#125; </code></pre>\n\n<h2 id=\"4-8-事务失效的原因（重要）\"><a href=\"#4-8-事务失效的原因（重要）\" class=\"headerlink\" title=\"4.8 事务失效的原因（重要）\"></a>4.8 事务失效的原因（重要）</h2><h3 id=\"4-8-1-数据库引擎不支持\"><a href=\"#4-8-1-数据库引擎不支持\" class=\"headerlink\" title=\"4.8.1 数据库引擎不支持\"></a>4.8.1 数据库引擎不支持</h3><p><strong>以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。</strong> 从 MySQL 5.5.5 开始的默认存储引擎是 InnoDB，之前默认的都是 MyISAM。所以这点需要注意，底层引擎不支持事务，再怎么操作事务都无效。</p>\n<h3 id=\"4-8-2-没有被-Spring-管理\"><a href=\"#4-8-2-没有被-Spring-管理\" class=\"headerlink\" title=\"4.8.2 没有被 Spring 管理\"></a>4.8.2 没有被 Spring 管理</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; @Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;</code></pre>\n\n<p>如果此时把 @Service 注解注释掉，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。</p>\n<h3 id=\"4-8-3-方法不是-public-的\"><a href=\"#4-8-3-方法不是-public-的\" class=\"headerlink\" title=\"4.8.3 方法不是 public 的\"></a>4.8.3 方法不是 public 的</h3><p><strong>@Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。</strong></p>\n<h3 id=\"4-8-4-自身调用问题\"><a href=\"#4-8-4-自身调用问题\" class=\"headerlink\" title=\"4.8.4 自身调用问题\"></a>4.8.4 自身调用问题</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    public void update(Order order) &#123;\n        updateOrder(order);\n    &#125;\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;</code></pre>\n\n<p><strong>上面的 update 方法上面没有加 @Transactional 注解，调用有 @Transactional 注解的 updateOrder 方法，updateOrder 方法上的事务不管用。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void update(Order order) &#123;\n        updateOrder(order);\n    &#125;\n    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;</code></pre>\n\n<p><strong>上面这次在 update 方法上加了 @Transactional，而 updateOrder 加了 REQUIRES_NEW 新开启一个事务，那么新开的事务不管用。</strong></p>\n<p><strong>因为它们发生了自身调用，调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效。</strong></p>\n<p><strong>解决方案：</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- 在Spring配置中添加标签 --&gt;\n&lt;aop:aspectj-autoproxy expose-proxy&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;!-- &lt;aop:config expose-proxy&#x3D;&quot;true&quot;&gt; --&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 在代码的调用中要求使用代理对象去调用即可：\n((ServiceA ) AopContext.currentProxy()).insert();</code></pre>\n\n<h3 id=\"4-8-5-数据源没有配置事务管理器\"><a href=\"#4-8-5-数据源没有配置事务管理器\" class=\"headerlink\" title=\"4.8.5 数据源没有配置事务管理器\"></a>4.8.5 数据源没有配置事务管理器</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">@Bean\npublic PlatformTransactionManager transactionManager(DataSource dataSource) &#123;\n    return new DataSourceTransactionManager(dataSource);\n&#125;</code></pre>\n\n<h3 id=\"4-8-6-不支持事务\"><a href=\"#4-8-6-不支持事务\" class=\"headerlink\" title=\"4.8.6 不支持事务\"></a>4.8.6 不支持事务</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void update(Order order) &#123;\n        updateOrder(order);\n    &#125;\n    @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;</code></pre>\n\n<p><strong>Propagation.NOT_SUPPORTED： 表示不以事务运行，当前若存在事务则挂起</strong></p>\n<h3 id=\"4-8-7-异常被-catch\"><a href=\"#4-8-7-异常被-catch\" class=\"headerlink\" title=\"4.8.7 异常被 catch\"></a>4.8.7 异常被 catch</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        try &#123;\n            &#x2F;&#x2F; update order\n        &#125; catch &#123;\n\t\t\t&#x2F;&#x2F; 异常被 catch，但又不抛出来\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-8-8-异常类型错误\"><a href=\"#4-8-8-异常类型错误\" class=\"headerlink\" title=\"4.8.8 异常类型错误\"></a>4.8.8 异常类型错误</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class OrderServiceImpl implements OrderService &#123;\n\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        try &#123;\n            &#x2F;&#x2F; update order\n        &#125; catch &#123;\n            throw new Exception(&quot;更新错误&quot;);\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n\n<p><strong>这样事务也是不生效的，因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Transactional(rollbackFor &#x3D; Exception.class)</code></pre>\n\n<p><strong>这个配置仅限于 Throwable 异常类及其子类</strong></p>\n<h1 id=\"5-Spring5-新特性\"><a href=\"#5-Spring5-新特性\" class=\"headerlink\" title=\"5. Spring5 新特性\"></a>5. Spring5 新特性</h1><p><strong>整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的和方法在代码库中删除</strong></p>\n<h2 id=\"5-1-自带的通用日志封装-log4j2\"><a href=\"#5-1-自带的通用日志封装-log4j2\" class=\"headerlink\" title=\"5.1 自带的通用日志封装 log4j2\"></a>5.1 自带的通用日志封装 log4j2</h2><ul>\n<li>Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2</li>\n<li><strong>Spring5 框架整合 Log4j2</strong></li>\n</ul>\n<h3 id=\"5-1-1-引入依赖\"><a href=\"#5-1-1-引入依赖\" class=\"headerlink\" title=\"5.1.1 引入依赖\"></a>5.1.1 引入依赖</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n      &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;log4j-api&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.13.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n      &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.13.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- 使用slf4j日志门面 --&gt;\n&lt;dependency&gt;\n      &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;log4j-slf4j-impl&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.13.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"5-1-2-配置文件-log4j2-xml\"><a href=\"#5-1-2-配置文件-log4j2-xml\" class=\"headerlink\" title=\"5.1.2 配置文件 log4j2.xml\"></a>5.1.2 配置文件 log4j2.xml</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration status&#x3D;&quot;INFO&quot;&gt;\n    &lt;!--定义所有的appender --&gt;\n    &lt;appenders&gt;\n        &lt;!--这个输出控制台的配置 --&gt;\n        &lt;console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt;\n            &lt;!--输出日志的格式 --&gt;\n            &lt;PatternLayout pattern&#x3D;&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;&#x2F;&gt;\n        &lt;&#x2F;console&gt;\n    &lt;&#x2F;appenders&gt;\n    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;\n    &lt;loggers&gt;\n        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息 --&gt;\n        &lt;logger name&#x3D;&quot;org.springframework&quot; level&#x3D;&quot;INFO&quot;&gt;&lt;&#x2F;logger&gt;\n        &lt;logger name&#x3D;&quot;org.mybatis&quot; level&#x3D;&quot;INFO&quot;&gt;&lt;&#x2F;logger&gt;\n        &lt;root level&#x3D;&quot;info&quot;&gt;\n            &lt;appender-ref ref&#x3D;&quot;Console&quot; &#x2F;&gt;\n        &lt;&#x2F;root&gt;\n    &lt;&#x2F;loggers&gt;\n&lt;&#x2F;configuration&gt;</code></pre>\n\n<h3 id=\"5-1-3-手动打印日志\"><a href=\"#5-1-3-手动打印日志\" class=\"headerlink\" title=\"5.1.3 手动打印日志\"></a>5.1.3 手动打印日志</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserLog &#123;\n    public static final  Logger log &#x3D; LoggerFactory.getLogger(UserLog.class);\n    public static void main(String[] args) &#123;\n        log.info(&quot;hello log4j2&quot;);\n        log.warn(&quot;hello log4j2&quot;);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"5-2-Spring5-核心容器支持-Nullable-注解\"><a href=\"#5-2-Spring5-核心容器支持-Nullable-注解\" class=\"headerlink\" title=\"5.2 Spring5 核心容器支持 @Nullable 注解\"></a>5.2 Spring5 核心容器支持 @Nullable 注解</h2><p><strong>@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空</strong></p>\n<ol>\n<li><strong>注解用在方法上面，方法返回值可以为空</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420202009.png\"></li>\n<li><strong>注解使用在方法参数里面，方法参数可以为空</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420202019.png\"></li>\n<li><strong>注解使用在属性上面，属性值可以为空</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420202028.png\"></li>\n</ol>\n<h2 id=\"5-3-Spring5-核心容器支持函数式风格-GenericApplicationContext\"><a href=\"#5-3-Spring5-核心容器支持函数式风格-GenericApplicationContext\" class=\"headerlink\" title=\"5.3 Spring5 核心容器支持函数式风格 GenericApplicationContext\"></a>5.3 Spring5 核心容器支持函数式风格 GenericApplicationContext</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;函数式风格创建对象，交给 spring 进行管理\npublic void testGenericApplicationContext() &#123;\n\t&#x2F;&#x2F;1 创建 GenericApplicationContext 对象 \n\tGenericApplicationContext context &#x3D; new GenericApplicationContext();\n\t&#x2F;&#x2F;2 调用 context 的方法对象注册 \n\tcontext.refresh();\n\tcontext.registerBean(&quot;user1&quot;,User.class,() -&gt; new User());\n\t&#x2F;&#x2F;3 获取在 spring 注册的对象 \n\t&#x2F;&#x2F; User user &#x3D; (User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;); \n\tUser user &#x3D; (User)context.getBean(&quot;user1&quot;);\n\tSystem.out.println(user);\n&#125;</code></pre>\n\n<h2 id=\"5-4-Spring5-支持整合-JUnit5\"><a href=\"#5-4-Spring5-支持整合-JUnit5\" class=\"headerlink\" title=\"5.4 Spring5 支持整合 JUnit5\"></a>5.4 Spring5 支持整合 JUnit5</h2><h3 id=\"5-4-1-整合-JUnit4\"><a href=\"#5-4-1-整合-JUnit4\" class=\"headerlink\" title=\"5.4.1 整合 JUnit4\"></a>5.4.1 整合 JUnit4</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RunWith(SpringJUnit4ClassRunner.class) &#x2F;&#x2F; 单元测试框架 \n@ContextConfiguration(&quot;classpath:bean.xml&quot;) &#x2F;&#x2F; 加载配置文件 \npublic class JTest4 &#123; \n    @Autowired \n    private UserService userService; \n    @Test \n    public void test1() &#123; \n        userService.accountMoney(); \n    &#125; \n&#125; </code></pre>\n\n<h3 id=\"5-4-2-Spring5-整合-JUnit5\"><a href=\"#5-4-2-Spring5-整合-JUnit5\" class=\"headerlink\" title=\"5.4.2 Spring5 整合 JUnit5\"></a>5.4.2 Spring5 整合 JUnit5</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; @ExtendWith(SpringExtension.class) \n&#x2F;&#x2F; @ContextConfiguration(&quot;classpath:bean1.xml&quot;)\n@SpringJUnitConfig(locations &#x3D; &quot;classpath:bean1.xml&quot;)\npublic class JTest5 &#123; \n    @Autowired \n    private UserService userService; \n    @Test \n    public void test1() &#123; \n        userService.accountMoney(); \n    &#125; \n&#125;</code></pre>\n\n<h1 id=\"6-Webflux\"><a href=\"#6-Webflux\" class=\"headerlink\" title=\"6. Webflux\"></a>6. <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html\">Webflux</a></h1><p><strong>Spring5 新添加的模块，用于 Web 开发。功能和 SpringMVC 类似，Webflux 使用响应式编程出现的框架。传统 Web 框架，比如 SpringMVC，这些基于 Servlet 容器，Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现的。</strong></p>\n<h2 id=\"6-1-异步非阻塞（NIO）\"><a href=\"#6-1-异步非阻塞（NIO）\" class=\"headerlink\" title=\"6.1 异步非阻塞（NIO）\"></a>6.1 异步非阻塞（NIO）</h2><p><strong>异步与非阻塞都是针对对象不一样</strong></p>\n<ul>\n<li><strong>异步和同步针对调用者</strong><br>调用者发送请求，如果等着对方回应之后才去做其他事情就是同步；如果<strong>发送请求之后不等着对方回应就去做其他事情就是异步</strong></li>\n<li><strong>阻塞和非阻塞针对被调用者</strong><br>被调用者受到请求之后，做完请求任务之后才给出反馈就是阻塞；<strong>受到请求之后马上给出反馈然后再去做事情就是非阻塞</strong></li>\n</ul>\n<h2 id=\"6-2-SpringMVC-与-Webflux-对比\"><a href=\"#6-2-SpringMVC-与-Webflux-对比\" class=\"headerlink\" title=\"6.2 SpringMVC 与 Webflux 对比\"></a>6.2 SpringMVC 与 Webflux 对比</h2><p><strong>Webflux</strong></p>\n<ul>\n<li><strong>非阻塞式：</strong> 在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程</li>\n<li><strong>函数式编程：</strong> Spring5 框架基于 Java8，Webflux 使用 Java8 函数式编程方式实现路由请求</li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202042.png\"></p>\n<ul>\n<li>两个框架都可以使用注解方式，都运行在 Tomcat 等容器中</li>\n<li><strong>SpringMVC 采用命令式编程，Webflux 采用异步响应式编程</strong></li>\n</ul>\n<h2 id=\"6-3-响应式编程（Java-实现）\"><a href=\"#6-3-响应式编程（Java-实现）\" class=\"headerlink\" title=\"6.3 响应式编程（Java 实现）\"></a>6.3 响应式编程（Java 实现）</h2><h3 id=\"6-3-1-概念\"><a href=\"#6-3-1-概念\" class=\"headerlink\" title=\"6.3.1 概念\"></a>6.3.1 概念</h3><p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>\n<p><strong>例：</strong> 电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似 <code>&quot;=B1+C1&quot;</code> 的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。</p>\n<h3 id=\"6-3-2-Java8-及其之前版本\"><a href=\"#6-3-2-Java8-及其之前版本\" class=\"headerlink\" title=\"6.3.2 Java8 及其之前版本\"></a>6.3.2 Java8 及其之前版本</h3><p><strong>提供的观察者模式两个类 Observer 和 Observable</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ObserverDemo extends Observable &#123;\n    public static void main(String[] args) &#123;\n        ObserverDemo observerDemo &#x3D; new ObserverDemo();\n\n        observerDemo.addObserver((o, arg) -&gt; &#123;\n            System.out.println(&quot;发生变化&quot;);\n        &#125;);\n        observerDemo.addObserver((o, arg) -&gt; &#123;\n            System.out.println(&quot;手动被观察者通知，准备改变&quot;);\n        &#125;);\n\n        observerDemo.setChanged();\n        observerDemo.notifyObservers();\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202051.png\"></p>\n<h3 id=\"6-3-3-Java9-及其之后版本\"><a href=\"#6-3-3-Java9-及其之后版本\" class=\"headerlink\" title=\"6.3.3 Java9 及其之后版本\"></a>6.3.3 Java9 及其之后版本</h3><p><strong>使用 Flow 这个 API，Flow 是 JDK 对 Reactive Stream (响应式流&#x2F;反应流) 的实现，Reactive Stream 是一套基于发布&#x2F;订阅模式的数据处理规范。</strong></p>\n<p>响应式流从 2013 年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者需要有无限制的缓冲区或丢弃。<br>更确切地说，Reactive 流目的是“找到最小的一组接口，方法和协议，用来描述必要的操作和实体以实现这样的目标：<strong>以非阻塞背压方式实现数据的异步流</strong>”。</p>\n<p><strong>响应式流 (Reactive Stream) 规范诞生，定义了如下四个接口：</strong></p>\n<ul>\n<li>Subscription：接口定义了连接发布者和订阅者的方法</li>\n<li>Publisher：接口定义了发布者的方法</li>\n<li>Subscriber：接口定义了订阅者的方法</li>\n<li>Processor&lt;T,R&gt;：接口定义了处理器</li>\n</ul>\n<h2 id=\"6-4-响应式编程（Reactor-实现）\"><a href=\"#6-4-响应式编程（Reactor-实现）\" class=\"headerlink\" title=\"6.4 响应式编程（Reactor 实现）\"></a>6.4 响应式编程（Reactor 实现）</h2><ol>\n<li><strong>Reactor 是满足 Reactive 规范的框架</strong></li>\n<li>Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作符<br><strong>Flux 对象实现发布者，返回 N 个元素；Mono 实现发布者，返回 0 或者 1 个元素</strong></li>\n<li>Flux 和 Mono 都是<strong>数据流</strong>的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：<strong>元素值，错误信号，完成信号</strong><br><strong>错误信号和完成信号都代表终止信号，用于告诉订阅者数据流结束了；错误信号终止数据流同时把错误信息传递给订阅者</strong></li>\n</ol>\n<h3 id=\"6-4-1-引入-POM-依赖\"><a href=\"#6-4-1-引入-POM-依赖\" class=\"headerlink\" title=\"6.4.1 引入 POM 依赖\"></a>6.4.1 引入 POM 依赖</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n\t&lt;groupId&gt;io.projectreactor&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;reactor-core&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.4.15&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"6-4-2-实现\"><a href=\"#6-4-2-实现\" class=\"headerlink\" title=\"6.4.2 实现\"></a>6.4.2 实现</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReactorDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; just 方法直接声明\n        Flux&lt;Integer&gt; flux &#x3D; Flux.just(1, 2, 3, 4);\n        flux.subscribe(System.out::println);\n    \n        Mono&lt;Integer&gt; mono &#x3D; Mono.just(1);\n        mono.subscribe(System.out::print);\n\n        &#x2F;&#x2F; 其他方法\n        Integer[] integers &#x3D; &#123;1, 2, 3, 4&#125;;\n        Flux.fromArray(integers);\n\n        List&lt;Integer&gt; list &#x3D; Arrays.asList(integers);\n        Flux.fromIterable(list);\n\n        Stream&lt;Integer&gt; stream &#x3D; list.stream();\n        Flux.fromStream(stream);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202101.png\"></p>\n<ul>\n<li><strong>错误信号和完成信号都是终止信号，不能共存</strong></li>\n<li>如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流</li>\n<li>如果没有错误信号，没有完成信号，表示是无限数据流</li>\n</ul>\n<p><strong>调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生</strong></p>\n<h3 id=\"6-4-3-操作符\"><a href=\"#6-4-3-操作符\" class=\"headerlink\" title=\"6.4.3 操作符\"></a>6.4.3 操作符</h3><p><strong>对数据流进行一道道操作，称为操作符</strong></p>\n<ol>\n<li><p><strong>map：元素映射为新元素</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420202112.png\"></p>\n</li>\n<li><p><strong>flatMap：元素映射为流。把每个元素转换成流，再把转换后的多个流合并成大的流</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202121.png\"></p>\n</li>\n</ol>\n<h3 id=\"6-4-4-Spring-Webflux-执行流程和核心-API\"><a href=\"#6-4-4-Spring-Webflux-执行流程和核心-API\" class=\"headerlink\" title=\"6.4.4 Spring Webflux 执行流程和核心 API\"></a>6.4.4 Spring Webflux 执行流程和核心 API</h3><p><strong>Spring Webflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO （异步非阻塞）的框架</strong></p>\n<ol>\n<li><strong>BIO</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420202133.png\"></li>\n<li><strong>NIO。通过 Channel（通道），在 Selector（选择器）里进行注册。实现多路复用，对每个通道选择不同的状态</strong><br><img src=\"http://img.fan223.cn/2023/04/20230420202143.png\"></li>\n<li><strong>Spring Webflux 执行过程和 SpringMVC 相似</strong><br><strong>Spring Webflux 核心控制器 DispatchHandler，实现接口 WebHandler，其中有一个 handle 方法</strong><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123; &#x2F;&#x2F; http 请求响应信息\n\tif (this.handlerMappings &#x3D;&#x3D; null) &#123;\n\t\treturn createNotFoundError();\n\t&#125;\n\tif (CorsUtils.isPreFlightRequest(exchange.getRequest())) &#123;\n\t\treturn handlePreFlight(exchange);\n\t&#125;\n\treturn Flux.fromIterable(this.handlerMappings)\n\t\t\t.concatMap(mapping -&gt; mapping.getHandler(exchange))\n\t\t\t.next()\n\t\t\t.switchIfEmpty(createNotFoundError())\n\t\t\t.flatMap(handler -&gt; invokeHandler(exchange, handler))\n\t\t\t.flatMap(result -&gt; handleResult(exchange, result));\n&#125;</code></pre></li>\n<li><strong>Spring Webflux 里面 DispatcherHandler，负责请求的处理</strong><ul>\n<li><strong>HandlerMapping：请求查询到处理的方法</strong></li>\n<li><strong>HandlerAdapter：真正负责请求处理</strong></li>\n<li><strong>HandlerResultHandler：响应结果处理</strong></li>\n</ul>\n</li>\n<li><strong>Spring Webflux 实现函数式编程，两个接口：RouterFunction（路由处理）和 HandlerFunction（处理函数）</strong></li>\n</ol>\n<h2 id=\"6-5-Spring-Webflux（基于注解编程模型）\"><a href=\"#6-5-Spring-Webflux（基于注解编程模型）\" class=\"headerlink\" title=\"6.5 Spring Webflux（基于注解编程模型）\"></a>6.5 Spring Webflux（基于注解编程模型）</h2><p><strong>SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型。使用注解编程模型方式，和 SpringMVC 使用相似，只需要把相关依赖配置到项目中，SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器</strong></p>\n<h3 id=\"6-5-1-引入-POM-依赖\"><a href=\"#6-5-1-引入-POM-依赖\" class=\"headerlink\" title=\"6.5.1  引入 POM 依赖\"></a>6.5.1  引入 POM 依赖</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-webflux&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"6-5-2-Controller\"><a href=\"#6-5-2-Controller\" class=\"headerlink\" title=\"6.5.2 Controller\"></a>6.5.2 Controller</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\npublic class UserController &#123;\n\n\t@Resource\n\tprivate UserService userService;\n\n\t@GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\n\tpublic Mono&lt;User&gt; getUserById(@PathVariable int id)&#123;\n\t\treturn userService.getUserById(id);\n\t&#125;\n\n\t@GetMapping(&quot;&#x2F;user&quot;)\n\tpublic Flux&lt;User&gt; getAllUser()&#123;\n\t\treturn userService.getAllUser();\n\t&#125;\n\n\t@PostMapping(&quot;&#x2F;addUser&quot;)\n\tpublic Mono&lt;Void&gt; addUser(@RequestBody User user)&#123;\n\t\treturn userService.addUser(Mono.just(user));\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"6-5-3-Entity-和-Service\"><a href=\"#6-5-3-Entity-和-Service\" class=\"headerlink\" title=\"6.5.3 Entity 和 Service\"></a>6.5.3 Entity 和 Service</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private String id;\n    private String name;\n    private String gender;\n&#125;\n\npublic interface UserService &#123;\n\tMono&lt;User&gt; getUserById(int id);\n\n\tFlux&lt;User&gt; getAllUser();\n\n\tMono&lt;Void&gt; addUser(Mono&lt;User&gt; userMono);\n&#125;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n\tpublic static final Map&lt;Integer, User&gt; MAP &#x3D; new HashMap&lt;&gt;();\n\n\tpublic UserServiceImpl() &#123;\n\t\tMAP.put(1, new User(&quot;user1&quot;, &quot;张三&quot;, &quot;男&quot;));\n\t\tMAP.put(2, new User(&quot;user2&quot;, &quot;李四&quot;, &quot;女&quot;));\n\t\tMAP.put(3, new User(&quot;user3&quot;, &quot;王五&quot;, &quot;男&quot;));\n\t&#125;\n\n\t@Override\n\tpublic Mono&lt;User&gt; getUserById(int id) &#123;\n\t\treturn Mono.justOrEmpty(MAP.get(id));\n\t&#125;\n\n\t@Override\n\tpublic Flux&lt;User&gt; getAllUser() &#123;\n\t\treturn Flux.fromIterable(MAP.values());\n\t&#125;\n\n\t@Override\n\tpublic Mono&lt;Void&gt; addUser(Mono&lt;User&gt; userMono) &#123;\n\t\treturn userMono.doOnNext(user -&gt; &#123;\n\t\t\tMAP.put(MAP.size() + 1, user);\n\t\t&#125;).thenEmpty(Mono.empty());\n\t&#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202156.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202209.png\"></p>\n<ul>\n<li><strong>SpringMVC 方式实现，同步阻塞的方式，基于 SpringMVC + Servlet + Tomcat</strong></li>\n<li><strong>Spring Webflux 方式实现，异步非阻塞方式，基于 Spring Webflux + Reactor + Netty</strong></li>\n</ul>\n<h2 id=\"6-6-Spring-Webflux（基于函数式编程模型）\"><a href=\"#6-6-Spring-Webflux（基于函数式编程模型）\" class=\"headerlink\" title=\"6.6 Spring Webflux（基于函数式编程模型）\"></a>6.6 Spring Webflux（基于函数式编程模型）</h2><ol>\n<li>在使用函数式编程模型操作时候，<strong>需要自己初始化服务器</strong></li>\n<li>基于函数式编程模型时候，有<strong>两个核心接口：RouterFunction（实现路由功能，请求转发给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）</strong><br>核心任务定义两个函数式接口的实现并且启动需要的服务器</li>\n<li><strong>Spring Webflux 请求和响应不再是 ServletRequest 和 ServletResponse ，而是 ServerRequest 和 ServerResponse</strong></li>\n</ol>\n<h3 id=\"6-6-1-Entity-和-Service\"><a href=\"#6-6-1-Entity-和-Service\" class=\"headerlink\" title=\"6.6.1 Entity 和 Service\"></a>6.6.1 Entity 和 Service</h3><p><strong>与 6.5.3 同</strong></p>\n<h3 id=\"6-6-2-handler\"><a href=\"#6-6-2-handler\" class=\"headerlink\" title=\"6.6.2 handler\"></a>6.6.2 handler</h3><p><strong>创建 Handler（具体实现方法）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserHandler &#123;\n\n    private final UserService userService;\n\n    public UserHandler(UserService userService) &#123;\n        this.userService &#x3D; userService;\n    &#125;\n\n    public Mono&lt;ServerResponse&gt; getUserById(ServerRequest serverRequest) &#123;\n        &#x2F;&#x2F; 获取 Id 值\n        Integer id &#x3D; Integer.valueOf(serverRequest.pathVariable(&quot;id&quot;));\n        &#x2F;&#x2F; 空值处理\n        Mono&lt;ServerResponse&gt; notFound &#x3D; ServerResponse.notFound().build();\n        &#x2F;&#x2F; 调用 service 方法得到数据\n        Mono&lt;User&gt; userMono &#x3D; userService.getUserById(id);\n        &#x2F;&#x2F; 把 userMono 进行转换返回\n        return userMono.flatMap(user -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)\n                .body(BodyInserters.fromObject(user))).switchIfEmpty(notFound);\n    &#125;\n\n    public Mono&lt;ServerResponse&gt; getAllUser(ServerRequest serverRequest) &#123;\n        Flux&lt;User&gt; allUser &#x3D; userService.getAllUser();\n\n        return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)\n                .body(userMono, User.class);\n&#x2F;&#x2F;        return userMono.flatMap(user -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)\n&#x2F;&#x2F;                .body(BodyInserters.fromObject(user))).switchIfEmpty(notFound);\n    &#125;\n\n    public Mono&lt;ServerResponse&gt; addUser(ServerRequest serverRequest)&#123;\n        &#x2F;&#x2F; 得到 user 对象\n        Mono&lt;User&gt; userMono &#x3D; serverRequest.bodyToMono(User.class);\n\n        return ServerResponse.ok().build(userService.addUser(userMono));\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"6-6-3-Server\"><a href=\"#6-6-3-Server\" class=\"headerlink\" title=\"6.6.3 Server\"></a>6.6.3 Server</h3><p>先创建 Router 路由，再创建服务器完成适配，最后进行调用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Server &#123;\n\n\t&#x2F;&#x2F; 3. 调用\n    public static void main(String[] args) throws IOException &#123;\n        Server server &#x3D; new Server();\n        server.createReactorServer();\n        System.in.read();\n    &#125;\n\n    &#x2F;&#x2F; 1. 创建 Router 路由\n    public RouterFunction&lt;ServerResponse&gt; routerFunction() &#123;\n        UserServiceImpl userService &#x3D; new UserServiceImpl();\n        UserHandler userHandler &#x3D; new UserHandler(userService);\n\n        return RouterFunctions.route(RequestPredicates.GET(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\n                        .and(RequestPredicates.accept(MediaType.APPLICATION_JSON)), userHandler::getUserById)\n                .andRoute(RequestPredicates.GET(&quot;&#x2F;users&quot;)\n                        .and(RequestPredicates.accept(MediaType.APPLICATION_JSON)), userHandler::getAllUser);\n    &#125;\n\n    &#x2F;&#x2F; 2. 创建服务器完成适配\n    public void createReactorServer()&#123;\n        &#x2F;&#x2F; 路由和 handler 适配\n        RouterFunction&lt;ServerResponse&gt; routerFunction &#x3D; routerFunction();\n        HttpHandler httpHandler &#x3D; RouterFunctions.toHttpHandler(routerFunction);\n        ReactorHttpHandlerAdapter handlerAdapter &#x3D; new ReactorHttpHandlerAdapter(httpHandler);\n\n        &#x2F;&#x2F; 创建服务器\n        HttpServer httpServer &#x3D; HttpServer.create();\n        httpServer.handle(handlerAdapter).bindNow();\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"6-6-4-Client\"><a href=\"#6-6-4-Client\" class=\"headerlink\" title=\"6.6.4 Client\"></a>6.6.4 Client</h3><p><strong>使用 WebClient 调用</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 调用服务器地址\n        WebClient webClient &#x3D; WebClient.create(&quot;http:&#x2F;&#x2F;localhost:1289&quot;);\n\n        &#x2F;&#x2F; 根据 Id 查询\n        String id &#x3D; &quot;1&quot;;\n        User block &#x3D; webClient.get().uri(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)\n                .retrieve().bodyToMono(User.class).doOnNext(System.out::println).block();\n        System.out.println(block);\n\n        &#x2F;&#x2F; 查询所有\n        webClient.get().uri(&quot;&#x2F;users&quot;).accept(MediaType.APPLICATION_JSON)\n                .retrieve().bodyToFlux(User.class).doOnNext(System.out::println).blockLast();\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202223.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230420202235.png\"></p>\n","feature":false,"text":"1. IOC1.1 概念 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理 好处：降低耦合度 1.2 IOC 底层原理XML解析、工厂模式、反射 1.3 IOC（接口） IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 Spring 提供IOC容器两种实...","link":"","photos":[],"count_time":{"symbolsCount":"62k","symbolsTime":"56 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-IOC\"><span class=\"toc-text\">1. IOC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-IOC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.2 IOC 底层原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-IOC%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89\"><span class=\"toc-text\">1.3 IOC（接口）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-IOC-%E6%93%8D%E4%BD%9C-Bean-%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.4 IOC 操作 Bean 管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-1-%E5%9F%BA%E4%BA%8E-XML-%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1.4.1 基于 XML 方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-1-1-%E5%9F%BA%E4%BA%8E-XML-%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.4.1.1 基于 XML 方式创建对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-1-2-%E5%9F%BA%E4%BA%8E-xml-%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">1.4.1.2 基于 xml 方式注入属性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-1-3-%E5%9F%BA%E4%BA%8E-XML-%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7%EF%BC%88%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">1.4.1.3 基于 XML 方式注入属性（其他类型属性）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-1-4-%E5%B7%A5%E5%8E%82-Bean%EF%BC%88FactoryBean%EF%BC%89\"><span class=\"toc-text\">1.4.1.4 工厂 Bean（FactoryBean）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-2-bean-%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">1.4.2 bean 作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-3-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">1.4.3 bean 生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-4-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8-BeanPostProcessor\"><span class=\"toc-text\">1.4.4 后置处理器 BeanPostProcessor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-5-XML-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D\"><span class=\"toc-text\">1.4.5 XML 自动装配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-6-XML%EF%BC%88%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%EF%BC%89\"><span class=\"toc-text\">1.4.6 XML（引入外部属性文件）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1.5 基于注解方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-1-Spring-%E9%92%88%E5%AF%B9-Bean-%E7%AE%A1%E7%90%86%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%8F%90%E4%BE%9B%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">1.5.1 Spring 针对 Bean 管理中创建对象提供注解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-2-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.5.2 基于注解方式创建对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-3-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">1.5.3 基于注解方式实现属性注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-4-%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%EF%BC%88%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%89\"><span class=\"toc-text\">1.5.4 完全注解开发（配置类）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-AOP\"><span class=\"toc-text\">2. AOP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-AOP-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2.2 AOP 底层原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-AOP-%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">2.2.1 AOP 底层使用动态代理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-AOP%EF%BC%88JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89\"><span class=\"toc-text\">2.2.2 AOP（JDK 动态代理）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-AOP-%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">2.3 AOP 术语</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-AOP-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.4 AOP 操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-1-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%EF%BC%88%E6%8A%BD%E5%8F%96%E5%85%AC%E5%85%B1%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">2.4.1 基于注解方式（抽取公共切入点）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-2-AspectJ-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2.4.2 AspectJ 配置文件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-JdbcTemplate\"><span class=\"toc-text\">3. JdbcTemplate</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">3.1 配置连接属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Dao%E5%B1%82\"><span class=\"toc-text\">3.2 Dao层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Service-%E5%B1%82\"><span class=\"toc-text\">3.3 Service 层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E6%B5%8B%E8%AF%95%E7%B1%BB\"><span class=\"toc-text\">3.4 测试类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">4. 事务操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4.2 接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-1-PlatformTransactionManager-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4.2.1 PlatformTransactionManager 接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-2-TransactionDefinition-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4.2.2 TransactionDefinition 接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-3-TransactionStatus-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4.2.3 TransactionStatus 接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">4.3 Spring 事务管理介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.4 注解声明式事务管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">4.5 声明式事务管理参数配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-XML-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.6 XML 声明式事务管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.7 完全注解开发声明式事务管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-8-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89\"><span class=\"toc-text\">4.8 事务失效的原因（重要）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E4%B8%8D%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">4.8.1 数据库引擎不支持</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-2-%E6%B2%A1%E6%9C%89%E8%A2%AB-Spring-%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.8.2 没有被 Spring 管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-3-%E6%96%B9%E6%B3%95%E4%B8%8D%E6%98%AF-public-%E7%9A%84\"><span class=\"toc-text\">4.8.3 方法不是 public 的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-4-%E8%87%AA%E8%BA%AB%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4.8.4 自身调用问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-5-%E6%95%B0%E6%8D%AE%E6%BA%90%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8\"><span class=\"toc-text\">4.8.5 数据源没有配置事务管理器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-6-%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">4.8.6 不支持事务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-7-%E5%BC%82%E5%B8%B8%E8%A2%AB-catch\"><span class=\"toc-text\">4.8.7 异常被 catch</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-8-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">4.8.8 异常类型错误</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Spring5-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">5. Spring5 新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E8%87%AA%E5%B8%A6%E7%9A%84%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E5%B0%81%E8%A3%85-log4j2\"><span class=\"toc-text\">5.1 自带的通用日志封装 log4j2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">5.1.1 引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-log4j2-xml\"><span class=\"toc-text\">5.1.2 配置文件 log4j2.xml</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-3-%E6%89%8B%E5%8A%A8%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">5.1.3 手动打印日志</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-Spring5-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81-Nullable-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">5.2 Spring5 核心容器支持 @Nullable 注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-Spring5-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E5%BC%8F%E9%A3%8E%E6%A0%BC-GenericApplicationContext\"><span class=\"toc-text\">5.3 Spring5 核心容器支持函数式风格 GenericApplicationContext</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-Spring5-%E6%94%AF%E6%8C%81%E6%95%B4%E5%90%88-JUnit5\"><span class=\"toc-text\">5.4 Spring5 支持整合 JUnit5</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-1-%E6%95%B4%E5%90%88-JUnit4\"><span class=\"toc-text\">5.4.1 整合 JUnit4</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-2-Spring5-%E6%95%B4%E5%90%88-JUnit5\"><span class=\"toc-text\">5.4.2 Spring5 整合 JUnit5</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-Webflux\"><span class=\"toc-text\">6. Webflux</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%88NIO%EF%BC%89\"><span class=\"toc-text\">6.1 异步非阻塞（NIO）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-SpringMVC-%E4%B8%8E-Webflux-%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">6.2 SpringMVC 与 Webflux 对比</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88Java-%E5%AE%9E%E7%8E%B0%EF%BC%89\"><span class=\"toc-text\">6.3 响应式编程（Java 实现）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">6.3.1 概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-2-Java8-%E5%8F%8A%E5%85%B6%E4%B9%8B%E5%89%8D%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">6.3.2 Java8 及其之前版本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-3-Java9-%E5%8F%8A%E5%85%B6%E4%B9%8B%E5%90%8E%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">6.3.3 Java9 及其之后版本</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88Reactor-%E5%AE%9E%E7%8E%B0%EF%BC%89\"><span class=\"toc-text\">6.4 响应式编程（Reactor 实现）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-1-%E5%BC%95%E5%85%A5-POM-%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">6.4.1 引入 POM 依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-2-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">6.4.2 实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-3-%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">6.4.3 操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-4-Spring-Webflux-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A0%B8%E5%BF%83-API\"><span class=\"toc-text\">6.4.4 Spring Webflux 执行流程和核心 API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-5-Spring-Webflux%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%89\"><span class=\"toc-text\">6.5 Spring Webflux（基于注解编程模型）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-5-1-%E5%BC%95%E5%85%A5-POM-%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">6.5.1  引入 POM 依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-5-2-Controller\"><span class=\"toc-text\">6.5.2 Controller</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-5-3-Entity-%E5%92%8C-Service\"><span class=\"toc-text\">6.5.3 Entity 和 Service</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-6-Spring-Webflux%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%89\"><span class=\"toc-text\">6.6 Spring Webflux（基于函数式编程模型）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-6-1-Entity-%E5%92%8C-Service\"><span class=\"toc-text\">6.6.1 Entity 和 Service</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-6-2-handler\"><span class=\"toc-text\">6.6.2 handler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-6-3-Server\"><span class=\"toc-text\">6.6.3 Server</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-6-4-Client\"><span class=\"toc-text\">6.6.4 Client</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"SpringMVC 总结","uid":"153deb9c806beaeb0b25c611326c4f25","slug":"BlogRepository/Spring/SpringMVC 总结","date":"2022-06-10T18:22:45.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/Spring/SpringMVC 总结.json","keywords":null,"cover":"https://cover.png","text":"1. 配置1.1 MVC 概念MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的 JavaBean，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）JavaBean 分为两类： 一类称为实体类 Bean：专门存...","link":"","photos":[],"count_time":{"symbolsCount":"58k","symbolsTime":"53 mins."},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"记 Vue + Element-UI 上传组件上传图片到 https 图床接口（sm:ms）","uid":"7879396660455873787f556f0fa69f30","slug":"BlogRepository/问题记录/记 Vue + Element-UI 上传组件上传图片到 https 图床接口（smms）","date":"2022-05-21T02:10:12.000Z","updated":"2023-04-20T13:57:44.648Z","comments":true,"path":"api/articles/BlogRepository/问题记录/记 Vue + Element-UI 上传组件上传图片到 https 图床接口（smms）.json","keywords":null,"cover":"https://cover.png","text":"1. 上传组件action 表示上传的地址，这里使用 http-request 覆盖默认的上传行为，自定义上传的实现 &lt;el-upload action&#x3D;&quot;&quot; class&#x3D;&quot;alignContainer&quot; :htt...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"问题记录","slug":"问题记录","count":7,"path":"api/categories/问题记录.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}