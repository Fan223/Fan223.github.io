{"title":"Redis 6总结（1）","uid":"56daa6f6e65f7cd942daf401bb41ead5","slug":"BlogRepository/Redis/Redis 6总结（1）","date":"2022-02-24T01:12:39.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Redis/Redis 6总结（1）.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-NoSQL-数据库简介\"><a href=\"#1-NoSQL-数据库简介\" class=\"headerlink\" title=\"1. NoSQL 数据库简介\"></a>1. NoSQL 数据库简介</h1><h2 id=\"1-1-技术发展\"><a href=\"#1-1-技术发展\" class=\"headerlink\" title=\"1.1 技术发展\"></a>1.1 技术发展</h2><p>技术的分类：</p>\n<ol>\n<li>解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li>\n<li>解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</li>\n<li>解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li>\n</ol>\n<h3 id=\"1-1-1-问题\"><a href=\"#1-1-1-问题\" class=\"headerlink\" title=\"1.1.1 问题\"></a>1.1.1 问题</h3><p><img src=\"http://img.fan223.cn/2023/04/20230418090307.png\"></p>\n<h3 id=\"1-1-2-解决CPU及内存压力\"><a href=\"#1-1-2-解决CPU及内存压力\" class=\"headerlink\" title=\"1.1.2 解决CPU及内存压力\"></a>1.1.2 解决CPU及内存压力</h3><p>使用负载均衡减少服务器压力，但存在登录验证问题</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090319.png\"></p>\n<h3 id=\"1-1-3-解决IO压力\"><a href=\"#1-1-3-解决IO压力\" class=\"headerlink\" title=\"1.1.3 解决IO压力\"></a>1.1.3 解决IO压力</h3><p><img src=\"http://img.fan223.cn/2023/04/20230418090331.png\"></p>\n<h2 id=\"1-2-NoSQL-数据库\"><a href=\"#1-2-NoSQL-数据库\" class=\"headerlink\" title=\"1.2 NoSQL 数据库\"></a>1.2 NoSQL 数据库</h2><h3 id=\"1-2-1-NoSQL-数据库概述\"><a href=\"#1-2-1-NoSQL-数据库概述\" class=\"headerlink\" title=\"1.2.1 NoSQL 数据库概述\"></a>1.2.1 NoSQL 数据库概述</h3><p>NoSQL（NoSQL &#x3D; Not Only SQL ），意即“不仅仅是SQL”，泛指非关系型的数据库</p>\n<p>NoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力</p>\n<ul>\n<li>不遵循 SQL 标准。</li>\n<li>不支持 ACID。</li>\n<li>远超于 SQL 的性能。</li>\n</ul>\n<h3 id=\"1-2-2-NoSQL-适用场景\"><a href=\"#1-2-2-NoSQL-适用场景\" class=\"headerlink\" title=\"1.2.2 NoSQL 适用场景\"></a>1.2.2 NoSQL 适用场景</h3><ul>\n<li>对数据高并发的读写</li>\n<li>海量数据的读写</li>\n<li>对数据高可扩展性的</li>\n</ul>\n<h3 id=\"1-2-3-NoSQL不适用场景\"><a href=\"#1-2-3-NoSQL不适用场景\" class=\"headerlink\" title=\"1.2.3 NoSQL不适用场景\"></a>1.2.3 NoSQL不适用场景</h3><ul>\n<li>需要事务支持</li>\n<li>基于 SQL 的结构化查询存储，处理复杂的关系,需要<font color=\"red\">即时查询</font></li>\n<li><font color=\"red\">（<strong>用不着 SQL 的和用了 SQL 也不行的情况，请考虑用 NoSQL）</strong></font></li>\n</ul>\n<h3 id=\"1-2-4-常用的-NoSQL-数据库\"><a href=\"#1-2-4-常用的-NoSQL-数据库\" class=\"headerlink\" title=\"1.2.4 常用的 NoSQL 数据库\"></a>1.2.4 常用的 NoSQL 数据库</h3><h4 id=\"1-2-4-1-Memcache\"><a href=\"#1-2-4-1-Memcache\" class=\"headerlink\" title=\"1.2.4.1 Memcache\"></a>1.2.4.1 Memcache</h4><p><img src=\"http://img.fan223.cn/2023/04/20230418090348.png\"></p>\n<h4 id=\"1-2-4-2-Redis\"><a href=\"#1-2-4-2-Redis\" class=\"headerlink\" title=\"1.2.4.2 Redis\"></a>1.2.4.2 Redis</h4><p><img src=\"http://img.fan223.cn/2023/04/20230418090359.png\"></p>\n<h4 id=\"1-2-4-3-MongoDB\"><a href=\"#1-2-4-3-MongoDB\" class=\"headerlink\" title=\"1.2.4.3 MongoDB\"></a>1.2.4.3 MongoDB</h4><p><img src=\"http://img.fan223.cn/2023/04/20230418090409.png\"></p>\n<h2 id=\"1-3-行式存储数据库（大数据时代）\"><a href=\"#1-3-行式存储数据库（大数据时代）\" class=\"headerlink\" title=\"1.3 行式存储数据库（大数据时代）\"></a>1.3 行式存储数据库（大数据时代）</h2><h3 id=\"1-3-1-行式数据库\"><a href=\"#1-3-1-行式数据库\" class=\"headerlink\" title=\"1.3.1 行式数据库\"></a>1.3.1 行式数据库</h3><p><img src=\"http://img.fan223.cn/2023/04/20230418090425.png\"></p>\n<h3 id=\"1-3-2-列式数据库\"><a href=\"#1-3-2-列式数据库\" class=\"headerlink\" title=\"1.3.2 列式数据库\"></a>1.3.2 列式数据库</h3><p><img src=\"http://img.fan223.cn/2023/04/20230418090435.png\"></p>\n<h4 id=\"1-3-2-1-HBase\"><a href=\"#1-3-2-1-HBase\" class=\"headerlink\" title=\"1.3.2.1 HBase\"></a>1.3.2.1 HBase</h4><p><img src=\"http://img.fan223.cn/2023/04/20230418090445.png\"></p>\n<p>HBase 是 <strong>Hadoop</strong> 项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中</p>\n<p>HBase 的目标就是处理数据量<font color=\"red\"><strong>非常庞大</strong></font>的表，可以用<font color=\"red\"><strong>普通计算机</strong></font>处理超过<font color=\"red\"><strong>10亿行</strong></font>数据，还可处理有数百万<font color=\"red\"><strong>列</strong></font>元素的数据表</p>\n<h4 id=\"1-3-2-2-Cassandra\"><a href=\"#1-3-2-2-Cassandra\" class=\"headerlink\" title=\"1.3.2.2 Cassandra\"></a>1.3.2.2 Cassandra</h4><p><img src=\"http://img.fan223.cn/2023/04/20230418090458.png\"></p>\n<p>Apache Cassandra 是一款免费的开源 NoSQL 数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的<font color=\"red\"><strong>海量数据集（数据量通常达到PB级别）</strong></font>。在众多显著特性当中，Cassandra 最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程</p>\n<p>计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p>\n<ul>\n<li>位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位</li>\n<li>字节 byte：8个二进制位为一个字节(B)，最常用的单位</li>\n<li>1KB (Kilobyte 千字节)&#x3D;1024B</li>\n<li>1MB (Megabyte 兆字节 简称“兆”)&#x3D;1024KB</li>\n<li>1GB (Gigabyte 吉字节 又称“千兆”)&#x3D;1024MB</li>\n<li>1TB (Trillionbyte 万亿字节 太字节)&#x3D;1024GB，其中1024&#x3D;2^10 ( 2 的10次方)</li>\n<li>1PB（Petabyte 千万亿字节 拍字节）&#x3D;1024TB</li>\n<li>1EB（Exabyte 百亿亿字节 艾字节）&#x3D;1024PB</li>\n<li>1ZB (Zettabyte 十万亿亿字节 泽字节)&#x3D; 1024 EB</li>\n<li>1YB (Jottabyte 一亿亿亿字节 尧字节)&#x3D; 1024 ZB</li>\n<li>1BB (Brontobyte 一千亿亿亿字节)&#x3D; 1024 YB.<br>注：“兆”为百万级数量单位</li>\n</ul>\n<h2 id=\"1-4-图关系型数据库\"><a href=\"#1-4-图关系型数据库\" class=\"headerlink\" title=\"1.4 图关系型数据库\"></a>1.4 图关系型数据库</h2><p><img src=\"http://img.fan223.cn/2023/04/20230418090521.png\"></p>\n<p>主要应用：社会关系，公共交通网络，地图及网络拓扑（n *（n-1）&#x2F; 2）</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090533.png\"></p>\n<h1 id=\"2-Redis-概述安装\"><a href=\"#2-Redis-概述安装\" class=\"headerlink\" title=\"2. Redis 概述安装\"></a>2. Redis 概述<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/123102635\">安装</a></h1><ul>\n<li>Redis 是一个<font color=\"red\">开源</font>的 <font color=\"red\">key-value</font> 存储系统</li>\n<li>和 Memcached 类似，它支持存储的 value 类型相对更多，包括 <font color=\"red\">string</font>（字符串）、<font color=\"red\">list</font>（链表）、<font color=\"red\">set</font>（集合）、<font color=\"red\">zset</font>（sorted set –有序集合）和 <font color=\"red\">hash</font>（哈希类型）</li>\n<li>这些数据类型都支持 push&#x2F;pop、add&#x2F;remove 以及取交集并集和差集及更丰富的操作，而且这些操作都是<font color=\"red\">原子性</font>的</li>\n<li>在此基础上，Redis 支持各种不同方式的<font color=\"red\">排序</font></li>\n<li>与 memcached 一样，为了保证效率，数据都是<font color=\"red\">缓存在内存</font>中</li>\n<li>区别的是 Redis 会<font color=\"red\">周期性</font>的把更新的<font color=\"red\">数据写入磁盘</font>或者把修改操作写入追加的记录文件</li>\n<li>并且在此基础上实现了 <font color=\"red\">master-slave（主从）</font>同步</li>\n</ul>\n<h2 id=\"2-1-应用场景\"><a href=\"#2-1-应用场景\" class=\"headerlink\" title=\"2.1 应用场景\"></a>2.1 应用场景</h2><h3 id=\"2-1-1-配合关系型数据库做高速缓存\"><a href=\"#2-1-1-配合关系型数据库做高速缓存\" class=\"headerlink\" title=\"2.1.1 配合关系型数据库做高速缓存\"></a>2.1.1 配合关系型数据库做高速缓存</h3><ul>\n<li><p>高频次，热门访问的数据，降低数据库IO</p>\n</li>\n<li><p>分布式架构，做 session 共享</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090550.png\"></p>\n</li>\n</ul>\n<h3 id=\"2-1-2-多样的数据结构存储持久化数据\"><a href=\"#2-1-2-多样的数据结构存储持久化数据\" class=\"headerlink\" title=\"2.1.2 多样的数据结构存储持久化数据\"></a>2.1.2 多样的数据结构存储持久化数据</h3><p><img src=\"http://img.fan223.cn/2023/04/20230418090607.png\"></p>\n<h2 id=\"2-2-Redis-安装\"><a href=\"#2-2-Redis-安装\" class=\"headerlink\" title=\"2.2 Redis 安装\"></a>2.2 Redis <a href=\"https://blog.csdn.net/ACE_U_005A/article/details/123102635\">安装</a></h2><h2 id=\"2-3-Redis-介绍相关知识\"><a href=\"#2-3-Redis-介绍相关知识\" class=\"headerlink\" title=\"2.3 Redis 介绍相关知识\"></a>2.3 Redis 介绍相关知识</h2><p><img src=\"http://img.fan223.cn/2023/04/20230418090632.png\"></p>\n<p><strong>Redis是单线程+多路IO复用技术</strong></p>\n<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>\n<p><font color=\"red\"><strong>串行   vs   多线程+锁（memcached） vs   单线程+多路IO复用(Redis)</strong></font></p>\n<p>（与 Memcache 三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）</p>\n<h1 id=\"3-常用五大数据类型\"><a href=\"#3-常用五大数据类型\" class=\"headerlink\" title=\"3. 常用五大数据类型\"></a>3. 常用五大数据类型</h1><p><strong>String、List、Set、Hash、Zset</strong></p>\n<table>\n  <tr> <th>对象</th> <th>编码</th> <th>数据结构</th> </tr>\n  <tr> <td rowspan=\"3\"> string(字符串对象)</td> <td> int </td> <td> 可以存储 long 类型的整数 </td> </tr>\n  <tr> <td> embstr </td> <td> embstr 编码的简单动态字符串 </td> </tr>\n  <tr> <td> row </td> <td> 简单动态字符串（SDS） </td> </tr>\n  <tr> <td rowspan=\"2\"> list（列表对象） </td> <td> ziplist </td> <td> 压缩列表 </td> </tr>\n  <tr> <td> linkedisk </td> <td> 双端链表 </td> </tr>\n  <tr> <td rowspan=\"2\"> hash（哈希对象） </td> <td> ziplist </td> <td> 压缩列表 </td> </tr>\n  <tr> <td> hashtable </td> <td> 字典 </td> </tr>\n  <tr> <td rowspan=\"2\"> set（集合对象） </td> <td> intset </td> <td> 整数集合 </td> </tr>\n  <tr> <td> hashtable </td> <td> 字典 </td> </tr>\n  <tr> <td rowspan=\"2\"> zset（有序集合对象） </td> <td> ziplist </td> <td> 压缩列表 </td> </tr>\n  <tr> <td> skiplist </td> <td> 字典 + 跳跃表 </td> </tr>\n</table>\n\n<h2 id=\"3-1-Redis键-key\"><a href=\"#3-1-Redis键-key\" class=\"headerlink\" title=\"3.1.\tRedis键(key)\"></a>3.1.\tRedis键(key)</h2><ol>\n<li>keys * ：查看当前库所有 key    (匹配：keys *1)</li>\n<li>exists key ：判断某个 key 是否存在</li>\n<li>type key ：查看你的 key 是什么类型</li>\n<li>del key ：删除指定的 key 数据</li>\n<li>unlink key ：根据 value 选择非阻塞删除，仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作</li>\n<li>expire key 10 ：10秒钟：为给定的 key 设置过期时间</li>\n<li>ttl key ：查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</li>\n<li>select ：命令切换数据库</li>\n<li>dbsize ：查看当前数据库的 key 的数量</li>\n<li>flushdb ：清空当前库</li>\n<li>flushall ：通杀全部库</li>\n</ol>\n<h2 id=\"3-2-Redis字符串（String）\"><a href=\"#3-2-Redis字符串（String）\" class=\"headerlink\" title=\"3.2 Redis字符串（String）\"></a>3.2 Redis字符串（String）</h2><h3 id=\"3-2-1-简介\"><a href=\"#3-2-1-简介\" class=\"headerlink\" title=\"3.2.1 简介\"></a>3.2.1 简介</h3><ul>\n<li>String 是 Redis 最基本的数据类型，可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value</li>\n<li>String 类型是<font color=\"red\">二进制安全的</font>。意味着 Redis 的string 可以包含任何数据。比如 JPG 图片或者序列化的对象</li>\n<li>一个 Redis 中字符串 value 最多可以是 <font color=\"red\"><strong>512M</strong></font></li>\n</ul>\n<h3 id=\"3-2-2-常用命令\"><a href=\"#3-2-2-常用命令\" class=\"headerlink\" title=\"3.2.2 常用命令\"></a>3.2.2 常用命令</h3><p>添加键值对</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">set &lt;key&gt; &lt;value&gt; </code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090707.png\"></p>\n<ul>\n<li>NX：当数据库中key不存在时，可以将key-value添加数据库</li>\n<li>XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</li>\n<li>EX：key的超时秒数</li>\n<li>PX：key的超时毫秒数，与EX互斥<br><img src=\"http://img.fan223.cn/2023/04/20230418090718.png\"></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li><strong>get key</strong><br>查询对应键值</li>\n<li>append key value<br>将给定的 value 追加到原值的末尾</li>\n<li>strlen key<br>获得值的长度</li>\n<li><strong>setnx key value</strong><br>只有在 key 不存在时    设置 key 的值</li>\n<li>incr key<br>将 key 中储存的数字值增1<br>只能对数字值操作，如果为空，新增值为1</li>\n<li>decr key<br>将 key 中储存的数字值减1<br>只能对数字值操作，如果为空，新增值为-1</li>\n<li>incrby &#x2F; decrby  key 步长<br>将 key 中储存的数字值增减。自定义步长。原子性<br><img src=\"http://img.fan223.cn/2023/04/20230418090731.png\"><br><strong>所谓原子操作是指不会被线程调度机制打断的操作；</strong><br>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）<br>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作<br><strong>Redis 单命令的原子性主要得益于 Redis 的单线程</strong></li>\n<li><strong>mset key1 value1 key2 value2 …..</strong><br>同时设置一个或多个 key-value 对</li>\n<li><strong>mget  key1 key2 key3 …..</strong><br>同时获取一个或多个 value</li>\n<li>msetnx key1 value1 key2 value2 …..<br>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在<br>原子性，有一个失败则都失败</li>\n<li>getrange  key 起始位置 结束位置<br>获得值的范围，类似java中的substring，前包，后包</li>\n<li>setrange  key 起始位置 value<br>用 value 覆写 key 所储存的字符串值，从 起始位置 开始(索引从0开始)</li>\n<li><strong>setex  key 过期时间 value</strong><br>设置键值的同时，设置过期时间，单位秒</li>\n<li>getset key value<br>以新换旧，设置了新值同时获得旧值</li>\n</ol></blockquote>\n<h3 id=\"3-2-3-数据结构\"><a href=\"#3-2-3-数据结构\" class=\"headerlink\" title=\"3.2.3 数据结构\"></a>3.2.3 数据结构</h3><p>String 的数据结构为简单动态字符串（Simple Dynamic String，缩写 SDS）。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList ，采用预分配冗余空间的方式来减少内存的频繁分配</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090754.png\"></p>\n<p>内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M</p>\n<h2 id=\"3-3-Redis-列表（List）\"><a href=\"#3-3-Redis-列表（List）\" class=\"headerlink\" title=\"3.3 Redis 列表（List）\"></a>3.3 Redis 列表（List）</h2><h3 id=\"3-3-1-简介\"><a href=\"#3-3-1-简介\" class=\"headerlink\" title=\"3.3.1 简介\"></a>3.3.1 简介</h3><p>单键多值</p>\n<ul>\n<li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</li>\n<li>它的底层实际是个 <strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。即 <font color=\"red\"><strong>查询性能较差</strong></font></li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090815.png\"></p>\n<h3 id=\"3-3-2-常用命令\"><a href=\"#3-3-2-常用命令\" class=\"headerlink\" title=\"3.3.2 常用命令\"></a>3.3.2 常用命令</h3><ol>\n<li><strong>lpush&#x2F;rpush  key value1 value2 value3 ….</strong><br>从左边 &#x2F; 右边插入一个或多个值</li>\n<li>lpop&#x2F;rpop  key<br>从左边 &#x2F; 右边吐出一个值。<strong>值在键在，值光键亡</strong>。</li>\n<li>rpoplpush  key1 key2<br>从 key1 列表右边吐出一个值，插到 key2 列表左边。</li>\n<li>lrange key start stop<br>按照索引下标获得元素(从左到右)<br><strong>lrange mylist 0 -1</strong><br>0 左边第一个，-1 右边第一个，（0-1表示获取所有）</li>\n<li>lindex key index<br>按照索引下标获得元素(从左到右)</li>\n<li>llen key<br>获得列表长度</li>\n<li>linsert key before&#x2F;after value newvalue<br>在 value 的前面 &#x2F; 后面插入 newvalue 插入值</li>\n<li>lrem key n value<br>从左边删除 n 个value(从左到右)</li>\n<li>lset key index value<br>将列表 key 下标为 index 的值替换成 value</li>\n</ol>\n<h3 id=\"3-2-3-数据结构-1\"><a href=\"#3-2-3-数据结构-1\" class=\"headerlink\" title=\"3.2.3 数据结构\"></a>3.2.3 数据结构</h3><p>List 的数据结构为快速链表 quickList</p>\n<ul>\n<li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表</li>\n<li>它将所有的元素紧挨着一起存储，分配的是一块连续的内存</li>\n<li>当数据量比较多的时候才会改成 quicklist</li>\n<li>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如列表里存的只是int类型的数据，结构上还需要两个额外的指针 prev 和 next</li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090826.png\"></p>\n<p>Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余</p>\n<h2 id=\"3-4-Redis-集合（Set）\"><a href=\"#3-4-Redis-集合（Set）\" class=\"headerlink\" title=\"3.4 Redis 集合（Set）\"></a>3.4 Redis 集合（Set）</h2><h3 id=\"3-4-1-简介\"><a href=\"#3-4-1-简介\" class=\"headerlink\" title=\"3.4.1 简介\"></a>3.4.1 简介</h3><p>Redis Set 对外提供的功能与 List 类似是一个列表的功能，特殊之处在于 Set 是可以 <font color=\"red\"><strong>自动排重</strong></font> 的，当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的</p>\n<p>Redis 的 Se t是 String 类型的 <font color=\"red\"><strong>无序集合</strong></font> 。<font color=\"red\"><strong>它底层其实是一个 value 为 null 的 hash 表</strong></font>，所以添加，删除，查找的<font color=\"red\"><strong>复杂度都是O(1)</strong></font></p>\n<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>\n<h3 id=\"3-4-2-常用命令\"><a href=\"#3-4-2-常用命令\" class=\"headerlink\" title=\"3.4.2 常用命令\"></a>3.4.2 常用命令</h3><ol>\n<li><strong>sadd key value1 value2 …..</strong><br>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li>\n<li><strong>smembers key</strong><br>取出该集合的所有值。</li>\n<li><strong>sismember key value</strong><br>判断集合 key 是否为含有该 value 值，有1，没有0</li>\n<li>scard key<br>返回该集合的元素个数。</li>\n<li><strong>srem key value1 value2 ….</strong><br>删除集合中的某个元素。</li>\n<li>spop key<br>随机从该集合中吐出一个值。</li>\n<li>srandmember key n<br>随机从该集合中取出n个值。不会从集合中删除 。</li>\n<li>smove source target value<br>把集合中一个值从一个集合移动到另一个集合</li>\n<li>sinter key1 key2<br>返回两个集合的交集元素。</li>\n<li>sunion key1 key2<br>返回两个集合的并集元素。</li>\n<li>sdiff key1 key2<br>返回两个集合的差集元素（key1中的，不包含key2中的）</li>\n</ol>\n<h3 id=\"3-4-3-数据结构\"><a href=\"#3-4-3-数据结构\" class=\"headerlink\" title=\"3.4.3 数据结构\"></a>3.4.3 数据结构</h3><p>Set 数据结构是 dict 字典，字典是用哈希表实现的</p>\n<p>Java 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。Redis 的 Set 结构也是一样，它的内部也使用 Hash 结构，所有的 value 都指向同一个内部值。</p>\n<h2 id=\"3-5-Redis哈希（Hash）\"><a href=\"#3-5-Redis哈希（Hash）\" class=\"headerlink\" title=\"3.5 Redis哈希（Hash）\"></a>3.5 Redis哈希（Hash）</h2><h3 id=\"3-5-1-简介\"><a href=\"#3-5-1-简介\" class=\"headerlink\" title=\"3.5.1 简介\"></a>3.5.1 简介</h3><p>Redis hash 是一个键值对集合。Redis hash 是一个 String 类型的 <strong>field</strong> 和 <strong>value</strong> 的映射表，hash **特别适合用于存储对象。<font color=\"red\"><strong>类似 Java 里面的 <code>Map&lt;String, Object&gt;</code></strong> </font></p>\n<p>用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key&#x2F;value 结构来存储，主要有以下2种存储方式：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090840.png\"></p>\n<h3 id=\"3-5-2-常用命令\"><a href=\"#3-5-2-常用命令\" class=\"headerlink\" title=\"3.5.2 常用命令\"></a>3.5.2 常用命令</h3><ol>\n<li>hset key field value<br>给 key 集合中的  field 键赋值 value</li>\n<li>hget key1 field<br>从 key1 集合 field 取出 value</li>\n<li>hmset key1 field1 value1 field2 value2…<br>批量设置 hash 的值</li>\n<li>hexists key1 field<br>查看哈希表 key 中，给定域 field 是否存在。</li>\n<li>hkeys key<br>列出该 hash 集合的所有 field</li>\n<li>hvals key<br>列出该 hash 集合的所有 value</li>\n<li>hincrby key field increment<br>为哈希表 key 中的域 field 的值加上增量 1   -1</li>\n<li>hsetnx key field value<br>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</li>\n</ol>\n<h3 id=\"3-5-3-数据结构\"><a href=\"#3-5-3-数据结构\" class=\"headerlink\" title=\"3.5.3 数据结构\"></a>3.5.3 数据结构</h3><p>Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable</p>\n<h2 id=\"3-6-Redis-有序集合-Zset（sorted-set）\"><a href=\"#3-6-Redis-有序集合-Zset（sorted-set）\" class=\"headerlink\" title=\"3.6 Redis 有序集合 Zset（sorted set）\"></a>3.6 Redis 有序集合 Zset（sorted set）</h2><h3 id=\"3-6-1-简介\"><a href=\"#3-6-1-简介\" class=\"headerlink\" title=\"3.6.1 简介\"></a>3.6.1 简介</h3><p>Redis 有序集合 Zset 与普通集合 Set 非常相似，是一个 <font color=\"red\"><strong>没有重复元素</strong></font> 的字符串集合。不同之处是有序集合的每个成员都关联了一个 <font color=\"red\"><strong>评分（score）</strong></font>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<font color=\"red\"><strong>集合的成员是唯一的，但是评分可以是重复的</strong></font></p>\n<p>因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表</p>\n<h3 id=\"3-6-2-常用命令\"><a href=\"#3-6-2-常用命令\" class=\"headerlink\" title=\"3.6.2 常用命令\"></a>3.6.2 常用命令</h3><ol>\n<li>zadd  key score1 value1 score2 value2…<br>将一个或多个 member 元素及其 score 值加入到有序集 key 当中</li>\n<li>zrange key start stop  [WITHSCORES]返回有序集 key 中，下标在 start stop之间的元素<br>带WITHSCORES，可以让分数一起和值返回到结果集</li>\n<li>zrangebyscore key minmax [withscores] [limit offset count]<br>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列</li>\n<li>zrevrangebyscore key maxmin [withscores] [limit offset count]同上，改为从大到小排列</li>\n<li>zincrby key increment value<br>为元素的score加上增量</li>\n<li>zrem  key value<br>删除该集合下，指定值的元素</li>\n<li>zcount key min max<br>统计该集合，分数区间内的元素个数</li>\n<li>zrank key value<br>返回该值在集合中的排名，从0开始</li>\n</ol>\n<h3 id=\"3-6-3-数据结构\"><a href=\"#3-6-3-数据结构\" class=\"headerlink\" title=\"3.6.3 数据结构\"></a>3.6.3 数据结构</h3><p>SortedSet（Zset）是Redis提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 <code>Map&lt;String, Double&gt;</code>，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表</p>\n<p>Zset 底层使用了两个数据结构</p>\n<ol>\n<li>hash，hash的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值</li>\n<li>跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表</li>\n</ol>\n<h3 id=\"3-6-4-跳跃表\"><a href=\"#3-6-4-跳跃表\" class=\"headerlink\" title=\"3.6.4 跳跃表\"></a>3.6.4 跳跃表</h3><p>1、简介<br>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单</p>\n<p>2、实例<br>对比有序链表和跳跃表，从链表中查询出51</p>\n<ol>\n<li>有序链表<br><img src=\"http://img.fan223.cn/2023/04/20230418090900.png\"><br>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较</li>\n<li>跳跃表<br><img src=\"http://img.fan223.cn/2023/04/20230418090911.png\"><ul>\n<li>从第2层开始，1节点比51节点小，向后比较</li>\n<li>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</li>\n<li>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</li>\n<li>在第0层，51节点为要查找的节点，节点被找到，共查找4次</li>\n</ul>\n</li>\n</ol>\n<p><strong>从此可以看出跳跃表比有序链表效率要高</strong></p>\n<h1 id=\"4-Redis-配置文件\"><a href=\"#4-Redis-配置文件\" class=\"headerlink\" title=\"4. Redis 配置文件\"></a>4. Redis 配置文件</h1><h2 id=\"4-1-Units-单位\"><a href=\"#4-1-Units-单位\" class=\"headerlink\" title=\"4.1 ###Units 单位###\"></a>4.1 ###Units 单位###</h2><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090928.png\"></p>\n<h2 id=\"4-2-INCLUDES-包含\"><a href=\"#4-2-INCLUDES-包含\" class=\"headerlink\" title=\"4.2 ###INCLUDES 包含###\"></a>4.2 ###INCLUDES 包含###</h2><p>类似 JSP 中的 include，多实例的情况可以把公用的配置文件提取出来</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090940.png\"></p>\n<h2 id=\"4-3-NETWORK-网络相关配置\"><a href=\"#4-3-NETWORK-网络相关配置\" class=\"headerlink\" title=\"4.3\t###NETWORK 网络相关配置###\"></a>4.3\t###NETWORK 网络相关配置###</h2><h3 id=\"4-3-1-bind\"><a href=\"#4-3-1-bind\" class=\"headerlink\" title=\"4.3.1 bind\"></a>4.3.1 bind</h3><p>默认情况 bind&#x3D;127.0.0.1 只能接受本机的访问请求。不写的情况下，无限制接受任何 ip 地址的访问。生产环境应该要写应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418090951.png\"></p>\n<h3 id=\"4-3-2-protected-mode\"><a href=\"#4-3-2-protected-mode\" class=\"headerlink\" title=\"4.3.2 protected-mode\"></a>4.3.2 protected-mode</h3><p>将本机访问保护模式设置 no</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091004.png\"></p>\n<h3 id=\"4-3-3-Port\"><a href=\"#4-3-3-Port\" class=\"headerlink\" title=\"4.3.3 Port\"></a>4.3.3 Port</h3><p>默认端口为 6379</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091017.png\"></p>\n<h3 id=\"4-3-4-tcp-backlog\"><a href=\"#4-3-4-tcp-backlog\" class=\"headerlink\" title=\"4.3.4 tcp-backlog\"></a>4.3.4 tcp-backlog</h3><p>设置 tcp 的 backlog，backlog 其实是一个连接队列，<strong>backlog 队列总和 &#x3D; 未完成三次握手队列 + 已经完成三次握手队列</strong>。在高并发环境下你需要一个<strong>高 backlog 值</strong>来避免慢客户端连接问题</p>\n<p>注意 Linux 内核会将这个值减小到 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 的值（128），所以需要确认增大 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 和 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091030.png\"></p>\n<h3 id=\"4-3-5-timeout\"><a href=\"#4-3-5-timeout\" class=\"headerlink\" title=\"4.3.5 timeout\"></a>4.3.5 timeout</h3><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091045.png\"></p>\n<h3 id=\"4-3-6-tcp-keepalive\"><a href=\"#4-3-6-tcp-keepalive\" class=\"headerlink\" title=\"4.3.6 tcp-keepalive\"></a>4.3.6 tcp-keepalive</h3><p>对访问客户端的一种心跳检测，每隔 n 秒检测一次。单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60 （默认 300）</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091056.png\"></p>\n<h2 id=\"4-4-GENERAL-通用\"><a href=\"#4-4-GENERAL-通用\" class=\"headerlink\" title=\"4.4 ###GENERAL 通用###\"></a>4.4 ###GENERAL 通用###</h2><h3 id=\"4-4-1-daemonize\"><a href=\"#4-4-1-daemonize\" class=\"headerlink\" title=\"4.4.1 daemonize\"></a>4.4.1 daemonize</h3><p>是否为后台进程，设置为 yes。守护进程，后台启动</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091108.png\"></p>\n<h3 id=\"4-4-2-pidfile\"><a href=\"#4-4-2-pidfile\" class=\"headerlink\" title=\"4.4.2 pidfile\"></a>4.4.2 pidfile</h3><p>存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091123.png\"></p>\n<h3 id=\"4-4-3-loglevel\"><a href=\"#4-4-3-loglevel\" class=\"headerlink\" title=\"4.4.3 loglevel\"></a>4.4.3 loglevel</h3><p>指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice。四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091137.png\"></p>\n<h3 id=\"4-4-4-logfile\"><a href=\"#4-4-4-logfile\" class=\"headerlink\" title=\"4.4.4 logfile\"></a>4.4.4 logfile</h3><p>日志文件名称</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091150.png\"></p>\n<h3 id=\"4-4-5-databases-16\"><a href=\"#4-4-5-databases-16\" class=\"headerlink\" title=\"4.4.5 databases 16\"></a>4.4.5 databases 16</h3><p>设定库的数量默认16，默认数据库为 0，可以使用 SELECT dbid 命令在连接上指定数据库 id</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091202.png\"></p>\n<h2 id=\"4-5-SECURITY-安全\"><a href=\"#4-5-SECURITY-安全\" class=\"headerlink\" title=\"4.5 ###SECURITY 安全###\"></a>4.5 ###SECURITY 安全###</h2><h3 id=\"4-5-1-设置密码\"><a href=\"#4-5-1-设置密码\" class=\"headerlink\" title=\"4.5.1 设置密码\"></a>4.5.1 设置密码</h3><p>在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。永久设置，需要在配置文件中进行设置</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091217.png\"></p>\n<h2 id=\"4-6-CLIENTS-客户端\"><a href=\"#4-6-CLIENTS-客户端\" class=\"headerlink\" title=\"4.6 #### CLIENTS 客户端\"></a>4.6 #### CLIENTS 客户端</h2><h3 id=\"4-6-1-maxclients\"><a href=\"#4-6-1-maxclients\" class=\"headerlink\" title=\"4.6.1 maxclients\"></a>4.6.1 maxclients</h3><p>设置redis同时可以与多少个客户端进行连接。默认情况下为 10000 个客户端。如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出 “max number of clients reached” 以作回应</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091230.png\"></p>\n<h2 id=\"4-7-MEMORY-MANAGEMENT-内存管理\"><a href=\"#4-7-MEMORY-MANAGEMENT-内存管理\" class=\"headerlink\" title=\"4.7 ####MEMORY MANAGEMENT 内存管理####\"></a>4.7 ####MEMORY MANAGEMENT 内存管理####</h2><h3 id=\"4-7-1-maxmemory\"><a href=\"#4-7-1-maxmemory\" class=\"headerlink\" title=\"4.7.1 maxmemory\"></a>4.7.1 maxmemory</h3><p>建议必须设置，否则，将内存占满，造成服务器宕机。设置 Redis 可以使用的内存量。一旦到达内存使用上限，Redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定</p>\n<p>如果 Redis 无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么 Redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等</p>\n<p>但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。如果你的 Redis 是主 Redis（说明你的 Redis有从 Redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091244.png\"></p>\n<h3 id=\"4-7-2-maxmemory-policy\"><a href=\"#4-7-2-maxmemory-policy\" class=\"headerlink\" title=\"4.7.2 maxmemory-policy\"></a>4.7.2 maxmemory-policy</h3><ul>\n<li>volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；（最近最少使用）</li>\n<li>allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key</li>\n<li>volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</li>\n<li>allkeys-random：在所有集合 key 中，移除随机的 key</li>\n<li>volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key</li>\n<li>noeviction：不进行移除。针对写操作，只是返回错误信息</li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091256.png\"></p>\n<h3 id=\"4-7-3maxmemory-samples\"><a href=\"#4-7-3maxmemory-samples\" class=\"headerlink\" title=\"4.7.3\tmaxmemory-samples\"></a>4.7.3\tmaxmemory-samples</h3><ul>\n<li>设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，Redis 默认会检查这么多个 key 并选择其中 LRU 的那个。</li>\n<li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091309.png\"></p>\n<h1 id=\"5-Redis的发布和订阅\"><a href=\"#5-Redis的发布和订阅\" class=\"headerlink\" title=\"5. Redis的发布和订阅\"></a>5. Redis的发布和订阅</h1><h2 id=\"5-1-简介\"><a href=\"#5-1-简介\" class=\"headerlink\" title=\"5.1 简介\"></a>5.1 简介</h2><p>Redis 发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道</p>\n<h2 id=\"5-2Redis的发布和订阅\"><a href=\"#5-2Redis的发布和订阅\" class=\"headerlink\" title=\"5.2\tRedis的发布和订阅\"></a>5.2\tRedis的发布和订阅</h2><ol>\n<li><p>客户端订阅频道<br><img src=\"http://img.fan223.cn/2023/04/20230418091329.png\"></p>\n</li>\n<li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091346.png\"></p>\n</li>\n</ol>\n<h2 id=\"5-3-发布订阅命令行实现\"><a href=\"#5-3-发布订阅命令行实现\" class=\"headerlink\" title=\"5.3 发布订阅命令行实现\"></a>5.3 发布订阅命令行实现</h2><p>1、打开一个客户端订阅 channel1</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">subscribe channel1</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091420.png\"></p>\n<p>2、打开另一个客户端，给 channel1 发布消息 hello</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">publish channel1 hello</code></pre>\n\n<p>返回的1是订阅者数量</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091434.png\"></p>\n<p>3、打开第一个客户端可以看到发送的消息</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091447.png\"></p>\n<p>注：发布的消息没有持久化，如果在订阅的客户端收不到 hello，只能收到订阅后发布的消息</p>\n<h1 id=\"6-Redis新数据类型\"><a href=\"#6-Redis新数据类型\" class=\"headerlink\" title=\"6. Redis新数据类型\"></a>6. Redis新数据类型</h1><h2 id=\"6-1-Bitmaps\"><a href=\"#6-1-Bitmaps\" class=\"headerlink\" title=\"6.1 Bitmaps\"></a>6.1 Bitmaps</h2><h3 id=\"6-1-1-简介\"><a href=\"#6-1-1-简介\" class=\"headerlink\" title=\"6.1.1 简介\"></a>6.1.1 简介</h3><p>现代计算机用二进制（位）作为信息的基础单位，1个字节等于8位， 例如“abc”字符串是由3个字节组成，但实际在计算机存储时将其用二进制表示， “abc”分别对应的 ASCII 码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091503.png\"></p>\n<p>合理地使用操作位能够有效地提高内存使用率和开发效率。Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：</p>\n<ol>\n<li><p>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作</p>\n</li>\n<li><p>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在 Bitmaps 中叫做偏移量</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091522.png\"></p>\n</li>\n</ol>\n<h3 id=\"6-1-2-命令\"><a href=\"#6-1-2-命令\" class=\"headerlink\" title=\"6.1.2 命令\"></a>6.1.2 命令</h3><p><strong>1、setbi</strong>t</p>\n<ol>\n<li>格式<br>setbit key offset value ：设置 Bitmaps 中某个偏移量的值（0或1），offset:偏移量从0开始<br><img src=\"http://img.fan223.cn/2023/04/20230418091535.png\"></li>\n<li>示例<br>每个独立用户是否访问过网站存放在 Bitmaps 中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的 id<br>设置键的第 offset 个位的值（从0算起） ， 假设现在有20个用户，userid&#x3D;1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图<br><img src=\"http://img.fan223.cn/2023/04/20230418091546.png\"><br>users:20220224 表示 2022-02-24 这天独立访问用户的 Bitmaps<br><img src=\"http://img.fan223.cn/2023/04/20230418091556.png\"><br><strong>注：</strong><ul>\n<li>很多应用的用户 id 以一个指定数字（例如10000） 开头， 直接将用户 id 和 Bitmaps 的偏移量对应势必会造成一定的浪费， 通常的做法是每次做 setbit 操作时将用户 id 减去这个指定数字</li>\n<li>在第一次初始化 Bitmaps 时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成 Redis 的阻塞</li>\n</ul>\n</li>\n</ol>\n<p><strong>2、getbit</strong></p>\n<ol>\n<li><p>格式<br>getbit key offset ：获取 Bitmaps 中某个偏移量的值，获取键的第 offset 位的值（从0开始算）<br><img src=\"http://img.fan223.cn/2023/04/20230418091612.png\"></p>\n</li>\n<li><p>示例<br>获取 id&#x3D;8 的用户是否在 2022-02-24 这天访问过， 返回0说明没有访问过，因为100根本不存在，所以也是返回0</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091623.png\"></p>\n</li>\n</ol>\n<p><strong>3、bitcount</strong><br>统计字符串被设置为 1 的 bit 数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含</p>\n<ol>\n<li><p>格式<br>bitcount key [start end] ：统计字符串从start字节到end字节比特值为1的数量<br><img src=\"http://img.fan223.cn/2023/04/20230418091634.png\"></p>\n</li>\n<li><p>示例<br>计算 2022-02-24 这天的独立访问用户数量<br><img src=\"http://img.fan223.cn/2023/04/20230418091644.png\"><br>start 和 end 代表起始和结束字节数， 下面操作计算用户 id 在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。<br><img src=\"http://img.fan223.cn/2023/04/20230418091656.png\"><br>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】，四个字节组</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>bitcount K1 1 2  ： 统计下标1、2字节组中 bit&#x3D;1 的个数，即 01000000  00000000<br>–》bitcount K1 1 2 　　–》1<br>bitcount K1 1 3  ： 统计下标1、2字节组中 bit&#x3D;1 的个数，即 01000000  00000000 00100001<br>–》bitcount K1 1 3　　–》3<br>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中 bit&#x3D;1 的个数，即 01000001  01000000  00000000<br>–》bitcount K1 0 -2　　–》3</p></blockquote>\n<p>注意：Redis 的 setbit 设置或清除的是 bit 位置，而 bitcount 计算的是 byte 位置</p>\n</li>\n</ol>\n<p><strong>4、bitop</strong><br>格式：bitop  and(or&#x2F;not&#x2F;xor) destkey [key…]</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091708.png\"></p>\n<p>bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中</p>\n<h3 id=\"6-1-3-Bitmaps-与-Set-对比\"><a href=\"#6-1-3-Bitmaps-与-Set-对比\" class=\"headerlink\" title=\"6.1.3 Bitmaps 与 Set 对比\"></a>6.1.3 Bitmaps 与 Set 对比</h3><p>设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091718.png\"></p>\n<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的!</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091745.png\"></p>\n<p>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万（大量的僵尸用户），那么两者的对比如下表所示， 很显然， 这时候使用 Bitmaps 就不太合适了， 因为基本上大部分位都是 0</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091807.png\"></p>\n<h2 id=\"6-2-HyperLogLog\"><a href=\"#6-2-HyperLogLog\" class=\"headerlink\" title=\"6.2 HyperLogLog\"></a>6.2 HyperLogLog</h2><h3 id=\"6-2-1-简介\"><a href=\"#6-2-1-简介\" class=\"headerlink\" title=\"6.2.1 简介\"></a>6.2.1 简介</h3><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView页面访问量）,可以使用 Redis 的 incr、incrby 轻松实现。但像 UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。解决基数问题有很多种方案：</p>\n<ol>\n<li>数据存储在MySQL表中，使用 distinct count 计算不重复个数</li>\n<li>使用Redis提供的 hash、set、bitmaps 等数据结构来处理</li>\n</ol>\n<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog。Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的</p>\n<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素</p>\n<p><strong>什么是基数?</strong></p>\n<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数</p>\n<h3 id=\"6-2-2-命令\"><a href=\"#6-2-2-命令\" class=\"headerlink\" title=\"6.2.2 命令\"></a>6.2.2 命令</h3><p><strong>1、pfadd</strong></p>\n<ol>\n<li>格式<br>pfadd  key element [element …] ：添加指定元素到 HyperLogLog 中<br><img src=\"http://img.fan223.cn/2023/04/20230418091830.png\"></li>\n<li>示例<br><img src=\"http://img.fan223.cn/2023/04/20230418091841.png\"><br>将所有元素添加到指定 HyperLogLog 数据结构中。如果执行命令后 HLL 估计的近似基数发生变化，则返回1，否则返回0</li>\n</ol>\n<p><strong>2、pfcount</strong></p>\n<ol>\n<li>格式<br>pfcount key [key …] ：计算 HLL 的近似基数，可以计算多个 HLL，比如用HLL 存储每天的 UV，计算一周的 UV 可以使用7天的 UV 合并计算即可<br><img src=\"http://img.fan223.cn/2023/04/20230418091852.png\"></li>\n<li>示例<br><img src=\"http://img.fan223.cn/2023/04/20230418091901.png\"></li>\n</ol>\n<p><strong>3、pfmerge</strong></p>\n<ol>\n<li><p>格式<br>pfmerge destkey sourcekey [sourcekey …] ：将一个或多个 HLL 合并后的结果存储在另一个 HLL 中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得<br><img src=\"http://img.fan223.cn/2023/04/20230418091911.png\"></p>\n</li>\n<li><p>示例</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091922.png\"></p>\n</li>\n</ol>\n<h2 id=\"6-3-Geospatial\"><a href=\"#6-3-Geospatial\" class=\"headerlink\" title=\"6.3 Geospatial\"></a>6.3 Geospatial</h2><h3 id=\"6-3-1-简介\"><a href=\"#6-3-1-简介\" class=\"headerlink\" title=\"6.3.1 简介\"></a>6.3.1 简介</h3><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。Redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作</p>\n<h3 id=\"6-3-2-命令\"><a href=\"#6-3-2-命令\" class=\"headerlink\" title=\"6.3.2 命令\"></a>6.3.2 命令</h3><p><strong>1、geoadd</strong></p>\n<ol>\n<li><p>格式<br>geoadd key longitude latitude member [longitude latitude member…] ：添加地理位置（经度，纬度，名称）<br><img src=\"http://img.fan223.cn/2023/04/20230418091934.png\"></p>\n</li>\n<li><p>示例</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418091946.png\"></p>\n<p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的</p>\n</li>\n</ol>\n<p><strong>2、geopos</strong></p>\n<ol>\n<li>格式<br>geopos  key member [member…] ：获得指定地区的坐标值<br><img src=\"http://img.fan223.cn/2023/04/20230418092117.png\"></li>\n<li>示例<br><img src=\"http://img.fan223.cn/2023/04/20230418092131.png\"></li>\n</ol>\n<p><strong>3、geodist</strong></p>\n<ol>\n<li><p>格式<br>geodist key member1 member2 [m|km|ft|mi ] ：获取两个位置之间的直线距离<br><img src=\"http://img.fan223.cn/2023/04/20230418092149.png\"></p>\n</li>\n<li><p>示例<br>获取两个位置之间的直线距离<br><img src=\"http://img.fan223.cn/2023/04/20230418092201.png\"><br>单位：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>m 表示单位为米[默认值]<br>km 表示单位为千米<br>mi 表示单位为英里<br>ft 表示单位为英尺</p></blockquote>\n<p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p>\n</li>\n</ol>\n<p><strong>4、georadius</strong></p>\n<ol>\n<li><p>格式<br>georadius key longitude latitude radius m|km|ft|mi ：以给定的经纬度为中心，找出某一半径内的元素<br><img src=\"http://img.fan223.cn/2023/04/20230418092212.png\"></p>\n</li>\n<li><p>示例</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230418092222.png\"></p>\n</li>\n</ol>\n","feature":false,"text":"1. NoSQL 数据库简介1.1 技术发展技术的分类： 解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis 解决性能的问题：N...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"Redis","slug":"Redis","count":3,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":5,"path":"api/tags/Redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1. NoSQL 数据库简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95\"><span class=\"toc-text\">1.1 技术发展</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.1.1 问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E8%A7%A3%E5%86%B3CPU%E5%8F%8A%E5%86%85%E5%AD%98%E5%8E%8B%E5%8A%9B\"><span class=\"toc-text\">1.1.2 解决CPU及内存压力</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-3-%E8%A7%A3%E5%86%B3IO%E5%8E%8B%E5%8A%9B\"><span class=\"toc-text\">1.1.3 解决IO压力</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">1.2 NoSQL 数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.2.1 NoSQL 数据库概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-NoSQL-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.2.2 NoSQL 适用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-3-NoSQL%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.2.3 NoSQL不适用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-4-%E5%B8%B8%E7%94%A8%E7%9A%84-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">1.2.4 常用的 NoSQL 数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-4-1-Memcache\"><span class=\"toc-text\">1.2.4.1 Memcache</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-4-2-Redis\"><span class=\"toc-text\">1.2.4.2 Redis</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-4-3-MongoDB\"><span class=\"toc-text\">1.2.4.3 MongoDB</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%89\"><span class=\"toc-text\">1.3 行式存储数据库（大数据时代）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-1-%E8%A1%8C%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">1.3.1 行式数据库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-2-%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">1.3.2 列式数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-1-HBase\"><span class=\"toc-text\">1.3.2.1 HBase</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-2-Cassandra\"><span class=\"toc-text\">1.3.2.2 Cassandra</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E5%9B%BE%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">1.4 图关系型数据库</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Redis-%E6%A6%82%E8%BF%B0%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">2. Redis 概述安装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.1 应用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-1-%E9%85%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%81%9A%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">2.1.1 配合关系型数据库做高速缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-2-%E5%A4%9A%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">2.1.2 多样的数据结构存储持久化数据</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-Redis-%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">2.2 Redis 安装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-Redis-%E4%BB%8B%E7%BB%8D%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">2.3 Redis 介绍相关知识</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3. 常用五大数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Redis%E9%94%AE-key\"><span class=\"toc-text\">3.1.\tRedis键(key)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89\"><span class=\"toc-text\">3.2 Redis字符串（String）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">3.2.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">3.2.2 常用命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.2.3 数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Redis-%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89\"><span class=\"toc-text\">3.3 Redis 列表（List）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">3.3.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">3.3.2 常用命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1\"><span class=\"toc-text\">3.2.3 数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-Redis-%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89\"><span class=\"toc-text\">3.4 Redis 集合（Set）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">3.4.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">3.4.2 常用命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.4.3 数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-Redis%E5%93%88%E5%B8%8C%EF%BC%88Hash%EF%BC%89\"><span class=\"toc-text\">3.5 Redis哈希（Hash）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">3.5.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">3.5.2 常用命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.5.3 数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-Zset%EF%BC%88sorted-set%EF%BC%89\"><span class=\"toc-text\">3.6 Redis 有序集合 Zset（sorted set）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">3.6.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">3.6.2 常用命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.6.3 数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-4-%E8%B7%B3%E8%B7%83%E8%A1%A8\"><span class=\"toc-text\">3.6.4 跳跃表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">4. Redis 配置文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-Units-%E5%8D%95%E4%BD%8D\"><span class=\"toc-text\">4.1 ###Units 单位###</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-INCLUDES-%E5%8C%85%E5%90%AB\"><span class=\"toc-text\">4.2 ###INCLUDES 包含###</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-NETWORK-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">4.3\t###NETWORK 网络相关配置###</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-1-bind\"><span class=\"toc-text\">4.3.1 bind</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-2-protected-mode\"><span class=\"toc-text\">4.3.2 protected-mode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-3-Port\"><span class=\"toc-text\">4.3.3 Port</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-4-tcp-backlog\"><span class=\"toc-text\">4.3.4 tcp-backlog</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-5-timeout\"><span class=\"toc-text\">4.3.5 timeout</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-6-tcp-keepalive\"><span class=\"toc-text\">4.3.6 tcp-keepalive</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-GENERAL-%E9%80%9A%E7%94%A8\"><span class=\"toc-text\">4.4 ###GENERAL 通用###</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-1-daemonize\"><span class=\"toc-text\">4.4.1 daemonize</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-2-pidfile\"><span class=\"toc-text\">4.4.2 pidfile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-3-loglevel\"><span class=\"toc-text\">4.4.3 loglevel</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-4-logfile\"><span class=\"toc-text\">4.4.4 logfile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-5-databases-16\"><span class=\"toc-text\">4.4.5 databases 16</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-SECURITY-%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">4.5 ###SECURITY 安全###</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-1-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81\"><span class=\"toc-text\">4.5.1 设置密码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-CLIENTS-%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">4.6 #### CLIENTS 客户端</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-1-maxclients\"><span class=\"toc-text\">4.6.1 maxclients</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-MEMORY-MANAGEMENT-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.7 ####MEMORY MANAGEMENT 内存管理####</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-1-maxmemory\"><span class=\"toc-text\">4.7.1 maxmemory</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-2-maxmemory-policy\"><span class=\"toc-text\">4.7.2 maxmemory-policy</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-3maxmemory-samples\"><span class=\"toc-text\">4.7.3\tmaxmemory-samples</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85\"><span class=\"toc-text\">5. Redis的发布和订阅</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">5.1 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85\"><span class=\"toc-text\">5.2\tRedis的发布和订阅</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">5.3 发布订阅命令行实现</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-Redis%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">6. Redis新数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-Bitmaps\"><span class=\"toc-text\">6.1 Bitmaps</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">6.1.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-2-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">6.1.2 命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-3-Bitmaps-%E4%B8%8E-Set-%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">6.1.3 Bitmaps 与 Set 对比</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-HyperLogLog\"><span class=\"toc-text\">6.2 HyperLogLog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">6.2.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-2-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">6.2.2 命令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-Geospatial\"><span class=\"toc-text\">6.3 Geospatial</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">6.3.1 简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-2-%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">6.3.2 命令</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"RedisTemplate常用方法总结（参考官方文档2.6.2）","uid":"7478131d527adbde00e55d0f806e6ef1","slug":"BlogRepository/Redis/RedisTemplate常用方法总结（参考官方文档2.6.2）","date":"2022-02-26T19:40:27.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Redis/RedisTemplate常用方法总结（参考官方文档2.6.2）.json","keywords":null,"cover":"https://cover.png","text":"1. 简介RedisTemplate 是 Spring Data Redis 提供给用户的最高级的抽象客户端，用户可直接通过 RedisTemplate进行多种操作 1.1 类继承关系public class RedisTemplate&lt;K, V&gt; extends R...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Redis","slug":"Redis","count":3,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":5,"path":"api/tags/Redis.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"服务器安装Redis和配置后台远程连接","uid":"f5cb41ad6b8fe76e1bcc157a340542d5","slug":"BlogRepository/服务器/服务器安装Redis和配置后台远程连接","date":"2022-02-24T00:48:55.000Z","updated":"2023-04-20T13:57:44.632Z","comments":true,"path":"api/articles/BlogRepository/服务器/服务器安装Redis和配置后台远程连接.json","keywords":null,"cover":"https://cover.png","text":"1. 官网下载 选择对应的版本进行下载 下载完成后上传到服务器上 解压文件，tar -zxvf redis-6.2.7.tar.gz 2. 安装2.1 环境安装 Redis 需要 C 语言的编译环境，先测试 gcc 版本，gcc --version 没有环境的需要进行安装，yum...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"服务器","slug":"服务器","count":4,"path":"api/categories/服务器.json"}],"tags":[{"name":"Redis","slug":"Redis","count":5,"path":"api/tags/Redis.json"},{"name":"服务器","slug":"服务器","count":5,"path":"api/tags/服务器.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}