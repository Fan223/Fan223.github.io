{"title":"RedisTemplate常用方法总结（参考官方文档2.6.2）","uid":"7478131d527adbde00e55d0f806e6ef1","slug":"BlogRepository/Redis/RedisTemplate常用方法总结（参考官方文档2.6.2）","date":"2022-02-26T19:40:27.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Redis/RedisTemplate常用方法总结（参考官方文档2.6.2）.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>RedisTemplate 是 Spring Data Redis 提供给用户的最高级的抽象客户端，用户可直接通过 RedisTemplate进行多种操作</p>\n<h2 id=\"1-1-类继承关系\"><a href=\"#1-1-类继承关系\" class=\"headerlink\" title=\"1.1 类继承关系\"></a>1.1 类继承关系</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RedisTemplate&lt;K, V&gt; extends RedisAccessor implements RedisOperations&lt;K, V&gt;, BeanClassLoaderAware &#123;\n&#125;</code></pre>\n\n<ul>\n<li>RedisAccessor：Base class for RedisTemplate defining common properties. Not intended to be used directly.<br>RedisTemplate 定义通用属性的基类。不打算直接使用</li>\n<li>RedisOperations：Interface that specified a basic set of Redis operations, implemented by RedisTemplate. Not often used but a useful option for extensibility and testability (as it can be easily mocked or stubbed).<br>指定一组基本 Redis 操作的接口，由 RedisTemplate 实现。不经常使用，但对于可扩展性和可测试性来说是一个有用的选项（因为它可以很容易地被模拟或存根）</li>\n<li>BeanClassLoaderAware：Callback that allows a bean to be aware of the bean class loader; that is, the class loader used by the present bean factory to load bean classes. This is mainly intended to be implemented by framework classes which have to pick up application classes by name despite themselves potentially being loaded from a shared class loader.<br>允许 bean 知道 bean 类加载器的回调；也就是当前bean工厂用来加载bean类的类加载器。这主要是由框架类实现的，这些框架类必须按名称选择应用程序类，尽管它们可能是从共享类加载器加载的</li>\n</ul>\n<h2 id=\"1-2-方法\"><a href=\"#1-2-方法\" class=\"headerlink\" title=\"1.2 方法\"></a>1.2 方法</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 配置默认序列化与反序列化工具类\n1.afterPropertiesSet\n&#x2F;&#x2F; 根据参数执行相关operation操作，例如，事务\n2.execute\n&#x2F;&#x2F; 执行pipelining流水线相关操作\n3.executePipelined\n&#x2F;&#x2F; 执行指定connection连接的相关操作\n4.executeWithStickyConnection\n&#x2F;&#x2F; 执行session内的execute方法\n5.executeSession\n&#x2F;&#x2F; 创建RedisConnection代理类\n6.createRedisConnectionProxy\n&#x2F;&#x2F; connection连接的预处理\n7.preProcessConnection\n&#x2F;&#x2F; 结果的后处理，默认什么都不做\n8.postProcessResult\n&#x2F;&#x2F; 是否向RedisCallback暴露本地连接\n9.isExposeConnection\n&#x2F;&#x2F; 设置是否向RedisCallback暴露本地连接\n10.setExposeConnection\n&#x2F;&#x2F; 12到26都是设置和获取相关序列化工具类\n11.isEnableDefaultSerializer\n12.setEnableDefaultSerializer\n13.getDefaultSerializer\n14.setDefaultSerializer\n15.setKeySerializer\n16.getKeySerializer\n17.setValueSerializer\n18.getValueSerializer\n19.getHashKeySerializer\n20.setHashKeySerializer\n21.getHashValueSerializer\n22.setHashValueSerializer\n23.getStringSerializer\n24.setStringSerializer\n25.setScriptExecutor\n&#x2F;&#x2F; 27到34为私有方法，不对外提供使用\n26.rawKey\n27.rawString\n28.rawValue\n29.rawKeys\n30.deserializeKey\n31.deserializeMixedResults\n32.deserializeSet\n33.convertTupleValues\n&#x2F;&#x2F; 执行事务\n34.exec\n35.execRaw\n&#x2F;&#x2F; 删除操作\n36.delete\n&#x2F;&#x2F; 接触链接\n37.unlink\n&#x2F;&#x2F; 查看是否含有指定key\n38.hasKey\n39.countExistingKeys\n&#x2F;&#x2F; 设置过期时间\n40.expire\n41.expireAt\n&#x2F;&#x2F; 转换成字节流并向channel发送message\n42.convertAndSend\n&#x2F;&#x2F; 获取过期时间\n43.getExpire\n&#x2F;&#x2F; 根据传入的正则表达式返回所有的key\n44.keys\n&#x2F;&#x2F; 取消指定key的过期时间\n45.persist\n&#x2F;&#x2F; 移动指定的key和index到数据库中\n46.move\n&#x2F;&#x2F; 从键空间随机获取一个key\n47.randomKey\n&#x2F;&#x2F; 将指定key改成目标key\n48.rename\n&#x2F;&#x2F; key不存在时，将指定key改成目标key\n49.renameIfAbsent\n&#x2F;&#x2F; 设置存储在指定key的类型\n50.type\n&#x2F;&#x2F; 检索存储在key的值的序列化版本\n51.dump\n&#x2F;&#x2F; 执行Redis的restore的命令\n52.restore\n&#x2F;&#x2F; 标记事务阻塞的开始\n53.multi\n&#x2F;&#x2F; 丢弃所有在multi之后发出的命令\n54.discard\n&#x2F;&#x2F; 观察指定key在事务处理开始即multi之后的修改情况\n55.watch\n&#x2F;&#x2F; 刷新先前观察的所有key\n56.unwatch\n&#x2F;&#x2F; 为key元素排序\n57.sort\n&#x2F;&#x2F; 关闭客户端连接\n58.killClient\n&#x2F;&#x2F; 请求连接客户端的相关信息和统计数据\n59.getClientList\n&#x2F;&#x2F; 更改复制配置到新的master\n60.slaveOf\n&#x2F;&#x2F; 将本机更改为master\n61.slaveOfNoOne\n&#x2F;&#x2F; 64到79都是获取相对应的操作\n62.opsForCluster\n63.opsForGeo\n64.boundGeoOps\n65.boundHashOps\n66.opsForHash\n67.opsForHyperLogLog\n68.opsForList\n69.boundListOps\n70.boundSetOps\n71.opsForSet\n72.opsForStream\n73.boundStreamOps\n74.boundValueOps\n75.opsForValue\n76.boundZSetOps\n77.opsForZSet\n&#x2F;&#x2F; 设置是否支持事务\n78.setEnableTransactionSupport\n&#x2F;&#x2F; 设置bean的类加载器\n79.setBeanClassLoader</code></pre>\n\n<h2 id=\"1-3-功能介绍\"><a href=\"#1-3-功能介绍\" class=\"headerlink\" title=\"1.3 功能介绍\"></a>1.3 功能介绍</h2><p>spring-data-redis 提供了如下功能：</p>\n<ol>\n<li><p>连接池自动管理，提供了一个高度封装的“RedisTemplate”类</p>\n</li>\n<li><p>进行了归类封装,将同一类型操作封装为operation接口</p>\n<ul>\n<li>ValueOperations：简单K-V操作</li>\n<li>SetOperations：set类型数据操作</li>\n<li>ZSetOperations：zset类型数据操作</li>\n<li>HashOperations：针对map类型的数据操作</li>\n<li>ListOperations：针对list类型的数据操作</li>\n</ul>\n</li>\n<li><p>提供了对 key 的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即 BoundKeyOperations</p>\n<ul>\n<li>BoundValueOperations</li>\n<li>BoundSetOperations</li>\n<li>BoundListOperations</li>\n<li>BoundSetOperations</li>\n<li>BoundHashOperations</li>\n</ul>\n</li>\n<li><p>将事务操作封装，有容器控制</p>\n</li>\n<li><p>针对数据的“序列化&#x2F;反序列化”，提供了多种可选择策略(RedisSerializer)</p>\n<ul>\n<li>JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream&#x2F;ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略</li>\n<li>StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“newString(bytes,charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略</li>\n<li>JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂</li>\n<li>OxmSerializer：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。【需要spring-oxm模块的支持】</li>\n</ul>\n<p>如果你的数据需要被第三方工具解析，那么数据应该使用 StringRedisSerializer 而不是 JdkSerializationRedisSerializer</p>\n</li>\n</ol>\n<h1 id=\"2-RedisTemplate-顶层方法\"><a href=\"#2-RedisTemplate-顶层方法\" class=\"headerlink\" title=\"2. RedisTemplate 顶层方法\"></a>2. RedisTemplate 顶层方法</h1><ol>\n<li>确定给定 key 是否存在，有的话就返回 true，没有就返回 false<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.hasKey(K key)</code></pre></li>\n<li>删除给定的 key<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.delete(K key)</code></pre></li>\n<li>删除给定 key 的集合<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.delete(Collection&lt;K&gt; keys)</code></pre></li>\n<li>执行 Redis 转储命令并返回结果，把key值序列化成byte[]类型<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.dump(K key)</code></pre></li>\n<li>对传入的key值设置过期时间、将给定 key 的过期时间设置为日期时间戳<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.expire(K key, long timeout, TimeUnit unit)\nredisTemplate.expireAt(K key, Date date)</code></pre></li>\n<li>查找与给定模式匹配的所有 key ，返回的是一个没有重复的Set类型<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.keys(K pattern)</code></pre></li>\n<li>将 oldKey 重命名为 newKey。<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.rename(K oldKey, K newKey)</code></pre></li>\n<li>获取key值的类型<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.\ttype(K key)</code></pre></li>\n<li>仅当 newKey 不存在时，才将密钥 oldKey 重命名为 newKey。<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.renameIfAbsent(K oldKey, K newKey)</code></pre></li>\n<li>随机从redis中获取一个key<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.randomKey()</code></pre></li>\n<li>获取当前key的剩下的过期时间<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.getExpire(K key)</code></pre></li>\n<li>获取剩余的过期时间，同时设置时间单位<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.\tgetExpire(K key, TimeUnit timeUnit)</code></pre></li>\n<li>删除 key 的过期时间<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.\tpersist(K key)</code></pre></li>\n<li>将给定的 key 移动到带有索引的数据库<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.\tmove(K key, int dbIndex)</code></pre></li>\n</ol>\n<h1 id=\"3-RedisTemplate-opsForValue-方法\"><a href=\"#3-RedisTemplate-opsForValue-方法\" class=\"headerlink\" title=\"3. RedisTemplate.opsForValue() 方法\"></a>3. RedisTemplate.opsForValue() 方法</h1><ol>\n<li>设置 key 跟 value 的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().set(K key, V value)</code></pre></li>\n<li>获取 key 的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().get(Object key)</code></pre></li>\n<li>设置key跟value的值，同时设置过期时间<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().set(K key, V value, Duration timeout)</code></pre></li>\n<li>在 start 和 end 之间获取键值的子字符串<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().get(K key, long start, long end)</code></pre></li>\n<li>设置 key 的值并返回其旧值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().getAndSet(K key, V value)</code></pre></li>\n<li>获取多个 key<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().multiGet(Collection&lt;K&gt; keys)</code></pre></li>\n<li>获取原来的key的值后在后面新增上新的字符串<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().append(K key, String value)</code></pre></li>\n<li>增量方式增加double值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().increment(K key, double increment)</code></pre></li>\n<li>通过increment(K key, long delta)方法以增量方式存储long值（正值则自增，负值则自减）<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().increment(K key, long increment)</code></pre></li>\n<li>仅当提供的 key 不存在时，才使用集合中提供的键值对将多个 key 设置为多个值。<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map)</code></pre></li>\n<li>使用集合中提供的键值对将多个 key 设置为多个值。<pre class=\"line-numbers language-none\"><code class=\"language-none\">Map map &#x3D; new HashMap(); map.put(&quot;1&quot;,&quot;1&quot;); map.put(&quot;2&quot;,&quot;2&quot;); \nmap.put(&quot;3&quot;,&quot;3&quot;); \nredisTemplate.opsForValue().multiSet(Map&lt;? extends K,? extends V&gt; map)</code></pre></li>\n<li>获取指定key的字符串的长度<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().size(K key)</code></pre></li>\n<li>用给定值覆盖从指定偏移量开始的 key 的部分。<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().set(K key, V value, long offset)</code></pre></li>\n<li>如果 key 不存在，则设置 key 以保存字符串值，存在返回false，否则返回true<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().setIfAbsent(key, value)</code></pre></li>\n<li>重新设置key的值并加入过期时间<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().set(key, value, timeout, unit)</code></pre></li>\n<li>将二进制第offset位值变为value<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().setBit(K key, long offset, boolean value)</code></pre></li>\n<li>对key所储存的字符串值，获取指定偏移量上的位(bit)<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForValue().getBit(K key, long offset)</code></pre></li>\n</ol>\n<h1 id=\"4-RedisTemplate-opsForHash-方法\"><a href=\"#4-RedisTemplate-opsForHash-方法\" class=\"headerlink\" title=\"4. RedisTemplate.opsForHash() 方法\"></a>4. RedisTemplate.opsForHash() 方法</h1><ol>\n<li>从 key 处的 hash 中获取给定 hashKey 的值，即 key field（hashKey） value<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().get(H key, Object hashKey)</code></pre></li>\n<li>获取存储在 key 的整个 hash，即获取所有值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().entries(H key)</code></pre></li>\n<li>设置hash hashKey 的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().put(H key, HK hashKey, HV value)</code></pre></li>\n<li>使用 m 中提供的数据将多个 hash 字段设置为多个值，即使用 map 进行赋值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().putAll(H key, Map&lt;? extends HK,? extends HV&gt; m)</code></pre></li>\n<li>仅当 hashKey 不存在时才设置 hash hashKey 的值。<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().putIfAbsent(H key, HK hashKey, HV value)</code></pre></li>\n<li>删除给定的hash hashKeys<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().delete(H key, Object... hashKeys)</code></pre></li>\n<li>确定给定的hash hashKey 是否存在<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().hasKey(H key, Object hashKey)</code></pre></li>\n<li>通过给定的增量增加hash hashKey 的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().increment(H key, HK hashKey, double increment)\nredisTemplate.opsForHash().increment(H key, HK hashKey, long increment)</code></pre></li>\n<li>在 key 处获取 hash 的 hashKey 集（字段）<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().keys(H key)</code></pre></li>\n<li>获取 key 的 hash 大小。<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().size(H key)</code></pre></li>\n<li>在 key 处获取 hash 的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().values(H key)</code></pre></li>\n<li>查看匹配的键值对<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForHash().scan(H key, ScanOptions options)</code></pre></li>\n</ol>\n<h1 id=\"5-RedisTemplate-opsForList-方法\"><a href=\"#5-RedisTemplate-opsForList-方法\" class=\"headerlink\" title=\"5. RedisTemplate.opsForList() 方法\"></a>5. RedisTemplate.opsForList() 方法</h1><ol>\n<li>从 key 的 list 中获取索引处的元素<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().index(K key, long index)</code></pre></li>\n<li>从 key 的 list 中获取 start 和 end 之间的元素<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().range(K key, long start, long end)</code></pre></li>\n<li>为 key 添加值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().leftPush(K key, V value)</code></pre></li>\n<li>将值添加到 key 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().leftPushAll(K key, Collection&lt;V&gt; values)</code></pre></li>\n<li>仅当 list 存在时，才将值添加到 key 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().leftPushIfPresent(K key, V value)</code></pre></li>\n<li>在 pivot 之前将值添加到 key 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().leftPush(K key, V pivot, V value)</code></pre></li>\n<li>将值附加到 key<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().rightPush(K key, V value)\nredisTemplate.opsForList().rightPushAll(K key, Collection&lt;V&gt; values)</code></pre></li>\n<li>在 pivot 之后将值添加到 key 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().rightPush(K key, V pivot, V value)</code></pre></li>\n<li>在列表元素的索引处设置值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().set(K key, long index, V value)</code></pre></li>\n<li>删除并返回存储在 key 的列表中的第一个元素、<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().leftPop(K key)\nredisTemplate.opsForList().leftPop(K key, Duration timeout)\nredisTemplate.opsForList().leftPop(K key, long count)\nredisTemplate.opsForList().leftPop(K key, long timeout, TimeUnit unit)</code></pre></li>\n<li>删除并返回存储在 key 的列表中的最后一个元素<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().rightPop(K key)\nredisTemplate.opsForList().rightPop(K key, Duration timeout)\nredisTemplate.opsForList().rightPop(K key, long count)\nredisTemplate.opsForList().rightPop(K key, long timeout, TimeUnit unit)</code></pre></li>\n<li>从 sourceKey 的列表中删除最后一个元素，将其附加到 destinationKey 并返回其值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().rightPopAndLeftPush(K sourceKey, K destinationKey)\nredisTemplate.opsForList().rightPopAndLeftPush(K sourceKey, K destinationKey, Duration timeout)</code></pre></li>\n<li>从存储在 key 的列表中删除第一个 count 出现的 value<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().remove(K key, long count, Object value)</code></pre></li>\n<li>在 start 和 end 之间的元素的 key 处修剪列表<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().trim(K key, long start, long end)</code></pre></li>\n<li>获取存储在 key 的列表的大小<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForList().size(K key)</code></pre></li>\n</ol>\n<h1 id=\"6-RedisTemplate-opsForSet-方法\"><a href=\"#6-RedisTemplate-opsForSet-方法\" class=\"headerlink\" title=\"6. RedisTemplate.opsForSet() 方法\"></a>6. RedisTemplate.opsForSet() 方法</h1><ol>\n<li>在 key 的 set 中添加给定值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().add(K key, V... values)</code></pre></li>\n<li>在 key 的 set 中删除给定值并返回已删除元素的数量<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().remove(K key, Object... values)</code></pre></li>\n<li>从 key 的 set 中移除并返回一个随机成员<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().\tpop(K key)</code></pre></li>\n<li>在 key 处获取集合的大小<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().size(K key)</code></pre></li>\n<li>检查在 key 的 set 中是否包含值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().isMember(K key, Object o)</code></pre></li>\n<li>返回在 key 和 otherKeys 处与所有给定 sets 相交的成员<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().intersect(K key, Collection&lt;K&gt; otherKeys)</code></pre></li>\n<li>在 key 和 otherKeys 处与所有给定 sets 相交，并将结果存储在 destKey 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)</code></pre></li>\n<li>在 key 和 otherKey 处相交所有给定的 sets，并将结果存储在 destKey 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().intersectAndStore(K key, K otherKey, K destKey)</code></pre></li>\n<li>合并给定 key 和 otherKey 的所有 sets<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().union(K key, K otherKey)</code></pre></li>\n<li>将给定 key 和 otherKey 处的所有 set 合并，并将结果存储在 destKey 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().unionAndStore(K key, K otherKey, K destKey)</code></pre></li>\n<li>获取差集<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().difference(key, otherKeys)</code></pre></li>\n<li>获取差集并存储到destKey<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().differenceAndStore(key, otherKey, destKey)</code></pre></li>\n<li>随机获取集合中的一个元素<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().randomMember(key)</code></pre></li>\n<li>获取集合中的所有元素<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().members(key)</code></pre></li>\n<li>随机获取集合中count个值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().randomMembers(key, count)</code></pre></li>\n<li>随机获取集合中count个值，但是去重<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().distinctRandomMembers(key, count)</code></pre></li>\n<li>遍历set<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForSet().scan(key, options)</code></pre></li>\n</ol>\n<h1 id=\"7-RedisTemplate-opsForZSet-方法\"><a href=\"#7-RedisTemplate-opsForZSet-方法\" class=\"headerlink\" title=\"7. RedisTemplate.opsForZSet() 方法\"></a>7. RedisTemplate.opsForZSet() 方法</h1><ol>\n<li>添加元素，从小到大排序<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().add(key, value, score)</code></pre></li>\n<li>删除多个values的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().remove(key, values)</code></pre></li>\n<li>增加元素的score值同时返回增加后的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().incrementScore(key, value, delta)</code></pre></li>\n<li>返回元素在集合的从小到大排名<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().rank(key, value)</code></pre></li>\n<li>返回元素在集合的由大到小排名<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().reverseRank(key, value)</code></pre></li>\n<li>获取集合中指定区间的元素<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().reverseRangeWithScores(key, start,end)</code></pre></li>\n<li>查询集合中的元素并从小到大排序<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().reverseRangeByScore(key, min, max)\nredisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, min, max)</code></pre></li>\n<li>从高到低的排序，然后获取最小与最大值之间的值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().reverseRangeByScore(key, min, max, start, end)</code></pre></li>\n<li>根据score值获取元素数量<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().incrementScore(key, value, delta)</code></pre></li>\n<li>获取集合的大小<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().size(key)redisTemplate.opsForZSet().zCard(key)</code></pre></li>\n<li>获取集合中key、value元素的score值<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().score(key, value)</code></pre></li>\n<li>移除指定索引元素<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().removeRange(key, start, end)</code></pre></li>\n<li>移除指定score范围的集合成员<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().removeRangeByScore(key, min, max)</code></pre></li>\n<li>获取key和otherKey的并集并存储在 destKey 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey)</code></pre></li>\n<li>获取key和otherKey的交集并存储在 destKey 中<pre class=\"line-numbers language-none\"><code class=\"language-none\">redisTemplate.opsForZSet().intersectAndStore(key, otherKey, destKey)</code></pre></li>\n</ol>\n","feature":false,"text":"1. 简介RedisTemplate 是 Spring Data Redis 提供给用户的最高级的抽象客户端，用户可直接通过 RedisTemplate进行多种操作 1.1 类继承关系public class RedisTemplate&lt;K, V&gt; extends R...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Redis","slug":"Redis","count":3,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":5,"path":"api/tags/Redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1. 简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">1.1 类继承关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.2 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1.3 功能介绍</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-RedisTemplate-%E9%A1%B6%E5%B1%82%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2. RedisTemplate 顶层方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-RedisTemplate-opsForValue-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3. RedisTemplate.opsForValue() 方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-RedisTemplate-opsForHash-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4. RedisTemplate.opsForHash() 方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-RedisTemplate-opsForList-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">5. RedisTemplate.opsForList() 方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-RedisTemplate-opsForSet-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">6. RedisTemplate.opsForSet() 方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-RedisTemplate-opsForZSet-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">7. RedisTemplate.opsForZSet() 方法</span></a></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Dubbo总结（分布式理论 + 使用）","uid":"4e9d049749f532005151e72d3b86b285","slug":"BlogRepository/开发技术及框架/Dubbo总结（分布式理论 + 使用）","date":"2022-03-08T16:24:40.000Z","updated":"2023-04-20T13:57:44.632Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/Dubbo总结（分布式理论 + 使用）.json","keywords":null,"cover":"https://cover.png","text":"1. 分布式基础理论1.1 什么是分布式系统？分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。分布式系统（distributed system）是建立在网络之上的软件系统 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":9,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"Dubbo","slug":"Dubbo","count":1,"path":"api/tags/Dubbo.json"},{"name":"架构","slug":"架构","count":1,"path":"api/tags/架构.json"},{"name":"分布式","slug":"分布式","count":1,"path":"api/tags/分布式.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"Redis 6总结（1）","uid":"56daa6f6e65f7cd942daf401bb41ead5","slug":"BlogRepository/Redis/Redis 6总结（1）","date":"2022-02-24T01:12:39.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Redis/Redis 6总结（1）.json","keywords":null,"cover":"https://cover.png","text":"1. NoSQL 数据库简介1.1 技术发展技术的分类： 解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis 解决性能的问题：N...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"Redis","slug":"Redis","count":3,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":5,"path":"api/tags/Redis.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}