{"title":"面试知识总结","uid":"1ac50bd4544cf8d138999af1e7bc1cf4","slug":"BlogRepository/面试/面试知识总结","date":"2022-07-10T08:09:06.000Z","updated":"2023-04-20T13:57:44.648Z","comments":true,"path":"api/articles/BlogRepository/面试/面试知识总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-Object\"><a href=\"#1-Object\" class=\"headerlink\" title=\"1. Object\"></a>1. Object</h1><p><strong>Object 类是一个特殊的类，是所有类的父类</strong></p>\n<h2 id=\"1-1-常见方法（11个）\"><a href=\"#1-1-常见方法（11个）\" class=\"headerlink\" title=\"1.1 常见方法（11个）\"></a>1.1 常见方法（11个）</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n *&#x2F;\npublic final native Class&lt;?&gt; getClass()\n&#x2F;**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n *&#x2F;\npublic native int hashCode()\n&#x2F;**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n *&#x2F;\npublic boolean equals(Object obj)\n&#x2F;**\n * naitive 方法，用于创建并返回当前对象的一份拷贝。\n *&#x2F;\nprotected native Object clone() throws CloneNotSupportedException\n&#x2F;**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n *&#x2F;\npublic String toString()\n&#x2F;**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n *&#x2F;\npublic final native void notify()\n&#x2F;**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n *&#x2F;\npublic final native void notifyAll()\n&#x2F;**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n *&#x2F;\npublic final native void wait(long timeout) throws InterruptedException\n&#x2F;**\n * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。\n *&#x2F;\npublic final void wait(long timeout, int nanos) throws InterruptedException\n&#x2F;**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n *&#x2F;\npublic final void wait() throws InterruptedException\n&#x2F;**\n * 实例被垃圾回收器回收的时候触发的操作\n *&#x2F;\nprotected void finalize() throws Throwable &#123; &#125;</code></pre>\n\n<h2 id=\"1-2-x3D-x3D-和-equals-的区别\"><a href=\"#1-2-x3D-x3D-和-equals-的区别\" class=\"headerlink\" title=\"1.2 &#x3D;&#x3D; 和 equals() 的区别\"></a>1.2 &#x3D;&#x3D; 和 equals() 的区别</h2><p><strong><code>==</code> 对于基本类型和引用类型的作用效果是不同的：</strong></p>\n<ul>\n<li>对于基本数据类型来说，<code>==</code> 比较的是值</li>\n<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址</p></blockquote>\n<p><strong><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code> 方法存在于 Object 类中，而 Object 类是所有类的直接或间接父类，因此所有的类都有 <code>equals()</code> 方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean equals(Object obj) &#123;\n     return (this &#x3D;&#x3D; obj);\n&#125;</code></pre>\n\n<p><strong><code>equals()</code> 方法存在两种使用情况：</strong></p>\n<ul>\n<li><strong>类没有重写 <code>equals()</code> 方法 ：</strong> 通过 <code>equals()</code> 比较该类的两个对象时，等价于通过 “&#x3D;&#x3D;” 比较这两个对象，对比它们的地址是否相等。使用的默认是 Object 类 equals() 方法</li>\n<li><strong>类重写了 <code>equals()</code> 方法 ：</strong> 一般我们都重写 equals() 方法来<strong>比较两个对象中的属性（地址里的内容）是否相等</strong>；若它们的属性相等，则返回 true(即认为这两个对象相等)</li>\n</ul>\n<p><strong>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean equals(Object anObject) &#123;\n    if (this &#x3D;&#x3D; anObject) &#123;\n        return true;\n    &#125;\n    if (anObject instanceof String) &#123;\n        String anotherString &#x3D; (String)anObject;\n        int n &#x3D; value.length;\n        if (n &#x3D;&#x3D; anotherString.value.length) &#123;\n            char v1[] &#x3D; value;\n            char v2[] &#x3D; anotherString.value;\n            int i &#x3D; 0;\n            while (n-- !&#x3D; 0) &#123;\n                if (v1[i] !&#x3D; v2[i])\n                    return false;\n                i++;\n            &#125;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<h2 id=\"1-3-hashCode-作用\"><a href=\"#1-3-hashCode-作用\" class=\"headerlink\" title=\"1.3 hashCode() 作用\"></a>1.3 hashCode() 作用</h2><p><strong><code>hashCode()</code> 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置</strong></p>\n<p><code>hashCode()</code> 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public native int hashCode();</code></pre>\n\n<p><strong>散列表存储的是键值对(key-value)，它的特点是：能根据 “键” 快速的检索出对应的 “值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>\n<p><strong>其实， <code>hashCode()</code> 和 <code>equals()</code> 都是用于比较两个对象是否相等</strong><br><strong>在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高！</strong></p>\n<p><strong>两个对象的 <code>hashCode</code> 值相等并不代表两个对象就相等</strong>，因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（<strong>所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code></strong>)</p>\n<ul>\n<li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）</li>\n<li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等</li>\n<li>如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等</li>\n</ul>\n<h2 id=\"1-4-重写-equals-时必须重写-hashCode-方法\"><a href=\"#1-4-重写-equals-时必须重写-hashCode-方法\" class=\"headerlink\" title=\"1.4 重写 equals() 时必须重写 hashCode() 方法\"></a>1.4 重写 equals() 时必须重写 hashCode() 方法</h2><p><strong>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等</strong></p>\n<p><strong>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等</strong></p>\n<ul>\n<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>\n<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）</li>\n</ul>\n<h1 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2. String\"></a>2. String</h1><h2 id=\"2-1-String、StringBuffer、StringBuilder-的区别\"><a href=\"#2-1-String、StringBuffer、StringBuilder-的区别\" class=\"headerlink\" title=\"2.1 String、StringBuffer、StringBuilder 的区别\"></a>2.1 String、StringBuffer、StringBuilder 的区别</h2><h3 id=\"2-1-1-可变性\"><a href=\"#2-1-1-可变性\" class=\"headerlink\" title=\"2.1.1 可变性\"></a>2.1.1 可变性</h3><p><strong><code>String</code> 是不可变的，改变值会重新创建一个对象</strong></p>\n<p><strong><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串</strong>，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;\n    char[] value;\n    public AbstractStringBuilder append(String str) &#123;\n        if (str &#x3D;&#x3D; null)\n            return appendNull();\n        int len &#x3D; str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count +&#x3D; len;\n        return this;\n    &#125;\n  \t&#x2F;&#x2F;...\n&#125;</code></pre>\n\n<h3 id=\"2-1-2-线程安全性\"><a href=\"#2-1-2-线程安全性\" class=\"headerlink\" title=\"2.1.2 线程安全性\"></a>2.1.2 线程安全性</h3><p><strong><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</strong></p>\n<p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法</p>\n<p><strong><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的</strong></p>\n<h3 id=\"2-1-3-性能\"><a href=\"#2-1-3-性能\" class=\"headerlink\" title=\"2.1.3 性能\"></a>2.1.3 性能</h3><p><strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象</strong></p>\n<p><code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。<strong>相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险</strong></p>\n<h3 id=\"2-1-4-使用场景\"><a href=\"#2-1-4-使用场景\" class=\"headerlink\" title=\"2.1.4 使用场景\"></a>2.1.4 使用场景</h3><ol>\n<li>操作少量的数据: 适用 <code>String</code></li>\n<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>\n<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>\n</ol>\n<h2 id=\"2-2-String-为什么是不可变的\"><a href=\"#2-2-String-为什么是不可变的\" class=\"headerlink\" title=\"2.2 String 为什么是不可变的?\"></a>2.2 String 为什么是不可变的?</h2><p><strong><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;\n    private final char value[];\n\t&#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p><strong>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。</strong> 因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）</p>\n<p><strong>String 真正不可变有下面几点原因：</strong></p>\n<ul>\n<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法</li>\n<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变</li>\n</ul>\n<h2 id=\"2-3-Java-9-对-String-的改变\"><a href=\"#2-3-Java-9-对-String-的改变\" class=\"headerlink\" title=\"2.3 Java 9 对 String 的改变\"></a>2.3 Java 9 对 String 的改变</h2><p><strong>在 Java 9 之后，<code>String</code> 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class String implements java.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;\n    &#x2F;&#x2F; @Stable 注解表示变量最多被修改一次，称为“稳定的”。\n    @Stable\n    private final byte[] value;\n&#125;\n\nabstract class AbstractStringBuilder implements Appendable, CharSequence &#123;\n    byte[] value;\n\n&#125;</code></pre>\n\n<p><strong><code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code></strong><br>新版的 <code>String</code> 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。<br>Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>\n<p>JDK 官方表示绝大部分字符串对象只包含 Latin-1 可表示的字符</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151014.png\"></p>\n<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。<br><strong><a href=\"https://openjdk.java.net/jeps/254\">https://openjdk.java.net/jeps/254</a></strong></p>\n<h2 id=\"2-4-字符串拼接用-“-”-还是-StringBuilder\"><a href=\"#2-4-字符串拼接用-“-”-还是-StringBuilder\" class=\"headerlink\" title=\"2.4 字符串拼接用 “+” 还是 StringBuilder\"></a>2.4 字符串拼接用 “+” 还是 StringBuilder</h2><p><strong>Java 语言本身并不支持运算符重载，“+” 和 “+&#x3D;” 是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str1 &#x3D; &quot;he&quot;;\nString str2 &#x3D; &quot;llo&quot;;\nString str3 &#x3D; &quot;world&quot;;\nString str4 &#x3D; str1 + str2 + str3;</code></pre>\n\n<p><strong>上面的代码对应的字节码如下：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static main([Ljava&#x2F;lang&#x2F;String;)V\n   L0\n    LINENUMBER 12 L0\n    LDC &quot;he&quot;\n    ASTORE 1\n   L1\n    LINENUMBER 13 L1\n    LDC &quot;llo&quot;\n    ASTORE 2\n   L2\n    LINENUMBER 14 L2\n    LDC &quot;world&quot;\n    ASTORE 3\n   L3\n    LINENUMBER 15 L3\n    NEW java&#x2F;lang&#x2F;StringBuilder &#x2F;&#x2F; 创建 StringBuilder\n    DUP\n    INVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()V\n    ALOAD 1\n    &#x2F;&#x2F; 调用 StringBuilder 的 append 方法\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\n    ALOAD 2\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\n    ALOAD 3\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\n    &#x2F;&#x2F; 调用 StringBuilder 的 toString 方法\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;\n    ASTORE 4\n   L4\n    LINENUMBER 16 L4\n    RETURN\n   L5\n    LOCALVARIABLE args [Ljava&#x2F;lang&#x2F;String; L0 L5 0\n    LOCALVARIABLE str1 Ljava&#x2F;lang&#x2F;String; L1 L5 1\n    LOCALVARIABLE str2 Ljava&#x2F;lang&#x2F;String; L2 L5 2\n    LOCALVARIABLE str3 Ljava&#x2F;lang&#x2F;String; L3 L5 3\n    LOCALVARIABLE str4 Ljava&#x2F;lang&#x2F;String; L4 L5 4\n    MAXSTACK &#x3D; 2\n    MAXLOCALS &#x3D; 5\n&#125;</code></pre>\n\n<p><strong>可以看出，字符串对象通过 “+” 的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象</strong></p>\n<p>不过，在循环内使用 “+” 进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String[] arr &#x3D; &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;\nString s &#x3D; &quot;&quot;;\nfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    s +&#x3D; arr[i];\n&#125;\nSystem.out.println(s);</code></pre>\n\n<p><strong><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static main([Ljava&#x2F;lang&#x2F;String;)V\n   L0\n    LINENUMBER 12 L0\n    ICONST_3\n    ANEWARRAY java&#x2F;lang&#x2F;String\n    DUP\n    ICONST_0\n    LDC &quot;he&quot;\n    AASTORE\n    DUP\n    ICONST_1\n    LDC &quot;llo&quot;\n    AASTORE\n    DUP\n    ICONST_2\n    LDC &quot;world&quot;\n    AASTORE\n    ASTORE 1\n   L1\n    LINENUMBER 13 L1\n    LDC &quot;&quot;\n    ASTORE 2\n   L2\n    LINENUMBER 14 L2\n    ICONST_0 &#x2F;&#x2F; \n    ISTORE 3\n   L3\n   FRAME APPEND [[Ljava&#x2F;lang&#x2F;String; java&#x2F;lang&#x2F;String I]\n    ILOAD 3\n    ALOAD 1\n    ARRAYLENGTH\n    IF_ICMPGE L4\n   L5\n    LINENUMBER 15 L5\n    NEW java&#x2F;lang&#x2F;StringBuilder &#x2F;&#x2F; 循环内部创建 StringBuilder 对象\n    DUP\n    INVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()V\n    ALOAD 2\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\n    ALOAD 1\n    ILOAD 3\n    AALOAD\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;\n    ASTORE 2\n   L6\n    LINENUMBER 14 L6\n    IINC 3 1\n    GOTO L3 &#x2F;&#x2F; \n   L4\n    LINENUMBER 17 L4\n   FRAME CHOP 1\n    GETSTATIC java&#x2F;lang&#x2F;System.out : Ljava&#x2F;io&#x2F;PrintStream;\n    ALOAD 2\n    INVOKEVIRTUAL java&#x2F;io&#x2F;PrintStream.println (Ljava&#x2F;lang&#x2F;String;)V\n   L7\n    LINENUMBER 18 L7\n    RETURN\n   L8\n    LOCALVARIABLE i I L3 L4 3\n    LOCALVARIABLE args [Ljava&#x2F;lang&#x2F;String; L0 L8 0\n    LOCALVARIABLE arr [Ljava&#x2F;lang&#x2F;String; L1 L8 1\n    LOCALVARIABLE s Ljava&#x2F;lang&#x2F;String; L2 L8 2\n    MAXSTACK &#x3D; 4\n    MAXLOCALS &#x3D; 4\n&#125;</code></pre>\n\n<p><strong>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String[] arr &#x3D; &#123;&quot;he&quot;, &quot;llo&quot;, &quot;world&quot;&#125;;\nStringBuilder s &#x3D; new StringBuilder();\nfor (String value : arr) &#123;\n    s.append(value);\n&#125;\nSystem.out.println(s);</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static main([Ljava&#x2F;lang&#x2F;String;)V\n   L0\n    LINENUMBER 12 L0\n    ICONST_3\n    ANEWARRAY java&#x2F;lang&#x2F;String\n    DUP\n    ICONST_0\n    LDC &quot;he&quot;\n    AASTORE\n    DUP\n    ICONST_1\n    LDC &quot;llo&quot;\n    AASTORE\n    DUP\n    ICONST_2\n    LDC &quot;world&quot;\n    AASTORE\n    ASTORE 1\n   L1\n    LINENUMBER 13 L1\n    NEW java&#x2F;lang&#x2F;StringBuilder &#x2F;&#x2F; 循环外面创建 StringBuilder 对象\n    DUP\n    INVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()V\n    ASTORE 2\n   L2\n    LINENUMBER 14 L2\n    ALOAD 1\n    ASTORE 3\n    ALOAD 3\n    ARRAYLENGTH\n    ISTORE 4\n    ICONST_0\n    ISTORE 5\n   L3\n   FRAME FULL [[Ljava&#x2F;lang&#x2F;String; [Ljava&#x2F;lang&#x2F;String; java&#x2F;lang&#x2F;StringBuilder [Ljava&#x2F;lang&#x2F;String; I I] []\n    ILOAD 5\n    ILOAD 4\n    IF_ICMPGE L4\n    ALOAD 3\n    ILOAD 5\n    AALOAD\n    ASTORE 6\n   L5\n    LINENUMBER 15 L5\n    ALOAD 2\n    ALOAD 6\n    INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\n    POP\n   L6\n    LINENUMBER 14 L6\n    IINC 5 1\n    GOTO L3\n   L4\n    LINENUMBER 17 L4\n   FRAME CHOP 3\n    GETSTATIC java&#x2F;lang&#x2F;System.out : Ljava&#x2F;io&#x2F;PrintStream;\n    ALOAD 2\n    INVOKEVIRTUAL java&#x2F;io&#x2F;PrintStream.println (Ljava&#x2F;lang&#x2F;Object;)V\n   L7\n    LINENUMBER 18 L7\n    RETURN\n   L8\n    LOCALVARIABLE value Ljava&#x2F;lang&#x2F;String; L5 L6 6\n    LOCALVARIABLE args [Ljava&#x2F;lang&#x2F;String; L0 L8 0\n    LOCALVARIABLE arr [Ljava&#x2F;lang&#x2F;String; L1 L8 1\n    LOCALVARIABLE s Ljava&#x2F;lang&#x2F;StringBuilder; L2 L8 2\n    MAXSTACK &#x3D; 4\n    MAXLOCALS &#x3D; 7\n&#125;</code></pre>\n\n<h2 id=\"2-5-String-equals-和-Object-equals-的区别\"><a href=\"#2-5-String-equals-和-Object-equals-的区别\" class=\"headerlink\" title=\"2.5 String.equals() 和 Object.equals() 的区别\"></a>2.5 String.equals() 和 Object.equals() 的区别</h2><p><strong><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址</strong></p>\n<h2 id=\"2-6-字符串常量池的作用\"><a href=\"#2-6-字符串常量池的作用\" class=\"headerlink\" title=\"2.6 字符串常量池的作用\"></a>2.6 字符串常量池的作用</h2><p><strong>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 在堆中创建字符串对象 ”ab“\n&#x2F;&#x2F; 将字符串对象 ”ab“ 的引用保存在字符串常量池中\nString aa &#x3D; &quot;ab&quot;;\n&#x2F;&#x2F; 直接返回字符串常量池中字符串对象 ”ab“ 的引用\nString bb &#x3D; &quot;ab&quot;;\nSystem.out.println(aa&#x3D;&#x3D;bb); &#x2F;&#x2F; true</code></pre>\n\n<p><strong><code>String s1 = new String(&quot;abc&quot;);</code> 这句话创建了几个字符串对象?</strong><br>1、如果字符串常量池中不存在字符串对象 “abc” 的引用，那么会在堆中创建 2 个字符串对象 “abc”</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; new String(&quot;abc&quot;);</code></pre>\n\n<p><strong>对应的字节码：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static main([Ljava&#x2F;lang&#x2F;String;)V\n   L0\n    LINENUMBER 12 L0\n    &#x2F;&#x2F; 1. 堆中创建一个 String 对象，此时未被初始化\n    NEW java&#x2F;lang&#x2F;String\n    DUP\n    &#x2F;&#x2F; 2. 堆中创建字符串对象 “abc” 并在字符串常量池中保存对应的引用\n    LDC &quot;abc&quot;\n    &#x2F;&#x2F; 3. 调用构造方法对 1 处创建的 String 对象赋值\n    INVOKESPECIAL java&#x2F;lang&#x2F;String.&lt;init&gt; (Ljava&#x2F;lang&#x2F;String;)V\n    ASTORE 1\n   L1\n    LINENUMBER 13 L1\n    RETURN\n   L2\n    LOCALVARIABLE args [Ljava&#x2F;lang&#x2F;String; L0 L2 0\n    LOCALVARIABLE s1 Ljava&#x2F;lang&#x2F;String; L1 L2 1\n    MAXSTACK &#x3D; 3\n    MAXLOCALS &#x3D; 2\n&#125;</code></pre>\n\n<p><strong><code>LDC</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中</strong></p>\n<p>2、如果字符串常量池中已存在字符串对象 “abc” 的引用，则只会在堆中创建 1 个字符串对象 “abc”</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 字符串常量池中已存在字符串对象 “abc” 的引用\nString s1 &#x3D; &quot;abc&quot;;\n&#x2F;&#x2F; 下面这段代码只会在堆中创建 1 个字符串对象 “abc”\nString s2 &#x3D; new String(&quot;abc&quot;);</code></pre>\n\n<p><strong>对应的字节码：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static main([Ljava&#x2F;lang&#x2F;String;)V\n   L0\n    LINENUMBER 13 L0\n    LDC &quot;abc&quot; &#x2F;&#x2F; 1\n    ASTORE 1\n   L1\n    LINENUMBER 15 L1\n    NEW java&#x2F;lang&#x2F;String &#x2F;&#x2F; 2\n    DUP\n    LDC &quot;abc&quot; &#x2F;&#x2F; 3\n    INVOKESPECIAL java&#x2F;lang&#x2F;String.&lt;init&gt; (Ljava&#x2F;lang&#x2F;String;)V\n    ASTORE 2\n   L2\n    LINENUMBER 16 L2\n    RETURN\n   L3\n    LOCALVARIABLE args [Ljava&#x2F;lang&#x2F;String; L0 L3 0\n    LOCALVARIABLE s1 Ljava&#x2F;lang&#x2F;String; L1 L3 1\n    LOCALVARIABLE s2 Ljava&#x2F;lang&#x2F;String; L2 L3 2\n    MAXSTACK &#x3D; 3\n    MAXLOCALS &#x3D; 3\n&#125;</code></pre>\n\n<p><strong>3 这个位置的 LDC 命令不会在堆中创建新的字符串对象 “abc”，这是因为 1 这个位置已经执行了一次 LDC 命令，已经在堆中创建过一次字符串对象“abc”了。3 这个位置执行 LDC 命令会直接返回字符串常量池中字符串对象 “abc” 对应的引用</strong></p>\n<h2 id=\"2-7-intern-方法的作用\"><a href=\"#2-7-intern-方法的作用\" class=\"headerlink\" title=\"2.7 intern 方法的作用\"></a>2.7 intern 方法的作用</h2><p><strong><code>String.intern()</code> 是一个 <code>native</code>（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p>\n<ul>\n<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用</li>\n<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 在堆中创建字符串对象 ”Java“\n&#x2F;&#x2F; 将字符串对象 ”Java“ 的引用保存在字符串常量池中\nString s1 &#x3D; &quot;Java&quot;;\n&#x2F;&#x2F; 直接返回字符串常量池中字符串对象 ”Java“ 对应的引用\nString s2 &#x3D; s1.intern();\n&#x2F;&#x2F; 会在堆中在单独创建一个字符串对象\nString s3 &#x3D; new String(&quot;Java&quot;);\n&#x2F;&#x2F; 直接返回字符串常量池中字符串对象 ”Java“ 对应的引用\nString s4 &#x3D; s3.intern();\n&#x2F;&#x2F; s1 和 s2 指向的是堆中的同一个对象\nSystem.out.println(s1 &#x3D;&#x3D; s2); &#x2F;&#x2F; true\n&#x2F;&#x2F; s3 和 s4 指向的是堆中不同的对象\nSystem.out.println(s3 &#x3D;&#x3D; s4); &#x2F;&#x2F; false\n&#x2F;&#x2F; s1 和 s4 指向的是堆中的同一个对象\nSystem.out.println(s1 &#x3D;&#x3D; s4); &#x2F;&#x2F; true</code></pre>\n\n<h2 id=\"2-8-String-类型的变量和常量做-“-”-运算时内部处理\"><a href=\"#2-8-String-类型的变量和常量做-“-”-运算时内部处理\" class=\"headerlink\" title=\"2.8 String 类型的变量和常量做 “+” 运算时内部处理\"></a>2.8 String 类型的变量和常量做 “+” 运算时内部处理</h2><p>字符串不加 <code>final</code> 关键字拼接</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str1 &#x3D; &quot;str&quot;;\nString str2 &#x3D; &quot;ing&quot;;\nString str3 &#x3D; &quot;str&quot; + &quot;ing&quot;;\nString str4 &#x3D; str1 + str2;\nString str5 &#x3D; &quot;string&quot;;\nSystem.out.println(str3 &#x3D;&#x3D; str4); &#x2F;&#x2F; false\nSystem.out.println(str3 &#x3D;&#x3D; str5); &#x2F;&#x2F; true\nSystem.out.println(str4 &#x3D;&#x3D; str5); &#x2F;&#x2F; false</code></pre>\n\n<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，JVM 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化</strong></p>\n<p><strong>在编译过程中，Javac 编译器会进行一个叫做 常量折叠(Constant Folding) 的代码优化</strong>。常量折叠<strong>会把常量表达式的值求出来作为常量嵌在最终生成的代码中</strong>，这是 Javac 编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）<br><strong>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会优化成 <code>String str3 = &quot;string&quot;;</code></strong></p>\n<p><strong>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</strong></p>\n<ul>\n<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量</li>\n<li><strong>final 修饰的基本数据类型和字符串变量</strong></li>\n<li>字符串通过 “+” 拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>\n</ul>\n<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化</strong><br>对象引用和 “+” 的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str4 &#x3D; new StringBuilder().append(str1).append(str2).toString();</code></pre>\n\n<p>在平时应尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code></p>\n<p><strong>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final String str1 &#x3D; &quot;str&quot;;\nfinal String str2 &#x3D; &quot;ing&quot;;\n&#x2F;&#x2F; 下面两个表达式其实是等价的\nString c &#x3D; &quot;str&quot; + &quot;ing&quot;; &#x2F;&#x2F; 常量池中的对象\nString d &#x3D; str1 + str2; &#x2F;&#x2F; 常量池中的对象\nSystem.out.println(c &#x3D;&#x3D; d); &#x2F;&#x2F; true</code></pre>\n\n<p><strong>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量</strong></p>\n<p><strong>如果 编译器在运行时才能知道其确切值的话，就无法对其优化</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final String str1 &#x3D; &quot;str&quot;;\n&#x2F;&#x2F; str2 在运行时才能确定其值\nfinal String str2 &#x3D; getStr();\nString c &#x3D; &quot;str&quot; + &quot;ing&quot;; &#x2F;&#x2F; 常量池中的对象\nString d &#x3D; str1 + str2; &#x2F;&#x2F; 在堆上创建的新的对象\nSystem.out.println(c &#x3D;&#x3D; d); &#x2F;&#x2F; false\n\npublic static String getStr() &#123;\n      return &quot;ing&quot;;\n&#125;</code></pre>\n\n<h1 id=\"3-深拷贝、浅拷贝、引用拷贝\"><a href=\"#3-深拷贝、浅拷贝、引用拷贝\" class=\"headerlink\" title=\"3. 深拷贝、浅拷贝、引用拷贝\"></a>3. 深拷贝、浅拷贝、引用拷贝</h1><ul>\n<li>浅拷贝：<strong>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点）</strong>，不过，如果<strong>原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象</strong></li>\n<li>深拷贝 ：<strong>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</strong></li>\n<li>引用拷贝：简单来说，引用拷贝就是两个不同的引用指向同一个对象</li>\n</ul>\n<p><strong>浅拷贝：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 实现了 Cloneable 接口，并重写了 clone() 方法\npublic class Address implements Cloneable&#123;\n    private String name;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Address clone() &#123;\n        try &#123;\n            return (Address) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n\npublic class Person implements Cloneable &#123;\n    private Address address;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Person clone() &#123;\n        try &#123;\n            Person person &#x3D; (Person) super.clone();\n            return person;\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试，从输出结构就可以看出， person1 的克隆对象和 person1 使用的仍然是同一个 Address 对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Person person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; true\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());</code></pre>\n\n<p><strong>深拷贝：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 简单对 Person 类的 clone() 方法进行修改，\n&#x2F;&#x2F; 连带着要把 Person 对象内部的 Address 对象一起复制\n@Override\npublic Person clone() &#123;\n    try &#123;\n        Person person &#x3D; (Person) super.clone();\n        person.setAddress(person.getAddress().clone());\n        return person;\n    &#125; catch (CloneNotSupportedException e) &#123;\n        throw new AssertionError();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试，从输出结构就可以看出，person1 的克隆对象和 person1 包含的 Address 对象已经是不同的了</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Person person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; false\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151039.png\"></p>\n<h1 id=\"4-集合\"><a href=\"#4-集合\" class=\"headerlink\" title=\"4. 集合\"></a>4. 集合</h1><p><img src=\"http://img.fan223.cn/2023/04/20230414151052.png\"></p>\n<h2 id=\"4-1-List、Set、Queue、Map-四者的区别\"><a href=\"#4-1-List、Set、Queue、Map-四者的区别\" class=\"headerlink\" title=\"4.1 List、Set、Queue、Map 四者的区别\"></a>4.1 List、Set、Queue、Map 四者的区别</h2><ul>\n<li><strong>List（有序):</strong> 存储的元素是有序的、可重复的。</li>\n<li><strong>Set(不可重复):</strong> 存储的元素是无序的、不可重复的。</li>\n<li><strong>Queue(排队功能):</strong> 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>\n<li><strong>Map(键值对):</strong> 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，<strong>key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</strong></li>\n</ul>\n<h2 id=\"4-2-集合框架底层数据结构总结\"><a href=\"#4-2-集合框架底层数据结构总结\" class=\"headerlink\" title=\"4.2 集合框架底层数据结构总结\"></a>4.2 集合框架底层数据结构总结</h2><p><strong>List</strong></p>\n<ul>\n<li><strong>Arraylist：</strong> <code>Object[]</code> 数组</li>\n<li><strong>Vector：</strong><code>Object[]</code> 数组</li>\n<li><strong>LinkedList：</strong> 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>\n</ul>\n<p><strong>Set</strong></p>\n<ul>\n<li><strong>HashSet(无序，唯一):</strong> 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>\n<li><strong>LinkedHashSet:</strong> <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>\n<li><strong>TreeSet(有序，唯一):</strong> 红黑树(自平衡的排序二叉树)</li>\n</ul>\n<p><strong>Queue</strong></p>\n<ul>\n<li><strong>PriorityQueue:</strong> <code>Object[]</code> 数组来实现二叉堆</li>\n<li><strong>ArrayQueue:</strong> <code>Object[]</code> 数组 + 双指针</li>\n</ul>\n<p><strong>Map</strong></p>\n<ul>\n<li><strong>HashMap：</strong> JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）<br>JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>\n<li><strong>LinkedHashMap：</strong> <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。<br>详细可以查看：<a href=\"https://www.imooc.com/article/22931\">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>\n<li><strong>Hashtable：</strong> 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h2 id=\"4-3-集合选用\"><a href=\"#4-3-集合选用\" class=\"headerlink\" title=\"4.3 集合选用\"></a>4.3 集合选用</h2><p><strong>根据集合的特点来选用，需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code></strong></p>\n<p><strong>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用</strong></p>\n<p><strong>当需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组</strong>，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了 “集合”，集合同样也是用来存储多个数据的。</p>\n<p><strong>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型</strong>；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，<strong>Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</strong></p>\n<h2 id=\"4-4-Collection-子接口之-List\"><a href=\"#4-4-Collection-子接口之-List\" class=\"headerlink\" title=\"4.4 Collection 子接口之 List\"></a>4.4 Collection 子接口之 List</h2><h3 id=\"4-4-1-ArrayList-和-Vector-的区别\"><a href=\"#4-4-1-ArrayList-和-Vector-的区别\" class=\"headerlink\" title=\"4.4.1 ArrayList 和 Vector 的区别\"></a>4.4.1 ArrayList 和 Vector 的区别</h3><ul>\n<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code> 存储，适用于频繁的查找工作，线程不安全</li>\n<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code> 存储，线程安全的</li>\n</ul>\n<h3 id=\"4-4-2-Arraylist-与-LinkedList-区别\"><a href=\"#4-4-2-Arraylist-与-LinkedList-区别\" class=\"headerlink\" title=\"4.4.2 Arraylist 与 LinkedList 区别\"></a>4.4.2 Arraylist 与 LinkedList 区别</h3><ol>\n<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全</li>\n<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <code>Object</code> 数组；<code>LinkedList</code> 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li>\n<li><strong>插入和删除是否受元素位置的影响</strong><ul>\n<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行 <code>add(E e)</code> 方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作</li>\n<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入</li>\n</ul>\n</li>\n<li>是否支持快速随机访问： <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)</li>\n<li>内存空间占用： <code>ArrayList</code> 的空 间浪费主要体现在在 <code>list</code> 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）</li>\n</ol>\n<p><strong>在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code></strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151110.png\"></p>\n<p>不要下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的时间复杂度都是 O(n)</p>\n<h3 id=\"4-4-3-双向链表和双向循环链表\"><a href=\"#4-4-3-双向链表和双向循环链表\" class=\"headerlink\" title=\"4.4.3 双向链表和双向循环链表\"></a>4.4.3 双向链表和双向循环链表</h3><p><strong>双向链表： 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点，<a href=\"https://juejin.cn/post/6844903648154271757\">https://juejin.cn/post/6844903648154271757</a></strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151136.png\"></p>\n<p><strong>双向循环链表： 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151338.png\"></p>\n<h3 id=\"4-4-4-RandomAccess-接口\"><a href=\"#4-4-4-RandomAccess-接口\" class=\"headerlink\" title=\"4.4.4 RandomAccess 接口\"></a>4.4.4 RandomAccess 接口</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface RandomAccess &#123;\n&#125;</code></pre>\n\n<p><strong>实际上 RandomAccess 接口中什么都没有定义。所以， RandomAccess 接口只是用来标识实现这个接口的类具有随机访问功能</strong></p>\n<p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 <code>list</code> 是否 <code>RandomAccess</code> 的实例，如果是，调用 <code>indexedBinarySearch()</code> 方法，如果不是，那么调用 <code>iteratorBinarySearch()</code> 方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;\n\tif (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n\t\treturn Collections.indexedBinarySearch(list, key);\n\telse\n\t\treturn Collections.iteratorBinarySearch(list, key);\n&#125;</code></pre>\n\n<p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。**<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问<strong>。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。</strong><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的**</p>\n<h2 id=\"4-5-Collection-子接口之-Set\"><a href=\"#4-5-Collection-子接口之-Set\" class=\"headerlink\" title=\"4.5 Collection 子接口之 Set\"></a>4.5 Collection 子接口之 Set</h2><h3 id=\"4-5-1-Comparable-和-Comparator-的区别\"><a href=\"#4-5-1-Comparable-和-Comparator-的区别\" class=\"headerlink\" title=\"4.5.1 Comparable 和 Comparator 的区别\"></a>4.5.1 Comparable 和 Comparator 的区别</h3><ul>\n<li><code>comparable</code> 接口实际上是出自 java.lang 包 它有一个 <code>compareTo(Object obj)</code> 方法用来排序</li>\n<li><code>comparator</code> 接口实际上是出自 java.util 包它有一个 <code>compare(Object obj1, Object obj2)</code> 方法用来排序</li>\n</ul>\n<p>一般需要对一个集合使用自定义排序时，我们就要重写 <code>compareTo()</code> 方法或 <code>compare()</code> 方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写 <code>compareTo()</code> 方法和使用自制的 <code>Comparator</code> 方法或者以两个 <code>Comparator</code> 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code></p>\n<p><strong>Comparator 定制排序</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;Integer&gt;();\narrayList.add(-1);\narrayList.add(3);\narrayList.add(3);\narrayList.add(-5);\narrayList.add(7);\narrayList.add(4);\narrayList.add(-9);\narrayList.add(-7);\nSystem.out.println(&quot;原始数组:&quot;);\nSystem.out.println(arrayList); &#x2F;&#x2F; [-1, 3, 3, -5, 7, 4, -9, -7]\n&#x2F;&#x2F; void reverse(List list)：反转\nCollections.reverse(arrayList);\nSystem.out.println(&quot;Collections.reverse(arrayList):&quot;);\nSystem.out.println(arrayList); &#x2F;&#x2F; [-7, -9, 4, 7, -5, 3, 3, -1]\n\n&#x2F;&#x2F; void sort(List list),按自然排序的升序排序\nCollections.sort(arrayList);\nSystem.out.println(&quot;Collections.sort(arrayList):&quot;);\nSystem.out.println(arrayList); &#x2F;&#x2F; [-9, -7, -5, -1, 3, 3, 4, 7]\n\n&#x2F;&#x2F; 定制排序的用法\nCollections.sort(arrayList, new Comparator&lt;Integer&gt;() &#123;\n\n\t@Override\n\tpublic int compare(Integer o1, Integer o2) &#123;\n\t\treturn o2.compareTo(o1);\n\t&#125;\n&#125;);\nSystem.out.println(&quot;定制排序后：&quot;);\nSystem.out.println(arrayList); &#x2F;&#x2F; [7, 4, 3, 3, -1, -5, -7, -9]</code></pre>\n\n<p><strong>重写 compareTo 方法实现按年龄来排序</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; person 对象没有实现 Comparable 接口，所以必须实现，\n&#x2F;&#x2F; 这样才不会出错，才可以使 treemap 中的数据按顺序排列\n&#x2F;&#x2F; String 类已经默认实现了Comparable接口，另外其他像 Integer 类等\n&#x2F;&#x2F; 都已经实现了Comparable接口，所以不需要另外实现了\npublic  class Person implements Comparable&lt;Person&gt; &#123;\n    private String name;\n    private int age;\n\n    public Person(String name, int age) &#123;\n        super();\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public String getName() &#123; return name; &#125;\n\n    public void setName(String name) &#123; this.name &#x3D; name; &#125;\n\n    public int getAge() &#123; return age; &#125;\n\n    public void setAge(int age) &#123; this.age &#x3D; age; &#125;\n\n    &#x2F;**\n     * T重写compareTo方法实现按年龄来排序\n     *&#x2F;\n    @Override\n    public int compareTo(Person o) &#123;\n        if (this.age &gt; o.getAge()) &#123;\n            return 1;\n        &#125;\n        if (this.age &lt; o.getAge()) &#123;\n            return -1;\n        &#125;\n        return 0;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tTreeMap&lt;Person, String&gt; pdata &#x3D; new TreeMap&lt;Person, String&gt;();\n\tpdata.put(new Person(&quot;张三&quot;, 30), &quot;zhangsan&quot;);\n\tpdata.put(new Person(&quot;李四&quot;, 20), &quot;lisi&quot;);\n\tpdata.put(new Person(&quot;王五&quot;, 10), &quot;wangwu&quot;);\n\tpdata.put(new Person(&quot;小红&quot;, 5), &quot;xiaohong&quot;);\n\t&#x2F;&#x2F; 得到 key 的值的同时得到 key 所对应的值\n\tSet&lt;Person&gt; keys &#x3D; pdata.keySet();\n\tfor (Person key : keys) &#123;\n\t\tSystem.out.println(key.getAge() + &quot;-&quot; + key.getName());\n\t&#125;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>结果：<br>5-小红<br>10-王五<br>20-李四<br>30-张三</p></blockquote>\n<h3 id=\"4-5-2-无序性和不可重复性\"><a href=\"#4-5-2-无序性和不可重复性\" class=\"headerlink\" title=\"4.5.2 无序性和不可重复性\"></a>4.5.2 无序性和不可重复性</h3><ul>\n<li><strong>无序性不等于随机性</strong> ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的</li>\n<li><strong>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>HashCode()</code> 方法</strong></li>\n</ul>\n<h3 id=\"4-5-3-HashSet、LinkedHashSet-和-TreeSet-三者的区别\"><a href=\"#4-5-3-HashSet、LinkedHashSet-和-TreeSet-三者的区别\" class=\"headerlink\" title=\"4.5.3 HashSet、LinkedHashSet 和 TreeSet 三者的区别\"></a>4.5.3 HashSet、LinkedHashSet 和 TreeSet 三者的区别</h3><ul>\n<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，<strong>都能保证元素唯一，并且都不是线程安全的</strong></li>\n<li><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同</strong><br><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序</li>\n<li>底层数据结构不同又导致这三者的应用场景不同。**<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景**</li>\n</ul>\n<h2 id=\"4-6-Collection-子接口之-Queue\"><a href=\"#4-6-Collection-子接口之-Queue\" class=\"headerlink\" title=\"4.6 Collection 子接口之 Queue\"></a>4.6 Collection 子接口之 Queue</h2><h3 id=\"4-6-1-Queue-与-Deque-的区别\"><a href=\"#4-6-1-Queue-与-Deque-的区别\" class=\"headerlink\" title=\"4.6.1 Queue 与 Deque 的区别\"></a>4.6.1 Queue 与 Deque 的区别</h3><ul>\n<li><strong><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则</strong></li>\n<li><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: <strong>一种在操作失败后会抛出异常，另一种则会返回特殊值</strong></li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151359.png\"></p>\n<ul>\n<li><strong><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素</strong></li>\n<li><code>Deque</code> 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类</li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151409.png\"></p>\n<p><strong>事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈</strong></p>\n<h3 id=\"4-6-2-ArrayDeque-与-LinkedList-的区别\"><a href=\"#4-6-2-ArrayDeque-与-LinkedList-的区别\" class=\"headerlink\" title=\"4.6.2 ArrayDeque 与 LinkedList 的区别\"></a>4.6.2 ArrayDeque 与 LinkedList 的区别</h3><p><strong>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能</strong></p>\n<ul>\n<li><strong><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现</strong></li>\n<li><code>ArrayDeque</code> 不支持存储 NULL 数据，但 <code>LinkedList</code> 支持。</li>\n<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而 <code>LinkedList</code> 早在 JDK1.2 时就已经存在</li>\n<li><strong><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢</strong></li>\n</ul>\n<p><strong>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</strong></p>\n<h3 id=\"4-6-3-PriorityQueue\"><a href=\"#4-6-3-PriorityQueue\" class=\"headerlink\" title=\"4.6.3 PriorityQueue\"></a>4.6.3 PriorityQueue</h3><p><strong><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队</strong></p>\n<ul>\n<li><strong><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</strong></li>\n<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素</li>\n<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象</li>\n<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后</li>\n</ul>\n<p><strong><code>PriorityQueue</code> 典型例题包括堆排序、求第K大的数、带权图的遍历等</strong></p>\n<h2 id=\"4-7-Map-接口\"><a href=\"#4-7-Map-接口\" class=\"headerlink\" title=\"4.7 Map 接口\"></a>4.7 Map 接口</h2><h3 id=\"4-7-1-HashMap-和-Hashtable-的区别\"><a href=\"#4-7-1-HashMap-和-Hashtable-的区别\" class=\"headerlink\" title=\"4.7.1 HashMap 和 Hashtable 的区别\"></a>4.7.1 HashMap 和 Hashtable 的区别</h3><ol>\n<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果要保证线程安全的话使用 <code>ConcurrentHashMap</code> ）</li>\n<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它</li>\n<li>对 Null key 和 Null value 的支持： <strong><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</strong>；<code>Hashtable</code> 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code></li>\n<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong><br>① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍<br>② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的 <code>tableSizeFor()</code> 方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</li>\n<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。<code>Hashtable</code> 没有这样的机制</li>\n</ol>\n<p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public HashMap(int initialCapacity, float loadFactor) &#123;\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity &#x3D; MAXIMUM_CAPACITY;\n    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n    this.loadFactor &#x3D; loadFactor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);\n&#125;\n public HashMap(int initialCapacity) &#123;\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n&#125;</code></pre>\n\n<p><strong>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Returns a power of two size for the given target capacity.\n *&#x2F;\nstatic final int tableSizeFor(int cap) &#123;\n    int n &#x3D; cap - 1;\n    n |&#x3D; n &gt;&gt;&gt; 1;\n    n |&#x3D; n &gt;&gt;&gt; 2;\n    n |&#x3D; n &gt;&gt;&gt; 4;\n    n |&#x3D; n &gt;&gt;&gt; 8;\n    n |&#x3D; n &gt;&gt;&gt; 16;\n    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n&#125;</code></pre>\n\n<h3 id=\"4-7-2-HashMap-和-HashSet-区别\"><a href=\"#4-7-2-HashMap-和-HashSet-区别\" class=\"headerlink\" title=\"4.7.2 HashMap 和 HashSet 区别\"></a>4.7.2 HashMap 和 HashSet 区别</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code> 是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151427.png\"></p>\n<h3 id=\"4-7-3-HashMap-和-TreeMap-区别\"><a href=\"#4-7-3-HashMap-和-TreeMap-区别\" class=\"headerlink\" title=\"4.7.3 HashMap 和 TreeMap 区别\"></a>4.7.3 HashMap 和 TreeMap 区别</h3><p><strong><code>TreeMap</code> 和 <code>HashMap</code> 都继承自 <code>AbstractMap</code> ，但 <code>TreeMap</code> 它还实现了 <code>NavigableMap</code> 接口和 <code>SortedMap</code> 接口</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151440.png\"></p>\n<ul>\n<li><strong>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</strong></li>\n<li><strong>实现 <code>SortedMap</code> 接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过也可以指定排序的比较器</strong></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * @author shuang.kou\n * @createTime 2020年06月15日 17:02:00\n *&#x2F;\npublic class Person &#123;\n    private Integer age;\n\n    public Person(Integer age) &#123;\n        this.age &#x3D; age;\n    &#125;\n\n    public Integer getAge() &#123;\n        return age;\n    &#125;\n\n\n    public static void main(String[] args) &#123;\n    \t&#x2F;**\n        TreeMap&lt;Person, String&gt; treeMap &#x3D; new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;\n            @Override\n            public int compare(Person person1, Person person2) &#123;\n                int num &#x3D; person1.getAge() - person2.getAge();\n                return Integer.compare(num, 0);\n            &#125;\n        &#125;);\n        *&#x2F;\n        TreeMap&lt;Person, String&gt; treeMap &#x3D; new TreeMap&lt;&gt;((person1, person2) -&gt; &#123;\n\t  \t\tint num &#x3D; person1.getAge() - person2.getAge();\n\t  \t\treturn Integer.compare(num, 0);\n\t\t&#125;);\n        treeMap.put(new Person(3), &quot;person1&quot;);\n        treeMap.put(new Person(18), &quot;person2&quot;);\n        treeMap.put(new Person(35), &quot;person3&quot;);\n        treeMap.put(new Person(16), &quot;person4&quot;);\n        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;\n            System.out.println(personStringEntry.getValue());\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>输出，<code>TreeMap</code> 中的元素已经是按照 Person 的 age 字段的升序来排列</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">person1\nperson4\nperson2\nperson3</code></pre>\n\n<p><strong>综上，相比于 <code>HashMap</code> 来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p>\n<h3 id=\"4-7-4-HashSet-如何检查重复\"><a href=\"#4-7-4-HashSet-如何检查重复\" class=\"headerlink\" title=\"4.7.4 HashSet 如何检查重复\"></a>4.7.4 HashSet 如何检查重复</h3><p>当把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashcode</code> 值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功</p>\n<p><strong>在 openjdk8 中，<code>HashSet</code> 的 <code>add()</code> 方法只是简单的调用了 <code>HashMap</code> 的 <code>put()</code> 方法，并且判断了一下返回值以确保是否有重复元素</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Returns: true if this set did not already contain the specified element\n&#x2F;&#x2F; 返回值：当set中没有包含add的元素时返回真\npublic boolean add(E e) &#123;\n        return map.put(e, PRESENT)&#x3D;&#x3D;null;\n&#125;</code></pre>\n\n<p><strong>在 <code>HashMap</code> 的 <code>putVal()</code> 方法中也能看到如下说明：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Returns : previous value, or null if none\n&#x2F;&#x2F; 返回值：如果插入位置没有元素返回null，否则返回上一个元素\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n...\n&#125;</code></pre>\n\n<p><strong>也就是说，在 openjdk8 中，实际上无论 <code>HashSet</code> 中是否已经存在了某元素，<code>HashSet</code> 都会直接插入，只是会在 <code>add()</code> 方法的返回值处告诉我们插入前是否存在相同元素</strong></p>\n<h3 id=\"4-7-5-HashMap-的底层实现\"><a href=\"#4-7-5-HashMap-的底层实现\" class=\"headerlink\" title=\"4.7.5 HashMap 的底层实现\"></a>4.7.5 HashMap 的底层实现</h3><p><strong>JDK1.8 之前</strong><br><strong>JDK1.8 之前 <code>HashMap</code> 底层是 数组和链表 结合在一起使用也就是 链表散列。</strong> <code>HashMap</code> 通过 key 的 <code>hashCode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <strong>(n - 1) &amp; hash</strong> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过<strong>拉链法解决冲突</strong></p>\n<p><strong>所谓扰动函数指的就是 <code>HashMap</code> 的 <code>hash</code> 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞</strong></p>\n<ul>\n<li>JDK1.7 的 <code>HashMap</code> 的 <code>hash</code> 方法源码，JDK 1.7 的 hash 方法的性能比 JDK 1.8 会稍差一点点，因为扰动了 4 次<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static int hash(int h) &#123;\n    &#x2F;&#x2F; This function ensures that hashCodes that differ only by\n    &#x2F;&#x2F; constant multiples at each bit position have a bounded\n    &#x2F;&#x2F; number of collisions (approximately 8 at default load factor).\n\n    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n&#125;</code></pre></li>\n<li>JDK1.8 的 <code>HashMap</code> 的 <code>hash</code> 方法源码，相比于 JDK 1.7 hash 方法更加简化，但是原理不变<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">  static final int hash(Object key) &#123;\n    int h;\n    &#x2F;&#x2F; key.hashCode()：返回散列值也就是hashcode\n    &#x2F;&#x2F; ^ ：按位异或\n    &#x2F;&#x2F; &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;</code></pre></li>\n</ul>\n<p><strong>“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151459.png\"></p>\n<p><strong>JDK1.8 之后</strong></p>\n<p>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151519.png\"></p>\n<p><strong><code>TreeMap</code>、<code>TreeSet</code> 以及 JDK1.8 之后的 <code>HashMap</code> 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构</strong></p>\n<h3 id=\"4-7-6-HashMap-的长度为什么是-2-的幂次方\"><a href=\"#4-7-6-HashMap-的长度为什么是-2-的幂次方\" class=\"headerlink\" title=\"4.7.6 HashMap 的长度为什么是 2 的幂次方\"></a>4.7.6 HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 <code>HashMap</code> 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。Hash 值的范围值 -2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。<strong>这个数组下标的计算方法是 <code>“ (n - 1) &amp; hash”</code>。（n 代表数组长度）。这也就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方</strong></p>\n<p><strong>算法应该如何设计？</strong><br>首先可能会想到采用 <code>%</code> 取余的操作来实现。但是：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 <code>hash%length==hash&amp;(length-1)</code> 的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于 % 能够提高运算效率，这就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方</strong></p>\n<h3 id=\"4-7-7-HashMap-多线程操作导致死循环问题\"><a href=\"#4-7-7-HashMap-多线程操作导致死循环问题\" class=\"headerlink\" title=\"4.7.7 HashMap 多线程操作导致死循环问题\"></a>4.7.7 HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的 <code>Rehash</code> 会造成元素之间会形成一个循环链表。不过，JDK 1.8 后解决了这个问题，但是还是不建议在多线程下使用 <code>HashMap</code>，因为<strong>多线程下使用 <code>HashMap</code> 还是会存在其他问题比如数据丢失。并发环境下推荐使用 <code>ConcurrentHashMap</code></strong><br><strong><a href=\"https://coolshell.cn/articles/9606.html\">https://coolshell.cn/articles/9606.html</a></strong></p>\n<h3 id=\"4-7-8-HashMap-常见遍历方式\"><a href=\"#4-7-8-HashMap-常见遍历方式\" class=\"headerlink\" title=\"4.7.8 HashMap 常见遍历方式\"></a>4.7.8 HashMap 常见遍历方式</h3><p><strong><a href=\"https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw\">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a></strong></p>\n<h3 id=\"4-7-9-ConcurrentHashMap-和-Hashtable-的区别\"><a href=\"#4-7-9-ConcurrentHashMap-和-Hashtable-的区别\" class=\"headerlink\" title=\"4.7.9 ConcurrentHashMap 和 Hashtable 的区别\"></a>4.7.9 ConcurrentHashMap 和 Hashtable 的区别</h3><p><strong><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同</strong></p>\n<ul>\n<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，<strong>数组 + 链表&#x2F;红黑二叉树</strong>。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 数组 + 链表 的形式，<strong>数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</strong></li>\n<li><strong>实现线程安全的方式（重要）</strong><br>① 在 JDK1.7 的时候，**<code>ConcurrentHashMap</code>（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 <strong>Node 数组+链表+红黑树</strong>的数据结构来实现，<strong>并发控制使用 <code>synchronized</code> 和 <code>CAS</code> 来操作</strong>。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本<br>② <code>Hashtable</code>(同一把锁) ：使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低</li>\n</ul>\n<p><strong><code>HashTable</code></strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151537.png\"></p>\n<p><strong>JDK1.7 的 <code>ConcurrentHashMap</code>：</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151552.png\"></p>\n<p><strong>JDK1.8 的 <code>ConcurrentHashMap</code>：</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414151606.png\"></p>\n<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，**Node 只能用于链表的情况，红黑树的情况需要使用 <code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树</p>\n<h3 id=\"4-7-10-ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现\"><a href=\"#4-7-10-ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现\" class=\"headerlink\" title=\"4.7.10 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现\"></a>4.7.10 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h3><p><strong>JDK1.7</strong></p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问</p>\n<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong><br><code>Segment</code> 继承了 <code>ReentrantLock</code>，所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;\n&#125;</code></pre>\n\n<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁</p>\n<p><strong>JDK1.8</strong></p>\n<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>CAS</code> 和 <code>synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code>1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>\n<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍</p>\n","feature":false,"text":"1. ObjectObject 类是一个特殊的类，是所有类的父类 1.1 常见方法（11个）&#x2F;** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 *&#x2F; public final nati...","link":"","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[{"name":"面试","slug":"面试","count":2,"path":"api/categories/面试.json"}],"tags":[{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Object\"><span class=\"toc-text\">1. Object</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%EF%BC%8811%E4%B8%AA%EF%BC%89\"><span class=\"toc-text\">1.1 常见方法（11个）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-x3D-x3D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.2 &#x3D;&#x3D; 和 equals() 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-hashCode-%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.3 hashCode() 作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.4 重写 equals() 时必须重写 hashCode() 方法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-String\"><span class=\"toc-text\">2. String</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.1 String、StringBuffer、StringBuilder 的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-1-%E5%8F%AF%E5%8F%98%E6%80%A7\"><span class=\"toc-text\">2.1.1 可变性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7\"><span class=\"toc-text\">2.1.2 线程安全性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-3-%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">2.1.3 性能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.1.4 使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84\"><span class=\"toc-text\">2.2 String 为什么是不可变的?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-Java-9-%E5%AF%B9-String-%E7%9A%84%E6%94%B9%E5%8F%98\"><span class=\"toc-text\">2.3 Java 9 对 String 的改变</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E2%80%9C-%E2%80%9D-%E8%BF%98%E6%98%AF-StringBuilder\"><span class=\"toc-text\">2.4 字符串拼接用 “+” 还是 StringBuilder</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-String-equals-%E5%92%8C-Object-equals-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.5 String.equals() 和 Object.equals() 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">2.6 字符串常量池的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-intern-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">2.7 intern 方法的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-String-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A-%E2%80%9C-%E2%80%9D-%E8%BF%90%E7%AE%97%E6%97%B6%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">2.8 String 类型的变量和常量做 “+” 运算时内部处理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">3. 深拷贝、浅拷贝、引用拷贝</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E9%9B%86%E5%90%88\"><span class=\"toc-text\">4. 集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-List%E3%80%81Set%E3%80%81Queue%E3%80%81Map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.1 List、Set、Queue、Map 四者的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4.2 集合框架底层数据结构总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E9%9B%86%E5%90%88%E9%80%89%E7%94%A8\"><span class=\"toc-text\">4.3 集合选用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-List\"><span class=\"toc-text\">4.4 Collection 子接口之 List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-1-ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.4.1 ArrayList 和 Vector 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-2-Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.4.2 Arraylist 与 LinkedList 区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-3-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">4.4.3 双向链表和双向循环链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-4-RandomAccess-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4.4.4 RandomAccess 接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-Set\"><span class=\"toc-text\">4.5 Collection 子接口之 Set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-1-Comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.5.1 Comparable 和 Comparator 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-2-%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7\"><span class=\"toc-text\">4.5.2 无序性和不可重复性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-3-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.5.3 HashSet、LinkedHashSet 和 TreeSet 三者的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-Collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-Queue\"><span class=\"toc-text\">4.6 Collection 子接口之 Queue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-1-Queue-%E4%B8%8E-Deque-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.6.1 Queue 与 Deque 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-2-ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.6.2 ArrayDeque 与 LinkedList 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-3-PriorityQueue\"><span class=\"toc-text\">4.6.3 PriorityQueue</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-Map-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4.7 Map 接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-1-HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.7.1 HashMap 和 Hashtable 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-2-HashMap-%E5%92%8C-HashSet-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.7.2 HashMap 和 HashSet 区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-3-HashMap-%E5%92%8C-TreeMap-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.7.3 HashMap 和 TreeMap 区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-4-HashSet-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D\"><span class=\"toc-text\">4.7.4 HashSet 如何检查重复</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-5-HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.7.5 HashMap 的底层实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-6-HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9\"><span class=\"toc-text\">4.7.6 HashMap 的长度为什么是 2 的幂次方</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-7-HashMap-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4.7.7 HashMap 多线程操作导致死循环问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-8-HashMap-%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.7.8 HashMap 常见遍历方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-9-ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.7.9 ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-10-ConcurrentHashMap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-x2F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.7.10 ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"记创建 SpringBoot 项目时连接超时，Cannot download \"https://start.spring.io\"","uid":"47df2e1dd7b2541fd7b7ee483506bab6","slug":"BlogRepository/问题记录/记创建 SpringBoot 项目时连接超时，Cannot download httpsstart.spring.io","date":"2022-07-25T17:19:20.000Z","updated":"2023-04-20T13:57:44.648Z","comments":true,"path":"api/articles/BlogRepository/问题记录/记创建 SpringBoot 项目时连接超时，Cannot download httpsstart.spring.io.json","keywords":null,"cover":"https://cover.png","text":"1. 问题首先，在第一阶段，连接 start.spring.io 超时 假如运气好第一阶段刷新成功，第二阶段创建，下载时报错超时，无法创建 2. 解决将地址 https://start.spring.io/ 改为 https://start.springboot.io/ 即可成功...","link":"","photos":[],"count_time":{"symbolsCount":146,"symbolsTime":"1 mins."},"categories":[{"name":"问题记录","slug":"问题记录","count":7,"path":"api/categories/问题记录.json"}],"tags":[{"name":"IDEA","slug":"IDEA","count":8,"path":"api/tags/IDEA.json"},{"name":"SpringBoot","slug":"SpringBoot","count":4,"path":"api/tags/SpringBoot.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"记 IDEA 启动 Command line is too long 解决","uid":"1b9f23e14da5dbec955e19baedd994be","slug":"BlogRepository/问题记录/记 IDEA 启动 Command line is too long 解决","date":"2022-07-01T07:24:03.000Z","updated":"2023-04-20T13:57:44.648Z","comments":true,"path":"api/articles/BlogRepository/问题记录/记 IDEA 启动 Command line is too long 解决.json","keywords":null,"cover":"https://cover.png","text":"1. IDEA 2021 及之前在项目的 .idea 文件中，找到 workspace.xml 文件 打开，找到 &lt;component name=&quot;PropertiesComponent&quot;&gt; 标签，在里面加上一条&lt;property name=...","link":"","photos":[],"count_time":{"symbolsCount":365,"symbolsTime":"1 mins."},"categories":[{"name":"问题记录","slug":"问题记录","count":7,"path":"api/categories/问题记录.json"}],"tags":[{"name":"IDEA","slug":"IDEA","count":8,"path":"api/tags/IDEA.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}