{"title":"面经总结","uid":"6e256074945a4399e89877260ce89de5","slug":"BlogRepository/面试/面经总结","date":"2023-04-14T06:52:55.000Z","updated":"2023-04-20T13:57:44.648Z","comments":true,"path":"api/articles/BlogRepository/面试/面经总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-百度-Java-后端一面（8-21）\"><a href=\"#1-百度-Java-后端一面（8-21）\" class=\"headerlink\" title=\"1. 百度 Java 后端一面（8-21）\"></a>1. 百度 Java 后端一面（8-21）</h1><h2 id=\"1-1-进程和线程的区别是什么？\"><a href=\"#1-1-进程和线程的区别是什么？\" class=\"headerlink\" title=\"1.1 进程和线程的区别是什么？\"></a>1.1 进程和线程的区别是什么？</h2><p>线程隶属于进程。进程是操作系统进行资源分配的最小单元，线程是操作系统进行任务分配的最小单元</p>\n<h2 id=\"1-2-进程通信与线程通信的方式有什么？\"><a href=\"#1-2-进程通信与线程通信的方式有什么？\" class=\"headerlink\" title=\"1.2 进程通信与线程通信的方式有什么？\"></a>1.2 进程通信与线程通信的方式有什么？</h2><ol>\n<li>管道（pipe）<br>管道是一种半双工（即可以在一个信号载体的两个方向上传输，但不能同时传输）的通信方式，数据只能单向流动，并且只能在具有亲缘关系的进程间使用，进程的亲缘关系通常是指父子进程关系</li>\n<li>有名管道（namedpipe）<br>也是半双工的通信方式，与管道不同的是，它允许无亲缘关系进程间的通信</li>\n<li>信号量（semophore）<br>信号量是一个计数器，可以用来控制多个线程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li>\n<li>信号（sinal）<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>\n<li>共享内存（shared memory）<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC（Inter-Process Communication） 方式，它是针对其他进程间通信效率低而专门设计的。往往与其他通信机制，如信号量，配合使用，来实现进程间的同步与通信</li>\n<li>套接字（socket）<br>套接字也是一种进程间通信机制，与其他通信机制不同的是，它可以用于不同设备及其间的进程通信</li>\n</ol>\n<h2 id=\"1-3-TCP-的三次握手和四次挥手\"><a href=\"#1-3-TCP-的三次握手和四次挥手\" class=\"headerlink\" title=\"1.3 TCP 的三次握手和四次挥手\"></a>1.3 TCP 的三次握手和四次挥手</h2><p>TCP 的三次握手是建立连接的过程</p>\n<ol>\n<li>客户端生成一个随机数 A，发送给服务器端请求连接</li>\n<li>服务器接收到随机数 A 后，将随机数 A + 1，然后生成随机数 B，返回给客户端</li>\n<li>客户端收到两个数据后，就建立起了连接</li>\n</ol>\n<p>TCP 的四次挥手是断开连接的过程</p>\n<ol>\n<li>A 发送随机数告诉 B 要断开链接，B 收到 A 的请求断开数据后，返回信息给 A，A 收到信息后，A 对 B 的链接取消</li>\n<li>当 B 不再发送数据了，就发送数据给 A，A 返回数据后，B 对 A 的链接取消</li>\n</ol>\n<h2 id=\"1-4-TCP-客户端四次挥手后是什么状态？\"><a href=\"#1-4-TCP-客户端四次挥手后是什么状态？\" class=\"headerlink\" title=\"1.4 TCP 客户端四次挥手后是什么状态？\"></a>1.4 TCP 客户端四次挥手后是什么状态？</h2><p>四次挥手即终止 TCP 连接过程，断开一个 TCP 连接，需要客户端和服务器端总共发送四个包来确认连接的断开</p>\n<h2 id=\"1-5-如何理解一次编写，随处运行？\"><a href=\"#1-5-如何理解一次编写，随处运行？\" class=\"headerlink\" title=\"1.5 如何理解一次编写，随处运行？\"></a>1.5 如何理解一次编写，随处运行？</h2><p>Java 程序运行在 Java 虚拟机（JVM）中，而 JVM 运行在操作系统上，JVM 内部对不同的操作系统之间进行了适配</p>\n<h2 id=\"1-6-JVM-如何知道-New-一个对象要多大内存？\"><a href=\"#1-6-JVM-如何知道-New-一个对象要多大内存？\" class=\"headerlink\" title=\"1.6 JVM 如何知道 New 一个对象要多大内存？\"></a>1.6 JVM 如何知道 New 一个对象要多大内存？</h2><p>对象在内存中的布局主要有三个组成部分，对象头、实例数据与对齐填充。确认对象的大小也是从这三个部分入手</p>\n<p>其中对象头又包括 Mark Word 和 Klass Word，当对象是一个数组时，对象头还会增加一块区域，用来保存数组的长度</p>\n<h2 id=\"1-7-JVM-堆内存不够如何解决？\"><a href=\"#1-7-JVM-堆内存不够如何解决？\" class=\"headerlink\" title=\"1.7 JVM 堆内存不够如何解决？\"></a>1.7 JVM 堆内存不够如何解决？</h2><ol>\n<li>调整最大堆内存和最小堆内存</li>\n<li>调整新生代和老年代的比值</li>\n<li>调整 Survivor 区和 Eden 区的比值</li>\n<li>设置年轻代和老年代的大小</li>\n</ol>\n<h2 id=\"1-8-聚集索引和非聚集索引都有哪些？\"><a href=\"#1-8-聚集索引和非聚集索引都有哪些？\" class=\"headerlink\" title=\"1.8 聚集索引和非聚集索引都有哪些？\"></a>1.8 聚集索引和非聚集索引都有哪些？</h2><p>聚集索引即主键索引，除了聚集索引以外的索引都是非聚集索引。非聚集索引又细分为普通索引、唯一索引、组合索引、全文索引</p>\n<h2 id=\"1-9-Redis-的缓存读写一致策略\"><a href=\"#1-9-Redis-的缓存读写一致策略\" class=\"headerlink\" title=\"1.9 Redis 的缓存读写一致策略\"></a>1.9 Redis 的缓存读写一致策略</h2><ol>\n<li><p><strong>Cache Aside Pattern（旁路缓存模式），适合读请求比较多的场景</strong><br>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准</p>\n<ul>\n<li><p><strong>写</strong> ：</p>\n<ol>\n<li>先更新 db</li>\n<li>然后直接删除 cache</li>\n</ol>\n</li>\n<li><p><strong>读</strong> :</p>\n<ol>\n<li>从 cache 中读取数据，读取到就直接返回</li>\n<li>cache 中读取不到的话，就从 db 中读取数据返回</li>\n<li>再把数据放到 cache 中</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>Read&#x2F;Write Through Pattern（读写穿透）</strong></p>\n<p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。这种缓存读写策略在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能</p>\n<ul>\n<li><p><strong>写（Write Through）：</strong></p>\n<ol>\n<li>先查 cache，cache 中不存在，直接更新 db</li>\n<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（ <strong>同步更新 cache 和 db</strong> ）</li>\n</ol>\n</li>\n<li><p><strong>读（Read Through）：</strong></p>\n<ol>\n<li>从 cache 中读取数据，读取到就直接返回 。</li>\n<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应</li>\n</ol>\n</li>\n</ul>\n<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中</p>\n</li>\n<li><p><strong>Write Behind Pattern（异步缓存写入）</strong></p>\n<p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写但是，但两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db</strong></p>\n<p>这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。这种策略在平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略</p>\n<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量</p>\n</li>\n</ol>\n<h1 id=\"2-快手-Java-开发一面（8-23）\"><a href=\"#2-快手-Java-开发一面（8-23）\" class=\"headerlink\" title=\"2. 快手 Java 开发一面（8-23）\"></a>2. 快手 Java 开发一面（8-23）</h1><h2 id=\"2-1-RabbitMQ-的架构\"><a href=\"#2-1-RabbitMQ-的架构\" class=\"headerlink\" title=\"2.1 RabbitMQ 的架构\"></a>2.1 RabbitMQ 的架构</h2><p><img src=\"http://img.fan223.cn/2023/04/20230414145002.png\"></p>\n<ol>\n<li>Producer（生产者）：消息生产者，通过 Channel 与 Server 端连接，负责发送消息至 Server 端</li>\n<li>Channel（信道）：负责连接客户端和 Server 端，是基于 TCP 连接之上的虚拟连接</li>\n<li>Broker（消息服务）：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。包括两个部分：Exchange 和 Queue</li>\n<li>Exchange（交换机）：负责将消息转发至各个队列</li>\n<li>Queue（队列）：以队列的方式存储消息实体，先进先出</li>\n<li>Consumer（消费者）：接收 Server 端推送过来的消息并进行处理</li>\n<li>Virtual host（虚拟主机）：当多个不同的用户使用同一个 RabbitMQ Server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 Exchange／Queue</li>\n</ol>\n<h2 id=\"2-2-Exchange-交换机类型\"><a href=\"#2-2-Exchange-交换机类型\" class=\"headerlink\" title=\"2.2 Exchange 交换机类型\"></a>2.2 Exchange 交换机类型</h2><p><strong>交换机主要包括如下 4 种类型：</strong></p>\n<ol>\n<li>Direct Exchange（直连交换机） ：所有发送到 DE 的消息被转发到 RouteKey 中指定的 Queue</li>\n<li>Fanout Exchange（扇型交换机）：不处理路由键，只需要简单的将队列绑定到交换机上。发送到交换机的消息都会被转发到与该交换机绑定的所有的队列</li>\n<li>Topic Exchange（主题交换机）：所有发送到 Topic Exchange 的消息被转发到所有关系 RouteKey 中指定 Topic 的 Queue 上 Exchange，将 RouteKey 和某 Topic 进行模糊匹配，此时队列需要绑定一个 Topic</li>\n<li>Headers exchange（头交换机）</li>\n</ol>\n<p>另外 RabbitMQ 默认定义一些交换机：</p>\n<ul>\n<li>默认交换机 amq.* exchanges</li>\n</ul>\n<p>还有一类特殊的交换机：</p>\n<ul>\n<li>Dead Letter Exchange（死信交换机）</li>\n</ul>\n<h2 id=\"2-3-消费者消费失败怎么处理，消费者怎么去再次消费\"><a href=\"#2-3-消费者消费失败怎么处理，消费者怎么去再次消费\" class=\"headerlink\" title=\"2.3 消费者消费失败怎么处理，消费者怎么去再次消费?\"></a>2.3 消费者消费失败怎么处理，消费者怎么去再次消费?</h2><p>消费者消费失败后，会把消费发回给 Broker 进行处理。客户端处理流程：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414145017.png\"></p>\n<p>Broker 收到消息后，会把消息重新发送到 CommitLog，发送到 CommitLog 之前，首先会修改 Topic 为 SCHEDULE_TOPIC_XXXX，这样就发送到了延时队列，延时队列再根据延时级别把消息投递到原始的队列，这样消费者就能再次拉取到。流程如下：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230414145027.png\"></p>\n<h2 id=\"2-4-消息队列持久化\"><a href=\"#2-4-消息队列持久化\" class=\"headerlink\" title=\"2.4 消息队列持久化\"></a>2.4 消息队列持久化</h2><ol>\n<li>交换机的持久化<br>如果使用常规的声明交换机的方法：<code>channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</code>，默认不是持久化的，在服务器重启之后，交换机会消失。在管理台的 Exchange 页签下查看交换机，可以看到使用上述方法声明的交换机，Features 一列是空的，即没有任何附加属性<br>可以使用 <code>channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;, true);</code> 声明交换机，第三个参数 durable，如果为 true 时则表示要做持久化</li>\n<li>队列的持久化<br>与交换机的持久化相同，队列的持久化也是通过 durable 参数实现的</li>\n<li>消息的持久化<br>消息的持久化是指当消息从交换机发送到队列之后，被消费者消费之前，服务器突然宕机重启，消息仍然存在。消息持久化的前提是队列持久化。使用 <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>这个属性，<code>channel.basicPublish(EXCHANGE_NAME,&quot;&quot;,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes())</code></li>\n</ol>\n<h2 id=\"2-5-MySQL-有哪些存储引擎，它们有什么区别\"><a href=\"#2-5-MySQL-有哪些存储引擎，它们有什么区别\" class=\"headerlink\" title=\"2.5 MySQL 有哪些存储引擎，它们有什么区别?\"></a>2.5 MySQL 有哪些存储引擎，它们有什么区别?</h2><p>MySQL 的存储引擎有：InnoDB 、MyISAM 、MEMORY、MERGE、EXAMPLE、ARCHIVE、CSV、BLACKHOLE、FEDERATED。常用的是 InnoDB 存储引擎和 MyISAM 存储引擎。MySQL 5.5 以后默认使用 InnoDB 存储引擎</p>\n<ol>\n<li><strong>是否支持行级锁</strong><br>MyISAM 只有表级锁（table-level locking），而 InnoDB 支持行级锁（row-level locking）和表级锁，默认为行级锁</li>\n<li><strong>是否支持事务</strong><br>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交（commit）和回滚（rollback）事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重复读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Gap Lock）</li>\n<li><strong>是否支持外键</strong><br>MyISAM 不支持，而 InnoDB 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此通常情况下，不建议在实际生产项目中使用外键</li>\n<li><strong>是否支持数据库异常崩溃后的安全恢复</strong><br>MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log</li>\n<li><strong>是否支持 MVCC</strong><br>MyISAM 不支持，而 InnoDB 支持。MyISAM 连行级锁都不支持，而 MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</li>\n<li><strong>索引实现不一样</strong><br>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一。InnoDB 引擎中，其数据文件本身就是索引文件。而 MyISAM 索引文件和数据文件是分离的</li>\n</ol>\n<h2 id=\"2-6-InnoDB-中有哪些锁\"><a href=\"#2-6-InnoDB-中有哪些锁\" class=\"headerlink\" title=\"2.6 InnoDB 中有哪些锁?\"></a>2.6 InnoDB 中有哪些锁?</h2><p><strong>行锁：</strong></p>\n<ol>\n<li><strong>记录锁（Record Lock）</strong> ：属于单个行记录上的锁</li>\n<li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身，左开右开</li>\n<li><strong>临键锁（Next-key Lock）</strong> ：Record Lock + Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入幻影记录，需要依赖间隙锁。左开右闭</li>\n<li><strong>插入意向锁（Insert Intention Lock）</strong>：一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了间隙锁，如果有的话，插入操作需要等待，直到拥有间隙锁的那个事务提交。但是 InnoDB 规定事务在等待的时候也需要在内存中生成一个锁结构 ，表明有事务想在某个间隙中插入新记录，现在在等待。于是就把这种类型的锁命名为插入意向锁</li>\n<li><strong>隐式锁</strong>：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务 id 的存在，相当于加了一个隐式锁。别的事务在对这条记录加 S 锁 或者 X 锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态</li>\n</ol>\n<p><strong>表锁：</strong></p>\n<ol>\n<li><p><strong>表级别的 S 锁 、 X 锁</strong></p>\n<ul>\n<li>在对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时， InnoDB 存储引擎不会为这个表添加表级别的 S 锁 或者 X 锁</li>\n<li>但在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其他事务对这个表并发执行诸如 SELECT 、 INSERT 、 DELETE 、 UPDATE 的语句会发生阻塞；同理，某个事务中对某个表执行 SELECT 、 INSERT 、 DELETE 、 UPDATE 语句时，在其他会话中对这个表执行 DDL 语句也会发生阻塞。这个过程其实是通过在 Server 层 使用一种称之为元数据锁 （Metadata Locks ，简称 MDL ）来实现的，一般情况下也不会使用 InnoDB 存储引擎自己提供的表级别的 S 锁 和 X 锁</li>\n</ul>\n</li>\n<li><p><strong>表级别的 IS 锁 、 IX 锁</strong><br>在对使用 InnoDB 存储引擎的表的某些记录加 S 锁或 X 锁之前，那就需要先在表级别加一个 IS 锁或 IX 锁。 IS 锁 和 IX 锁的使命只是为了后续在加表级别的 S 锁 和 X 锁 时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录</p>\n</li>\n<li><p><strong>表级别的 AUTO-INC 锁</strong><br>当给表的某个列添加 AUTO_INCREMENT 属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值。系统实现这种<strong>自动给 AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：</strong></p>\n<ul>\n<li>采用 AUTO-INC 锁<br>在执行插入语句时就在表级别加一个 AUTO-INC 锁，然后为每条待插入记录的 AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把 AUTO-INC 锁释放掉</li>\n<li>采用一个轻量级的锁<br>在为插入语句生成 AUTO_INCREMENT 修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的 AUTO_INCREMENT 列的值之后，就把该轻量级锁释放掉</li>\n</ul>\n<p>InnoDB 提供了一个称之为 innodb_autoinc_lock_mode 的系统变量来控制到底使用上述两种方式中的哪种来为 AUTO_INCREMENT 修饰的列进行赋值，当值为 0 时，一律采用 AUTO-INC 锁；当值为 2 时，一律采用轻量级锁；值为 1 时，两种方式混着来（在插入记录数量确定时采用轻量级锁，不确定时使用 AUTO-INC 锁）。不过值为 2 时，可能会造成不同事务中的插入语句为 AUTO_INCREMENT 修饰的列生成的值是交叉的，在有主从复制的场景中是不安全的</p>\n</li>\n</ol>\n<p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p>\n<ol>\n<li><strong>快照读</strong> （一致性非锁定读） ：由 MVCC 机制来保证不出现幻读</li>\n<li><strong>当前读</strong> （一致性锁定读）： 使用 Gap Lock 进行加锁来保证不出现幻读</li>\n</ol>\n<h2 id=\"2-7-TCP-x2F-IP-四层模型\"><a href=\"#2-7-TCP-x2F-IP-四层模型\" class=\"headerlink\" title=\"2.7 TCP&#x2F;IP 四层模型\"></a>2.7 TCP&#x2F;IP 四层模型</h2><ol>\n<li><strong>应用层</strong><br>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。<strong>应用层交互的数据单元称为报文</strong></li>\n<li><strong>传输层</strong><br>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务<br><strong>端口号即是这里的“端”，常把这一层数据叫做段。</strong> TCP（Transmission Control Protocol – 传输控制协议，传输效率低，用于传输可靠性要求高，数据量大的数据） 与 UDP（User Datagram Protocol – 用户数据报协议，用于传输可靠性要求不高，数据量小的数据）就在这一层，工作设备为四层交换机和路由器</li>\n<li><strong>网络层</strong><br>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。<strong>这一层就是常说的 IP 协议层。IP 协议是 Internet 的基础</strong></li>\n<li><strong>网络接口层</strong><br>网络接口层是数据链路层和物理层的合体<ul>\n<li><strong>数据链路层（Data Link Layer）通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）</strong><br>数据链路层的作用是对网络层交下来的 IP 数据报<strong>将比特组合成字节，再将字节组合成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</li>\n<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong><br>主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输，到达目的地后再转化为 1、0，也就是常说的数模转换与模数转换）。这一层的数据叫做比特</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"3-招银网络后端-Java\"><a href=\"#3-招银网络后端-Java\" class=\"headerlink\" title=\"3. 招银网络后端 Java\"></a>3. 招银网络后端 Java</h1><h2 id=\"3-1-介绍-List-和-Map-的数据结构（ArrayList、LinkedList、HashMap-…）\"><a href=\"#3-1-介绍-List-和-Map-的数据结构（ArrayList、LinkedList、HashMap-…）\" class=\"headerlink\" title=\"3.1 介绍 List 和 Map 的数据结构（ArrayList、LinkedList、HashMap …）\"></a>3.1 介绍 List 和 Map 的数据结构（ArrayList、LinkedList、HashMap …）</h2><ol>\n<li><strong>List 是一个元素有序（存储有序）、可重复的集合。集合的每个元素都有对应的索引，以便查询和修改。List 集合是允许存储 NULL 值的</strong><ul>\n<li><strong>ArrayList</strong><ul>\n<li>ArrayList 底层使用 <code>Object[]</code> 数组来存储元素；</li>\n<li>插入和删除元素的时间复杂度受元素位置的影响。添加元素到末尾时间复杂度为 <code>O(1)</code>；在指定位置 i 插入和删除元素时间复杂度为 <code>O(n-i)</code></li>\n<li>支持快速随机访问（即通过元素的序号快速获取元素对象）</li>\n<li>不同步，线程不安全</li>\n<li>空间浪费主要体现在列表的结尾会预留一定的容量空间</li>\n</ul>\n</li>\n<li>Vector<br>底层使用 <code>Object[]</code> 数组存储元素；线程安全</li>\n<li><strong>LinkedList，几乎不使用。</strong>要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好****<ul>\n<li>底层使用 双向链表 存储元素（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li>\n<li>在头尾插入或者删除元素不受元素位置的影响，时间复杂度为 <code>O(1)</code>；在指定位置 i 插入和删除元素时间复杂度为 <code>O(n)</code></li>\n<li>不支持高效的随机元素访问</li>\n<li>不同步，线程不安全</li>\n<li>空间花费体现在每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（要存放直接后继和直接前驱以及数据）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Map 没有继承 Collection，而是一个独立的接口。Map 是一种把键对象（Key）和值对象（Value）进行映射的集合，每一个元素都包含了一对键值对（Key，Value）。Map 存储的数据是没有顺序的，键不能重复，值可以重复</strong><ul>\n<li><p><strong>HashMap</strong></p>\n<ul>\n<li>线程不安全的，内部方法没有经过 <code>synchronized</code>修饰</li>\n<li>可以存储 NULL 的 Key 和 Value，但 NULL 作为键只能有一个，NULL 作为值可以有多个</li>\n<li>创建时如果不指定容量初始值，默认的初始化大小为 16，之后每次扩充，容量变为原来的 2 倍；创建时如果给定了容量初始值，会将其扩充为 2 的幂次方大小（<code>tableSizeFor()</code>方法）</li>\n<li>JDK1.8 之前 <code>HashMap</code> 由数组 + 链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）；JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>\n</ul>\n</li>\n<li><p><strong>LinkedHashMap</strong><br><code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑</p>\n</li>\n<li><p><strong>HashTable，基本不使用</strong></p>\n<ul>\n<li>线程安全的，内部方法基本都经过 <code>synchronized</code> 修饰</li>\n<li>不允许 NULL 键和 NULL 值，否则会抛出 <code>NullPointerException</code></li>\n<li>创建时如果不指定容量初始值，默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1；创建时如果给定了容量初始值，那么会直接使用给定的大小</li>\n<li>由数组 + 链表组成的，数组是主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）</li>\n</ul>\n</li>\n<li><p><strong>TreeMap</strong><br>红黑树，**<code>TreeMap</code> 和 <code>HashMap</code> 都继承自 <code>AbstractMap</code> ，但 <code>TreeMap</code> 还实现了 <code>NavigableMap</code> 接口和 <code>SortedMap</code> 接口**</p>\n<ul>\n<li><strong>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</strong></li>\n<li><strong>实现 <code>SortedMap</code> 接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 Key 的升序排序，不过也可以指定排序的比较器</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-2-Synchronized-与-ReentrantLock-的区别\"><a href=\"#3-2-Synchronized-与-ReentrantLock-的区别\" class=\"headerlink\" title=\"3.2 Synchronized 与 ReentrantLock 的区别\"></a>3.2 Synchronized 与 ReentrantLock 的区别</h2><ul>\n<li><strong>相似点：都是加锁方式同步，而且都是阻塞式的同步</strong><br>也就是说当一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）</li>\n<li><strong>功能区别：</strong> 这两种方式最大区别就是对于 Synchronized 来说，它是 Java 语言的关键字，是原生语法层面的互斥，需要 JVM 实现；而 ReentrantLock 是 JDK 1.5 之后提供的 API 层面的互斥锁，需要 <code>lock()</code>和 <code>unlock()</code>方法配合 <code>try/finally</code>语句块来完成</li>\n<li><strong>便利性：</strong> 很明显 Synchronized 的使用比较方便简洁，并且由编译器去保证锁的加锁和释放；而 ReenTrantLock 需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在 finally 中声明释放锁</li>\n<li><strong>锁的细粒度和灵活度：</strong> 很明显 ReenTrantLock 优于 Synchronized</li>\n<li><strong>性能的区别：</strong> 在 Synchronized 优化以前，Synchronized 的性能比 ReenTrantLock 差很多，但是自从 Synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能差不多；在两种方法都可用的情况下，官方甚至建议使用 Synchronized，其实 Synchronized 的优化感觉就借鉴了 ReenTrantLock 中的 CAS 技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞</li>\n</ul>\n<h2 id=\"3-3-造成死锁的原因，出现死锁怎么解决\"><a href=\"#3-3-造成死锁的原因，出现死锁怎么解决\" class=\"headerlink\" title=\"3.3 造成死锁的原因，出现死锁怎么解决\"></a>3.3 造成死锁的原因，出现死锁怎么解决</h2><h3 id=\"3-3-1-产生死锁的四个必要条件\"><a href=\"#3-3-1-产生死锁的四个必要条件\" class=\"headerlink\" title=\"3.3.1 产生死锁的四个必要条件\"></a>3.3.1 产生死锁的四个必要条件</h3><ol>\n<li><strong>互斥性：</strong> 线程对资源的占有是排他性的，一个资源只能被一个线程占有，直到释放</li>\n<li>请求和保持条件：一个线程对请求被占有资源发生阻塞时，对已经获得的资源不释放</li>\n<li>不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用</li>\n<li><strong>循环等待：</strong> 发生死锁时，线程进入死循环，永久阻塞</li>\n</ol>\n<h3 id=\"3-3-2-产生死锁的原因\"><a href=\"#3-3-2-产生死锁的原因\" class=\"headerlink\" title=\"3.3.2 产生死锁的原因\"></a>3.3.2 产生死锁的原因</h3><ol>\n<li><strong>竞争不可抢占性资源</strong><br>p1 已经打开 F1，想去打开 F2；p2 已经打开 F2，想去打开 F1；但是 F1 和 F2 都是不可抢占的，这时发生死锁</li>\n<li><strong>竞争可消耗资源引起死锁</strong><br>进程间通信，如果顺序不当，会产生死锁。比如 p1 发消息 m1 给 p2，p1 接收 p3 的消息 m3；p2 接收 p1 的 m1，发 m2 给 p3，p3 以此类推。如果进程之间是先发信息的那么可以完成通信，但是如果是先接收信息就会产生死锁</li>\n<li><strong>进程推进顺序不当</strong><br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁</li>\n</ol>\n<h3 id=\"3-3-3-死锁预防方法\"><a href=\"#3-3-3-死锁预防方法\" class=\"headerlink\" title=\"3.3.3 死锁预防方法\"></a>3.3.3 死锁预防方法</h3><ol>\n<li><strong>破坏“请求和保持”条件：想办法让进程已经有了资源就不要去竞争那些不可抢占的资源</strong><ul>\n<li>让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些为空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态</li>\n<li>还有一种方法是，要求进程在申请资源前，要释放自己拥有的资源</li>\n</ul>\n</li>\n<li><strong>破坏“不可抢占”条件：允许进程进行抢占</strong><ul>\n<li>方法一：如果去抢资源，被拒绝，就释放自己的资源</li>\n<li>方法二：操作系统允许抢，只要你优先级大，可以抢到</li>\n</ul>\n</li>\n<li><strong>破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出</strong></li>\n</ol>\n<h2 id=\"3-4-volatile-的作用，如何保证可见性\"><a href=\"#3-4-volatile-的作用，如何保证可见性\" class=\"headerlink\" title=\"3.4 volatile 的作用，如何保证可见性?\"></a>3.4 volatile 的作用，如何保证可见性?</h2><p><strong>📌 volatile 作用</strong></p>\n<ol>\n<li><strong>保证内存可见性，可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong><ul>\n<li>解决内存可见性问题方式的一种是加锁，但是使用锁太笨重，因为它会带来线程上下文的切换开销。Java 提供了一种弱形式的同步，也就是 volatile 关键字。该关键字确保对一个变量的更新对其他线程马上可见</li>\n<li>在 Java 中，如果将变量声明为 <strong>volatile</strong> ，这就指示 JVM 这个变量是共享且不稳定的，<strong>线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存，当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值</strong></li>\n<li>volatile 关键字并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果将一个变量使用 volatile 修饰，这就指示编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取</li>\n<li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。Synchronized 关键字两者都能保证</li>\n</ul>\n</li>\n<li><strong>防止指令重排序</strong><br>Java 内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性（如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性）的指令重排序。在单线程下重排序可以保证最终执行结果与程序顺序执行的结果一致，但是在多线程下就会出现问题。为了禁止指令重排序，可以使用 volatile 修饰 initialized 变量</li>\n<li><strong>注意：并不保证原子性</strong></li>\n</ol>\n<h2 id=\"3-5-什么是幂等，如何设计来规避幂等造成的影响\"><a href=\"#3-5-什么是幂等，如何设计来规避幂等造成的影响\" class=\"headerlink\" title=\"3.5 什么是幂等，如何设计来规避幂等造成的影响?\"></a>3.5 什么是幂等，如何设计来规避幂等造成的影响?</h2><p><strong>📌 幂等性：多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</strong></p>\n<p><strong>使用幂等的场景：</strong></p>\n<ol>\n<li><strong>前端重复提交</strong><br>用户注册，用户创建商品等操作，前端都会提交一些数据给后台服务，后台需要根据用户提交的数据在数据库中创建记录。如果用户不小心多点了几次，后端收到了好几次提交，这时就会在数据库中重复创建了多条记录。这就是接口没有幂等性带来的 bug</li>\n<li><strong>接口超时重试</strong><br>1对于给第三方调用的接口，有可能会因为网络原因而调用失败，这时，一般在设计的时候会对接口调用加上失败重试的机制。如果第一次调用已经执行了一半时，发生了网络异常。这时再次调用时就会因为脏数据的存在而出现调用异常</li>\n<li><strong>消息重复消费</strong><ul>\n<li>在使用消息中间件来处理消息队列，且手动 ack 确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列</li>\n<li>当消息被其他消费者重新消费时，如果没有幂等性，就会导致消息重复消费时结果异常，如数据库重复数据，数据库数据冲突，资源重复等</li>\n</ul>\n</li>\n</ol>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li><p><strong>Token 机制实现</strong><br>通过 Token 机制实现接口的幂等性，这是一种比较通用性的实现方法。具体流程步骤：</p>\n<ol>\n<li>客户端会先发送一个请求去获取 Token，服务端会生成一个全局唯一的 ID 作为 Token 保存在 Redis 中，同时把这个 ID 返回给客户端</li>\n<li>客户端第二次调用业务请求的时候必须携带这个 Token</li>\n<li>服务端会校验这个 Token，如果校验成功，则执行业务，并删除 Redis 中的 Token</li>\n<li>如果校验失败，说明 Redis 中已经没有对应的 Token，则表示重复操作，直接返回指定的结果给客户端</li>\n</ol>\n<p><strong>注意：</strong></p>\n<ul>\n<li>对 Redis 中是否存在 Token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性</li>\n<li>全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成</li>\n</ul>\n</li>\n<li><p><strong>基于 MySQL 实现</strong><br>这种实现方式是利用 MySQL 唯一索引的特性。具体流程步骤：</p>\n<ol>\n<li>建立一张去重表，其中某个字段需要建立唯一索引</li>\n<li>客户端去请求服务端，服务端会将这次请求的一些信息插入这张去重表中</li>\n<li>因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑</li>\n<li>如果插入失败，则代表已经执行过当前请求，直接返回</li>\n</ol>\n</li>\n<li><p><strong>基于 Redis 实现</strong><br>这种实现方式是基于 <code>SETNX</code> 命令实现的。<code>SETNX Key Value</code>：将 Key 的值设为 Value ，当且仅当 Key 不存在。若给定的 Key 已经存在，则 SETNX 不做任何动作。该命令在设置成功时返回 1，设置失败时返回 0。具体流程步骤：</p>\n<ol>\n<li>客户端先请求服务端，会拿到一个能代表这次请求业务的唯一字段</li>\n<li>将该字段以 SETNX 的方式存入 Redis 中，并根据业务设置相应的超时时间</li>\n<li>如果设置成功，证明这是第一次请求，则执行后续的业务逻辑</li>\n<li>如果设置失败，则代表已经执行过当前请求，直接返回</li>\n</ol>\n</li>\n</ol>\n<p>这几种实现幂等的方式其实都是大同小异的，类似的还有使用状态机、悲观锁、乐观锁的方式来实现。设计一个接口的时候，幂等都是首要考虑的问题，特别是负责设计转账、支付这种涉及到金额的接口</p>\n<h2 id=\"3-6-hashCode-与-equals-的关系\"><a href=\"#3-6-hashCode-与-equals-的关系\" class=\"headerlink\" title=\"3.6 hashCode() 与 equals() 的关系\"></a>3.6 hashCode() 与 equals() 的关系</h2><p>**📌 不会创建“类对应的散列表”（指不会在 <code>HashSet</code>，<code>HashTable</code>，<code>HashMap</code> 等等这些本质是散列表的数据结构中用到该类），不存在重写 equals() 要重写 hashCode()**。在这种情况下，该类的 <code>hashCode()</code>和 <code>equals()</code>没有任何关系</p>\n<ol>\n<li><code>hashCode()</code>：<code>hashCode()</code>除了打印引用所指向的对象地址看一看，没有任何调用，重写 <code>hashCode()</code>逻辑也没有用，反正没有调用</li>\n<li><code>equals()</code>：<code>equals()</code>用来比较，可以自定义比较逻辑</li>\n<li>关系：<code>hashCode()</code>和 <code>equals()</code>是两个独立方法，没有任何关系，所以不存在重写 <code>equals()</code>要重写 <code>hashCode()</code></li>\n</ol>\n<p>总结：当不在 <code>HashSet</code>，<code>HashTable</code>，<code>HashMap</code> 等等这些本质是散列表的数据结构中用到这个类，此时，<code>equals()</code>用来比较该类的两个对象是否相等，而 <code>hashCode()</code>则根本没有任何作用</p>\n<p>**📌 会创建“类对应的散列表”（即会在 HashSet, HashTable, HashMap 等等这些本质是散列表的数据结构中用到该类），重写 <code>equals()</code>一定要重写 <code>hashCode()</code>**。会创建“类对应的散列表”的情况下，该类的 <code>hashCode()</code>和 <code>equals()</code>是有关系的</p>\n<ol>\n<li>如果两个对象相等，那么它们的 <code>hashCode()</code>值一定相同。这里的“对象相等”是指通过 <code>equals()</code>比较两个对象时返回 true</li>\n<li>如果两个对象 <code>hashCode()</code>相等，它们的 <code>equals()</code>不一定相等。因为在散列表中，<code>hashCode()</code>相等，即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等，此时就出现所谓的哈希冲突场景<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用 HashSet 的情况，重写 equals() 必须重写 hashCode()\nData data1 &#x3D; new Data(1,2);\nData data2 &#x3D; new Data(1,2);\nSet&lt;Data&gt; set &#x3D; new HashSet&lt;&gt;();\nset.add(data1);\nset.add(data2);</code></pre></li>\n</ol>\n<h2 id=\"3-7-过滤器和拦截器的区别\"><a href=\"#3-7-过滤器和拦截器的区别\" class=\"headerlink\" title=\"3.7 过滤器和拦截器的区别\"></a>3.7 过滤器和拦截器的区别</h2><ol>\n<li><strong>过滤器（Filter）：</strong> 是在 Java Web 中将传入的 request、response 提前过滤掉一些信息，或者提前设置一些参数。然后再传入 Servlet 或 Struts2 的 action 进行业务逻辑处理。比如过滤掉非法 url（不是 <code>/login</code>的地址请求，如果用户没有登陆都过滤掉），或者在传入 Servlet 或 Struts2 的 action 前统一设置字符集，或者去除掉一些非法字符<br><strong>当有一堆东西的时候，只希望选择符合要求的某一些东西，定义这些要求的工具，就是过滤器</strong></li>\n<li><strong>拦截器（Interceptor）：</strong> 是面向切面编程（AOP，Aspect Oriented Program）的。就是在 Service 或者一个方法前调用一个方法，或者在方法后调用一个方法。比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作<br><strong>在一个流程正在进行的时候，希望干预它的进展，甚至终止它进行，这是拦截器做的事情</strong></li>\n</ol>\n<p><strong>区别：</strong></p>\n<ol>\n<li>拦截器是基于 Java 的反射机制的，而过滤器是基于函数的回调</li>\n<li>拦截器不依赖于 Servlet 容器，而过滤器依赖于 Servlet 容器</li>\n<li>拦截器只对 action 请求起作用，而过滤器则可以对几乎所有的请求起作用</li>\n<li>拦截器可以访问 action 上下文（ActionContext）、值、栈里面的对象，而过滤器不可以</li>\n<li>在 action 的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次</li>\n<li>拦截器可以获取 IOC 容器中的各个 Bean，而过滤器不行，这点很重要，在拦截器里注入一个 Service，可以调用业务逻辑</li>\n</ol>\n<h2 id=\"3-7-谈谈对-AOP-的理解\"><a href=\"#3-7-谈谈对-AOP-的理解\" class=\"headerlink\" title=\"3.7 谈谈对 AOP 的理解\"></a>3.7 谈谈对 AOP 的理解</h2><p><strong>面向切面编程（AOP），是面向对象的一种补充，它将一些与业务无关，但所有业务模块都会调用的公共逻辑（如事务管理、日志等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度（不通过修改源代码方式，在主干功能里面添加新功能）</strong></p>\n<p><strong>AOP 有两种实现方式：静态代理和动态代理</strong></p>\n<ol>\n<li><strong>静态代理：</strong> 代理类在编译阶段生成，在编译阶段将通知织入 Java 字节码中，也称编译时增强。AspectJ 使用的是静态代理</li>\n<li><strong>动态代理：</strong> 代理类在程序运行时创建，AOP 框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类</li>\n</ol>\n<p><strong>而 Spring AOP 动态代理又有两种实现方式：JDK 动态代理和 CGLIB 动态代理，两种方法同时存在，各有优劣</strong></p>\n<ul>\n<li>JDK 动态代理是由 Java 内部的反射机制来实现的，CGLIB 动态代理底层则是借助 asm 字节码生成框架来实现的</li>\n<li>总的来说，反射机制在生成类的过程中比较高效，而 asm 在生成类之后的相关执行过程中比较高效（可以通过将 asm 生成的类进行缓存，这样解决 asm 生成类过程低效问题）</li>\n<li>动态代理类 JDKProxy，实现 <code>InvocationHandler</code>接口，并且实现接口中的 <code>invoke()</code>方法。当客户端调用代理对象的业务方法时，代理对象执行 <code>invoke()</code>方法，<code>invoke()</code>方法把调用委派给 targetObject，相当于调用目标对象的方法，在 <code>invoke()</code>方法委派前判断权限，实现方法的拦截</li>\n<li>CGLIB 既可以对接口的类生成代理，也可以针对类生成代理</li>\n</ul>\n<h1 id=\"4-美团一面（8-23）\"><a href=\"#4-美团一面（8-23）\" class=\"headerlink\" title=\"4. 美团一面（8-23）\"></a>4. 美团一面（8-23）</h1><h2 id=\"4-1-线程池的几个核心参数介绍一下？\"><a href=\"#4-1-线程池的几个核心参数介绍一下？\" class=\"headerlink\" title=\"4.1 线程池的几个核心参数介绍一下？\"></a>4.1 线程池的几个核心参数介绍一下？</h2><ol>\n<li><strong><code>corePoolSize</code>（核心线程数）</strong><ul>\n<li>核心线程会一直存在，即使没有任务执行</li>\n<li>当线程数小于核心线程数的时候，即使有空闲线程，也会一直创建线程直到达到核心线程数</li>\n<li>设置 allowCoreThreadTimeout&#x3D;true（默认 false）时，核心线程会超时关闭</li>\n</ul>\n</li>\n<li><strong><code>queueCapacity</code>（任务队列容量）：</strong> 也叫阻塞队列，当核心线程都在运行，此时再有任务进来，会进入任务队列，排队等待线程执行</li>\n<li><strong><code>maxPoolSize</code>（最大线程数）</strong><ul>\n<li>线程池里允许存在的最大线程数量</li>\n<li>当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务</li>\n</ul>\n</li>\n<li><strong><code>keepAliveTime</code>（线程空闲时间）</strong><ul>\n<li>当线程空闲时间达到 keepAliveTime 时，线程会退出（关闭），直到线程数等于核心线程数</li>\n<li>如果设置了 allowCoreThreadTimeout&#x3D;true，则线程会退出直到线程数等于零</li>\n</ul>\n</li>\n<li><strong><code>allowCoreThreadTimeout</code>（允许核心线程超时）</strong></li>\n<li><strong><code>rejectedExecutionHandler</code>（任务拒绝处理器）</strong><ul>\n<li>当线程数量达到最大线程数，且任务队列已满时，会拒绝任务</li>\n<li>调用线程池 <code>shutdown()</code>方法后，会等待执行完线程池的任务之后，再 <code>shutdown()</code>。如果在调用了 <code>shutdown()</code>方法和线程池真正 <code>shutdown()</code>之间提交任务，会拒绝新任务</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-2-MySQL-是怎么保证-RR-级别的？\"><a href=\"#4-2-MySQL-是怎么保证-RR-级别的？\" class=\"headerlink\" title=\"4.2 MySQL 是怎么保证 RR 级别的？\"></a>4.2 MySQL 是怎么保证 RR 级别的？</h2><p><strong>📌 主要是依靠两个特性解决， 一个是 MVCC（多版本并发控制），一个是间隙锁</strong></p>\n<ul>\n<li><strong>事务利用 MVCC 进行的读取操作称之为一致性读 ，或者一致性无锁读 ，也称之为快照读（写操作加锁）</strong><br>一个事务在执行过程中只有第一次执行 SELECT 操作才会生成一个 ReadView（快照），之后的 SELECT 操作都复用这个 ReadView， 所以查询结果一样，避免了不可重复读和幻读的问题</li>\n<li><strong>由于 FOR UPDATE 的特性导致查询语句是使用的当前读， 并没有使用快照。 那么快照就不能保证解决幻读问题了。 这时就要使用间隙锁（读写都加锁）</strong><br>假如 SQL 的事务在执行到第一个查询语句的时候， 会加上间隙锁， 锁住的范围是（9，+∞），那么其他的事务无法在这个 ID 范围进行任何的修改和插入操作， 如果操作就会堵塞。这样 MySQL 通过间隙锁的功能解决了幻读问题，但是可以看到<strong>这个代价很大， 仅次于全表写锁</strong></li>\n</ul>\n<p><strong>间隙锁的死锁问题</strong></p>\n<ul>\n<li>正常的读写锁之间存在互斥关系，但是间隙锁与间隙锁之间是不互斥的。 假如一个事务 A 锁住了（0，100）的间隙，那么 B 事务也可以重复获取（0，100）的间隙锁</li>\n<li>上面两个事务都获取了间隙锁， 这个时候如果 A 事务要在这个间隙之间插入一条记录，会阻塞，因为 B 事务间隙锁了， 同样 B 事务也不能操作这个间隙了。 这样就导致了两个线程形成死锁</li>\n<li>这就是 InnoDB 解决幻读的代价</li>\n</ul>\n<h2 id=\"4-3-快照读和当前读的区别？UPDATE-是快照还是当前读？\"><a href=\"#4-3-快照读和当前读的区别？UPDATE-是快照还是当前读？\" class=\"headerlink\" title=\"4.3 快照读和当前读的区别？UPDATE 是快照还是当前读？\"></a>4.3 快照读和当前读的区别？UPDATE 是快照还是当前读？</h2><p><strong>当前读：</strong> 像 SELECT LOCK IN SHARE MODE（共享锁），SELECT FOR UPDATE；UPDATE，INSERT，DELETE（排他锁）这些操作都是⼀种当前读，因为它<strong>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进⾏加锁</strong></p>\n<p><strong>快照读：</strong> 不加锁的 SELECT 操作就是快照读，即不加锁的⾮阻塞读</p>\n<p><strong>快照读的前提是隔离级别不是未提交读和串⾏化级别，因为未提交读总是读取最新的数据⾏，⽽不是符合当前事务版本的数据⾏。⽽串⾏化则会对所有读取的⾏都加锁</strong></p>\n<h2 id=\"4-4-Redis-中的缓存雪崩，缓存击穿，缓存穿透问题都是什么意思？有什么区别？\"><a href=\"#4-4-Redis-中的缓存雪崩，缓存击穿，缓存穿透问题都是什么意思？有什么区别？\" class=\"headerlink\" title=\"4.4 Redis 中的缓存雪崩，缓存击穿，缓存穿透问题都是什么意思？有什么区别？\"></a>4.4 Redis 中的缓存雪崩，缓存击穿，缓存穿透问题都是什么意思？有什么区别？</h2><h3 id=\"4-4-1-缓存雪崩\"><a href=\"#4-4-1-缓存雪崩\" class=\"headerlink\" title=\"4.4.1 缓存雪崩\"></a>4.4.1 缓存雪崩</h3><p>当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是 <strong><strong>缓存雪崩</strong></strong></p>\n<p><strong>📌 大量数据同时过期</strong></p>\n<p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法如下：</p>\n<ol>\n<li><strong>均匀设置过期时间</strong><br>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。可以在对缓存数据设置过期时间时，给这些数据的过期时间加上一个随机数，这样就保证数据不会在同一时间过期</li>\n<li><strong>互斥锁</strong><ul>\n<li>当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li>\n<li>实现互斥锁的时候，最好设置超时时间，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象</li>\n</ul>\n</li>\n<li><strong>双 Key 策略</strong><ul>\n<li>对缓存数据可以使用两个 key，一个是主 key，会设置过期时间，一个是备 key，不会设置过期，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本</li>\n<li>当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，同时更新「主 key 」和「备 key 」的数据</li>\n</ul>\n</li>\n<li><strong>后台更新缓存</strong><ul>\n<li>业务线程不再负责更新缓存，缓存也不设置有效期，而是让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</li>\n<li>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为当系统内存紧张的时候，有些缓存数据会被“淘汰”，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了，解决该问题的方式有两种：<ul>\n<li>后台线程不仅负责定时更新缓存，而且也负责频繁地检测缓存是否有效，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般</li>\n<li>在业务线程发现缓存数据失效后（缓存数据被淘汰），通过消息队列发送一条消息通知后台线程更新缓存，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好</li>\n</ul>\n</li>\n<li>在业务刚上线的时候，最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的缓存预热，后台更新缓存的机制刚好也适合干这个事情</li>\n</ul>\n</li>\n</ol>\n<p><strong>📌 Redis 故障宕机</strong></p>\n<p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法如下：</p>\n<ol>\n<li><strong>服务熔断或请求限流机制</strong><ul>\n<li>由于 Redis 故障宕机而导致缓存雪崩问题时，可以启动服务熔断机制，暂停业务应用对缓存服务的访问，直接返回错误，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务</li>\n<li>服务熔断机制是保护数据库的正常运行，但是暂停了业务应用访问缓存服务，全部业务都无法正常工作</li>\n<li>为了减少对业务的影响，可以启用请求限流机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制</li>\n</ul>\n</li>\n<li><strong>构建 Redis 缓存高可靠集群</strong><ul>\n<li>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，在之前最好通过主从节点的方式构建 Redis 缓存高可靠集群来避免发生缓存雪崩</li>\n<li>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-4-2-缓存击穿\"><a href=\"#4-4-2-缓存击穿\" class=\"headerlink\" title=\"4.4.2 缓存击穿\"></a>4.4.2 缓存击穿</h3><p>业务中通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong></p>\n<p>可以发现缓存击穿跟缓存雪崩很相似，可以认为缓存击穿是缓存雪崩的一个子集。应对缓存击穿可以采取缓存雪崩的两种方案：</p>\n<ul>\n<li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li>\n<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间</li>\n</ul>\n<h3 id=\"4-4-3-缓存穿透\"><a href=\"#4-4-3-缓存穿透\" class=\"headerlink\" title=\"4.4.3 缓存穿透\"></a>4.4.3 缓存穿透</h3><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。当<strong>用户访问的数据，既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。缓存穿透的发生一般有这两种情况：</p>\n<ul>\n<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据</li>\n<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务</li>\n</ul>\n<p>应对缓存穿透的方案，常见的方案如下：</p>\n<ul>\n<li><strong>非法请求的限制</strong><br>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库</li>\n<li><strong>缓存空值或者默认值</strong><br>当线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库</li>\n</ul>\n<h1 id=\"5-Zoom-Java（8-23）\"><a href=\"#5-Zoom-Java（8-23）\" class=\"headerlink\" title=\"5. Zoom Java（8-23）\"></a>5. Zoom Java（8-23）</h1><h2 id=\"5-1-如果想监控线程池的资源，它的源码有没有提供什么方式来实现这个功能？\"><a href=\"#5-1-如果想监控线程池的资源，它的源码有没有提供什么方式来实现这个功能？\" class=\"headerlink\" title=\"5.1 如果想监控线程池的资源，它的源码有没有提供什么方式来实现这个功能？\"></a>5.1 如果想监控线程池的资源，它的源码有没有提供什么方式来实现这个功能？</h2><p>线程池提供了以下几个方法可以监控线程池的使用情况：</p>\n<ol>\n<li><code>getActiveCount()</code>：线程池中正在执行任务的线程数量</li>\n<li><code>getCompletedTaskCount()</code>：线程池已完成的任务数量，该值小于等于 taskCount</li>\n<li><code>getCorePoolSize()</code>：线程池的核心线程数量</li>\n<li><code>getLargestPoolSize()</code>：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了 maximumPoolSize</li>\n<li><code>getMaximumPoolSize()</code>：线程池的最大线程数量</li>\n<li><code>getPoolSize()</code>：线程池当前的线程数量</li>\n<li><code>getTaskCount()</code>：线程池已经执行的和未执行的任务总数</li>\n</ol>\n<p>通过这些方法，可以对线程池进行监控，在 <code>ThreadPoolExecutor</code> 类中提供了几个空方法，如 <code>beforeExecute</code> 方法， <code>afterExecute</code> 方法和 <code>terminated</code> 方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自 ThreadPoolExecutor 来进行扩展</p>\n<h2 id=\"5-2-Redis-哨兵模式和集群模式分别是用来解决什么问题的？\"><a href=\"#5-2-Redis-哨兵模式和集群模式分别是用来解决什么问题的？\" class=\"headerlink\" title=\"5.2 Redis 哨兵模式和集群模式分别是用来解决什么问题的？\"></a>5.2 Redis 哨兵模式和集群模式分别是用来解决什么问题的？</h2><p>哨兵模式就是一个基于主从复制的 Redis 集群解决方案，哨兵模式主要是提高了 Redis 服务的可用性和吞吐量，并不能缓解写压力以及解决缓存数据量过大的问题</p>\n<p>如果缓存的写请求比较多且需要缓存的数据比较大的话，哨兵模式是没办法做到的，这个时候就需要 Redis 的分片集群模式</p>\n<h3 id=\"5-2-1-使用集群模式的话会有什么限制吗？（不同节点上的数据无法使用事务）\"><a href=\"#5-2-1-使用集群模式的话会有什么限制吗？（不同节点上的数据无法使用事务）\" class=\"headerlink\" title=\"5.2.1 使用集群模式的话会有什么限制吗？（不同节点上的数据无法使用事务）\"></a>5.2.1 使用集群模式的话会有什么限制吗？（不同节点上的数据无法使用事务）</h3><ol>\n<li><strong>Key 批量操作支持有限</strong><br>如 mset、mget，目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于执行 mget、mset 等操作可能存在多个节点上，因此不被支持</li>\n<li><strong>Key 事务操作支持有限</strong><br>同理只支持多 Key 在统一节点上的事务操作，当多个 Key 分布在不同的节点上时无法使用事务功能</li>\n<li><strong>Key 作为数据分区的最小粒度读，因此不能将一个大的键值对象如 hash、list 等映射到不同的节点</strong></li>\n<li><strong>不支持多数据空间</strong><br>单机下的 Redis 可以支持 16 个数据库，集群模式下只能使用一个数据库空间，即 DB0</li>\n<li><strong>复制结构仅支持一层，从节点只能复制主节点，不支持嵌套梳妆复制结构</strong></li>\n</ol>\n<h3 id=\"5-2-2-如果想使用事务操作的话，希望-Key-能分布在一个节点上，有没有什么办法可以让-Key-分布在同一个节点上？（Redis-提供了这样的功能-hashtag）\"><a href=\"#5-2-2-如果想使用事务操作的话，希望-Key-能分布在一个节点上，有没有什么办法可以让-Key-分布在同一个节点上？（Redis-提供了这样的功能-hashtag）\" class=\"headerlink\" title=\"5.2.2 如果想使用事务操作的话，希望 Key 能分布在一个节点上，有没有什么办法可以让 Key 分布在同一个节点上？（Redis 提供了这样的功能 hashtag）\"></a>5.2.2 如果想使用事务操作的话，希望 Key 能分布在一个节点上，有没有什么办法可以让 Key 分布在同一个节点上？（Redis 提供了这样的功能 hashtag）</h3><p>想在集群环境下批量操作多个 Key，只有这些 Key 处在同一个节点下才会生效。只要<strong>在 Key 的前面加上一个相同的部分并用花括号括起来然后和后面真正的 Key 间隔一个字符即可</strong>，则前面的这个花括号部分为 hashtags 顾名思义就是用来计算 hash 落点的部分，<strong>有效 Key 为间隔一个字符之后的 Key</strong></p>\n<h2 id=\"5-3-Redis-用到了哪些数据结构？\"><a href=\"#5-3-Redis-用到了哪些数据结构？\" class=\"headerlink\" title=\"5.3 Redis 用到了哪些数据结构？\"></a>5.3 Redis 用到了哪些数据结构？</h2><table>\n  <tr> <th>对象</th> <th>编码</th> <th>数据结构</th> </tr>\n  <tr> <td rowspan=\"3\"> string(字符串对象)</td> <td> int </td> <td> 可以存储 long 类型的整数 </td> </tr>\n  <tr> <td> embstr </td> <td> embstr 编码的简单动态字符串 </td> </tr>\n  <tr> <td> row </td> <td> 简单动态字符串（SDS） </td> </tr>\n  <tr> <td rowspan=\"2\"> list（列表对象） </td> <td> ziplist </td> <td> 压缩列表 </td> </tr>\n  <tr> <td> linkedisk </td> <td> 双端链表 </td> </tr>\n  <tr> <td rowspan=\"2\"> hash（哈希对象） </td> <td> ziplist </td> <td> 压缩列表 </td> </tr>\n  <tr> <td> hashtable </td> <td> 字典 </td> </tr>\n  <tr> <td rowspan=\"2\"> set（集合对象） </td> <td> intset </td> <td> 整数集合 </td> </tr>\n  <tr> <td> hashtable </td> <td> 字典 </td> </tr>\n  <tr> <td rowspan=\"2\"> zset（有序集合对象） </td> <td> ziplist </td> <td> 压缩列表 </td> </tr>\n  <tr> <td> skiplist </td> <td> 字典 + 跳跃表 </td> </tr>\n</table>\n\n<h3 id=\"5-3-1-zset-的底层数据结构有没有了解过？\"><a href=\"#5-3-1-zset-的底层数据结构有没有了解过？\" class=\"headerlink\" title=\"5.3.1 zset 的底层数据结构有没有了解过？\"></a>5.3.1 zset 的底层数据结构有没有了解过？</h3><ul>\n<li><strong>压缩列表（ziplist）：</strong> ziplist 是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在 <code>O(1)</code> 的时间复杂度下完成 list 两端的 push 和 pop 操作。但是因为每次操作都需要重新分配 ziplist 的内存，所以实际复杂度和 ziplist 的内存使用量相关</li>\n<li><strong>跳跃表（skiplist）：</strong>  跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是 O(log(n))</li>\n</ul>\n<h3 id=\"5-3-2-为什么-zset-要在数据比较小的时候使用压缩列表呢，压缩列表是一个什么样的数据结构，能带来什么好处呢？\"><a href=\"#5-3-2-为什么-zset-要在数据比较小的时候使用压缩列表呢，压缩列表是一个什么样的数据结构，能带来什么好处呢？\" class=\"headerlink\" title=\"5.3.2 为什么 zset 要在数据比较小的时候使用压缩列表呢，压缩列表是一个什么样的数据结构，能带来什么好处呢？\"></a>5.3.2 为什么 zset 要在数据比较小的时候使用压缩列表呢，压缩列表是一个什么样的数据结构，能带来什么好处呢？</h3><p>因为 Redis 中的集合容器中，很多情况都用到了链表的实现，元素和元素之间通过储存的关联指针有序的串联起来，但是这样的指针往往是  <strong>随机 I&#x2F;O</strong> ，也就是指针地址是不连续的（分布不均匀）。而 ziplist 它本身是一块连续的内存块，所以它的读写是  <strong>顺序 I&#x2F;O</strong> ，从底层的磁盘读写来说，<strong>顺序 I&#x2F;O</strong> 的效率肯定是高于 <strong>随机 I&#x2F;O</strong></p>\n<p>那为什么不都用 <strong>顺序 I&#x2F;O</strong> 的 ziplist 代替 <strong>随机 I&#x2F;O</strong> 呢？因为 ziplist 是连续内存，当元素数量多了，意味着创建和扩展的时候需要操作更多的内存，所以 ziplist 针对元素少的时候才能提升效率</p>\n<h3 id=\"5-3-3-Redis-的-rehash-有了解过吗，是怎么进行-rehash-的？\"><a href=\"#5-3-3-Redis-的-rehash-有了解过吗，是怎么进行-rehash-的？\" class=\"headerlink\" title=\"5.3.3 Redis 的 rehash 有了解过吗，是怎么进行 rehash 的？\"></a>5.3.3 Redis 的 rehash 有了解过吗，是怎么进行 rehash 的？</h3><p>在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部 rehash 到 ht[1]的话，可能会导致服务器在一段时间内停止服务。所以，采用渐进式 rehash 的方式，详细步骤如下：</p>\n<ol>\n<li>为 ht[1]分配空间，让字典同时持有 ht[0]和 ht[1]两个哈希表</li>\n<li>将 rehashindex 的值设置为 0，表示 rehash 工作正式开始</li>\n<li>在 rehash 期间，每次对字典执行增删改查操作时，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashindex 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成以后，rehashindex 的值 +1</li>\n<li>随着字典操作的不断执行，最终会在某一时间段上 ht[0] 的所有键值对都会被 rehash 到 ht[1]，这时将 rehashindex 的值设置为-1，表示 rehash 操作结束</li>\n</ol>\n<p>渐进式 rehash 采用的是一种分而治之的方式，将 rehash 的操作分摊在每一个的访问中，避免集中式 rehash 而带来的庞大计算量</p>\n<p>需要注意的是在渐进式 rehash 的过程，如果有增删改查操作时，如果 index 大于 rehashindex，访问 ht[0]，否则访问 ht[1]</p>\n<h2 id=\"5-4-Java-线程有哪几种状态，以及状态之间如何转换的？\"><a href=\"#5-4-Java-线程有哪几种状态，以及状态之间如何转换的？\" class=\"headerlink\" title=\"5.4 Java 线程有哪几种状态，以及状态之间如何转换的？\"></a>5.4 Java 线程有哪几种状态，以及状态之间如何转换的？</h2><ol>\n<li><p><strong>新建（New）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Thread state for a thread which has not yet started.<br>尚未启动的线程的线程状态</p></blockquote>\n<p>New 表示线程被创建但尚未启动的状态：当用 <code>new Thread()</code> 新建一个线程时，如果线程<strong>没有开始运行 <code>start()</code> 方法，所以也没有开始执行 <code>run()</code> 方法里面的代码</strong>，那么此时它的状态就是 New。而一旦线程调用了 <code>start()</code>，它的状态就会从 New 变成 Runnable</p>\n</li>\n<li><p><strong>可运行（Runnable）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.<br>可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自操作系统的其他资源，例如处理器</p></blockquote>\n<p>从 JVM 的角度来看，处于 Runnable 状态的线程正在执行，但实际上它可能正在等待来自操作系统的一些资源，例如处理器。该状态可以被认为是具有 Ready（就绪） 和 Running（运行）两个子状态的复合状态。当线程转换到 Runnable 状态时，线程首先进入 Ready 子状态。线程调度决定线程何时可以实际开始 Running。 <code>Thread.yield()</code> 明确建议线程调度程序暂停当前正在执行的线程以允许其他线程执行。如果线程已启动且尚未死亡，则线程处于活动状态</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>A thread in the <strong>Runnable</strong> state is executing from the JVM’s point of view but in fact it may be waiting for some resources from the OS such as processor. This state could be considered as a composite state with two substates. When a thread transitions to the Runnable state, the thread first goes into the <strong>Ready</strong> substate. Thread scheduling decides when the thread could actually start  <strong>Running</strong> . Thread.yield() is explicit recommendation to thread scheduler to pause the currently executing thread to allow some other thread to execute. Thread is <strong>alive</strong> if it has been started and has not yet died.</p></blockquote>\n<ul>\n<li><p><strong>Ready（就绪）</strong><br>当线程对象<strong>调用了 <code>start()</code> 方法之后，线程处于就绪状态</strong> ，就绪意味着该线程可以执行，但具体什么时候执行将取决于 JVM 里线程调度器的调度</p>\n<ul>\n<li>不允许对一个线程多次使用 <code>start()</code></li>\n<li>线程执行完成之后，不能试图用 <code>start()</code> 将其唤醒</li>\n</ul>\n<p>其他状态 –&gt; 就绪</p>\n<ul>\n<li>线程调用 <code>start()</code>，新建状态转化为就绪状态</li>\n<li>线程 <code>sleep(long)</code> 时间到，等待状态转化为就绪状态</li>\n<li>阻塞式 IO 操作结果返回，线程变为就绪状态</li>\n<li>其他线程调用 <code>join()</code> 方法，结束之后转化为就绪状态</li>\n<li>线程对象拿到对象锁之后，也会进入就绪状态</li>\n</ul>\n</li>\n<li><p><strong>Running（运行）</strong><br>处于就绪状态的线程<strong>获得了 CPU 之后， 真正开始执行 <code>run()</code> 方法的线程执行体时，意味着该线程就已经处于运行状态</strong>。需要注意的是，对于单处理器，一个时刻只能有一个线程处于运行状态。对于抢占式策略的系统来说，系统会给每个线程一小段时间处理各自的任务。时间用完之后，系统负责夺回线程占用的资源。下一段时间里，系统会根据一定规则，再次进行调度</p>\n<p>运行状态 –&gt; 就绪状态，线程失去处理器资源。线程不一定完整执行，执行到一半，说不定就被别的线程抢走了。调用 <code>yield()</code>静态方法，暂时暂停当前线程，等待系统的线程调度器重新调度</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.<br>向调度程序提示当前线程愿意放弃其当前对处理器的使用。调度程序可以随意忽略此提示。</p></blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>阻塞（Blocked）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block&#x2F;method or reenter a synchronized block&#x2F;method after calling Object.wait.<br>线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块方法或调用 <code>Object.wait()</code> 后重新进入同步块方法</p></blockquote>\n<p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态</p>\n<ul>\n<li>Synchronized：线程等待进入 Synchronized 同步方法、线程等待进入 Synchronized 同步代码块</li>\n<li>Lock：线程等待进入 Lock 同步段</li>\n</ul>\n<p>线程取得锁，就会从阻塞状态转变为就绪状态</p>\n</li>\n<li><p><strong>无限期等待（Waiting）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:<br>等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：</p></blockquote>\n<ul>\n<li>没有设置 Timeout 参数的 <code>Object.wait()</code> 方法</li>\n<li>没有设置 Timeout 参数的 <code>Thread.join()</code> 方法</li>\n<li><code>LockSupport.park()</code> 方法</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>A thread in the waiting state is waiting for another thread to perform a particular action. For example, a thread that has called Object.wait() on an object is waiting for another thread to call Object.notify() or Object.notifyAll() on that object. A thread that has called Thread.join() is waiting for a specified thread to terminate.<br>处于等待状态的线程正在等待另一个线程执行特定操作。例如，一个对对象调用 <code>Object.wait()</code> 的线程正在等待另一个线程对该对象调用 <code>Object.notify()</code> 或 <code>Object.notifyAll()</code>。已调用 <code>Thread.join()</code> 的线程正在等待指定线程终止</p></blockquote>\n<p><code>LockSupport.unpark(Thread)</code>，与上面 <code>park()</code> 方法对应，给出许可证， 解除等待状态</p>\n</li>\n<li><p><strong>限期等待（Timed Waiting）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:<br>具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定时等待状态：</p></blockquote>\n<ul>\n<li><code>Thread.sleep()</code> 方法时间结束。调用 <code>Thread.sleep()</code> 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述</li>\n<li>设置了 Timeout 参数的 <code>Object.wait()</code> 方法时间结束。调用 <code>Object.wait()</code> 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述</li>\n</ul>\n<p><strong>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 <code>Thread.sleep()</code> 和 <code>Object.wait()</code> 等方法进入</strong></p>\n<ul>\n<li>设置了 Timeout 参数的 <code>Thread.join()</code> 方法时间结束</li>\n<li><code>LockSupport.parkNanos()</code> 方法</li>\n<li><code>LockSupport.parkUntil()</code> 方法</li>\n</ul>\n</li>\n<li><p><strong>终止（Terminated）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Thread state for a terminated thread. The thread has completed execution.<br>已终止线程的线程状态。线程已完成执行</p></blockquote>\n<p>可以是线程结束任务之后自己结束，或者产生了异常而结束</p>\n</li>\n</ol>\n<p><strong><code>sleep()</code> 和 <code>yield()</code> 的区别：</strong><br><code>sleep(long)</code> 方法会使线程转入超时等待状态 ，时间到了之后才会转入就绪状态。而 <code>yield()</code> 方法不会将线程转入等待，而是强制线程进入就绪状态。使用 <code>sleep(long)</code> 方法需要处理异常，而 <code>yield()</code> 不用</p>\n<p><strong>线程转换</strong></p>\n<ul>\n<li>线程的状态是需要一步步走的，比如线程从 New 状态不可以直接进入 Blocked 状态，它需要先经历 Runnable 状态</li>\n<li>线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换</li>\n</ul>\n<h2 id=\"5-5-线程中断有没有了解过？\"><a href=\"#5-5-线程中断有没有了解过？\" class=\"headerlink\" title=\"5.5 线程中断有没有了解过？\"></a>5.5 线程中断有没有了解过？</h2><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。线程中断最重要的 3 个方法，它们都是来自 Thread 类！</p>\n<ol>\n<li><strong>java.lang.Thread#interrupt</strong><br>中断目标线程，给目标线程发一个中断信号，线程被打上中断标</li>\n<li><strong>java.lang.Thread#isInterrupted()</strong><br>判断目标线程是否被中断，不会清除中断标记</li>\n<li><strong>java.lang.Thread#interrupted</strong><br>判断目标线程是否被中断，会清除中断标记</li>\n</ol>\n<h2 id=\"5-6-Java-中有什么无锁操作的方式？\"><a href=\"#5-6-Java-中有什么无锁操作的方式？\" class=\"headerlink\" title=\"5.6 Java 中有什么无锁操作的方式？\"></a>5.6 Java 中有什么无锁操作的方式？</h2><ol>\n<li><p><strong>原子工具类</strong><br>JDK 1.8 中，<code>java.util.concurrent.atomic</code> 包下类都是原子类，原子类都是基于 <code>sun.misc.Unsafe</code> 实现的</p>\n<ul>\n<li><p>CPU 为了解决并发问题，提供了 CAS 指令，全称 Compare And Swap，即比较并交互</p>\n</li>\n<li><p>CAS 指令需要 3 个参数，变量、比较值、新值。当变量的当前值与比较值相等时，才把变量更新为新值</p>\n</li>\n<li><p>CAS 是一条 CPU 指令，由 CPU 硬件级别上保证原子性</p>\n</li>\n<li><p><code>java.util.concurrent.atomic</code> 包中的原子分为：原子性基本数据类型、原子性对象引用类型、原子性数组、原子性对象属性更新器和原子性累加器</p>\n<ul>\n<li><strong>原子性基本数据类型</strong> ：<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code></li>\n<li><strong>原子性对象引用类型</strong> ：<code>AtomicReference</code>、<code>AtomicStampedReference</code>、<code>AtomicMarkableReference</code></li>\n<li><strong>原子性数组</strong> ：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code></li>\n<li><strong>原子性对象属性更新</strong> ：<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicReferenceFieldUpdater</code></li>\n<li><strong>原子性累加器</strong> ：<code>DoubleAccumulator</code>、<code>DoubleAdder</code>、<code>LongAccumulator</code>、<code>LongAdder</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>线程本地存储</strong></p>\n<ul>\n<li><code>java.lang.ThreadLocal</code> 类用于线程本地化存储</li>\n<li>线程本地化存储，就是为每一个线程创建一个变量，只有本线程可以在该变量中查看和修改值</li>\n<li>典型的使用例子就是，Spring 在处理数据库事务问题的时候，就用了 ThreadLocal 为每个线程存储了各自的数据库连接 Connection</li>\n<li>使用 ThreadLocal 要注意，在不使用该变量的时候，一定要调用 <code>remove()</code> 方法移除变量，否则可能造成内存泄漏的问题</li>\n</ul>\n</li>\n<li><p><strong>copy-on-write（需要写时复制）</strong></p>\n<ul>\n<li>体现的是一种延时策略</li>\n<li>Java 中的 copy-on-write 容器包括：<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code></li>\n<li>涉及到数组的全量复制，所以也比较耗内存，在写少的情况下使用比较适合</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-7-ThreadLocal-的基本原理是什么？\"><a href=\"#5-7-ThreadLocal-的基本原理是什么？\" class=\"headerlink\" title=\"5.7 ThreadLocal 的基本原理是什么？\"></a>5.7 ThreadLocal 的基本原理是什么？</h2><p>ThreadLocal 每个线程都有一个 ThreadLocalMap 结构，其中就保存着当前线程所持有的所有 ThreadLocal。ThreadLocal 本身只是一个引用，没有直接保存值，值是保存在 ThreadLocalMap 中，ThreadLocal 作为 key，值作为 value</p>\n<h2 id=\"5-8-Java-的泛型了解吗？\"><a href=\"#5-8-Java-的泛型了解吗？\" class=\"headerlink\" title=\"5.8 Java 的泛型了解吗？\"></a>5.8 Java 的泛型了解吗？</h2><ul>\n<li>Java 泛型是 JDK5 中引入的一个新特性，使用泛型参数，可以增强代码的可读性以及稳定性</li>\n<li>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型</li>\n<li><strong>但是 Java 的泛型是伪泛型，这是因为在 Java 编译期间，所有的泛型信息都会被擦掉，这也就是通常所说的类型擦除</strong>，编译器会在编译期间会动态地将泛型 T 擦除为 Object 或将 T extends xxxx 擦除为限定类型 XXX</li>\n<li>因此，泛型本质上其实还是编译器的行为，为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销，编译器通过擦除将泛型类转化为一般类</li>\n</ul>\n<h2 id=\"5-9-类-Dog-继承于-类-Animal，那么-List-lt-Dog-gt-能否赋值给-List-lt-Animal-gt\"><a href=\"#5-9-类-Dog-继承于-类-Animal，那么-List-lt-Dog-gt-能否赋值给-List-lt-Animal-gt\" class=\"headerlink\" title=\"5.9 类 Dog 继承于 类 Animal，那么 List&lt;Dog&gt; 能否赋值给 List&lt;Animal&gt;?\"></a>5.9 类 Dog 继承于 类 Animal，那么 <code>List&lt;Dog&gt;</code> 能否赋值给 <code>List&lt;Animal&gt;</code>?</h2><p>不能，数组在运行时可以获取自身类型，而 List 在运行时只能知道自己是一个 List，而无法获取参数类型。这说明 Java 的泛型其实是泛型擦除，也就是伪泛型</p>\n<p>这里也涉及到一个关键点，Java 的数组是协变的，而 List 是不变的。<strong>协变的意思就是 任意类 A 和 B，若 A 是 B 的父类，则 A[] 也是 B[] 的父类</strong>。如果给数组加上泛型，就会无法满足协变原则，因为无法在运行时知道数组的类型。所以 <strong>Java 是无法声明泛型数组的</strong></p>\n<h2 id=\"5-10-说说数据库的索引\"><a href=\"#5-10-说说数据库的索引\" class=\"headerlink\" title=\"5.10 说说数据库的索引\"></a>5.10 说说数据库的索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+ 树和 Hash</strong></p>\n<p>索引的作用就相当于书的目录。打个比方：在查字典的时候，如果没有目录，那就只能一页一页的去找需要查的那个字，速度很慢。如果有目录了，只需要先去目录里查找字的位置，然后直接翻到那一页就行了</p>\n<h2 id=\"5-11-聚簇索引和非聚簇索引能介绍一下吗？\"><a href=\"#5-11-聚簇索引和非聚簇索引能介绍一下吗？\" class=\"headerlink\" title=\"5.11 聚簇索引和非聚簇索引能介绍一下吗？\"></a>5.11 聚簇索引和非聚簇索引能介绍一下吗？</h2><p>部分可见 1.8。<strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引</strong>。在 MySQL 中，InnoDB 引擎的表的 .ibd 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引（B+ 树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据</p>\n<p><strong>📌 聚集索引的优点</strong></p>\n<p>聚集索引的查询速度非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据</p>\n<p><strong>📌 聚集索引的缺点</strong></p>\n<ol>\n<li><strong>依赖于有序的数据</strong> ：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢</li>\n<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li>\n</ol>\n<p><strong>非聚集索引即索引结构和数据分开存放的索引，二级索引属于非聚集索引。</strong> 非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</p>\n<p><strong>📌 非聚集索引的优点</strong></p>\n<p>更新代价比聚集索引要小。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>\n<p><strong>📌 非聚集索引的缺点</strong></p>\n<ol>\n<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>\n<li><strong>可能会二次查询(回表)</strong> ：这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li>\n</ol>\n<h2 id=\"5-12-哪些类-Spring-会帮我们管理呢？\"><a href=\"#5-12-哪些类-Spring-会帮我们管理呢？\" class=\"headerlink\" title=\"5.12 哪些类 Spring 会帮我们管理呢？\"></a>5.12 哪些类 Spring 会帮我们管理呢？</h2><p>Spring 是单例模式，常将 Controller、Service、Dao 中的类交给容器管理，是因为这些类在程序运行的整个周期中只需要被实例化一次。这些类一般都不具有一些状态信息，是无状态的，且生命周期与程序的生命周期相同，可称之为“功能类”</p>\n<p><strong>而实体类是要保存状态信息的，实体类的生命周期往往很短且不可被共享的，所以实体类往往都不交给容器来进行管理，可称之为“状态类”</strong></p>\n<h2 id=\"5-13-Spring-中为什么要将-bean-交给-Spring-来管理？\"><a href=\"#5-13-Spring-中为什么要将-bean-交给-Spring-来管理？\" class=\"headerlink\" title=\"5.13 Spring 中为什么要将 bean 交给 Spring 来管理？\"></a>5.13 Spring 中为什么要将 bean 交给 Spring 来管理？</h2><p>Spring 框架是一个资源管理整合框架，可以将自己写的对象或者是第三方提供的对象（连接池等）整合到一起。在使用 Spring 的 bean 对象时，会遇到两种情况：</p>\n<ul>\n<li>一是这个对象会用到很多次，频繁的使用，Spring 提供了懒加载（<code>@Lazy</code>）策略，必须跟作用域 singleton 联合使用，这种情况下，会把这个对象存到 bean 池中，内存中只有一份，并且一直存在，直到 bean 池销毁<br>当 bean 具有单例作用域（默认 singleton）时，Spring 只创建一个实例并在整个应用程序中共享它。单例是<strong>无状态对象</strong>的完美选择。如今的应用程序中的绝大多数 bean 都是无状态单例</li>\n<li>二是这个对象可能只会用到一次或者是寥寥几次，这个时候就没有必要让他一直存在到内存中，可以将作用域设置为 prototype，在每次调用的时候创建一次 ，用完销毁。因此，使用 Spring 管理 bean 对象可以实现对象对资源的有效使用</li>\n</ul>\n<p><strong>相关注解</strong></p>\n<ul>\n<li><code>@Lazy</code>：用于描述类，用来告诉 Spring 此类可以支持延迟加载，通常配合作用域 singleton 使用</li>\n<li><code>@Scope</code>：用于定义作用域，默认是 singleton，当定义为 prototype 时，每次获取对象都会创建一个新的实例，并且不会交给 Spring 管理，Spring 可以对它进行初始化，但不能销毁</li>\n<li><code>@PostConstruct</code>：注解用于描述 bean 对象生命周期方法中的初始化方法，此方法会在对象的构造方法之后执行（是对象创建以后的初始化）</li>\n<li><code>@PreDestroy</code>：注解用于描述 Bean 对象生命周期方法中的销毁方法，此方法会在对象销毁之前执行（当作用域为 prototype 时，此方法不会执行）</li>\n</ul>\n<h2 id=\"5-14-为什么使用-Cookie-会导致-CSRF-攻击，而-JWT-能避免？\"><a href=\"#5-14-为什么使用-Cookie-会导致-CSRF-攻击，而-JWT-能避免？\" class=\"headerlink\" title=\"5.14 为什么使用 Cookie 会导致 CSRF 攻击，而 JWT 能避免？\"></a>5.14 为什么使用 Cookie 会导致 CSRF 攻击，而 JWT 能避免？</h2><p>CSRF 攻击需要依赖 Cookie ，Session 认证中 Cookie 中的 SessionID 是由浏览器发送到服务端的，<strong>只要发出请求，Cookie 就会被携带。借助这个特性，即使黑客无法获取你的 SessionID，只要让你误点攻击链接，就可以达到攻击效果</strong>。另外，并不是必须点击链接才可以达到攻击效果，很多时候，只要你打开了某个页面，CSRF 攻击就会发生</p>\n<p>一般情况下使用 JWT 的话，在登录成功获得 JWT 之后，一般会选择存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。因此，即使你点击了非法链接发送了请求到服务端，这个非法请求也是不会携带 JWT 的，所以这个请求将是非法的</p>\n<p>总结来说就是：<strong>使用 JWT 进行身份验证不需要依赖 Cookie ，因此可以避免 CSRF 攻击。</strong> 不过，这样也会存在 XSS 攻击的风险。为了避免 XSS 攻击，你可以选择将 JWT 存储在标记为 httpOnly 的 Cookie 中。但是，这样又导致了你必须自己提供 CSRF 保护，因此，实际项目中我们通常也不会这么做。常见的避免 XSS 攻击的方式是过滤掉请求中存在 XSS 攻击风险的可疑字符串</p>\n","feature":true,"text":"1. 百度 Java 后端一面（8-21）1.1 进程和线程的区别是什么？线程隶属于进程。进程是操作系统进行资源分配的最小单元，线程是操作系统进行任务分配的最小单元 1.2 进程通信与线程通信的方式有什么？ 管道（pipe）管道是一种半双工（即可以在一个信号载体的两个方向上传输，...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"29 mins."},"categories":[{"name":"面试","slug":"面试","count":2,"path":"api/categories/面试.json"}],"tags":[{"name":"面经","slug":"面经","count":1,"path":"api/tags/面经.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E7%99%BE%E5%BA%A6-Java-%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2%EF%BC%888-21%EF%BC%89\"><span class=\"toc-text\">1. 百度 Java 后端一面（8-21）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.1 进程和线程的区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.2 进程通信与线程通信的方式有什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">1.3 TCP 的三次握手和四次挥手</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-TCP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%8E%E6%98%AF%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%EF%BC%9F\"><span class=\"toc-text\">1.4 TCP 客户端四次挥手后是什么状态？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%EF%BC%8C%E9%9A%8F%E5%A4%84%E8%BF%90%E8%A1%8C%EF%BC%9F\"><span class=\"toc-text\">1.5 如何理解一次编写，随处运行？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-JVM-%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93-New-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A6%81%E5%A4%9A%E5%A4%A7%E5%86%85%E5%AD%98%EF%BC%9F\"><span class=\"toc-text\">1.6 JVM 如何知道 New 一个对象要多大内存？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-JVM-%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F\"><span class=\"toc-text\">1.7 JVM 堆内存不够如何解决？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">1.8 聚集索引和非聚集索引都有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-9-Redis-%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">1.9 Redis 的缓存读写一致策略</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%BF%AB%E6%89%8B-Java-%E5%BC%80%E5%8F%91%E4%B8%80%E9%9D%A2%EF%BC%888-23%EF%BC%89\"><span class=\"toc-text\">2. 快手 Java 开发一面（8-23）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-RabbitMQ-%E7%9A%84%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">2.1 RabbitMQ 的架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-Exchange-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.2 Exchange 交换机类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%80%8E%E4%B9%88%E5%8E%BB%E5%86%8D%E6%AC%A1%E6%B6%88%E8%B4%B9\"><span class=\"toc-text\">2.3 消费者消费失败怎么处理，消费者怎么去再次消费?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">2.4 消息队列持久化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-MySQL-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.5 MySQL 有哪些存储引擎，它们有什么区别?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-InnoDB-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81\"><span class=\"toc-text\">2.6 InnoDB 中有哪些锁?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-TCP-x2F-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.7 TCP&#x2F;IP 四层模型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E5%90%8E%E7%AB%AF-Java\"><span class=\"toc-text\">3. 招银网络后端 Java</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E4%BB%8B%E7%BB%8D-List-%E5%92%8C-Map-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88ArrayList%E3%80%81LinkedList%E3%80%81HashMap-%E2%80%A6%EF%BC%89\"><span class=\"toc-text\">3.1 介绍 List 和 Map 的数据结构（ArrayList、LinkedList、HashMap …）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Synchronized-%E4%B8%8E-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3.2 Synchronized 与 ReentrantLock 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%87%BA%E7%8E%B0%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">3.3 造成死锁的原因，出现死锁怎么解决</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">3.3.1 产生死锁的四个必要条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">3.3.2 产生死锁的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-3-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.3.3 死锁预防方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-volatile-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">3.4 volatile 的作用，如何保证可见性?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%9D%A5%E8%A7%84%E9%81%BF%E5%B9%82%E7%AD%89%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">3.5 什么是幂等，如何设计来规避幂等造成的影响?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-hashCode-%E4%B8%8E-equals-%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">3.6 hashCode() 与 equals() 的关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3.7 过滤器和拦截器的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-%E8%B0%88%E8%B0%88%E5%AF%B9-AOP-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">3.7 谈谈对 AOP 的理解</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2%EF%BC%888-23%EF%BC%89\"><span class=\"toc-text\">4. 美团一面（8-23）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F\"><span class=\"toc-text\">4.1 线程池的几个核心参数介绍一下？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81-RR-%E7%BA%A7%E5%88%AB%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">4.2 MySQL 是怎么保证 RR 级别的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FUPDATE-%E6%98%AF%E5%BF%AB%E7%85%A7%E8%BF%98%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%9F\"><span class=\"toc-text\">4.3 快照读和当前读的区别？UPDATE 是快照还是当前读？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-Redis-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">4.4 Redis 中的缓存雪崩，缓存击穿，缓存穿透问题都是什么意思？有什么区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-1-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9\"><span class=\"toc-text\">4.4.1 缓存雪崩</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF\"><span class=\"toc-text\">4.4.2 缓存击穿</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-3-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\"><span class=\"toc-text\">4.4.3 缓存穿透</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Zoom-Java%EF%BC%888-23%EF%BC%89\"><span class=\"toc-text\">5. Zoom Java（8-23）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E5%A6%82%E6%9E%9C%E6%83%B3%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%B5%84%E6%BA%90%EF%BC%8C%E5%AE%83%E7%9A%84%E6%BA%90%E7%A0%81%E6%9C%89%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9B%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%AA%E5%8A%9F%E8%83%BD%EF%BC%9F\"><span class=\"toc-text\">5.1 如果想监控线程池的资源，它的源码有没有提供什么方式来实现这个功能？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-Redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%88%86%E5%88%AB%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">5.2 Redis 哨兵模式和集群模式分别是用来解决什么问题的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-1-%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%9D%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9F%EF%BC%88%E4%B8%8D%E5%90%8C%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%EF%BC%89\"><span class=\"toc-text\">5.2.1 使用集群模式的话会有什么限制吗？（不同节点上的数据无法使用事务）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-2-%E5%A6%82%E6%9E%9C%E6%83%B3%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%B8%8C%E6%9C%9B-Key-%E8%83%BD%E5%88%86%E5%B8%83%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%8A%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%A9-Key-%E5%88%86%E5%B8%83%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%8A%EF%BC%9F%EF%BC%88Redis-%E6%8F%90%E4%BE%9B%E4%BA%86%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8A%9F%E8%83%BD-hashtag%EF%BC%89\"><span class=\"toc-text\">5.2.2 如果想使用事务操作的话，希望 Key 能分布在一个节点上，有没有什么办法可以让 Key 分布在同一个节点上？（Redis 提供了这样的功能 hashtag）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-Redis-%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F\"><span class=\"toc-text\">5.3 Redis 用到了哪些数据结构？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-1-zset-%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%EF%BC%9F\"><span class=\"toc-text\">5.3.1 zset 的底层数据结构有没有了解过？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88-zset-%E8%A6%81%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83%E5%B0%8F%E7%9A%84%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%91%A2%EF%BC%8C%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">5.3.2 为什么 zset 要在数据比较小的时候使用压缩列表呢，压缩列表是一个什么样的数据结构，能带来什么好处呢？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-3-Redis-%E7%9A%84-rehash-%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%8C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C-rehash-%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">5.3.3 Redis 的 rehash 有了解过吗，是怎么进行 rehash 的？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-Java-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">5.4 Java 线程有哪几种状态，以及状态之间如何转换的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%EF%BC%9F\"><span class=\"toc-text\">5.5 线程中断有没有了解过？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-Java-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">5.6 Java 中有什么无锁操作的方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-7-ThreadLocal-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">5.7 ThreadLocal 的基本原理是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-8-Java-%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">5.8 Java 的泛型了解吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-9-%E7%B1%BB-Dog-%E7%BB%A7%E6%89%BF%E4%BA%8E-%E7%B1%BB-Animal%EF%BC%8C%E9%82%A3%E4%B9%88-List-lt-Dog-gt-%E8%83%BD%E5%90%A6%E8%B5%8B%E5%80%BC%E7%BB%99-List-lt-Animal-gt\"><span class=\"toc-text\">5.9 类 Dog 继承于 类 Animal，那么 List&lt;Dog&gt; 能否赋值给 List&lt;Animal&gt;?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-10-%E8%AF%B4%E8%AF%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">5.10 说说数据库的索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-11-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">5.11 聚簇索引和非聚簇索引能介绍一下吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-12-%E5%93%AA%E4%BA%9B%E7%B1%BB-Spring-%E4%BC%9A%E5%B8%AE%E6%88%91%E4%BB%AC%E7%AE%A1%E7%90%86%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">5.12 哪些类 Spring 会帮我们管理呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-13-Spring-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86-bean-%E4%BA%A4%E7%BB%99-Spring-%E6%9D%A5%E7%AE%A1%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">5.13 Spring 中为什么要将 bean 交给 Spring 来管理？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-14-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Cookie-%E4%BC%9A%E5%AF%BC%E8%87%B4-CSRF-%E6%94%BB%E5%87%BB%EF%BC%8C%E8%80%8C-JWT-%E8%83%BD%E9%81%BF%E5%85%8D%EF%BC%9F\"><span class=\"toc-text\">5.14 为什么使用 Cookie 会导致 CSRF 攻击，而 JWT 能避免？</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Spring Security 总结","uid":"84bebe9cd32f64471707a2ec9d7cecfe","slug":"BlogRepository/Spring/Spring Security 总结","date":"2022-03-15T09:18:25.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring Security 总结.json","keywords":null,"cover":"https://cover.png","text":"1. 概要1.1 名词概念1.1.1 主体（principal）使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体 1.1.2 认证（authentication）权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。笼...","link":"","photos":[],"count_time":{"symbolsCount":"108k","symbolsTime":"1:38"},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true}}