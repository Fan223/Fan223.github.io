{"title":"通过 Request 请求获取真实 IP 地址以及对应省份城市和系统浏览器信息","uid":"ac0a19fc42d1d09f368f9cb237bd1e7b","slug":"BlogRepository/开发实践/通过 Request 请求获取真实 IP 地址以及对应省份城市","date":"2022-12-16T08:20:26.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/开发实践/通过 Request 请求获取真实 IP 地址以及对应省份城市.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-获取真实-IP-地址\"><a href=\"#1-获取真实-IP-地址\" class=\"headerlink\" title=\"1. 获取真实 IP 地址\"></a>1. 获取真实 IP 地址</h1><h2 id=\"1-1-代码\"><a href=\"#1-1-代码\" class=\"headerlink\" title=\"1.1 代码\"></a>1.1 代码</h2><p>代码如下，这里的 <code>CommonUtil.isBlank()</code> 为封装的判空方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static String getIpAddress(HttpServletRequest request) &#123;\n        &#x2F;&#x2F; 首先, 获取 X-Forwarded-For 中的 IP 地址，它在 HTTP 扩展协议中能表示真实的客户端 IP\n        String ipAddress &#x3D; request.getHeader(&quot;X-Forwarded-For&quot;);\n        if (CommonUtil.isNotBlank(ipAddress) &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 多次反向代理后会有多个 ip 值，第一个 ip 才是真实 ip, 例: X-Forwarded-For: client, proxy1, proxy2，proxy…\n            int index &#x3D; ipAddress.indexOf(&quot;,&quot;);\n            if (index !&#x3D; -1) &#123;\n                return ipAddress.substring(0, index);\n            &#125;\n\n            return ipAddress;\n        &#125;\n\n        &#x2F;&#x2F; 如果 X-Forwarded-For 获取不到, 就去获取 X-Real-IP\n        ipAddress &#x3D; request.getHeader(&quot;X-Real-IP&quot;);\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 X-Real-IP 获取不到, 就去获取 Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 Proxy-Client-IP 获取不到, 就去获取 WL-Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 WL-Proxy-Client-IP 获取不到, 就去获取 HTTP_CLIENT_IP\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 HTTP_CLIENT_IP 获取不到, 就去获取 HTTP_X_FORWARDED_FOR\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 都获取不到, 最后才通过 request.getRemoteAddr() 获取IP\n            ipAddress &#x3D; request.getRemoteAddr();\n        &#125;\n\n        return &quot;0:0:0:0:0:0:0:1&quot;.equals(ipAddress) ? &quot;127.0.0.1&quot; : ipAddress;;\n&#125;</code></pre>\n\n<h2 id=\"1-2-解释\"><a href=\"#1-2-解释\" class=\"headerlink\" title=\"1.2 解释\"></a>1.2 解释</h2><p>1、首先，获取 <code>X-Forwarded-For</code> 中第 0 位的 IP 地址，它在 HTTP 扩展协议中能表示真实的客户端 IP，如下例：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>X-Forwarded-For: client, proxy1, proxy2, proxy…</p></blockquote>\n<p>2、如果 <code>X-Forwarded-For</code> 获取不到，就去获取 <code>X-Real-IP</code> ，<code>X-Real-IP</code> 获取不到，就依次获取 <code>Proxy-Client-IP</code> 、<code>WL-Proxy-Client-IP</code> 、<code>HTTP_CLIENT_IP</code> 、 <code>HTTP_X_FORWARDED_FOR</code> 。最后获取不到才通过 <code>request.getRemoteAddr()</code> 获取 IP</p>\n<ol>\n<li><strong><code>X-Real-IP</code> ：</strong> 记录请求的客户端真实 IP，与 <code>X-Forwarded-For</code> 类似</li>\n<li><strong><code>Proxy-Client-IP</code> ：</strong> 代理客户端的 IP，如果客户端真实 IP 获取不到的时候，就只能获取代理客户端的 IP 了</li>\n<li><strong><code>WL-Proxy-Client-IP</code> ：</strong> 在 Weblogic 下获取真实 IP 所用的的参数</li>\n<li><strong><code>HTTP_CLIENT_IP</code> 、<code>HTTP_X_FORWARDED_FOR</code> ：</strong> 可以理解为 <code>X-Forwarded-For</code> ， 它们是 PHP 中的用法</li>\n</ol>\n<p>3、在服务器上通过 <code>request.getRemoteAddr()</code> 获取服务器的地址时，获取到的是 IPV6 的 0:0:0:0:0:0:0:1，需要转换为 IPV4 的 127.0.0.1</p>\n<h2 id=\"1-3-Nginx-配置请求头参数\"><a href=\"#1-3-Nginx-配置请求头参数\" class=\"headerlink\" title=\"1.3 Nginx 配置请求头参数\"></a>1.3 Nginx 配置请求头参数</h2><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">server &#123;\n        listen       8081;\n        server_name  localhost;\n\n        location &#x2F; &#123;\n            root   html&#x2F;resource-nav;\n            index  index.html index.htm;\n        &#125;\n  \n        location ~ &#x2F;resNav &#123;\n            #代理请求头相关\n\t    proxy_set_header Host $host:$server_port; \n\t    proxy_set_header X-Real-Ip $remote_addr;\n\t    proxy_set_header X-Forwarded-For $remote_addr;\n  \n            proxy_pass http:&#x2F;&#x2F;ip:port;\n        &#125;\n&#125;</code></pre>\n\n<h1 id=\"2-通过-IP-地址获取省份城市信息\"><a href=\"#2-通过-IP-地址获取省份城市信息\" class=\"headerlink\" title=\"2. 通过 IP 地址获取省份城市信息\"></a>2. 通过 IP 地址获取省份城市信息</h1><p>分为两种方式，在线和离线：</p>\n<p><strong>1、使用在线第三方提供的 api：</strong></p>\n<ul>\n<li>ip-api.com</li>\n<li>ip.taotao.com</li>\n<li>百度地图 api</li>\n<li>新浪 iplookup</li>\n</ul>\n<p><strong>2、使用离线查询方式：</strong></p>\n<ul>\n<li>纯真库</li>\n<li>GeoLite2</li>\n<li>埃文科技</li>\n</ul>\n<p>具体的数据丰富性、准确性和查询速度可自行搜集相关资料。由于 GeoLite2 免费，且离线查询速度更快和稳定，同时不限制 API 并发数等，这里使用 GeoLite2 来获取省份城市信息，同时数据丰富性也比较高</p>\n<h2 id=\"2-1-下载-GeoLite2-City-库\"><a href=\"#2-1-下载-GeoLite2-City-库\" class=\"headerlink\" title=\"2.1 下载 GeoLite2 City 库\"></a>2.1 下载 GeoLite2 City 库</h2><p>GeoLite 数据库是 MaxMind 公司旗下的 ，GeoLite 数据库有开源版本和收费版本，这里使用开源版本，GeoLite 目前已经更新到 2 了，所以下载 GeoLite2 City 库。下载地址如下：<a href=\"https://dev.maxmind.com/geoip/geolite2-free-geolocation-data\">GeoLite2 Free Geolocation Data | MaxMind Developer Portal</a></p>\n<p>点击页面中的 Download Files</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152159.png\"></p>\n<p>未登录的话会跳转到登录页面</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152211.png\"></p>\n<p>没有账户的话点击创建</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152222.png\"></p>\n<p>这里会有几种账户形式，选择登录免费的 GeoLite2 数据库和 Web 服务</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152232.png\"></p>\n<p>填写完对应的信息后，会发一封设置密码的邮件，点击链接设置密码</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152245.png\"></p>\n<p>完成后点击进行登录</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152254.png\"></p>\n<p>输入用户名密码进行登录，用户名就是邮箱地址</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152306.png\"></p>\n<p>选择下载数据库</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152316.png\"></p>\n<p>选择 GZIP 下载</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152327.png\"></p>\n<p>下载完成后会得到一个 tar 包文件</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152338.png\"></p>\n<p>解压后里面就是我们需要的数据库文件（Windows 可用 7-Zip 解压）</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152349.png\"></p>\n<h2 id=\"2-2-使用\"><a href=\"#2-2-使用\" class=\"headerlink\" title=\"2.2 使用\"></a>2.2 使用</h2><h3 id=\"2-2-1将文件放入项目根路径下\"><a href=\"#2-2-1将文件放入项目根路径下\" class=\"headerlink\" title=\"2.2.1将文件放入项目根路径下\"></a>2.2.1将文件放入项目根路径下</h3><p><img src=\"http://img.fan223.cn/2023/04/20230419152359.png\"></p>\n<h3 id=\"2-2-2-引入依赖\"><a href=\"#2-2-2-引入依赖\" class=\"headerlink\" title=\"2.2.2 引入依赖\"></a>2.2.2 引入依赖</h3><p>好像 3.0 版本以上最低支持 JDK 11，假如是 JDK 8 的话最高使用 2.16.1 即可</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- GeoIP2 --&gt;\n&lt;dependency&gt;\n        &lt;groupId&gt;com.maxmind.geoip2&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;geoip2&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.16.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"2-2-3-代码\"><a href=\"#2-2-3-代码\" class=\"headerlink\" title=\"2.2.3 代码\"></a>2.2.3 代码</h3><p>这里的 <code>new DatabaseReader.Builder(database).build()</code> 支持两种类型，一种是 File，一种是 InputStream。本地项目两种皆可，但打包到服务器上运行时获取 File 类型文件可能会存在问题，最好通过流的方式来获取构建</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    public static void main(String[] args) throws IOException, GeoIp2Exception &#123;\n        &#x2F;&#x2F; 读取数据库文件\n        ClassPathResource classPathResource &#x3D; new ClassPathResource(&quot;GeoLite2-City.mmdb&quot;);\n        InputStream database &#x3D; database &#x3D; classPathResource.getInputStream();\n        &#x2F;&#x2F; 创建数据库\n        DatabaseReader reader &#x3D; new DatabaseReader.Builder(database).build();\n        &#x2F;&#x2F; 获取 IP 地址信息\n        InetAddress ipAddress &#x3D; InetAddress.getByName(&quot;139.227.47.35&quot;);\n\n        &#x2F;&#x2F; 获取查询信息\n        CityResponse response &#x3D; reader.city(ipAddress);\n\n        &#x2F;&#x2F; 国家信息\n        Country country &#x3D; response.getCountry();\n        System.out.println(country.getIsoCode()); &#x2F;&#x2F; &#39;CN&#39;\n        System.out.println(country.getName()); &#x2F;&#x2F; &#39;China&#39;\n        &#x2F;&#x2F; &#123;de&#x3D;China, ru&#x3D;Китай, pt-BR&#x3D;China, ja&#x3D;中国, en&#x3D;China, fr&#x3D;Chine, zh-CN&#x3D;中国, es&#x3D;China&#125;\n        System.out.println(country.getNames());\n        System.out.println(country.getNames().get(&quot;zh-CN&quot;)); &#x2F;&#x2F; &#39;中国&#39;\n\n        &#x2F;&#x2F; 省级信息\n        Subdivision subdivision &#x3D; response.getMostSpecificSubdivision();\n        System.out.println(subdivision.getIsoCode()); &#x2F;&#x2F; &#39;SH&#39;\n        System.out.println(subdivision.getName()); &#x2F;&#x2F; &#39;Shanghai&#39;\n        &#x2F;&#x2F; &#123;&#123;en&#x3D;Shanghai, fr&#x3D;Municipalité de Shanghai, zh-CN&#x3D;上海, pt-BR&#x3D;Xangai&#125;&#125;\n        System.out.println(subdivision.getNames());\n        System.out.println(subdivision.getNames().get(&quot;zh-CN&quot;)); &#x2F;&#x2F; &#39;上海&#39;\n\n        &#x2F;&#x2F; 城市信息\n        City city &#x3D; response.getCity();\n        System.out.println(city.getName()); &#x2F;&#x2F; &#39;Shanghai&#39;\n        System.out.println(city.getNames().get(&quot;zh-CN&quot;)); &#x2F;&#x2F; &#39;上海&#39;\n\n        &#x2F;&#x2F; 邮政编码(国内的可能获取不到)\n        Postal postal &#x3D; response.getPostal();\n        System.out.println(postal.getCode()); &#x2F;&#x2F; &#39;55423&#39;\n\n        &#x2F;&#x2F; 经纬度\n        Location location &#x3D; response.getLocation();\n        System.out.println(location.getLatitude()); &#x2F;&#x2F; 纬度 31.2222\n        System.out.println(location.getLongitude()); &#x2F;&#x2F; 经度 121.4581\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419152413.png\"></p>\n<h2 id=\"2-3-封装成工具类\"><a href=\"#2-3-封装成工具类\" class=\"headerlink\" title=\"2.3 封装成工具类\"></a>2.3 封装成工具类</h2><p><strong>1、实体类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\n@TableName(&quot;login_geo&quot;)\npublic class LoginGeoDO &#123;\n\n    &#x2F;&#x2F; 主键ID\n    private String id;\n\n    &#x2F;&#x2F; 国家 ISO 代码\n    private String countryIsoCode;\n\n    &#x2F;&#x2F; 国家名称\n    private String countryName;\n\n    &#x2F;&#x2F; 国家中文名称\n    private String countryZhCnName;\n\n    &#x2F;&#x2F; 省级 ISO 代码, 外国则是同级别地区代码\n    private String subdivisionIsoCode;\n\n    &#x2F;&#x2F; 省级名称\n    private String subdivisionName;\n\n    &#x2F;&#x2F; 省级中文名称\n    private String subdivisionZhCnName;\n\n    &#x2F;&#x2F; 城市名称\n    private String cityName;\n\n    &#x2F;&#x2F; 城市中文名称\n    private String cityZhCnName;\n\n    &#x2F;&#x2F; 邮政编码\n    private String postal;\n\n    &#x2F;&#x2F; 纬度\n    private double latitude;\n\n    &#x2F;&#x2F; 经度\n    private double longitude;\n\n    &#x2F;&#x2F; 创建时间\n    private Timestamp createTime;\n\n    &#x2F;&#x2F; 更新时间\n    private Timestamp updateTime;\n&#125;</code></pre>\n\n<p><strong>2、封装工具类</strong></p>\n<p>这里把前面获取 IP 地址的方法也封装进来了，LogUtil 为封装的日志工具类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AuthUtil &#123;\n\n    private static InputStream database;\n\n    private static DatabaseReader reader;\n\n    static &#123;\n        &#x2F;&#x2F; 读取数据库文件\n        LogUtil.info(&quot;读取数据库文件&quot;);\n        ClassPathResource classPathResource &#x3D; new ClassPathResource(&quot;GeoLite2-City.mmdb&quot;);\n        &#x2F;&#x2F; 创建数据库\n        try &#123;\n            database &#x3D; classPathResource.getInputStream();\n            reader &#x3D; new DatabaseReader.Builder(database).build();\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e.getMessage());\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 获取 IP 地址\n     *\n     * @param request 请求\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2022&#x2F;11&#x2F;28 9:08\n     *&#x2F;\n    public static String getIpAddress(HttpServletRequest request) &#123;\n        &#x2F;&#x2F; 首先, 获取 X-Forwarded-For 中的 IP 地址，它在 HTTP 扩展协议中能表示真实的客户端 IP\n        String ipAddress &#x3D; request.getHeader(&quot;X-Forwarded-For&quot;);\n        if (CommonUtil.isNotBlank(ipAddress) &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 多次反向代理后会有多个 ip 值，第一个 ip 才是真实 ip, 例: X-Forwarded-For: client, proxy1, proxy2，proxy…\n            int index &#x3D; ipAddress.indexOf(&quot;,&quot;);\n            if (index !&#x3D; -1) &#123;\n                return ipAddress.substring(0, index);\n            &#125;\n\n            return ipAddress;\n        &#125;\n\n        &#x2F;&#x2F; 如果 X-Forwarded-For 获取不到, 就去获取 X-Real-IP\n        ipAddress &#x3D; request.getHeader(&quot;X-Real-IP&quot;);\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 X-Real-IP 获取不到, 就去获取 Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 Proxy-Client-IP 获取不到, 就去获取 WL-Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 WL-Proxy-Client-IP 获取不到, 就去获取 HTTP_CLIENT_IP\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 HTTP_CLIENT_IP 获取不到, 就去获取 HTTP_X_FORWARDED_FOR\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 都获取不到, 最后才通过 request.getRemoteAddr() 获取IP\n            ipAddress &#x3D; request.getRemoteAddr();\n        &#125;\n\n        return ipAddress;\n    &#125;\n\n    &#x2F;**\n     * 通过 IP 地址获取地理信息\n     *\n     * @param ipAddress IP地址\n     * @return &#123;@link LoginGeoDO&#125;\n     * @author Fan\n     * @since 2022&#x2F;12&#x2F;14 16:35\n     *&#x2F;\n    public static LoginGeoDO getGeoInformation(String ipAddress) &#123;\n        try &#123;\n            &#x2F;&#x2F; 获取 IP 地址信息\n            InetAddress inetAddress &#x3D; InetAddress.getByName(ipAddress);\n            &#x2F;&#x2F; 获取查询信息\n            CityResponse response &#x3D; reader.city(inetAddress);\n            LoginGeoDO loginGeoDO &#x3D; new LoginGeoDO();\n\n            &#x2F;&#x2F; 国家信息\n            Country country &#x3D; response.getCountry();\n            loginGeoDO.setCountryIsoCode(country.getIsoCode());\n            loginGeoDO.setCountryName(country.getName());\n            loginGeoDO.setCountryZhCnName(country.getNames().get(&quot;zh-CN&quot;));\n\n            &#x2F;&#x2F; 省级信息\n            Subdivision subdivision &#x3D; response.getMostSpecificSubdivision();\n            loginGeoDO.setSubdivisionIsoCode(subdivision.getIsoCode());\n            loginGeoDO.setSubdivisionName(subdivision.getName());\n            loginGeoDO.setSubdivisionZhCnName(subdivision.getNames().get(&quot;zh-CN&quot;));\n\n            &#x2F;&#x2F; 城市信息\n            City city &#x3D; response.getCity();\n            loginGeoDO.setCityName(city.getName());\n            loginGeoDO.setCityZhCnName(city.getNames().get(&quot;zh-CN&quot;));\n\n            &#x2F;&#x2F; 邮政编码(国内的可能获取不到)\n            Postal postal &#x3D; response.getPostal();\n            loginGeoDO.setPostal(postal.getCode());\n\n            &#x2F;&#x2F; 经纬度\n            Location location &#x3D; response.getLocation();\n            loginGeoDO.setLatitude(location.getLatitude());\n            loginGeoDO.setLongitude(location.getLongitude());\n\n            return loginGeoDO;\n        &#125; catch (IOException | GeoIp2Exception exception) &#123;\n            LogUtil.error(exception.getMessage());\n            return null;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"3-获取系统、浏览器信息\"><a href=\"#3-获取系统、浏览器信息\" class=\"headerlink\" title=\"3. 获取系统、浏览器信息\"></a>3. 获取系统、浏览器信息</h1><p>该类信息一般通过 UA（User Agent）标识来获取。 User Agent 中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等</p>\n<p>先获取请求头中的 User-Agent</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String ua &#x3D; request.getHeader(&quot;User-Agent&quot;);</code></pre>\n\n<p>引入 UserAgentUtils 依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- UserAgentUtils --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;eu.bitwalker&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;UserAgentUtils&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.21&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>使用提供的 UserAgent 类来解析 ua 字符串</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">UserAgent userAgent &#x3D; UserAgent.parseUserAgentString(ua);\n\n&#x2F;&#x2F; 操作系统\nuserAgent.getOperatingSystem().getName()\n&#x2F;&#x2F; 浏览器\nuserAgent.getBrowser().getName()</code></pre>\n","feature":false,"text":"1. 获取真实 IP 地址1.1 代码代码如下，这里的 CommonUtil.isBlank() 为封装的判空方法 public static String getIpAddress(HttpServletRequest request) &#123; &#x2F;&#x2F; ...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"开发实践","slug":"开发实践","count":6,"path":"api/categories/开发实践.json"}],"tags":[{"name":"GeoIP2","slug":"GeoIP2","count":1,"path":"api/tags/GeoIP2.json"},{"name":"UserAgentUtils","slug":"UserAgentUtils","count":1,"path":"api/tags/UserAgentUtils.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E-IP-%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">1. 获取真实 IP 地址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1.1 代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">1.2 解释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-Nginx-%E9%85%8D%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">1.3 Nginx 配置请求头参数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E9%80%9A%E8%BF%87-IP-%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96%E7%9C%81%E4%BB%BD%E5%9F%8E%E5%B8%82%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">2. 通过 IP 地址获取省份城市信息</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E4%B8%8B%E8%BD%BD-GeoLite2-City-%E5%BA%93\"><span class=\"toc-text\">2.1 下载 GeoLite2 City 库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.2 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1%E5%B0%86%E6%96%87%E4%BB%B6%E6%94%BE%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%A0%B9%E8%B7%AF%E5%BE%84%E4%B8%8B\"><span class=\"toc-text\">2.2.1将文件放入项目根路径下</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">2.2.2 引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-3-%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2.2.3 代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%B0%81%E8%A3%85%E6%88%90%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">2.3 封装成工具类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">3. 获取系统、浏览器信息</span></a></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Vue3 总结（开发）","uid":"6c3cfbb59bb90aa0cd86d47a59e86094","slug":"BlogRepository/Vue/Vue3 总结（开发）","date":"2022-12-20T16:57:55.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/Vue/Vue3 总结（开发）.json","keywords":null,"cover":"https://cover.png","text":"更详细的 API 和使用见：Vue2 总结（开发）_凡 223 的博客 1. Vue Router官网地址：Home | Vue Router (vuejs.org) 1.1 安装npm install vue-router@4 1.2 使用1.2.1 new Router 变成...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"基础微服务项目架构构建总结","uid":"1777dd13afd91a7e9bd508c03cf35724","slug":"BlogRepository/开发实践/基础微服务项目架构构建总结","date":"2022-11-16T06:08:04.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/开发实践/基础微服务项目架构构建总结.json","keywords":null,"cover":"https://cover.png","text":"1. Maven 依赖版本管理1.1 Maven 依赖的优先级1、最短路径优先 工程中依赖了 B、C 两个 jar 包 在 B jar 包内引用了 C jar 包版本为 1.0 在工程内直接引用的 C jar 包版本为 2.0 Project -&gt; B -&gt; C(1....","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"开发实践","slug":"开发实践","count":6,"path":"api/categories/开发实践.json"}],"tags":[{"name":"IDEA","slug":"IDEA","count":8,"path":"api/tags/IDEA.json"},{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}