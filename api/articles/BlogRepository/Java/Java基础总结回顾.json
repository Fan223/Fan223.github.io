{"title":"Java基础总结回顾","uid":"1fa3d488b05424ad20d9fbd33108a055","slug":"BlogRepository/Java/Java基础总结回顾","date":"2022-04-12T09:31:14.000Z","updated":"2023-03-13T19:13:04.933Z","comments":true,"path":"api/articles/BlogRepository/Java/Java基础总结回顾.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-说明\"><a href=\"#1-说明\" class=\"headerlink\" title=\"1. 说明\"></a>1. 说明</h1><h2 id=\"1-1-编译与运行\"><a href=\"#1-1-编译与运行\" class=\"headerlink\" title=\"1.1 编译与运行\"></a>1.1 编译与运行</h2><ol>\n<li>编译：是指将编写的 Java 源文件翻译成 JVM 认识的 class 文件，在这个过程中， javac 编译器会检查所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功</li>\n<li>运行：是指将 class文件 交给 JVM 去运行，此时 JVM 会去执行编写的程序</li>\n</ol>\n<h2 id=\"1-2-main-方法\"><a href=\"#1-2-main-方法\" class=\"headerlink\" title=\"1.2 main 方法\"></a>1.2 main 方法</h2><p>主方法，写法是固定格式不可以更改。main 方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从 main 方法这里开始执行</p>\n<h2 id=\"1-3-keywords-关键字\"><a href=\"#1-3-keywords-关键字\" class=\"headerlink\" title=\"1.3 keywords  关键字\"></a>1.3 keywords  关键字</h2><p>指在程序中，Java 已经定义好的单词，具有特殊含义。如 public 、class 、static 、void 等，这些单词已经被 Java 定义好，全部都是小写字母</p>\n<h2 id=\"1-4-标识符\"><a href=\"#1-4-标识符\" class=\"headerlink\" title=\"1.4 标识符\"></a>1.4 标识符</h2><p>指在程序中，自己定义的内容，如类的名字、方法的名字和变量的名字等等<br><strong>命名规则： 硬性要求</strong></p>\n<ol>\n<li>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线）</li>\n<li>标识符不能以数字开头</li>\n<li>标识符不能是关键字</li>\n</ol>\n<p><strong>命名规范： 软性建议</strong></p>\n<ol>\n<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）</li>\n<li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）</li>\n<li>变量名规范：全部小写</li>\n</ol>\n<h1 id=\"2-常量、变量、数据类型、运算符\"><a href=\"#2-常量、变量、数据类型、运算符\" class=\"headerlink\" title=\"2. 常量、变量、数据类型、运算符\"></a>2. 常量、变量、数据类型、运算符</h1><h2 id=\"2-1-常量\"><a href=\"#2-1-常量\" class=\"headerlink\" title=\"2.1 常量\"></a>2.1 常量</h2><p>是指在 Java 程序中固定不变的数据<br><img src=\"https://img-blog.csdnimg.cn/9506a5243d0044379ada6e2ef139521d.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-2-变量\"><a href=\"#2-2-变量\" class=\"headerlink\" title=\"2.2 变量\"></a>2.2 变量</h2><p>常量是固定不变的数据，那么在程序中可以变化的量称为变量，Java 中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型</p>\n<p><strong>变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">数据类型 变量名 &#x3D; 数据值;</code></pre>\n\n<p>变量名称：在同一个大括号范围内，变量的名字不可以相同<br>变量赋值：定义的变量，不赋值不能使用</p>\n<h2 id=\"2-3-数据类型\"><a href=\"#2-3-数据类型\" class=\"headerlink\" title=\"2.3 数据类型\"></a>2.3 数据类型</h2><p>Java的数据类型分为两大类：</p>\n<ol>\n<li>基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔</li>\n<li>引用数据类型：包括 类 、 数组 、 接口</li>\n</ol>\n<p><strong>四类八种基本数据类型：</strong><br><img src=\"https://img-blog.csdnimg.cn/b450c25188914222bd0bedc2f7421edc.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-4-数据类型转换\"><a href=\"#2-4-数据类型转换\" class=\"headerlink\" title=\"2.4 数据类型转换\"></a>2.4 数据类型转换</h2><p>Java 程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换</p>\n<h3 id=\"2-4-1-自动转换\"><a href=\"#2-4-1-自动转换\" class=\"headerlink\" title=\"2.4.1 自动转换\"></a>2.4.1 自动转换</h3><p><strong>将 取值范围小的类型 自动提升为 取值范围大的类型，byte、short、char 运算时直接提升为 int</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tbyte a &#x3D; 1;\n\tint b &#x3D; a + 1;\n\tSystem.out.println(b);\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/b6b0a55d5dad40b48c5ec1143fc97704.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/ba62c993c9b34a18a322e22f176510e8.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-4-2-强制转换\"><a href=\"#2-4-2-强制转换\" class=\"headerlink\" title=\"2.4.2 强制转换\"></a>2.4.2 强制转换</h3><p><strong>将 取值范围大的类型 强制转换成 取值范围小的类型 。自动转换是 Java 自动执行的，而强制转换需要自己手动执行</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">数据类型 变量名 &#x3D; （数据类型）被转数据值;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; double 类型数据强制转成 int 类型，直接去掉小数点\nint i &#x3D; (int)1.5;\n\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; short 类型变量，内存中 2 个字节\n\tshort s &#x3D; 1;\n\t&#x2F;*\n\t出现编译失败\n\ts 和 1 做运算的时候，1 是 int 类型，s 会被提升为 int 类型\n\ts+1 后的结果是 int 类型，将结果在赋值会 short 类型时发生错误\n\tshort 内存 2 个字节，int 类型 4 个字节\n\t必须将 int 强制转成 short 才能完成赋值\n\t*&#x2F;\n\ts &#x3D; s + 1; &#x2F;&#x2F; 编译失败\n\ts &#x3D; (short)(s+1); &#x2F;&#x2F; 编译成功\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/da83494d0cb04a83909ef1a08e931b50.png\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>浮点转成整数，直接取消小数点，可能造成数据损失精度</li>\n<li>int 强制转成 short 砍掉2个字节，可能造成数据丢失</li>\n</ol>\n<h2 id=\"2-5-运算符\"><a href=\"#2-5-运算符\" class=\"headerlink\" title=\"2.5 运算符\"></a>2.5 运算符</h2><h3 id=\"2-5-1-位运算符\"><a href=\"#2-5-1-位运算符\" class=\"headerlink\" title=\"2.5.1 位运算符\"></a>2.5.1 位运算符</h3><p><img src=\"https://img-blog.csdnimg.cn/a7dcac241b1441a48f53a32560bccf91.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-5-2-赋值运算符\"><a href=\"#2-5-2-赋值运算符\" class=\"headerlink\" title=\"2.5.2 赋值运算符\"></a>2.5.2 赋值运算符</h3><p><img src=\"https://img-blog.csdnimg.cn/ea990acac4f842e78305ab5f93bf3ac7.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-5-3-三元运算符\"><a href=\"#2-5-3-三元运算符\" class=\"headerlink\" title=\"2.5.3 三元运算符\"></a>2.5.3 三元运算符</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">数据类型 变量名 &#x3D; 布尔类型表达式？结果1：结果2;</code></pre>\n\n<h3 id=\"2-5-4-instanceof\"><a href=\"#2-5-4-instanceof\" class=\"headerlink\" title=\"2.5.4 instanceof\"></a>2.5.4 instanceof</h3><p><strong>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">(Object reference variable) instanceof  (class&#x2F;interface type);\nObject name &#x3D; &quot;James&quot;;\nObject age &#x3D; 17;\nboolean resultName &#x3D; name instanceof String; &#x2F;&#x2F; 由于 name 是 String 类型，所以返回 true\nboolean resultAge &#x3D; age instanceof String; &#x2F;&#x2F; 由于 age 是 Integer 类型，所以返回 false</code></pre>\n\n<p>其中左边 obj 为一个对象，右边 Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果 result 都返回 true，否则返回false。</p>\n<p>注：编译器会检查 obj 是否能转换成右边的 Class 类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p>\n<h3 id=\"2-5-5-运算符优先级\"><a href=\"#2-5-5-运算符优先级\" class=\"headerlink\" title=\"2.5.5 运算符优先级\"></a>2.5.5 运算符优先级</h3><p><img src=\"https://img-blog.csdnimg.cn/e9c4bb075fc240709c3c2d0dc407276e.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-数组\"><a href=\"#3-数组\" class=\"headerlink\" title=\"3. 数组\"></a>3. 数组</h1><h2 id=\"3-1-概念\"><a href=\"#3-1-概念\" class=\"headerlink\" title=\"3.1 概念\"></a>3.1 概念</h2><p><strong>存储数据长度固定的容器，保证多个数据的数据类型要一致，数组有定长特性，长度一旦指定，不可更改</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 数组存储的数据类型[] 数组名字 &#x3D; new 数组存储的数据类型[长度];\n2. 数据类型[] 数组名 &#x3D; new 数据类型[]&#123;元素1,元素2,元素3...&#125;;\n3. 数据类型[] 数组名 &#x3D; &#123;元素1,元素2,元素3...&#125;;</code></pre>\n\n<h2 id=\"3-2-数组内存图\"><a href=\"#3-2-数组内存图\" class=\"headerlink\" title=\"3.2 数组内存图\"></a>3.2 数组内存图</h2><h3 id=\"3-2-1-内存概述\"><a href=\"#3-2-1-内存概述\" class=\"headerlink\" title=\"3.2.1 内存概述\"></a>3.2.1 内存概述</h3><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>\n<h3 id=\"3-2-2-JVM-内存划分（简略）\"><a href=\"#3-2-2-JVM-内存划分（简略）\" class=\"headerlink\" title=\"3.2.2 JVM 内存划分（简略）\"></a>3.2.2 JVM 内存划分（简略）</h3><p><strong>1.8 之后，方法区由元空间（Metaspace）取代</strong><br><img src=\"https://img-blog.csdnimg.cn/cba93524ffcb435a8e31ce61a0a11d94.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-2-3-两个独立数组内存图\"><a href=\"#3-2-3-两个独立数组内存图\" class=\"headerlink\" title=\"3.2.3 两个独立数组内存图\"></a>3.2.3 两个独立数组内存图</h3><p><img src=\"https://img-blog.csdnimg.cn/7074d24242624f63b429208a71983a65.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-3-数组工具类\"><a href=\"#3-3-数组工具类\" class=\"headerlink\" title=\"3.3 数组工具类\"></a>3.3 数组工具类</h2><ol>\n<li><strong>Arrays.sort：元素排序，会改变原数组</strong></li>\n<li><strong>Arrays.toString：返回指定数组内容的字符串表示形式</strong></li>\n<li><strong>Arrays.binarySearch：查找元素位置</strong></li>\n<li><strong>contains：查找元素是否存在</strong></li>\n<li>Arrays.equals：数组比较</li>\n<li><strong>Collections.min、Collections.max：获取最大值和最小值</strong><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int min &#x3D; (int) Collections.min(Arrays.asList(numbers));</code></pre></li>\n<li>Arrays.asList、addAll：数组合并<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List list &#x3D; new ArrayList(Arrays.asList(a));\nlist.addAll(Arrays.asList(b));</code></pre></li>\n<li>Arrays.fill：数组填充</li>\n<li>System.arraycopy：数组扩容&#x2F;复制</li>\n<li>retainAll： 数组交集</li>\n<li>removeAll：数组差集</li>\n</ol>\n<h1 id=\"4-类与对象、封装、继承、多态\"><a href=\"#4-类与对象、封装、继承、多态\" class=\"headerlink\" title=\"4. 类与对象、封装、继承、多态\"></a>4. 类与对象、封装、继承、多态</h1><h2 id=\"4-1-类与对象\"><a href=\"#4-1-类与对象\" class=\"headerlink\" title=\"4.1 类与对象\"></a>4.1 类与对象</h2><p><strong>类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物</strong></p>\n<ol>\n<li>属性：就是该事物的状态信息，<strong>成员变量：对应事物的属性，有默认值</strong></li>\n<li>行为：就是该事物能够做什么， <strong>成员方法：对应事物的行为</strong></li>\n</ol>\n<p><strong>对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为</strong></p>\n<p><strong>类与对象的关系：</strong></p>\n<ol>\n<li>类是对一类事物的描述，是抽象的</li>\n<li>对象是一类事物的实例，是具体的</li>\n<li>类是对象的模板，对象是类的实体</li>\n</ol>\n<h2 id=\"4-2-成员变量和局部变量区别\"><a href=\"#4-2-成员变量和局部变量区别\" class=\"headerlink\" title=\"4.2 成员变量和局部变量区别\"></a>4.2 成员变量和局部变量区别</h2><ol>\n<li>在类中的位置不同：成员变量：类中，方法外；局部变量：方法中或者方法声明上(形式参数)</li>\n<li>作用范围不一样：成员变量：类中；局部变量：方法中</li>\n<li><strong>初始化值的不同：</strong> 成员变量：有默认值；局部变量：没有默认值。必须先定义，赋值，最后使用<br><img src=\"https://img-blog.csdnimg.cn/0bd46e1671524456af3dc7483d0c9a17.png\" alt=\"在这里插入图片描述\"></li>\n<li><strong>在内存中的位置不同：</strong> 成员变量：堆内存；局部变量：栈内存</li>\n<li><strong>生命周期不同：</strong> 成员变量：随着对象的创建而存在，随着对象的消失而消失；局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li>\n</ol>\n<h2 id=\"4-3-封装-private\"><a href=\"#4-3-封装-private\" class=\"headerlink\" title=\"4.3 封装 private\"></a>4.3 封装 private</h2><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装用来防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p>\n<p><strong>将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问，this 代表当前对象的引用(谁调用就代表谁)</strong></p>\n<h2 id=\"4-4-继承-super\"><a href=\"#4-4-继承-super\" class=\"headerlink\" title=\"4.4 继承 super\"></a>4.4 继承 super</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。多个类可以称为子类，单独那一个类称为<strong>父类、超类（superclass）或者基类</strong>。</p>\n<p><strong>子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为</strong></p>\n<h2 id=\"4-5-继承之后的属性和行为\"><a href=\"#4-5-继承之后的属性和行为\" class=\"headerlink\" title=\"4.5 继承之后的属性和行为\"></a>4.5 继承之后的属性和行为</h2><ol>\n<li>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量。<strong>super，代表父类的存储空间标识(可以理解为父亲的引用)</strong></li>\n<li>子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。<strong>子类方法覆盖父类方法，必须要保证权限大于等于父类权限</strong></li>\n<li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。构造方法的作用是初始化成员变量的。所以<strong>子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用</strong></li>\n<li><strong>Java只支持单继承，不支持多继承</strong></li>\n</ol>\n<h2 id=\"4-6-抽象类-abstract\"><a href=\"#4-6-抽象类-abstract\" class=\"headerlink\" title=\"4.6 抽象类 abstract\"></a>4.6 抽象类 abstract</h2><p><strong>把没有方法主体的方法称为抽象方法。该方法的具体实现由子类提供。Java语法规定，如果一个类包含抽象方法，那么该类必须是抽象类</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">修饰符 abstract 返回值类型 方法名 (参数列表)；</code></pre>\n\n<p>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p>\n<h2 id=\"4-7-多态\"><a href=\"#4-7-多态\" class=\"headerlink\" title=\"4.7 多态\"></a>4.7 多态</h2><p><strong>是指同一行为，具有多个不同表现形式</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">父类类型 变量名 &#x3D; new 子类对象；\n变量名.方法名();</code></pre>\n\n<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法</strong></p>\n<h2 id=\"4-8-引用类型转换\"><a href=\"#4-8-引用类型转换\" class=\"headerlink\" title=\"4.8 引用类型转换\"></a>4.8 引用类型转换</h2><h3 id=\"4-8-1-向上转型\"><a href=\"#4-8-1-向上转型\" class=\"headerlink\" title=\"4.8.1 向上转型\"></a>4.8.1 向上转型</h3><p><strong>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</strong> 当父类引用指向一个子类对象时，便是向上转型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">父类类型 变量名 &#x3D; new 子类类型();</code></pre>\n\n<h3 id=\"4-8-2-向下转型\"><a href=\"#4-8-2-向下转型\" class=\"headerlink\" title=\"4.8.2 向下转型\"></a>4.8.2 向下转型</h3><p><strong>父类类型向子类类型向下转换的过程，这个过程是强制的</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">子类类型 变量名 &#x3D; (子类类型) 父类变量名;</code></pre>\n\n<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。<strong>想要调用子类特有的方法，必须做向下转型。可以使用 instanceof 关键字，给引用变量做类型的校验</strong></p>\n<h1 id=\"5-修饰符、内部类\"><a href=\"#5-修饰符、内部类\" class=\"headerlink\" title=\"5. 修饰符、内部类\"></a>5. 修饰符、内部类</h1><h2 id=\"5-1-修饰符\"><a href=\"#5-1-修饰符\" class=\"headerlink\" title=\"5.1 修饰符\"></a>5.1 修饰符</h2><h3 id=\"5-1-1-权限修饰符\"><a href=\"#5-1-1-权限修饰符\" class=\"headerlink\" title=\"5.1.1 权限修饰符\"></a>5.1.1 权限修饰符</h3><p><img src=\"https://img-blog.csdnimg.cn/6a52861a81454d48b00c7da0cc24009c.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"5-1-2-final\"><a href=\"#5-1-2-final\" class=\"headerlink\" title=\"5.1.2 final\"></a>5.1.2 final</h3><p><strong>final： 不可改变。可以用于修饰类、方法和变量</strong></p>\n<ol>\n<li>final 变量：变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值</li>\n<li>final 方：父类中的 final 方法可以被子类继承，但是不能被子类重写</li>\n<li>final 类：final 类不能被继承，没有类能够继承 final 类的任何特性</li>\n</ol>\n<h3 id=\"5-1-3-static\"><a href=\"#5-1-3-static\" class=\"headerlink\" title=\"5.1.3  static\"></a>5.1.3  static</h3><ol>\n<li><strong>静态变量</strong><br>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</li>\n<li><strong>静态方法</strong><br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li>\n</ol>\n<h3 id=\"5-1-4-synchronize\"><a href=\"#5-1-4-synchronize\" class=\"headerlink\" title=\"5.1.4 synchronize\"></a>5.1.4 synchronize</h3><p><strong>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符</strong></p>\n<h3 id=\"5-1-5-transient\"><a href=\"#5-1-5-transient\" class=\"headerlink\" title=\"5.1.5 transient\"></a>5.1.5 transient</h3><p><strong>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型</strong></p>\n<h3 id=\"5-1-6-volatile\"><a href=\"#5-1-6-volatile\" class=\"headerlink\" title=\"5.1.6 volatile\"></a>5.1.6 volatile</h3><p><strong>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值</strong></p>\n<p><strong>一个 volatile 对象引用可能是 null</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyRunnable implements Runnable&#123;\n    private volatile boolean active;\n    public void run()&#123;\n        active &#x3D; true;\n        while (active)&#123; &#x2F;&#x2F; 第一行\n            &#x2F;&#x2F; 代码\n        &#125;\n    &#125;\n    public void stop()&#123;\n        active &#x3D; false; &#x2F;&#x2F; 第二行\n    &#125;\n&#125;\n&#x2F;* 通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），\n在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，\n那么在 第二行 的 active 值为 false 时循环不会停止。\n但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。\n*&#x2F;</code></pre>\n\n<h2 id=\"5-2-内部类\"><a href=\"#5-2-内部类\" class=\"headerlink\" title=\"5.2 内部类\"></a>5.2 内部类</h2><p><strong>将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类</strong></p>\n<h3 id=\"5-2-1-成员内部类\"><a href=\"#5-2-1-成员内部类\" class=\"headerlink\" title=\"5.2.1 成员内部类\"></a>5.2.1 成员内部类</h3><p><strong>定义在类中方法外的类</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class 外部类 &#123;\n\tclass 内部类&#123;\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>内部类可以直接访问外部类的成员，包括私有成员。外部类要访问内部类的成员，必须要建立内部类的对象。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">外部类名.内部类名 对象名 &#x3D; new 外部类型().new 内部类型()；</code></pre>\n\n<h3 id=\"5-2-2-匿名内部类\"><a href=\"#5-2-2-匿名内部类\" class=\"headerlink\" title=\"5.2.2  匿名内部类\"></a>5.2.2  匿名内部类</h3><p><strong>内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象，匿名内部类必须继承一个父类或者实现一个父接口</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new 父类名或者接口名()&#123;\n\t&#x2F;&#x2F; 方法重写\n\t@Override\n\tpublic void method() &#123;\n\t\t&#x2F;&#x2F; 执行语句\n\t&#125;\n&#125;;</code></pre>\n\n<h1 id=\"6-String-类、Math-类、Collections-类\"><a href=\"#6-String-类、Math-类、Collections-类\" class=\"headerlink\" title=\"6. String 类、Math 类、Collections 类\"></a>6. String 类、Math 类、Collections 类</h1><h2 id=\"6-1-String-类\"><a href=\"#6-1-String-类\" class=\"headerlink\" title=\"6.1 String 类\"></a>6.1 String 类</h2><p><strong>字符串不变：字符串的值在创建后不能被更改</strong><br><img src=\"https://img-blog.csdnimg.cn/3f2c2040522a46fb9e2d28f4a4374fc3.png\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li><code>public boolean equals (Object anObject)</code> ：将此字符串与指定对象进行比较</li>\n<li><code>public boolean equalsIgnoreCase (String anotherString) </code>：将此字符串与指定对象进行比较，忽略大小写</li>\n<li><strong><code>compareTo、compareToIgnoreCase</code>：字符串比较</strong></li>\n<li><code>regionMatches</code>：比较字符串区域相等</li>\n<li><code>public int length ()</code> ：返回此字符串的长度</li>\n<li><code>public String concat (String str)、+ </code>：将指定的字符串连接到该字符串的末尾</li>\n<li><code>public char charAt (int index) </code>：<strong>返回指定索引处的 char值</strong></li>\n<li><code>public int indexOf (String str) </code>：<strong>返回指定子字符串第一次出现在该字符串内的索引</strong></li>\n<li><code>public String substring (int beginIndex)</code> ：<strong>返回一个子字符串，从 beginIndex 开始截取字符串到字符串结尾</strong></li>\n<li><code>public String substring (int beginIndex, int endIndex)</code> ：<strong>返回一个子字符串，从 beginIndex 到 endIndex 截取字符串。含 beginIndex，不含 endIndex</strong></li>\n<li><code>public char[] toCharArray ()</code> ：将此字符串转换为新的字符数组</li>\n<li><code>public byte[] getBytes () </code>：使用平台的默认字符集将该 String编码转换为新的字节数组</li>\n<li><code>public String replace (CharSequence target, CharSequence replacement) 、replaceFirst、replaceAll</code>：将与 target 匹配的字符串使用 replacement 字符串替换</li>\n<li><code>public String[] split(String regex)</code> ：<strong>将此字符串按照给定的 regex（规则）拆分为字符串数组</strong></li>\n<li><strong><code>StringBuffer.reverse</code>：字符串反转</strong></li>\n<li><strong><code>delete（StringBuffer）</code>：字符串删除</strong></li>\n<li><code>public boolean startsWith(String prefix) </code> ：<strong>判断是否以某字符串开头</strong></li>\n</ol>\n<h2 id=\"6-2-Math类\"><a href=\"#6-2-Math类\" class=\"headerlink\" title=\"6.2 Math类\"></a>6.2 Math类</h2><ol>\n<li>public static double abs(double a) ：返回 double 值的绝对值</li>\n<li>public static double ceil(double a) ：返回大于等于参数的最小的整数</li>\n<li>public static double floor(double a) ：返回小于等于参数最大的整数</li>\n<li>public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)</li>\n</ol>\n<h2 id=\"6-3-Collections-类\"><a href=\"#6-3-Collections-类\" class=\"headerlink\" title=\"6.3 Collections 类\"></a>6.3 Collections 类</h2><ol>\n<li>排序</li>\n<li>查找，替换操作</li>\n<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>\n</ol>\n<p><strong>排序操作</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void reverse(List list)&#x2F;&#x2F;反转\nvoid shuffle(List list)&#x2F;&#x2F;随机排序\nvoid sort(List list)&#x2F;&#x2F;按自然排序的升序排序\nvoid sort(List list, Comparator c)&#x2F;&#x2F;定制排序，由Comparator控制排序逻辑\nvoid swap(List list, int i , int j)&#x2F;&#x2F;交换两个索引位置的元素\nvoid rotate(List list, int distance)&#x2F;&#x2F;旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</code></pre>\n\n<p><strong>查找，替换操作</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int binarySearch(List list, Object key)&#x2F;&#x2F;对List进行二分查找，返回索引，注意List必须是有序的\nint max(Collection coll)&#x2F;&#x2F;根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\nint max(Collection coll, Comparator c)&#x2F;&#x2F;根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\nvoid fill(List list, Object obj)&#x2F;&#x2F;用指定的元素代替指定list中的所有元素\nint frequency(Collection c, Object o)&#x2F;&#x2F;统计元素出现次数\nint indexOfSubList(List list, List target)&#x2F;&#x2F;统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)\nboolean replaceAll(List list, Object oldVal, Object newVal)&#x2F;&#x2F;用新元素替换旧元素</code></pre>\n\n<p><strong>同步控制</strong><br>Collections 提供了多个 <code>synchronizedXxx()</code> 方法，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题</p>\n<p><code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>, <code>LinkedList</code>, <code>HashMap</code>, <code>TreeMap</code> 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合，但效率非常低，需要线程安全的集合类型时考虑使用 JUC 包下的并发集合</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">synchronizedCollection(Collection&lt;T&gt;  c) &#x2F;&#x2F;返回指定 collection 支持的同步（线程安全的）collection。\nsynchronizedList(List&lt;T&gt; list)&#x2F;&#x2F;返回指定列表支持的同步（线程安全的）List。\nsynchronizedMap(Map&lt;K,V&gt; m) &#x2F;&#x2F;返回由指定映射支持的同步（线程安全的）Map。\nsynchronizedSet(Set&lt;T&gt; s) &#x2F;&#x2F;返回指定 set 支持的同步（线程安全的）set。</code></pre>\n\n<h2 id=\"6-4-Comparator-比较器\"><a href=\"#6-4-Comparator-比较器\" class=\"headerlink\" title=\"6.4 Comparator 比较器\"></a>6.4 Comparator 比较器</h2><p>排序简单的说就是两个对象之间比较大小，在 JAVA 中提供了两种比较实现的方式，一种是比较死板的采用 java.lang.Comparable 接口去实现，一种是灵活的当我需要做排序的时候在去选择的 java.util.Comparator 接口完成</p>\n<ol>\n<li><p><strong>public static <T> void sort(List<T> list) 这个方法完成的排序，实际上要求了被排序的类型需要实现 Comparable 接口完成比较的功能</strong></p>\n</li>\n<li><p><strong>public static <T> void sort(List<T> list，Comparator&lt;? super T&gt; ) 方法灵活的完成，这个里面就涉及到了 Comparator 这个接口</strong><br>位于 java.util 包下，排序是 comparator 能实现的功能之一，该接口代表一个比较器，比较器具有可比性！需要比较两个对象谁排在前谁排在后：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public int compare(String o1, String o2) ：比较其两个参数的顺序</code></pre>\n\n<p><strong>两个对象比较的结果有三种：大于，等于，小于</strong><br>如果要按照升序排序， 则 o1 小于 o2，返回（负数），相等返回0，o1 大于o2返回（正数） 如果要按照降序排序 则 o1 小于 o2，返回（正数），相等返回0，o1大于o2返回（负数）</p>\n</li>\n<li><p>Comparable 和 Comparator 两个接口的区别</p>\n<ul>\n<li>Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。只能在类中实现 compareTo() 一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过 Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器</li>\n<li>Comparator：强行对某个对象进行整体排序。可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"7-异常\"><a href=\"#7-异常\" class=\"headerlink\" title=\"7. 异常\"></a>7. 异常</h1><h2 id=\"7-1-非检查性异常\"><a href=\"#7-1-非检查性异常\" class=\"headerlink\" title=\"7.1 非检查性异常\"></a>7.1 非检查性异常</h2><p><img src=\"https://img-blog.csdnimg.cn/58caebadb7d047449c14c88b13d99bd1.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"7-2-检查性异常\"><a href=\"#7-2-检查性异常\" class=\"headerlink\" title=\"7.2 检查性异常\"></a>7.2 检查性异常</h2><p><img src=\"https://img-blog.csdnimg.cn/8ef65b9d2a394cb08c02253289d83582.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"7-3-异常方法\"><a href=\"#7-3-异常方法\" class=\"headerlink\" title=\"7.3 异常方法\"></a>7.3 异常方法</h2><p><img src=\"https://img-blog.csdnimg.cn/baa179d8f58f4a738c99324fe470abcc.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"7-4-声明自定义异常\"><a href=\"#7-4-声明自定义异常\" class=\"headerlink\" title=\"7.4 声明自定义异常\"></a>7.4 声明自定义异常</h2><ol>\n<li>所有异常都必须是 Throwable 的子类</li>\n<li>如果希望写一个检查性异常类，则需要继承 Exception 类</li>\n<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 自定义异常类，继承Exception类\npublic class InsufficientFundsException extends Exception&#123;\n  &#x2F;&#x2F;此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱\n  private double amount;\n  public InsufficientFundsException(double amount)&#123;\n    this.amount &#x3D; amount;\n  &#125; \n  public double getAmount()&#123;\n    return amount;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"7-5-通用异常\"><a href=\"#7-5-通用异常\" class=\"headerlink\" title=\"7.5 通用异常\"></a>7.5 通用异常</h2><ul>\n<li>JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类</li>\n<li>程序级异常：由程序或者 API 程序抛出的异常。如 IllegalArgumentException 类，IllegalStateException 类</li>\n</ul>\n<h1 id=\"8-时间处理\"><a href=\"#8-时间处理\" class=\"headerlink\" title=\"8. 时间处理\"></a>8. 时间处理</h1><h2 id=\"8-1-格式化时间-SimpleDateFormat、printf\"><a href=\"#8-1-格式化时间-SimpleDateFormat、printf\" class=\"headerlink\" title=\"8.1 格式化时间 SimpleDateFormat、printf\"></a>8.1 格式化时间 SimpleDateFormat、printf</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Main&#123;\n    public static void main(String[] args)&#123;\n        Date date &#x3D; new Date();\n        String strDateFormat &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;;\n        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(strDateFormat);\n        System.out.println(sdf.format(date)); &#x2F;&#x2F; 2015-03-27 21:13:23\n     \t&#x2F;&#x2F; printf 的使用  \n    \tSystem.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date); &#x2F;&#x2F; 星期一 九月 10 10:43:36 CST 2012\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/c0a8f7b6c5dc41fb9fd1a2379fa70a0f.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/8a48b341b3ad489eae734809e2b5c5e1.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"8-2-获取某个时间点-Calendar\"><a href=\"#8-2-获取某个时间点-Calendar\" class=\"headerlink\" title=\"8.2 获取某个时间点 Calendar\"></a>8.2 获取某个时间点 Calendar</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Main &#123;\n    public static void main(String[] args) &#123;\n        Calendar cal &#x3D; Calendar.getInstance();\n        int day &#x3D; cal.get(Calendar.DATE);\n        int month &#x3D; cal.get(Calendar.MONTH) + 1;\n        int year &#x3D; cal.get(Calendar.YEAR);\n        int dow &#x3D; cal.get(Calendar.DAY_OF_WEEK);\n        int dom &#x3D; cal.get(Calendar.DAY_OF_MONTH);\n        int doy &#x3D; cal.get(Calendar.DAY_OF_YEAR);\n \n        System.out.println(&quot;当期时间: &quot; + cal.getTime()); &#x2F;&#x2F; Fri Mar 27 21:44:15 CST 2015\n        System.out.println(&quot;日期: &quot; + day); &#x2F;&#x2F; 27\n        System.out.println(&quot;月份: &quot; + month); &#x2F;&#x2F; 3\n        System.out.println(&quot;年份: &quot; + year); &#x2F;&#x2F; 2015\n        System.out.println(&quot;一周的第几天: &quot; + dow);  &#x2F;&#x2F; 6, 星期日为一周的第一天输出为 1，星期一输出为 2，以此类推\n        System.out.println(&quot;一月中的第几天: &quot; + dom); &#x2F;&#x2F; 27\n        System.out.println(&quot;一年的第几天: &quot; + doy); &#x2F;&#x2F; 86\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"8-3-LocalDateTime-代替-Calendar\"><a href=\"#8-3-LocalDateTime-代替-Calendar\" class=\"headerlink\" title=\"8.3 LocalDateTime 代替 Calendar\"></a>8.3 LocalDateTime 代替 Calendar</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tLocalDateTime localDateTime &#x3D; LocalDateTime.now();\n\n    System.out.println(localDateTime); &#x2F;&#x2F; 2021-12-22T08:56:53.923\n\tSystem.out.println(localDateTime.plusYears(2)); &#x2F;&#x2F; 加2年\n\tSystem.out.println(localDateTime.plusDays(2)); &#x2F;&#x2F; 加两天\n\tSystem.out.println(localDateTime.minusYears(2)); &#x2F;&#x2F; 减两年\n\tSystem.out.println(localDateTime.minusDays(2)); &#x2F;&#x2F; 减两天\n\tSystem.out.println(localDateTime.toString());    &#x2F;&#x2F; 转字符串 结果：2021-12-22T08:56:53.923\n\tSystem.out.println(localDateTime.toLocalDate()); &#x2F;&#x2F; 获取日期(LocalDate) 结果：2021-12-22\n\tSystem.out.println(localDateTime.toLocalTime()); &#x2F;&#x2F; 获取时间(LocalTime) 结果：08:56:53.923\n\tSystem.out.println(localDateTime.getDayOfMonth()); &#x2F;&#x2F; 获取当前时间月份的第几天\n\tSystem.out.println(localDateTime.getDayOfWeek());  &#x2F;&#x2F; 获取当前周的第几天\n\tSystem.out.println(localDateTime.getDayOfYear());  &#x2F;&#x2F; 获取当前时间在该年属于第几天\n\tSystem.out.println(localDateTime.getYear()); &#x2F;&#x2F; 获取当前时间的年份\n\tSystem.out.println(localDateTime.getMonthValue()); &#x2F;&#x2F; 获取当前时间的月份(阿拉伯文)\n\tSystem.out.println(localDateTime.getMonth());      &#x2F;&#x2F; 获取当前时间的月份(英文)\n\tSystem.out.println(localDateTime.getHour());       &#x2F;&#x2F; 获取当前时间的小时数\n\tSystem.out.println(localDateTime.getMinute());     &#x2F;&#x2F; 获取当前时间的分钟数\n\n\t&#x2F;&#x2F; 构造时间\n\tLocalDateTime startTime &#x3D; LocalDateTime.of(2021, 1, 1, 20, 31, 20);\n\tLocalDateTime endTime &#x3D; LocalDateTime.of(2021, 1, 3, 20, 31, 20);\n\t&#x2F;&#x2F; 比较时间\n\tSystem.out.println(localDateTime.isAfter(startTime)); &#x2F;&#x2F; 结果：true\n\tSystem.out.println(localDateTime.isBefore(endTime));  &#x2F;&#x2F; 结果：false\n\t&#x2F;&#x2F;获取毫秒数(使用 Instant)\n\tSystem.out.println(localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()); \n\t&#x2F;&#x2F;获取秒数(使用 Instant)\n    System.out.println(localDateTime.atZone(ZoneId.systemDefault()).toInstant().getEpochSecond()); \n    &#x2F;&#x2F; LocalDateTime 获取秒数\n\tLong second &#x3D; LocalDateTime.now().toEpochSecond(ZoneOffset.of(&quot;+8&quot;));\n\t&#x2F;&#x2F; LocalDateTime 获取毫秒数\n\tLong milliSecond &#x3D; LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).toEpochMilli();\n\t&#x2F;&#x2F; 获取本月的第一天的0点0分0秒和最后一天的23点59分59秒\n\tLocalDateTime beginMonth &#x3D; localDateTime.with(TemporalAdjusters.firstDayOfMonth()).withHour(0).withMinute(0).withSecond(0);\n\tLocalDateTime endMonth &#x3D; localDateTime.with(TemporalAdjusters.lastDayOfMonth()).withHour(23).withMinute(59).withSecond(59);\n\t&#x2F;&#x2F; LocalDateTime 转 Date\n\tDate date &#x3D; Date.from(localDateTime.toInstant(ZoneOffset.of(&quot;+8&quot;)));\n\t&#x2F;&#x2F; Date 转 LocalDateTime\n\tdate.toInstant().atOffset(ZoneOffset.of(&quot;+8&quot;)).toLocalDateTime();\n&#125;</code></pre>\n\n<h2 id=\"8-4-Instant-代替-Date\"><a href=\"#8-4-Instant-代替-Date\" class=\"headerlink\" title=\"8.4 Instant 代替 Date\"></a>8.4 Instant 代替 Date</h2><p><strong>时区需要加 8 小时</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tInstant instant &#x3D; Instant.now().plusMillis(TimeUnit.HOURS.toMillis(8));\n\tSystem.out.println(instant); &#x2F;&#x2F; 2021-12-22T08:59:57.491Z\n&#125;</code></pre>\n\n<h2 id=\"8-5-DateTimeFormatter-代替-SimopleDateFormat\"><a href=\"#8-5-DateTimeFormatter-代替-SimopleDateFormat\" class=\"headerlink\" title=\"8.5 DateTimeFormatter 代替 SimopleDateFormat\"></a>8.5 DateTimeFormatter 代替 SimopleDateFormat</h2><p><strong>时间要使用 LocalDateTime</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tDateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n\tString format &#x3D; dtf.format(LocalDateTime.now());\n\tSystem.out.println(format); &#x2F;&#x2F; 2021-12-22 09:04:47\n&#125;</code></pre>\n\n<h2 id=\"8-6-日期比较\"><a href=\"#8-6-日期比较\" class=\"headerlink\" title=\"8.6 日期比较\"></a>8.6 日期比较</h2><ol>\n<li>使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值</li>\n<li>使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true</li>\n<li>使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口</li>\n</ol>\n<h1 id=\"9-正则、标签、finalize\"><a href=\"#9-正则、标签、finalize\" class=\"headerlink\" title=\"9. 正则、标签、finalize\"></a>9. 正则、标签、finalize</h1><h2 id=\"9-1-正则\"><a href=\"#9-1-正则\" class=\"headerlink\" title=\"9.1 正则\"></a>9.1 正则</h2><h3 id=\"9-1-1-语法\"><a href=\"#9-1-1-语法\" class=\"headerlink\" title=\"9.1.1 语法\"></a>9.1.1 语法</h3><p><img src=\"https://img-blog.csdnimg.cn/2746b4aac4c6454b8752e605e37ef276.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"9-1-2-Matcher\"><a href=\"#9-1-2-Matcher\" class=\"headerlink\" title=\"9.1.2 Matcher\"></a>9.1.2 Matcher</h3><h4 id=\"9-1-2-1-索引方法\"><a href=\"#9-1-2-1-索引方法\" class=\"headerlink\" title=\"9.1.2.1 索引方法\"></a>9.1.2.1 索引方法</h4><p><img src=\"https://img-blog.csdnimg.cn/c2db29ee7efd4957a2956dec67f9322e.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"9-1-2-2-查找方法\"><a href=\"#9-1-2-2-查找方法\" class=\"headerlink\" title=\"9.1.2.2 查找方法\"></a>9.1.2.2 查找方法</h4><ul>\n<li>matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求</li>\n<li>lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/45014e551d9044a9a5a5b86963826069.png\" alt=\"在这里插入图片描述\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RegexMatches&#123;\n    private static final String REGEX &#x3D; &quot;foo&quot;;\n    private static final String INPUT &#x3D; &quot;fooooooooooooooooo&quot;;\n    private static final String INPUT2 &#x3D; &quot;ooooofoooooooooooo&quot;;\n    private static Pattern pattern;\n    private static Matcher matcher;\n    private static Matcher matcher2;\n \n    public static void main( String[] args )&#123;\n       pattern &#x3D; Pattern.compile(REGEX);\n       matcher &#x3D; pattern.matcher(INPUT);\n       matcher2 &#x3D; pattern.matcher(INPUT2);\n \n       System.out.println(&quot;Current REGEX is: &quot;+REGEX); &#x2F;&#x2F; foo\n       System.out.println(&quot;Current INPUT is: &quot;+INPUT); &#x2F;&#x2F; fooooooooooooooooo\n       System.out.println(&quot;Current INPUT2 is: &quot;+INPUT2); &#x2F;&#x2F; ooooofoooooooooooo\n \n       System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt()); &#x2F;&#x2F; true\n       System.out.println(&quot;matches(): &quot;+matcher.matches()); &#x2F;&#x2F; false\n       System.out.println(&quot;lookingAt(): &quot;+matcher2.lookingAt()); &#x2F;&#x2F; false\n   &#125;\n&#125;</code></pre>\n\n<h4 id=\"9-1-2-3-替换方法\"><a href=\"#9-1-2-3-替换方法\" class=\"headerlink\" title=\"9.1.2.3 替换方法\"></a>9.1.2.3 替换方法</h4><p><img src=\"https://img-blog.csdnimg.cn/f36ebbebe98640b0b4b39ce14eb5dcce.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"9-1-2-4-PatternSyntaxException\"><a href=\"#9-1-2-4-PatternSyntaxException\" class=\"headerlink\" title=\"9.1.2.4 PatternSyntaxException\"></a>9.1.2.4 PatternSyntaxException</h4><p><strong>PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误</strong><br><img src=\"https://img-blog.csdnimg.cn/8fba04c09f3f42cb94b3b3eebd6433ca.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"9-2-标签\"><a href=\"#9-2-标签\" class=\"headerlink\" title=\"9.2 标签\"></a>9.2 标签</h2><p><strong>Java 中的标签是为循环设计的，是为了在多重循环中方便的使用 break 和coutinue</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Main &#123;\n    public static void main(String[] args) &#123;\n        String strSearch &#x3D; &quot;This is the string in which you have to search for a substring.&quot;;\n        String substring &#x3D; &quot;substring&quot;;\n        boolean found &#x3D; false;\n        int max &#x3D; strSearch.length() - substring.length();\n        &#x2F;&#x2F; 标签\n        testlbl:\n        for (int i &#x3D; 0; i &lt;&#x3D; max; i++) &#123;\n            int length &#x3D; substring.length();\n            int j &#x3D; i;\n            int k &#x3D; 0;\n            while (length-- !&#x3D; 0) &#123;\n                if(strSearch.charAt(j++) !&#x3D; substring.charAt(k++))&#123;\n                    continue testlbl;\n                &#125;\n            &#125;\n            found &#x3D; true;\n            break testlbl; &#x2F;&#x2F; break 到标签位置\n        &#125;\n        if (found) &#123;\n            System.out.println(&quot;发现子字符串。&quot;);\n        &#125;\n        else &#123;\n            System.out.println(&quot;字符串中没有发现子字符串。&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"9-3-finalize\"><a href=\"#9-3-finalize\" class=\"headerlink\" title=\"9.3 finalize\"></a>9.3 finalize</h2><p>在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。如：可以使用 finalize() 来确保一个对象打开的文件被关闭了。在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void finalize()&#123;\n   &#x2F;&#x2F; 在这里终结代码\n&#125;\n&#x2F;* 关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。\n当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法\n*&#x2F;</code></pre>\n\n<h1 id=\"10-IO\"><a href=\"#10-IO\" class=\"headerlink\" title=\"10. IO\"></a>10. IO</h1><h2 id=\"10-1-IO-流\"><a href=\"#10-1-IO-流\" class=\"headerlink\" title=\"10.1 IO 流\"></a>10.1 IO 流</h2><p><img src=\"https://img-blog.csdnimg.cn/d3395668564f4e65a6f068725f1a8c3d.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"10-2-字节流\"><a href=\"#10-2-字节流\" class=\"headerlink\" title=\"10.2 字节流\"></a>10.2 字节流</h2><h3 id=\"10-2-1-FileInputStream\"><a href=\"#10-2-1-FileInputStream\" class=\"headerlink\" title=\"10.2.1 FileInputStream\"></a>10.2.1 FileInputStream</h3><p><strong>该流用于从文件读取数据，它的对象可以用关键字 new 来创建</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 可以使用字符串类型的文件名来创建一个输入流对象来读取文件\n\tInputStream is &#x3D; new FileInputStream(&quot;E:&#x2F;&#x2F;a.txt&quot;);\n&#x2F;&#x2F; 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象\n    File file &#x3D; new File(&quot;E:&#x2F;&#x2F;a.txt&quot;);\n    InputStream in &#x3D; new FileInputStream(file);\n\tint len &#x3D; 0;\n    while ((len &#x3D; fis.read()) !&#x3D; -1)&#123;\n    \tSystem.out.println(len); &#x2F;&#x2F; 228 189 160 229 165 189\n    &#125;\n\tbyte[] bytes &#x3D; new byte[1024];\n\tint len &#x3D; 0;\n\twhile ((len &#x3D; fis.read(bytes)) !&#x3D; -1)&#123;\n\t\tSystem.out.println(new String(bytes,0,len)); &#x2F;&#x2F; 你好...\n\t&#125;\n\tfis.close();</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/6d08dddedb1648949466e124c13e42d7.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"10-2-2-FileOutputStream\"><a href=\"#10-2-2-FileOutputStream\" class=\"headerlink\" title=\"10.2.2 FileOutputStream\"></a>10.2.2 FileOutputStream</h3><p><strong>该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用字符串类型的文件名来创建一个输出流对象\n\tOutputStream os &#x3D; new FileOutputStream(&quot;E:&#x2F;&#x2F;b.txt&quot;);\n&#x2F;&#x2F; 使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象\n    File file &#x3D; new File(&quot;E:&#x2F;&#x2F;a.txt&quot;);\n    OutputStream os &#x3D; new FileOutputStream(file);\n\tos.write(97); &#x2F;&#x2F; a\n\tbyte[] bytes &#x3D; &#123;65,66,67,68,69&#125;;\n\tos.write(bytes); &#x2F;&#x2F; ABCDE\n\tos.write(&quot;你好&quot;.getBytes()); &#x2F;&#x2F; 你好\n\tos.close();</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/b05be07b1a194495ac53707fbe7fb043.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"10-3-字符流\"><a href=\"#10-3-字符流\" class=\"headerlink\" title=\"10.3 字符流\"></a>10.3 字符流</h2><h3 id=\"10-3-1-FileReader\"><a href=\"#10-3-1-FileReader\" class=\"headerlink\" title=\"10.3.1 FileReader\"></a>10.3.1 FileReader</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">FileReader fr &#x3D; new FileReader(&quot;E:&#x2F;&#x2F;a.txt&quot;);\nchar[] chars &#x3D; new char[1024];\nint len &#x3D; 0;\nwhile ((len &#x3D; fr.read(chars)) !&#x3D; -1)&#123;\n\tSystem.out.println(new String(chars,0,len)); &#x2F;&#x2F; 你好...\n&#125;\nfr.close();</code></pre>\n\n<h3 id=\"10-3-2-FileWriter\"><a href=\"#10-3-2-FileWriter\" class=\"headerlink\" title=\"10.3.2 FileWriter\"></a>10.3.2 FileWriter</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">FileWriter fw &#x3D; new FileWriter(&quot;E:&#x2F;&#x2F;a.txt&quot;);\nFileWriter fw &#x3D; new FileWriter(&quot;E:&#x2F;&#x2F;a.txt&quot;,true); &#x2F;&#x2F; 续写开关 true:不会创建新的文件覆盖源文件,可以续写\nchar[] chars &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125;;\nfw.write(chars); &#x2F;&#x2F; abcd\nfw.write(&quot;你好&quot;); &#x2F;&#x2F; abcd你好\nfw.flush();\nfw.close();</code></pre>\n\n<h2 id=\"10-4-缓冲流\"><a href=\"#10-4-缓冲流\" class=\"headerlink\" title=\"10.4 缓冲流\"></a>10.4 缓冲流</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 写入文件\nBufferedWriter out &#x3D; new BufferedWriter(new FileWriter(&quot;E:&#x2F;&#x2F;runoob.txt&quot;));\nout.write(&quot;菜鸟教程&quot;);\nout.close();\n&#x2F;&#x2F; 读取文件\nBufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;E:&#x2F;&#x2F;runoob.txt&quot;));\nString str;\nwhile ((str &#x3D; br.readLine()) !&#x3D; null)&#123;\n\tSystem.out.println(str); &#x2F;&#x2F; 菜鸟教程\n&#125;</code></pre>\n\n<h1 id=\"11-Collection\"><a href=\"#11-Collection\" class=\"headerlink\" title=\"11. Collection\"></a>11. Collection</h1><h2 id=\"11-1-集合框架\"><a href=\"#11-1-集合框架\" class=\"headerlink\" title=\"11.1 集合框架\"></a>11.1 集合框架</h2><p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等<br><img src=\"https://img-blog.csdnimg.cn/9e5c694310674b4891a34ad61bf3167b.png\" alt=\"在这里插入图片描述\"><br>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>\n<ul>\n<li><strong>接口：</strong> 是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>\n<li><strong>实现（类）：</strong> 是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap</li>\n<li><strong>算法：</strong> 是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/a40159bc36b04b6fa7965910ad2a9aca.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"11-2-集合接口\"><a href=\"#11-2-集合接口\" class=\"headerlink\" title=\"11.2 集合接口\"></a>11.2 集合接口</h2><p>Set 和 List 的区别：</p>\n<ol>\n<li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素</li>\n<li>Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;</li>\n<li>List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt;</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/ae06b885dc9d49e59e99468d5ed49ea7.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"11-3-集合实现类\"><a href=\"#11-3-集合实现类\" class=\"headerlink\" title=\"11.3 集合实现类\"></a>11.3 集合实现类</h2><p><img src=\"https://img-blog.csdnimg.cn/f29984366288497b806a5c0fa4cf26f0.png\" alt=\"在这里插入图片描述\"><br><strong>java.util 包中定义的类：</strong><br><img src=\"https://img-blog.csdnimg.cn/05f0eb08c1bf494b97dd098afdbc2111.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"10-4-遍历\"><a href=\"#10-4-遍历\" class=\"headerlink\" title=\"10.4 遍历\"></a>10.4 遍历</h2><p><strong>推荐使用 entrySet 和 forEach 方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(16);\n\tmap.put(&quot;张三&quot;,&quot;13&quot;);\n\tmap.put(&quot;李四&quot;,&quot;14&quot;);\n\tmap.put(&quot;王五&quot;,&quot;16&quot;);\n\tmap.put(&quot;赵六&quot;,&quot;13&quot;);\n\tfor (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;\n\t\tSystem.out.println(entry.getKey() + &quot; &quot; + entry.getValue());\n\t&#125;\n\tmap.forEach((key,value) -&gt; &#123;\n\t\tSystem.out.println(key + &quot; &quot; + value);\n\t&#125;);\n&#125;</code></pre>\n\n<h2 id=\"11-5-允许空值情况\"><a href=\"#11-5-允许空值情况\" class=\"headerlink\" title=\"11.5 允许空值情况\"></a>11.5 允许空值情况</h2><p><img src=\"https://img-blog.csdnimg.cn/b320ccac9bea41dab050cf1d33041568.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"11-6-ArrayList\"><a href=\"#11-6-ArrayList\" class=\"headerlink\" title=\"11.6 ArrayList\"></a>11.6 ArrayList</h2><p><img src=\"https://img-blog.csdnimg.cn/8424aef193934c86b7598da89421aeae.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"11-7-LinkedList\"><a href=\"#11-7-LinkedList\" class=\"headerlink\" title=\"11.7 LinkedList\"></a>11.7 LinkedList</h2><p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。<br><strong>以下情况使用 ArrayList :</strong></p>\n<ul>\n<li>频繁访问列表中的某一个元素</li>\n<li>只需要在列表末尾进行添加和删除元素操作</li>\n</ul>\n<p><strong>以下情况使用 LinkedList :</strong></p>\n<ul>\n<li>你需要通过循环迭代来访问列表中的某些元素</li>\n<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作</li>\n</ul>\n<h2 id=\"11-8-HashMap\"><a href=\"#11-8-HashMap\" class=\"headerlink\" title=\"11.8 HashMap\"></a>11.8 HashMap</h2><p><img src=\"https://img-blog.csdnimg.cn/250c9452c24045b4a7d5a2ca475a2c2e.png\" alt=\"在这里插入图片描述\"><br><strong>进阶部分见：<a href=\"https://blog.csdn.net/ACE_U_005A/article/details/123276268\">https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;123276268</a></strong></p>\n","feature":false,"text":"1. 说明1.1 编译与运行 编译：是指将编写的 Java 源文件翻译成 JVM 认识的 class 文件，在这个过程中， javac 编译器会检查所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功 运行：是指将 class文件 交给 JVM 去运行，此时 JVM...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"Java","slug":"Java","count":4,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">1. 说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">1.1 编译与运行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-main-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.2 main 方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-keywords-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">1.3 keywords  关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E6%A0%87%E8%AF%86%E7%AC%A6\"><span class=\"toc-text\">1.4 标识符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2. 常量、变量、数据类型、运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">2.1 常量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">2.2 变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.3 数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">2.4 数据类型转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-1-%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">2.4.1 自动转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">2.4.2 强制转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2.5 运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-1-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2.5.1 位运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2.5.2 赋值运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-3-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">2.5.3 三元运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-4-instanceof\"><span class=\"toc-text\">2.5.4 instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-5-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">2.5.5 运算符优先级</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">3. 数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE\"><span class=\"toc-text\">3.2 数组内存图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.2.1 内存概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-JVM-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%EF%BC%88%E7%AE%80%E7%95%A5%EF%BC%89\"><span class=\"toc-text\">3.2.2 JVM 内存划分（简略）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E4%B8%A4%E4%B8%AA%E7%8B%AC%E7%AB%8B%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE\"><span class=\"toc-text\">3.2.3 两个独立数组内存图</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">3.3 数组工具类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">4. 类与对象、封装、继承、多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">4.1 类与对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.2 成员变量和局部变量区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E5%B0%81%E8%A3%85-private\"><span class=\"toc-text\">4.3 封装 private</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E7%BB%A7%E6%89%BF-super\"><span class=\"toc-text\">4.4 继承 super</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%90%8E%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">4.5 继承之后的属性和行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-%E6%8A%BD%E8%B1%A1%E7%B1%BB-abstract\"><span class=\"toc-text\">4.6 抽象类 abstract</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">4.7 多态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-8-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">4.8 引用类型转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-1-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B\"><span class=\"toc-text\">4.8.1 向上转型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B\"><span class=\"toc-text\">4.8.2 向下转型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">5. 修饰符、内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">5.1 修饰符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-1-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">5.1.1 权限修饰符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-2-final\"><span class=\"toc-text\">5.1.2 final</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-3-static\"><span class=\"toc-text\">5.1.3  static</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-4-synchronize\"><span class=\"toc-text\">5.1.4 synchronize</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-5-transient\"><span class=\"toc-text\">5.1.5 transient</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-6-volatile\"><span class=\"toc-text\">5.1.6 volatile</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">5.2 内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">5.2.1 成员内部类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">5.2.2  匿名内部类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-String-%E7%B1%BB%E3%80%81Math-%E7%B1%BB%E3%80%81Collections-%E7%B1%BB\"><span class=\"toc-text\">6. String 类、Math 类、Collections 类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-String-%E7%B1%BB\"><span class=\"toc-text\">6.1 String 类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-Math%E7%B1%BB\"><span class=\"toc-text\">6.2 Math类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-Collections-%E7%B1%BB\"><span class=\"toc-text\">6.3 Collections 类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-Comparator-%E6%AF%94%E8%BE%83%E5%99%A8\"><span class=\"toc-text\">6.4 Comparator 比较器</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">7. 异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E9%9D%9E%E6%A3%80%E6%9F%A5%E6%80%A7%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">7.1 非检查性异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E6%A3%80%E6%9F%A5%E6%80%A7%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">7.2 检查性异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E5%BC%82%E5%B8%B8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">7.3 异常方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">7.4 声明自定义异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-5-%E9%80%9A%E7%94%A8%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">7.5 通用异常</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86\"><span class=\"toc-text\">8. 时间处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4-SimpleDateFormat%E3%80%81printf\"><span class=\"toc-text\">8.1 格式化时间 SimpleDateFormat、printf</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-2-%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E6%97%B6%E9%97%B4%E7%82%B9-Calendar\"><span class=\"toc-text\">8.2 获取某个时间点 Calendar</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-3-LocalDateTime-%E4%BB%A3%E6%9B%BF-Calendar\"><span class=\"toc-text\">8.3 LocalDateTime 代替 Calendar</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-4-Instant-%E4%BB%A3%E6%9B%BF-Date\"><span class=\"toc-text\">8.4 Instant 代替 Date</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-5-DateTimeFormatter-%E4%BB%A3%E6%9B%BF-SimopleDateFormat\"><span class=\"toc-text\">8.5 DateTimeFormatter 代替 SimopleDateFormat</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-6-%E6%97%A5%E6%9C%9F%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">8.6 日期比较</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9-%E6%AD%A3%E5%88%99%E3%80%81%E6%A0%87%E7%AD%BE%E3%80%81finalize\"><span class=\"toc-text\">9. 正则、标签、finalize</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E6%AD%A3%E5%88%99\"><span class=\"toc-text\">9.1 正则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-1-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">9.1.1 语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-2-Matcher\"><span class=\"toc-text\">9.1.2 Matcher</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-2-1-%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">9.1.2.1 索引方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-2-2-%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">9.1.2.2 查找方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-2-3-%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">9.1.2.3 替换方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-1-2-4-PatternSyntaxException\"><span class=\"toc-text\">9.1.2.4 PatternSyntaxException</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">9.2 标签</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-finalize\"><span class=\"toc-text\">9.3 finalize</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10-IO\"><span class=\"toc-text\">10. IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-1-IO-%E6%B5%81\"><span class=\"toc-text\">10.1 IO 流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-2-%E5%AD%97%E8%8A%82%E6%B5%81\"><span class=\"toc-text\">10.2 字节流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-2-1-FileInputStream\"><span class=\"toc-text\">10.2.1 FileInputStream</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-2-2-FileOutputStream\"><span class=\"toc-text\">10.2.2 FileOutputStream</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-3-%E5%AD%97%E7%AC%A6%E6%B5%81\"><span class=\"toc-text\">10.3 字符流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-3-1-FileReader\"><span class=\"toc-text\">10.3.1 FileReader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-3-2-FileWriter\"><span class=\"toc-text\">10.3.2 FileWriter</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-4-%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">10.4 缓冲流</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11-Collection\"><span class=\"toc-text\">11. Collection</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-1-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">11.1 集合框架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-2-%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">11.2 集合接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-3-%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">11.3 集合实现类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-4-%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">10.4 遍历</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-5-%E5%85%81%E8%AE%B8%E7%A9%BA%E5%80%BC%E6%83%85%E5%86%B5\"><span class=\"toc-text\">11.5 允许空值情况</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-6-ArrayList\"><span class=\"toc-text\">11.6 ArrayList</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-7-LinkedList\"><span class=\"toc-text\">11.7 LinkedList</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-8-HashMap\"><span class=\"toc-text\">11.8 HashMap</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"MyBatis-Plus 使用总结","uid":"245a7be88615344e5adce1986b47a4ce","slug":"BlogRepository/开发技术及框架/MyBatis-Plus 使用总结","date":"2022-05-03T04:47:04.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/MyBatis-Plus 使用总结.json","keywords":null,"cover":"https://cover.png","text":"1. POM 依赖&lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":8,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","count":2,"path":"api/tags/MyBatis-Plus.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"VSCode 常用插件及配置使用","uid":"785e31ee7915429fd9b18ba85be30b4c","slug":"BlogRepository/开发工具及环境/VSCode 常用插件及配置使用","date":"2022-04-05T12:38:14.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发工具及环境/VSCode 常用插件及配置使用.json","keywords":null,"cover":"https://cover.png","text":"1. 常用插件 Bracket Pair Colorizer 2 Debugger for Chrome Auto Close Tag Auto Rename Tag Beautify ESLint Java extension pack：Java 相关包大全 GitHub Co...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"开发工具及环境","slug":"开发工具及环境","count":11,"path":"api/categories/开发工具及环境.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"},{"name":"VSCode","slug":"VSCode","count":2,"path":"api/tags/VSCode.json"},{"name":"编辑器","slug":"编辑器","count":2,"path":"api/tags/编辑器.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}