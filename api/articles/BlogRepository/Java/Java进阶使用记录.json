{"title":"Java进阶使用记录","uid":"9f7419bdbcee20c9483c8a0576ef5202","slug":"BlogRepository/Java/Java进阶使用记录","date":"2022-03-08T16:26:17.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Java/Java进阶使用记录.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-Asset-断言\"><a href=\"#1-Asset-断言\" class=\"headerlink\" title=\"1. Asset 断言\"></a>1. Asset 断言</h1><p>用于对值进行判断，为真则运行，否则报错，多用于调试</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Assert.isNull(null, &quot;是否为空&quot;); &#x2F;&#x2F; 为空则运行\nAssert.notNull(&quot;&quot;, &quot;是否不为空&quot;); &#x2F;&#x2F; 不为空则运行\nAssert.notEmpty(new ArrayList&lt;&gt;(), &quot;数组是否不为空&quot;); &#x2F;&#x2F; 不为空则运行</code></pre>\n\n<p><strong>可以使用 assert 进行更多判断操作，使用原则：</strong></p>\n<ol>\n<li>使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。</li>\n<li>使用断言对函数的参数进行确认。</li>\n<li>在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。</li>\n<li>一般教科书都鼓励程序员们进行防错性的程序设计，但要这种编程风格会隐瞒错误。当进行防错性编程时，如果”不可能发生”的事情的确发生了，则要使用断言进行报警。</li>\n</ol>\n<h2 id=\"1-1-IDEA-开启-assert\"><a href=\"#1-1-IDEA-开启-assert\" class=\"headerlink\" title=\"1.1 IDEA 开启 assert\"></a>1.1 IDEA 开启 assert</h2><p><img src=\"http://img.fan223.cn/2023/04/20230419111245.png\"></p>\n<p>新版 IDEA 默认把 VM Options 去掉了，需要手动加进来</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111300.png\"></p>\n<p>在 VM Options 里输入 -ea 开启断言</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111313.png\"></p>\n<h2 id=\"1-2-assert-使用\"><a href=\"#1-2-assert-使用\" class=\"headerlink\" title=\"1.2 assert 使用\"></a>1.2 assert 使用</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tint num &#x3D; 10;\n\t&#x2F;&#x2F; 判断 num 是否大于 12，不大于则为假，报错；大于则为真，继续运行\n\tassert num &gt; 12;\n\tSystem.out.println(&quot;运行&quot;);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111324.png\"></p>\n<p>也可以在后面定义错误信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tint i &#x3D; 10;\n\t&#x2F;&#x2F; 假如 i &lt; 10，则 i++，否则则报错\n\tassert (i++ &lt; 10) : &quot;num 大于等于 10&quot;;\n\tSystem.out.println(i);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111337.png\"></p>\n<h1 id=\"2-泛型\"><a href=\"#2-泛型\" class=\"headerlink\" title=\"2. 泛型\"></a>2. 泛型</h1><ul>\n<li>？ 表示不确定的 Java类型</li>\n<li>T  （type）表示 Java类型</li>\n<li>K  代表 Java 键值中的 Key</li>\n<li>V  代表 Java 键值中的Value</li>\n<li>E  代表 Element</li>\n</ul>\n<h2 id=\"2-1-定义和使用泛型类\"><a href=\"#2-1-定义和使用泛型类\" class=\"headerlink\" title=\"2.1 定义和使用泛型类\"></a>2.1 定义和使用泛型类</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[修饰符] class 类名&lt;代表泛型的变量&gt; {  }</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 定义泛型类\nclass User&lt;Fan&gt;&#123;\n    private Fan type;\n\n    public User(Fan type) &#123;\n        this.type &#x3D; type;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;type&#x3D;&quot; + type +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public Fan getType() &#123;\n        return type;\n    &#125;\n\n    public void setType(Fan type) &#123;\n        this.type &#x3D; type;\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tUser&lt;String&gt; stringUser &#x3D; new User&lt;&gt;(&quot;String&quot;);  &#x2F;&#x2F; 可以限制泛型为 String\n\tSystem.out.println(stringUser); &#x2F;&#x2F; 输出 String\n\n\tUser user &#x3D; new User&lt;&gt;(1); &#x2F;&#x2F; 不进行限制\n\tSystem.out.println(user); &#x2F;&#x2F; 输出 1\n\tuser.setType(&quot;类型&quot;); \n\tSystem.out.println(user); &#x2F;&#x2F; 输出 类型\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111348.png\"></p>\n<h2 id=\"2-2-定义和使用泛型方法\"><a href=\"#2-2-定义和使用泛型方法\" class=\"headerlink\" title=\"2.2 定义和使用泛型方法\"></a>2.2 定义和使用泛型方法</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) {  }</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 定义泛型方法\nclass Person&#123;\n    public &lt;Fan&gt; void show(Fan fan)&#123;\n        System.out.println(fan);\n    &#125;\n    public &lt;Fan&gt; Fan showFan(Fan fan)&#123;\n        return fan;\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tPerson person &#x3D; new Person();\n\tperson.show(&quot;String&quot;); &#x2F;&#x2F; 无返回，直接输出\n\n\t&#x2F;&#x2F; 传入一个 List 的 User泛型对象，User 的泛型又为 List\n\tArrayList&lt;User&lt;List&lt;String&gt;&gt;&gt; users &#x3D; person.showFan(new ArrayList&lt;User&lt;List&lt;String&gt;&gt;&gt;()&#123;\n\t\t&#123;\n\t\t\tthis.add(new User&lt;&gt;(new ArrayList&lt;String&gt;()&#123;\n\t\t\t\t&#123;\n\t\t\t\t\tthis.add(&quot;array11&quot;);\n\t\t\t\t\tthis.add(&quot;array12&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;));\n\t\t\tthis.add(new User&lt;&gt;(new ArrayList&lt;String&gt;()&#123;\n\t\t\t\t&#123;\n\t\t\t\t\tthis.add(&quot;array21&quot;);\n\t\t\t\t\tthis.add(&quot;array22&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;));\n\t\t&#125;\n\t&#125;);\n\tSystem.out.println(users); &#x2F;&#x2F; 输出返回值\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111357.png\"></p>\n<h2 id=\"2-3-定义和使用泛型接口\"><a href=\"#2-3-定义和使用泛型接口\" class=\"headerlink\" title=\"2.3 定义和使用泛型接口\"></a>2.3 定义和使用泛型接口</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>修饰符 interface 接口名&lt;代表泛型的变量&gt; {  }</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">interface MyInterface&lt;Fan&gt;&#123;\n    void add(Fan fan);\n\n    Fan get(Fan fan);\n&#125;</code></pre>\n\n<h3 id=\"2-3-1-定义实现类时确定泛型的类型\"><a href=\"#2-3-1-定义实现类时确定泛型的类型\" class=\"headerlink\" title=\"2.3.1 定义实现类时确定泛型的类型\"></a>2.3.1 定义实现类时确定泛型的类型</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MyInterfaceImpl implements MyInterface&lt;String&gt;&#123;\n    @Override\n    public void add(String s) &#123;\n    \tSystem.out.println(s + &quot;，fan&quot;);\n    &#125;\n\n    @Override\n    public String get(String s) &#123;\n        return s;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"2-3-2-始终不确定泛型的类型，直到创建对象时，确定泛型的类型\"><a href=\"#2-3-2-始终不确定泛型的类型，直到创建对象时，确定泛型的类型\" class=\"headerlink\" title=\"2.3.2 始终不确定泛型的类型，直到创建对象时，确定泛型的类型\"></a>2.3.2 始终不确定泛型的类型，直到创建对象时，确定泛型的类型</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 实现类\nclass MyInterfaceImpl&lt;Fan&gt; implements MyInterface&lt;Fan&gt;&#123;\n\n    @Override\n    public void add(Fan fan) &#123;\n        System.out.println(fan + &quot;，fan&quot;);\n    &#125;\n\n    @Override\n    public Fan get(Fan fan) &#123;\n        return fan;\n    &#125;\n&#125;\n&#x2F;&#x2F; 主启动类\npublic static void main(String[] args)&#123;\n\tMyInterface myInterface &#x3D; new MyInterfaceImpl(); &#x2F;&#x2F; 不限制泛型\n\tmyInterface.add(1);\n\tMyInterface&lt;String&gt; myInterface1 &#x3D; new MyInterfaceImpl&lt;&gt;(); &#x2F;&#x2F; 限制泛型为 String\n\tSystem.out.println(myInterface1.get(&quot;String&quot;));\n&#125;</code></pre>\n\n<h2 id=\"2-4-泛型通配符-？\"><a href=\"#2-4-泛型通配符-？\" class=\"headerlink\" title=\"2.4 泛型通配符 ？\"></a>2.4 泛型通配符 ？</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符 &lt;?&gt; 表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用</p>\n<h3 id=\"2-4-1-通配符基础使用\"><a href=\"#2-4-1-通配符基础使用\" class=\"headerlink\" title=\"2.4.1 通配符基础使用\"></a>2.4.1 通配符基础使用</h3><p>泛型的通配符：不知道使用什么类型来接收的时候，此时可以使用 <code>?,?</code> 表示未知通配符。此时只能接受数据,不能往该集合中存储数据。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tget(new ArrayList&lt;Integer&gt;()&#123;\n\t\t&#123;\n\t\t\tthis.add(1);\n\t\t\tthis.add(2);\n\t\t&#125;\n\t&#125;);\n\tget(new LinkedList&lt;String&gt;()&#123;\n\t\t&#123;\n\t\t\tthis.add(&quot;String1&quot;);\n\t\t\tthis.add(&quot;String1&quot;);\n\t\t&#125;\n\t&#125;);\n&#125;\npublic static void get(Collection&lt;?&gt; collection)&#123; &#x2F;&#x2F; 可以传入任意的 Collection 下的类型\n\tcollection.stream().forEach(o -&gt; &#123;\n\t\tSystem.out.println(o);\n\t&#125;);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111409.png\"></p>\n<h4 id=\"2-4-2-通配符高级使用—-受限泛型\"><a href=\"#2-4-2-通配符高级使用—-受限泛型\" class=\"headerlink\" title=\"2.4.2 通配符高级使用—-受限泛型\"></a>2.4.2 通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限</p>\n<p><strong>泛型的上限：</strong></p>\n<ul>\n<li><strong>格式：</strong> 类型名称 &lt;? extends 类 &gt; 对象名称</li>\n<li><strong>意义：</strong> 只能接收该类型及其子类</li>\n</ul>\n<p><strong>泛型的下限：</strong></p>\n<ul>\n<li><strong>格式：</strong> 类型名称 &lt;? super 类 &gt; 对象名称</li>\n<li><strong>意义：</strong> 只能接收该类型及其父类型</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类\n&#x2F;&#x2F; Collection 可以换为 ArrayList 等其他类型\npublic static void getElement1(Collection&lt;? extends Number&gt; collection)&#123;\n\n&#125;\n&#x2F;&#x2F; 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类\npublic static void getElement2(Collection&lt;? super Number&gt; collection)&#123;\n\n&#125;\n&#x2F;&#x2F; 现已知 Object 类，String 类，Number 类，Integer 类，其中 Number 是 Integer 的父类\npublic static void main(String[] args) &#123;\n    Collection&lt;Integer&gt; integer &#x3D; new ArrayList&lt;Integer&gt;();\n    Collection&lt;String&gt; string &#x3D; new ArrayList&lt;String&gt;();\n    Collection&lt;Number&gt; number &#x3D; new ArrayList&lt;Number&gt;();\n    Collection&lt;Object&gt; object &#x3D; new ArrayList&lt;Object&gt;();\n  \n    getElement1(integer);\n    getElement1(string);&#x2F;&#x2F;报错\n    getElement1(number);\n    getElement1(object);&#x2F;&#x2F;报错\n  \n    getElement2(integer);&#x2F;&#x2F;报错\n    getElement2(string);&#x2F;&#x2F;报错\n    getElement2(number);\n    getElement2(object);\n&#125;</code></pre>\n\n<h1 id=\"3-反射\"><a href=\"#3-反射\" class=\"headerlink\" title=\"3. 反射\"></a>3. 反射</h1><ul>\n<li><p>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</p>\n</li>\n<li><p>反射：将类的各个组成部分封装为其他对象，这就是反射机制<br>好处：</p>\n<ol>\n<li>可以在程序运行过程中，操作这些对象</li>\n<li>可以解耦，提高程序的可扩展性</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"3-1-获取Class对象的方式\"><a href=\"#3-1-获取Class对象的方式\" class=\"headerlink\" title=\"3.1 获取Class对象的方式\"></a>3.1 获取Class对象的方式</h2><ol>\n<li><strong><code>Class.forName(&quot;全类名&quot;)</code>：将字节码文件加载进内存，返回Class对象</strong><br>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li>\n<li><strong><code>类名.class</code>：通过类名的属性 class 获取</strong><br>多用于参数的传递</li>\n<li><strong><code>对象.getClass()</code>：getClass()方法是Object类中的方法，Object类是所有类的父类，所有创建的对象都有该方法.</strong><br>多用于对象的获取字节码的方式</li>\n<li><strong>通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取</strong></li>\n</ol>\n<p><strong>结论：</strong><br>同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个</p>\n<h2 id=\"3-2-Class对象功能\"><a href=\"#3-2-Class对象功能\" class=\"headerlink\" title=\"3.2 Class对象功能\"></a>3.2 Class对象功能</h2><p><strong>获取功能：</strong></p>\n<ol>\n<li><strong>获取成员变量</strong><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 获取所有 public 的成员变量，包括继承的\nField[] getFields() \n&#x2F;&#x2F; 获取指定名称的 public 成员变量\nField getField(String name) \n&#x2F;&#x2F; 获取所有的成员变量，不考虑修饰符，不包括继承的（这里只能获取到 private 的属性，但并不能访问该 private 字段的值,除非加上 setAccessible(true)）\nField[] getDeclaredFields() \n&#x2F;&#x2F; 获取指定名称的所有成员变量，不考虑修饰符\nField getDeclaredField(String name) </code></pre></li>\n<li><strong>获取构造方法</strong><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 获取所有 public 的构造方法\nConstructor&lt;?&gt;[] getConstructors() \n&#x2F;&#x2F; 获取传入数据类型的对应构造方法，Constructor&lt;UserTest&gt; constructor &#x3D; userTestClass.getConstructor(String.class, Integer.class);\nConstructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)  \n&#x2F;&#x2F; 不考虑修饰符获取\nConstructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)   \n&#x2F;&#x2F; 不考虑修饰符获取\nConstructor&lt;?&gt;[] getDeclaredConstructors()  </code></pre></li>\n<li><strong>获取成员方法</strong><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 获取所有 public 的成员方法，包括继承的\nMethod[] getMethods() \n&#x2F;&#x2F; 获取指定名称和传入参数类型的 public 成员方法，Method test &#x3D; userTestClass.getMethod(&quot;test&quot;, String.class);\nMethod getMethod(String name, 类&lt;?&gt;... parameterTypes) \n&#x2F;&#x2F; 获取所有的成员方法，不包括继承的\nMethod[] getDeclaredMethods() \n&#x2F;&#x2F; 获取指定名称和传入参数类型的所有成员方法\nMethod getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) </code></pre></li>\n<li><strong>获取全类名</strong><pre class=\"line-numbers language-none\"><code class=\"language-none\">String getName()  </code></pre></li>\n</ol>\n<h2 id=\"3-3-Field-成员变量\"><a href=\"#3-3-Field-成员变量\" class=\"headerlink\" title=\"3.3 Field 成员变量\"></a>3.3 Field 成员变量</h2><p><strong>操作：</strong></p>\n<ol>\n<li>设置值<br>void set(Object obj, Object value)</li>\n<li>获取值<br>get(Object obj)</li>\n<li>忽略访问权限修饰符的安全检查（可以获取 private 的成员变量的值）<br>setAccessible(true)：暴力反射</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 示例类\nclass UserTest&#123;\n    private String name;\n    private Integer age;\n    public String birthday;\n\n    public UserTest() &#123;\n    &#125;\n\n    public UserTest(String name, Integer age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public void test()&#123;\n        System.out.println(&quot;test&quot;);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;UserTest&#123;&quot; +\n                &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age&#x3D;&quot; + age +\n                &quot;, birthday&#x3D;&#39;&quot; + birthday + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception &#123;\n\tUserTest userTest &#x3D; new UserTest(); &#x2F;&#x2F; 新建一个对象\n\tClass&lt;? extends UserTest&gt; aClass &#x3D; userTest.getClass(); &#x2F;&#x2F; 通过对象.getClass() 的方式获取字节码\n\tField[] fields &#x3D; aClass.getFields(); &#x2F;&#x2F; 获取 public 的成员变量\n\tfor (Field field : fields) &#123;\n\t    &#x2F;&#x2F; public java.lang.String fan.demo02.UserTest.birthday\n\t\tSystem.out.println(field);\n\t\tSystem.out.println(field.getName()); &#x2F;&#x2F; birthday\n\n\t\tSystem.out.println(field.get(userTest)); &#x2F;&#x2F; 获取值 null\n\t\tfield.set(userTest,&quot;2001&quot;); &#x2F;&#x2F; 设置值，传入对象和设置的值\n\t\tSystem.out.println(field.get(userTest)); &#x2F;&#x2F; 2001\n\t&#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111430.png\"></p>\n<h2 id=\"3-4-Constructor-构造方法\"><a href=\"#3-4-Constructor-构造方法\" class=\"headerlink\" title=\"3.4 Constructor 构造方法\"></a>3.4 Constructor 构造方法</h2><p><strong>创建对象：</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>T newInstance(Object… initargs)</p></blockquote>\n<p>注：如果使用空参数构造方法创建对象，操作可以简化：<strong>Class对象.newInstance方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception &#123;\n\t&#x2F;&#x2F; 无参构造创建对象\n\tClass&lt;UserTest&gt; userTestClass &#x3D; UserTest.class;  &#x2F;&#x2F; 通过类名.class 的方式获取字节码\n\tUserTest userTest &#x3D; userTestClass.newInstance(); &#x2F;&#x2F; 直接通过Class对象.newInstance() 方法创建对象\n\tUserTest userTest &#x3D; userTestClass.getConstructor().newInstance(); &#x2F;&#x2F; 获取构造方法再调用 newInstance 方法\n\n\t&#x2F;&#x2F; 有参构造创建对象，传入对应的数据类型\n\tConstructor&lt;UserTest&gt; constructor &#x3D; userTestClass.getConstructor(String.class, Integer.class);\n    UserTest userTest &#x3D; constructor.newInstance(&quot;张三&quot;,1);\n&#125;</code></pre>\n\n<h2 id=\"3-5-Method-方法对象\"><a href=\"#3-5-Method-方法对象\" class=\"headerlink\" title=\"3.5 Method 方法对象\"></a>3.5 Method 方法对象</h2><p><strong>执行方法：</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Object invoke(Object obj, Object… args) ：调用 obj 对象的成员方法，参数是args，返回值是 Object 类型</p></blockquote>\n<p><strong>获取方法名称：</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>String getName:获取方法名</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception &#123;\n\tClass&lt;UserTest&gt; userTestClass &#x3D; UserTest.class;\n\tMethod test &#x3D; userTestClass.getMethod(&quot;test&quot;, String.class);\n\tSystem.out.println(test); &#x2F;&#x2F; public void fan.demo02.UserTest.test(java.lang.String)\n\tSystem.out.println(test.getName()); &#x2F;&#x2F; test\n\n\tUserTest userTest &#x3D; userTestClass.newInstance(); &#x2F;&#x2F; 创建对象\n\t&#x2F;&#x2F; 调用对象的 test 方法，有传参，传入参数 “李四”，有返回值，输出 “李四”\n    System.out.println(test.invoke(userTest,&quot;李四&quot;));\n\n\t&#x2F;&#x2F; 调用对象的 test1 方法，无传参，无返回值，输出为 null\n    Method test1 &#x3D; aClass.getMethod(&quot;test1&quot;);\n    System.out.println(test1.invoke(userTest));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111443.png\"></p>\n<h1 id=\"4-注解\"><a href=\"#4-注解\" class=\"headerlink\" title=\"4. 注解\"></a>4. 注解</h1><h2 id=\"4-1-概念\"><a href=\"#4-1-概念\" class=\"headerlink\" title=\"4.1 概念\"></a>4.1 概念</h2><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p>\n<ul>\n<li>注解：说明程序的。给计算机看的。@注解名称</li>\n<li>注释：用文字描述程序的。给程序员看的</li>\n</ul>\n<h2 id=\"4-2-作用分类\"><a href=\"#4-2-作用分类\" class=\"headerlink\" title=\"4.2 作用分类\"></a>4.2 作用分类</h2><ol>\n<li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li>\n<li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li>\n<li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译 【Override】</li>\n</ol>\n<h2 id=\"4-3-JDK中预定义的一些注解\"><a href=\"#4-3-JDK中预定义的一些注解\" class=\"headerlink\" title=\"4.3 JDK中预定义的一些注解\"></a>4.3 JDK中预定义的一些注解</h2><ul>\n<li>@Override\t：检测被该注解标注的方法是否是继承自父类(接口)的</li>\n<li>@Deprecated：该注解标注的内容，表示已过时</li>\n<li>@SuppressWarnings：压制警告<br>一般传递参数 all  @SuppressWarnings(“all”)</li>\n</ul>\n<h2 id=\"4-4-自定义注解\"><a href=\"#4-4-自定义注解\" class=\"headerlink\" title=\"4.4 自定义注解\"></a>4.4 自定义注解</h2><ul>\n<li><p><strong>格式：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 元注解\npublic @interface 注解名称&#123;\n \t属性列表;\n &#125;</code></pre></li>\n<li><p><strong>本质：</strong><br>注解本质上就是一个接口，该接口默认继承 Annotation 接口</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>public interface MyAnnotation  extends java.lang.annotation.Annotation { }</p></blockquote>\n</li>\n<li><p><strong>属性：接口中的抽象方法</strong></p>\n<ul>\n<li>1、属性的返回值类型有下列取值<ul>\n<li>基本数据类型</li>\n<li>String</li>\n<li>枚举</li>\n<li>注解</li>\n<li>以上类型的数组</li>\n</ul>\n</li>\n<li>2、定义了属性，在使用时需要给属性赋值<ul>\n<li>如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值</li>\n<li>如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可</li>\n<li>数组赋值时，值使用 { } 包裹。如果数组中只有一个值，则 { } 可以省略</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>元注解：用于描述注解的注解</strong></p>\n<ul>\n<li><strong>@Target：描述注解能够作用的位置</strong><ul>\n<li>ElementType取值：<ul>\n<li>TYPE：可以作用于类上</li>\n<li>METHOD：可以作用于方法上</li>\n<li>FIELD：可以作用于成员变量上</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>@Retention：描述注解被保留的阶段（存活阶段）</strong><ul>\n<li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到 class 字节码文件中，并被 JVM 读取到</li>\n</ul>\n</li>\n<li><strong>@Documented：描述注解是否被抽取到 api 文档中</strong></li>\n<li><strong>@Inherited：所标记的类的子类也会拥有这个注解</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 自定义一个注解\n@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;) &#x2F;&#x2F; 作用在变量和方法上\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface MyAnnotation &#123;\n    String value() default &quot;fan&quot;; &#x2F;&#x2F; 设置默认值\n    boolean isNull(); &#x2F;&#x2F; 不设置默认值，通过标注注解时传入\n&#125;\n&#x2F;&#x2F; 配置注解\n@MyAnnotation(isNull &#x3D; true)\n@Data\nclass Person &#123;\n    private String name;\n    private int age;\n    private boolean isDelete;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception&#123;\n\tPerson person &#x3D; new Person();\n\tClass&lt;? extends Person&gt; personClass &#x3D; person.getClass();\n\n\t&#x2F;&#x2F; 通过反射，获取作用在类上的注解\n\tMyAnnotation annotation &#x3D; personClass.getAnnotation(MyAnnotation.class); \n\t&#x2F;&#x2F; @fan.annotation.MyAnnotation(value&#x3D;fan, isNull&#x3D;true)\n\tSystem.out.println(annotation);\n\n\tperson.setName(annotation.value()); &#x2F;&#x2F; 注入从注解里获取到的值\n\tperson.setDelete(annotation.isNull());\n\tSystem.out.println(person);  &#x2F;&#x2F; Person(name&#x3D;fan, age&#x3D;0, isDelete&#x3D;true)\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111501.png\"></p>\n<h1 id=\"5-函数式接口\"><a href=\"#5-函数式接口\" class=\"headerlink\" title=\"5. 函数式接口\"></a>5. 函数式接口</h1><h2 id=\"5-1-概念\"><a href=\"#5-1-概念\" class=\"headerlink\" title=\"5.1 概念\"></a>5.1 概念</h2><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong></p>\n<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的 for-each 语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java 中的 Lambda 可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的</p></blockquote>\n<h2 id=\"5-2-格式\"><a href=\"#5-2-格式\" class=\"headerlink\" title=\"5.2 格式\"></a>5.2 格式</h2><p><strong>只要确保接口中有且仅有一个抽象方法即可</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">修饰符 interface 接口名称 &#123;\n\tpublic abstract 返回值类型 方法名称(可选参数信息);\n\t&#x2F;&#x2F; 其他非抽象方法内容\n&#125;</code></pre>\n\n<h2 id=\"5-3-FunctionalInterface-注解\"><a href=\"#5-3-FunctionalInterface-注解\" class=\"headerlink\" title=\"5.3 @FunctionalInterface 注解\"></a>5.3 @FunctionalInterface 注解</h2><p>与 @Override 注解的作用类似，Java 8 中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注解可用于一个接口的定义上：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FunctionalInterface\npublic interface MyFunctionalInterface &#123;\n\tvoid myMethod();\n&#125;</code></pre>\n\n<p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样</p>\n<h2 id=\"5-4-自定义函数式接口\"><a href=\"#5-4-自定义函数式接口\" class=\"headerlink\" title=\"5.4 自定义函数式接口\"></a>5.4 自定义函数式接口</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 定义一个函数式接口\n@FunctionalInterface\npublic interface MyFunction &#123;\n    String myMethod(String name); &#x2F;&#x2F; public abstract 可以省略\n    default void hidden() &#123; &#125;;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 最基础写法\n\ttest(new MyFunction() &#123;\n\t\t@Override\n\t\tpublic String myMethod(String name) &#123;\n\t\t\tSystem.out.println(&quot;myMethod方法执行！&quot;);\n\t\t\treturn name;\n\t\t&#125;\n\t&#125;);\n\t&#x2F;&#x2F; 使用 Lambda 表达式\n\ttest(name -&gt; &#123;\n\t\tSystem.out.println(&quot;myMethod方法执行！&quot;);\n\t\treturn name;\n\t&#125;);\n\t&#x2F;&#x2F; 假如没有其他语句直接返回值，可以省略大括号和 return\n\ttest(name -&gt; name);\n&#125;\n\npublic static void test(MyFunction myFunction)&#123;\n\tString name &#x3D; myFunction.myMethod(&quot;fan&quot;);\n\tSystem.out.println(name);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111513.png\"></p>\n<h2 id=\"5-5-Lambda-的延迟执行\"><a href=\"#5-5-Lambda-的延迟执行\" class=\"headerlink\" title=\"5.5 Lambda 的延迟执行\"></a>5.5 Lambda 的延迟执行</h2><p>当 flag 为 false 的时候，Lambda将不会执行。从而达到节省性能的效果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\ttest(false, name -&gt; &#123;\n\t\tSystem.out.println(&quot;myMethod方法执行！&quot;);\n\t\treturn name;\n\t&#125;);\n&#125;\npublic static void test(Boolean flag, MyFunction myFunction)&#123;\n\tif (flag &#x3D;&#x3D; true)&#123;\n\t\tString s &#x3D; myFunction.myMethod(&quot;fan&quot;);\n\t\tSystem.out.println(s);\n\t&#125;else &#123;\n\t\tSystem.out.println(&quot;未执行&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111528.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的</p></blockquote>\n<h2 id=\"5-6-Lambda-作为参数和返回值\"><a href=\"#5-6-Lambda-作为参数和返回值\" class=\"headerlink\" title=\"5.6 Lambda 作为参数和返回值\"></a>5.6 Lambda 作为参数和返回值</h2><p>如果抛开实现原理不说，Java 中的 Lambda 表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用 Lambda 表达式进行替代。使用 Lambda 表达式作为方法参数，其实就是使用函数式接口作为方法参数</p>\n<h3 id=\"5-6-1-作为参数\"><a href=\"#5-6-1-作为参数\" class=\"headerlink\" title=\"5.6.1 作为参数\"></a>5.6.1 作为参数</h3><p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就可以使用 Lambda 进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo04Runnable &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tstartThread(() ‐&gt; System.out.println(&quot;线程任务执行！&quot;));\n\t&#125;\n\tprivate static void startThread(Runnable runnable) &#123;\n\t\tnew Thread(runnable).start();\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"5-6-2-作为返回值\"><a href=\"#5-6-2-作为返回值\" class=\"headerlink\" title=\"5.6.2 作为返回值\"></a>5.6.2 作为返回值</h3><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个 Lambda 表达式。当需要通过一个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo06Comparator &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tString[] array &#x3D; &#123; &quot;abc&quot;, &quot;ab&quot;, &quot;abcd&quot; &#125;;\n\t\tSystem.out.println(Arrays.toString(array));\n\t\tArrays.sort(array, newComparator());\n\t\tSystem.out.println(Arrays.toString(array));\n\t&#125;\n\tprivate static Comparator&lt;String&gt; newComparator() &#123;\n\t\treturn (a, b) ‐&gt; b.length() ‐ a.length();\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"5-7-常用函数式接口\"><a href=\"#5-7-常用函数式接口\" class=\"headerlink\" title=\"5.7 常用函数式接口\"></a>5.7 常用函数式接口</h2><p>JDK 提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供</p>\n<h3 id=\"5-7-1-Supplier\"><a href=\"#5-7-1-Supplier\" class=\"headerlink\" title=\"5.7.1 Supplier\"></a>5.7.1 Supplier</h3><p>java.util.function.Supplier<T> 接口仅包含一个无参的方法： T get() 。用来<strong>获取一个泛型参数指定类型的对象数据</strong>。由于这是一个函数式接口，这也就意味着对应的 Lambda 表达式需要“对外提供”一个符合泛型类型的对象数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tSystem.out.println(test(new Supplier&lt;String&gt;() &#123;\n\t\t@Override\n\t\tpublic String get() &#123; &#x2F;&#x2F; 参数类型为使用 Supplier 时指定的数据类型\n\t\t\treturn &quot;fan&quot;;\n\t\t&#125;\n\t&#125;));\n\tSystem.out.println(test(() -&gt; &quot;fan&quot;));\n&#125;\npublic static String test(Supplier&lt;String&gt; supplier)&#123;\n\treturn supplier.get();\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111543.png\"></p>\n<h3 id=\"5-7-2-Consumer\"><a href=\"#5-7-2-Consumer\" class=\"headerlink\" title=\"5.7.2 Consumer\"></a>5.7.2 Consumer</h3><p>java.util.function.Consumer&lt;T&gt; 接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费一个数据，其数据类型由泛型决定</strong></p>\n<ol>\n<li><p><strong>抽象方法：accept</strong><br>Consumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    test(&quot;fan&quot;, new Consumer&lt;String&gt;() &#123;\n        @Override\n        public void accept(String  name) &#123;\n            System.out.println(name);\n        &#125;\n    &#125;);\n    test(&quot;fan&quot;, name -&gt; System.out.println(name));\n&#125;\n\npublic static void test(String name, Consumer&lt;String&gt; consumer)&#123;\n    consumer.accept(name);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111559.png\"></p>\n</li>\n<li><p><strong>默认方法：andThen</strong><br>如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的 default 方法 andThen</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    test(&quot;fan&quot;, one -&gt; System.out.println(one.toLowerCase()), \n            two -&gt; System.out.println(two.toUpperCase()));\n&#125;\n\npublic static void test(String name, Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)&#123;\n    Consumer&lt;String&gt; stringConsumer &#x3D; one.andThen(two);\n    stringConsumer.accept(name);\n\n    one.andThen(two).accept(name);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111613.png\"></p>\n</li>\n</ol>\n<h3 id=\"5-7-3-Predicate\"><a href=\"#5-7-3-Predicate\" class=\"headerlink\" title=\"5.7.3 Predicate\"></a>5.7.3 Predicate</h3><p>有时候我们需要<strong>对某种类型的数据进行判断，从而得到一个 boolean 值结果</strong>。这时可以使用 java.util.function.Predicate&lt;T&gt; 接口</p>\n<ol>\n<li><p><strong>抽象方法：test</strong><br>Predicate 接口中包含一个抽象方法： boolean test(T t) 。用于条件判断的场景</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    test(&quot;false&quot;, new Predicate&lt;String&gt;() &#123;\n        @Override\n        public boolean test(String s) &#123;\n            return s.length() &gt; 4; &#x2F;&#x2F; 返回一个判断\n        &#125;\n    &#125;);\n    &#x2F;&#x2F; 判断字符串长度是否小于 4\n    test(&quot;false&quot;, s -&gt; s.length() &lt; 4);\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; predicate)&#123;\n    boolean test &#x3D; predicate.test(str);\n    System.out.println(test);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111625.png\"></p>\n</li>\n<li><p><strong>默认方法：and</strong><br>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用  default 方法 and</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 判断字符串是否存在 H 并且存在 W\n    test(&quot;fanHW&quot;, one -&gt; one.contains(&quot;H&quot;), two -&gt; two.contains(&quot;W&quot;));\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)&#123;\n    boolean test &#x3D; one.and(two).test(str);\n    System.out.println(test);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111634.png\"></p>\n</li>\n<li><p><strong>默认方法：or</strong><br>与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F; 判断字符串是否存在 H 或存在 W\n    test(&quot;fanH&quot;, one -&gt; one.contains(&quot;H&quot;), two -&gt; two.contains(&quot;W&quot;));\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)&#123;\n    boolean test &#x3D; one.or(two).test(str);\n    System.out.println(test);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111645.png\"></p>\n</li>\n<li><p><strong>默认方法：negate</strong><br>它是执行了test方法之后，对结果 boolean 值进行 “!” 取反。一定要在 test 方法调用之前调用 negate 方法，正如 and 和 or 方法一样</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    test(&quot;fanH&quot;, one -&gt; one.contains(&quot;H&quot;), two -&gt; two.contains(&quot;W&quot;));\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)&#123;\n    boolean test &#x3D; one.or(two).negate().test(str); &#x2F;&#x2F; 对结果取反\n    System.out.println(test);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111655.png\"></p>\n</li>\n</ol>\n<h3 id=\"5-7-4-Function\"><a href=\"#5-7-4-Function\" class=\"headerlink\" title=\"5.7.4 Function\"></a>5.7.4 Function</h3><p>java.util.function.Function&lt;T,R&gt; 接口用来<strong>根据一个类型的数据得到另一个类型的数据</strong>，前者称为前置条件，后者称为后置条件</p>\n<ol>\n<li><p><strong>抽象方法：apply</strong><br>Function 接口中最主要的抽象方法为：R apply(T t) ，根据类型 T 的参数获取类型R的结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 将 String 类型转换为 Integer 类型\npublic static void main(String[] args) &#123;\n    test(&quot;1234&quot;, new Function&lt;String, Integer&gt;() &#123;\n        @Override\n        public Integer apply(String s) &#123;\n            System.out.println(&quot;apply方法执行！&quot;);\n            return Integer.parseInt(s); &#x2F;&#x2F; 返回转换后的类型\n        &#125;\n    &#125;);\n    test(&quot;1234&quot;, s -&gt; Integer.parseInt(s));\n&#125;\n\npublic static void test(String str, Function&lt;String, Integer&gt; function)&#123;\n    Integer apply &#x3D; function.apply(str);\n    System.out.println(apply);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111715.png\"></p>\n</li>\n<li><p><strong>默认方法：andThen</strong><br>Function 接口中有一个默认的 andThen 方法，用来进行组合操作，用于“先做什么，再做什么”的场景</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 先进行类型转换，然后再将转换后的类型的值乘以 10\n    test(&quot;1234&quot;, one -&gt; Integer.parseInt(one), two -&gt; two *&#x3D; 10);\n&#125;\n\npublic static void test(String str, Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)&#123;\n    Integer apply &#x3D; one.andThen(two).apply(str);\n    System.out.println(apply);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111732.png\"></p>\n</li>\n</ol>\n<h1 id=\"6-网络编程\"><a href=\"#6-网络编程\" class=\"headerlink\" title=\"6. 网络编程\"></a>6. 网络编程</h1><p>网络编程，就是在一定的协议下，实现两台计算机的通信的程序</p>\n<h2 id=\"6-1-网络通信协议\"><a href=\"#6-1-网络通信协议\" class=\"headerlink\" title=\"6.1 网络通信协议\"></a>6.1 网络通信协议</h2><ul>\n<li><strong>网络通信协议</strong>：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。</li>\n<li><strong>TCP&#x2F;IP协议</strong>：传输控制协议&#x2F;因特网互联协议( Transmission Control Protocol&#x2F;Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>\n<li><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/123406567\"><strong>模型各分层作用及对应协议</strong></a></li>\n</ul>\n<h2 id=\"6-2-协议分类\"><a href=\"#6-2-协议分类\" class=\"headerlink\" title=\"6.2 协议分类\"></a>6.2 协议分类</h2><p>通信的协议还是比较复杂的， java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。java.net 包中提供了两种常见的网络协议的支持</p>\n<h3 id=\"6-2-1-TCP\"><a href=\"#6-2-1-TCP\" class=\"headerlink\" title=\"6.2.1 TCP\"></a>6.2.1 TCP</h3><p>传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输</p>\n<p><strong>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</strong></p>\n<ul>\n<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</li>\n<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求</li>\n<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接</li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111746.png\"></p>\n<p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等</p>\n<h3 id=\"6-2-2-UDP\"><a href=\"#6-2-2-UDP\" class=\"headerlink\" title=\"6.2.2 UDP\"></a>6.2.2 UDP</h3><p>用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在 64k 以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等</p>\n<h2 id=\"6-3-网络编程三要素\"><a href=\"#6-3-网络编程三要素\" class=\"headerlink\" title=\"6.3  网络编程三要素\"></a>6.3  网络编程三要素</h2><h3 id=\"6-3-1-协议\"><a href=\"#6-3-1-协议\" class=\"headerlink\" title=\"6.3.1 协议\"></a>6.3.1 协议</h3><p>计算机网络通信必须遵守的规则</p>\n<h3 id=\"6-3-2-IP地址\"><a href=\"#6-3-2-IP地址\" class=\"headerlink\" title=\"6.3.2 IP地址\"></a>6.3.2 IP地址</h3><p>指互联网协议地址（Internet Protocol Address），俗称 IP。IP 地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”</p>\n<p><strong>IP地址分类</strong></p>\n<ul>\n<li>IPv4：是一个 32 位的二进制数，通常被分为 4 个字节，表示成 a.b.c.d 的形式，例如 192.168.65.100 。其中 a、b、c、d 都是0~255之间的十进制整数，那么最多可以表示42亿个</li>\n<li>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。有资料显示，全球 IPv4 地址在2011年2月分配完毕。为了扩大地址空间，拟通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 ，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题</li>\n</ul>\n<p><strong>常用命令</strong></p>\n<ul>\n<li>查看本机IP地址<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ipconfig</code></pre></li>\n<li>检查网络是否连通<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ping IP地址</code></pre></li>\n</ul>\n<h3 id=\"6-3-3-端口号\"><a href=\"#6-3-3-端口号\" class=\"headerlink\" title=\"6.3.3 端口号\"></a>6.3.3 端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>\n<p>如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了</p>\n<ul>\n<li><strong>端口号</strong>：用两个字节表示的整数，它的取值范围是 0-65535。其中，0~1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</li>\n</ul>\n<p>利用 <strong>协议 + IP地址 + 端口号</strong> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互<br><strong><a href=\"https://blog.csdn.net/ACE_U_005A/article/details/123416212\">Window 和 Linux 查看端口常用命令</a></strong></p>\n<h2 id=\"6-4-TCP-通信程序\"><a href=\"#6-4-TCP-通信程序\" class=\"headerlink\" title=\"6.4 TCP 通信程序\"></a>6.4 TCP 通信程序</h2><p>TCP 通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。两端通信时步骤：</p>\n<ol>\n<li>服务端程序，需要事先启动，等待客户端的连接</li>\n<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端</li>\n</ol>\n<p>在Java中，提供了两个类用于实现 TCP 通信程序：</p>\n<ol>\n<li>客户端： java.net.Socket 类表示<br>创建 Socket 对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信</li>\n<li>服务端： java.net.ServerSocket 类表示<br>创建 ServerSocket 对象，相当于开启一个服务，并等待客户端的连接</li>\n</ol>\n<h3 id=\"6-4-1-Socket-类\"><a href=\"#6-4-1-Socket-类\" class=\"headerlink\" title=\"6.4.1 Socket 类\"></a>6.4.1 Socket 类</h3><p>Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点</p>\n<p><strong>构造方法：public Socket(String host, int port)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Socket client &#x3D; new Socket(&quot;127.0.0.1&quot;, 6666);</code></pre>\n\n<p>创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的 host 是 null ，则相当于指定地址为回送地址</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输</p></blockquote>\n<p><strong>成员方法</strong></p>\n<ul>\n<li><strong>public InputStream getInputStream() ： 返回此套接字的输入流。</strong><ul>\n<li>如果此 Scoket 具有相关联的通道，则生成的 InputStream 的所有操作也关联该通道</li>\n<li>关闭生成的 InputStream 也将关闭相关的 Socket</li>\n</ul>\n</li>\n<li><strong>public OutputStream getOutputStream() ： 返回此套接字的输出流。</strong><ul>\n<li>如果此 Scoket 具有相关联的通道，则生成的 OutputStream 的所有操作也关联该通道</li>\n<li>关闭生成的 OutputStream 也将关闭相关的 Socket</li>\n</ul>\n</li>\n<li><strong>public void close() ：关闭此套接字。</strong><ul>\n<li>一旦一个 Socket 被关闭，它不可再使用。</li>\n<li>关闭此 Socket 也将关闭相关的 InputStream 和 OutputStream</li>\n</ul>\n</li>\n<li><strong>public void shutdownOutput() ： 禁用此套接字的输出流</strong><ul>\n<li>任何先前写出的数据将被发送，随后终止输出流</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-4-2-ServerSocket-类\"><a href=\"#6-4-2-ServerSocket-类\" class=\"headerlink\" title=\"6.4.2 ServerSocket 类\"></a>6.4.2 ServerSocket 类</h3><p>ServerSocket 类：这个类实现了服务器套接字，该对象等待通过网络的请求</p>\n<p><strong>构造方法：public ServerSocket(int port)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ServerSocket server &#x3D; new ServerSocket(6666);</code></pre>\n\n<p>使用该构造方法在创建 ServerSocket 对象时，就可以将其绑定到一个指定的端口号上，参数 port 就是端口号</p>\n<p><strong>成员方法</strong></p>\n<ul>\n<li><strong>public Socket accept()</strong><br>侦听并接受连接，返回一个新的 Socket 对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接</li>\n</ul>\n<h3 id=\"6-4-3-通信流程\"><a href=\"#6-4-3-通信流程\" class=\"headerlink\" title=\"6.4.3 通信流程\"></a>6.4.3 通信流程</h3><ol>\n<li>【服务端】启动，创建 ServerSocket 对象，等待连接</li>\n<li>【客户端】启动，创建 Socket 对象，请求连接</li>\n<li>【服务端】接收连接，调用 accept 方法，并返回一个 Socket 对象</li>\n<li>【客户端】Socket 对象，获取 OutputStream，向服务端写出数据</li>\n<li>【服务端】Scoket 对象，获取 InputStream，读取客户端发送的数据</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>到此，客户端向服务端发送数据成功。</p></blockquote>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111811.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>自此，服务端向客户端回写数据。</p></blockquote>\n<ol start=\"6\">\n<li>【服务端】Socket 对象，获取 OutputStream，向客户端回写数据</li>\n<li>【客户端】Scoket 对象，获取 InputStream，解析回写数据</li>\n<li>【客户端】释放资源，断开连接</li>\n</ol>\n<h3 id=\"6-4-4-使用\"><a href=\"#6-4-4-使用\" class=\"headerlink\" title=\"6.4.4 使用\"></a>6.4.4 使用</h3><h4 id=\"6-4-4-1-服务端和客户端案例\"><a href=\"#6-4-4-1-服务端和客户端案例\" class=\"headerlink\" title=\"6.4.4.1 服务端和客户端案例\"></a>6.4.4.1 服务端和客户端案例</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 服务端\npublic static void main(String[] args) throws IOException &#123;\n\tSystem.out.println(&quot;服务端启动 , 等待连接 .... &quot;);\n\t&#x2F;&#x2F; 1.创建 ServerSocket对象，绑定端口，开始等待连接\n\tServerSocket serverSocket &#x3D; new ServerSocket(6666);\n\t&#x2F;&#x2F; 2.接收连接 accept 方法, 返回 socket 对象\n\tSocket server &#x3D; serverSocket.accept();\n\t&#x2F;&#x2F; 3.通过socket 获取输入流\n\tInputStream inputStream &#x3D; server.getInputStream();\n\t&#x2F;&#x2F; 4.一次性读取数据\n\t&#x2F;&#x2F; 4.1 创建字节数组\n\tbyte[] bytes &#x3D; new byte[1024];\n\t&#x2F;&#x2F; 4.2 据读取到字节数组中.\n\tint len &#x3D; inputStream.read(bytes);\n\t&#x2F;&#x2F; 4.3 解析数组,打印字符串信息\n\tString str &#x3D; new String(bytes, 0, len);\n\tSystem.out.println(str);\n\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 回写数据 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t&#x2F;&#x2F; 5. 通过 socket 获取输出流\n\tOutputStream outputStream &#x3D; server.getOutputStream();\n\t&#x2F;&#x2F; 6. 回写数据\n\toutputStream.write(&quot;服务端回复给客户端，数据 111 已收到&quot;.getBytes());\n\t&#x2F;&#x2F; 7.关闭资源.\n\tinputStream.close();\n\toutputStream.close();\n\tserver.close();\n&#125;\n&#x2F;&#x2F; 客户端\npublic static void main(String[] args) throws Exception &#123;\n\tSystem.out.println(&quot;客户端开始发送数据&quot;);\n\t&#x2F;&#x2F; 1.创建 Socket ( ip , port ) , 确定连接到哪里\n\tSocket client &#x3D; new Socket(&quot;localhost&quot;, 6666);\n\t&#x2F;&#x2F; 2.获取流对象 . 输出流\n\tOutputStream outputStream &#x3D; client.getOutputStream();\n\t&#x2F;&#x2F; 3.写出数据.\n\toutputStream.write(&quot;客户端发送到服务端的数据 111&quot;.getBytes());\n\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 获取回写数据 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t&#x2F;&#x2F; 4. 通过 Scoket 获取输入流对象\n\tInputStream inputStream &#x3D; client.getInputStream();\n\t&#x2F;&#x2F; 5. 读取数据数据\n\tbyte[] bytes &#x3D; new byte[1024];\n\tint len &#x3D; inputStream.read(bytes);\n\tString str &#x3D; new String(bytes, 0, len);\n\tSystem.out.println(str);\n\t&#x2F;&#x2F; 6. 关闭资源\n\toutputStream.close();\n\tinputStream.close();\n\tclient.close();\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111824.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111834.png\"></p>\n<h4 id=\"6-4-4-2-B-x2F-S-案例\"><a href=\"#6-4-4-2-B-x2F-S-案例\" class=\"headerlink\" title=\"6.4.4.2 B&#x2F;S 案例\"></a>6.4.4.2 B&#x2F;S 案例</h4><p>访问文件位置，web&#x2F;index.html</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111846.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 服务端\npublic static void main(String[] args) throws IOException &#123;\n\tSystem.out.println(&quot;服务端启动 , 等待连接 .... &quot;);\n\t&#x2F;&#x2F; 1. 创建ServerSocket 对象，监听端口\n\tServerSocket server &#x3D; new ServerSocket(8888);\n\t&#x2F;&#x2F; 2. 接收连接 accept 方法, 返回 socket 对象\n\tSocket socket &#x3D; server.accept();\n\t&#x2F;&#x2F; 3. 转换流读取浏览器的请求消息\n\tBufferedReader bufferedReader &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\tString requst &#x3D; bufferedReader.readLine(); &#x2F;&#x2F; 读取一行，GET &#x2F;web&#x2F;index.html HTTP&#x2F;1.1\n\t&#x2F;&#x2F; 3.1 取出请求资源的路径\n\tString[] strArr &#x3D; requst.split(&quot; &quot;); &#x2F;&#x2F;\n\t&#x2F;&#x2F; 3.2 去掉 web 前面的 &#x2F;\n\tString path &#x3D; strArr[1].substring(1); &#x2F;&#x2F; web&#x2F;index.html\n\t&#x2F;&#x2F; 4. 读取客户端请求的资源文件\n\t&#x2F;&#x2F; 通过从字节码获取文件位置\n\t&#x2F;&#x2F; InputStream fis &#x3D; SocketTest.class.getClassLoader().getResourceAsStream(path);\n\t&#x2F;&#x2F; 通过从项目根路径获取文件位置\n\tFileInputStream fileInputStream &#x3D; new FileInputStream(&quot;src&#x2F;main&#x2F;resources&#x2F;&quot; + path);\n\tbyte[] bytes&#x3D; new byte[1024];\n\tint len &#x3D; 0 ;\n\t&#x2F;&#x2F; 5. 字节输出流,将文件写回客户端\n\tOutputStream out &#x3D; socket.getOutputStream();\n\t&#x2F;&#x2F; 5.1 写入HTTP协议响应头,固定写法\n\tout.write(&quot;HTTP&#x2F;1.1 200 OK\\r\\n&quot;.getBytes());\n\tout.write(&quot;Content‐Type:text&#x2F;html\\r\\n&quot;.getBytes());\n\t&#x2F;&#x2F; 5.2 必须要写入空行,否则浏览器不解析\n\tout.write(&quot;\\r\\n&quot;.getBytes());\n\twhile((len &#x3D; fileInputStream.read(bytes)) !&#x3D; -1)&#123;\n\t\tout.write(bytes, 0, len);\n\t&#125;\n\tfileInputStream.close();\n\tout.close();\n\tbufferedReader.close();\n\tsocket.close();\n\tserver.close();\n&#125;</code></pre>\n\n<p>浏览器地址输入 localhost:8888&#x2F;web&#x2F;index.html 进行访问，浏览器请求消息：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111902.png\"></p>\n<h1 id=\"7-Stream-流\"><a href=\"#7-Stream-流\" class=\"headerlink\" title=\"7. Stream 流\"></a>7. Stream 流</h1><ol>\n<li>可以以一种声明的方式处理数据，Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象</li>\n<li>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等</li>\n<li>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作（terminal operation）得到前面处理的结果</li>\n</ol>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111922.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>“Stream流” 其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）</li>\n<li><strong>这里的 filter 、sorted、map 等都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 collect 执行的时候，整个模型才会按照指定策略执行操作。而这得益于 Lambda 的延迟执行特性</strong></li>\n</ul></blockquote>\n<h2 id=\"7-1-概念\"><a href=\"#7-1-概念\" class=\"headerlink\" title=\"7.1 概念\"></a>7.1 概念</h2><p><strong>Stream（流）是一个来自数据源的元素队列并支持聚合操作</strong></p>\n<ul>\n<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算</li>\n<li>数据源流的来源。 可以是集合，数组，I&#x2F;O channel， 产生器 generator 等</li>\n<li>聚合操作类似SQL语句一样的操作， 比如 filter, map, reduce, find, match, sorted 等</li>\n</ul>\n<p><strong>特征：</strong></p>\n<ul>\n<li><strong>Pipelining：</strong> 中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行（laziness）和短路（short-circuiting）</li>\n<li><strong>内部迭代：</strong> 以前对集合遍历都是通过 Iterator 或者 For-Each 的方式，显式的在集合外部进行迭代， 这叫做外部迭代。Stream提供了内部迭代的方式，通过访问者模式（Visitor）实现</li>\n</ul>\n<h2 id=\"7-2-获取流\"><a href=\"#7-2-获取流\" class=\"headerlink\" title=\"7.2 获取流\"></a>7.2 获取流</h2><p>java.util.stream.Stream<T> 是Java 8 新加入的最常用的流接口。（这并不是一个函数式接口）</p>\n<ul>\n<li><strong>stream() ：为集合创建串行流，所有的 Collection 集合都可以通过 stream 默认方法获取流</strong></li>\n<li><strong>parallelStream() ：为集合创建并行流</strong><br>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。<br>使用并行流并不是一定会提高效率，因为 JVM 对数据进行切片和切换线程也需要时间。所以数据量越小，串行操作越快；数据量越大，并行操作效果越好。</li>\n<li><strong>Stream 接口的静态方法 of 可以获取数组对应的流，或者使用 Arrays.stream()</strong></li>\n</ul>\n<h2 id=\"7-3-常用方法\"><a href=\"#7-3-常用方法\" class=\"headerlink\" title=\"7.3 常用方法\"></a>7.3 常用方法</h2><ul>\n<li><strong>Intermediate（中间操作）</strong><ul>\n<li>一个流可以后面跟随 0 个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（<strong>lazy</strong>），就是说，仅仅调用到这类方法，并没有真正开始流的遍历</li>\n<li><strong>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</strong></li>\n</ul>\n</li>\n<li><strong>Terminal（终端操作）</strong><ul>\n<li>一个流只能有一个 terminal 操作，当这个操作执行后，返回的不是一个流，无法再被操作。所以这必定是流的最后一个操作。多个 intermediate 操作只会在 Terminal 操作的时候融合起来，一次循环完成，Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果。</li>\n<li><strong>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</strong></li>\n</ul>\n</li>\n<li><strong>short-circuiting（短路操作）</strong><ul>\n<li>对于一个 intermediate 操作，如果它接受的是一个无限大的 Stream，但返回一个有限的新Stream</li>\n<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果</li>\n<li><strong>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-3-1-forEach\"><a href=\"#7-3-1-forEach\" class=\"headerlink\" title=\"7.3.1 forEach\"></a>7.3.1 forEach</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void forEach(Consumer&lt;? super T&gt; action);</code></pre>\n\n<p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 以下都用这个 ArrayList 进行操作\n\tArrayList&lt;User&gt; users &#x3D; new ArrayList&lt;&gt;();\n\tusers.add(User.builder().name(&quot;张三&quot;).age(19).build());\n\tusers.add(User.builder().name(&quot;李四&quot;).age(20).build());\n\tusers.add(User.builder().name(&quot;王五&quot;).age(21).build());\n\tusers.add(User.builder().name(&quot;赵六&quot;).age(22).build());\n\n\tusers.stream().forEach(new Consumer&lt;User&gt;() &#123;\n\t\t@Override\n\t\tpublic void accept(User user) &#123;\n\t\t\tSystem.out.println(user);\n\t\t&#125;\n\t&#125;);\n\tusers.stream().forEach(user -&gt; System.out.println(user));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111937.png\"></p>\n<h3 id=\"7-3-2-filter\"><a href=\"#7-3-2-filter\" class=\"headerlink\" title=\"7.3.2 filter\"></a>7.3.2 filter</h3><p>可以通过 filter 方法将一个流转换成另一个子集流</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></pre>\n\n<p>该接口接收一个 Predicate 函数式接口参数（可以是一个 Lambda 或方法引用）作为筛选条件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 返回名字里含有 “三” 的 user\n\tusers.stream().filter(new Predicate&lt;User&gt;() &#123;\n\t\t@Override\n\t\tpublic boolean test(User user) &#123;\n\t\t\treturn user.getName().contains(&quot;三&quot;);\n\t\t&#125;\n\t&#125;).forEach(user -&gt; System.out.println(user));\n\tusers.stream().filter(user -&gt; user.getName().contains(&quot;三&quot;)).forEach(user -&gt; System.out.println(user));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419111952.png\"></p>\n<h3 id=\"7-3-3-map\"><a href=\"#7-3-3-map\" class=\"headerlink\" title=\"7.3.3 map\"></a>7.3.3 map</h3><p>将流中的元素映射到另一个流中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></pre>\n\n<p>该接口需要一个 Function 函数式接口参数，可以将当前流中的 T 类型数据转换为另一种 R 类型的流</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 将 user 转换为获取 user中的 name\n\tusers.stream().map(new Function&lt;User, String&gt;() &#123;\n\t\t@Override\n\t\tpublic String apply(User user) &#123;\n\t\t\treturn user.getName();\n\t\t&#125;\n\t&#125;).forEach(s -&gt; System.out.println(s));\n\tusers.stream().map(user -&gt; user.getName()).forEach(s -&gt; System.out.println(s));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112002.png\"></p>\n<h3 id=\"7-3-4-limit\"><a href=\"#7-3-4-limit\" class=\"headerlink\" title=\"7.3.4 limit\"></a>7.3.4 limit</h3><p>limit 方法可以对流进行截取，只取用前 n 个</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Stream&lt;T&gt; limit(long maxSize);</code></pre>\n\n<p>参数是一个 long 型，如果集合当前长度大于参数则进行截取，否则不进行操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tusers.stream().limit(3).forEach(user -&gt; System.out.println(user));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112017.png\"></p>\n<h3 id=\"7-3-5-count\"><a href=\"#7-3-5-count\" class=\"headerlink\" title=\"7.3.5 count\"></a>7.3.5 count</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long count();</code></pre>\n\n<p>统计个数，该方法返回一个 long 值代表元素个数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tlong count &#x3D; users.stream().count();\n\tSystem.out.println(count);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112029.png\"></p>\n<h3 id=\"7-3-6-skip\"><a href=\"#7-3-6-skip\" class=\"headerlink\" title=\"7.3.6 skip\"></a>7.3.6 skip</h3><p>跳过前几个元素，使用 skip 方法获取一个截取之后的新流</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Stream&lt;T&gt; skip(long n);</code></pre>\n\n<p>如果流的当前长度大于 n，则跳过前 n 个；否则将会得到一个长度为 0 的空流</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tusers.stream().skip(2).forEach(user -&gt; System.out.println(user));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112051.png\"></p>\n<h3 id=\"7-3-7-collect-和-Collectors\"><a href=\"#7-3-7-collect-和-Collectors\" class=\"headerlink\" title=\"7.3.7 collect 和 Collectors\"></a>7.3.7 collect 和 Collectors</h3><p>collect 可以收集流中的数据到【集合】或者【数组】中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);\n&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);</code></pre>\n\n<p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 转换为 List\n\tList&lt;User&gt; collect &#x3D; users.stream().collect(Collectors.toList());\n\tSystem.out.println(collect);\n\t&#x2F;&#x2F; 转换为 Map，Key 为 name，Value 为 age\n\tMap&lt;String, Integer&gt; collect1 &#x3D; users.stream().collect(Collectors.toMap(user -&gt; user.getName(), user -&gt; user.getAge()));\n\tSystem.out.println(collect1);\n\t&#x2F;&#x2F; 合并字符串，添加分隔符\n\tString collect2 &#x3D; users.stream().map(user -&gt; user.getName()).collect(Collectors.joining(&quot;, &quot;));\n\tSystem.out.println(collect2);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112102.png\"></p>\n<p><strong>Collectors 的操作：</strong></p>\n<ol>\n<li>counting：<strong>统计聚合结果的元素数量</strong></li>\n<li>averagingDouble、averagingInt、averagingLong：<strong>计算聚合元素的平均值</strong>，返回值都是 Double 类型</li>\n<li>summingDouble、summingInt、summingLong：和上面的平均值方法类似，在需要类型转换时，需要强制转换。summingDouble 返回的是 Double 类型、summingInt 返回的是 Integer 类型，summingLong 返回的是 Long 类型</li>\n<li>maxBy、minBy：<strong>求聚合元素中指定比较器中的最大&#x2F;最小元素</strong></li>\n<li>summarizingDouble、summarizingInt、summarizingLong：<strong>统计结果</strong>，summarizingDouble 返回 DoubleSummaryStatistics 类型，summarizingInt 返回 IntSummaryStatistics 类型，summarizingLong 返回 LongSummaryStatistics 类型</li>\n<li><strong>toList、toSet、toCollection</strong>：将聚合之后的元素，重新封装到队列中，然后返回，toList 方法返回的是 List 子类，toSet 返回的是 Set 子类，toCollection 返回的是 Collection 子类。Collection 的子类包括 List、Set 等众多子类，所以 toCollection 更加灵活</li>\n<li>toMap、toConcurrentMap：<strong>将聚合元素，重新组装为 Map 结构</strong>，toMap 返回的是 Map，toConcurrentMap 返回 ConcurrentMap，也就是说，toConcurrentMap 返回的是线程安全的 Map 结构</li>\n<li>groupingBy、groupingByConcurrent：roupingBy 与 toMap 都是将聚合元素进行分组，区别是，toMap 结果是 1:1 的 k-v 结构，<strong>groupingBy 的结果是 1:n 的 k-v 结构</strong></li>\n<li>partitioningBy：partitioningBy 与 groupingBy 的区别在于，partitioningBy 借助 Predicate 断言，可以将集合元素分为 true 和 false 两部分</li>\n<li>joining：<strong>对 String 类型的元素进行聚合，拼接成一个字符串返回</strong></li>\n<li>collectingAndThen：先对集合进行一次聚合操作，然后通过 Function 定义的函数，对聚合后的结果再次处理</li>\n<li>mapping：先通过 Function 函数处理数据，然后通过 Collector 方法聚合元素</li>\n<li>reducing：提供了三个重载方法，maxBy 和 minBy 这两个函数就是通过 reducing 实现的：<ol>\n<li>public static <T> Collector&lt;T, ?, Optional<T>&gt; reducing(BinaryOperator<T> op)：直接通过 BinaryOperator 操作，返回值是 Optional</li>\n<li>public static <T> Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator<T> op)：预定默认值，然后通过 BinaryOperator 操作</li>\n<li>public static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator<U> op)：预定默认值，通过 Function 操作元素，然后通过 BinaryOperator 操作</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"7-3-8-concat\"><a href=\"#7-3-8-concat\" class=\"headerlink\" title=\"7.3.8 concat\"></a>7.3.8 concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tStream&lt;String&gt; stringStream &#x3D; users.stream().map(user -&gt; user.getName());\n\tStream&lt;Integer&gt; integerStream &#x3D; users.stream().map(user -&gt; user.getAge());\n\t&#x2F;&#x2F; 将包含 name 和 age 的两个流合成一个\n\tStream.concat(stringStream, integerStream).forEach(serializable -&gt; System.out.println(serializable));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112117.png\"></p>\n<h1 id=\"8-方法引用\"><a href=\"#8-方法引用\" class=\"headerlink\" title=\"8. 方法引用\"></a>8. 方法引用</h1><p>双冒号 <strong><font color=\"red\">::</font></strong> 为引用运算符，而它所在的表达式被称为方法引用。如果 Lambda 要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为 Lambda 的替代者。如：</p>\n<ul>\n<li>Lambda 表达式写法： s -&gt; System.out.println(s)<br>拿到参数之后经 Lambda 之手，继而传递给 System.out.println 方法去处理。</li>\n<li><strong>方法引用写法： System.out::println</strong><br>直接让 System.out 中的 println 方法来取代 Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</li>\n</ul>\n<p>使用 Lambda，根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。函数式接口是 Lambda 的基础，而方法引用是 Lambda 的孪生兄弟。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; Lambda 写法\n\tusers.stream().map(user -&gt; user).forEach(user -&gt; System.out.println(user));\n\t&#x2F;&#x2F; 方法引用\n\tusers.stream().map(User::toString).forEach(System.out::println);\n\tusers.stream().map(User::getName).forEach(System.out::println);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112128.png\"></p>\n<h1 id=\"9-序列化与反序列化\"><a href=\"#9-序列化与反序列化\" class=\"headerlink\" title=\"9. 序列化与反序列化\"></a>9. 序列化与反序列化</h1><h2 id=\"9-1-概念\"><a href=\"#9-1-概念\" class=\"headerlink\" title=\"9.1 概念\"></a>9.1 概念</h2><ul>\n<li>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型</li>\n<li>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象</li>\n<li>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象</li>\n<li>类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法</li>\n</ul>\n<h2 id=\"9-2-序列化\"><a href=\"#9-2-序列化\" class=\"headerlink\" title=\"9.2 序列化\"></a>9.2 序列化</h2><p>一个类的对象要想序列化成功，必须满足两个条件：</p>\n<ul>\n<li>该类必须实现 java.io.Serializable 接口</li>\n<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须用 transient 注明是短暂的</li>\n</ul>\n<p>ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。该程序执行后，就创建了一个名为 employee.ser 文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Employee implements java.io.Serializable&#123;\n   public String name;\n   public String address;\n   public transient int SSN; &#x2F;&#x2F; 短暂的\n   public int number;\n   public void mailCheck()&#123;\n      System.out.println(&quot;Mailing a check to &quot; + name + &quot; &quot; + address);\n   &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SerializeDemo&#123;\n   public static void main(String [] args)&#123;\n      Employee e &#x3D; new Employee();\n      e.name &#x3D; &quot;Reyan Ali&quot;;\n      e.address &#x3D; &quot;Phokka Kuan, Ambehta Peer&quot;;\n      e.SSN &#x3D; 11122333;\n      e.number &#x3D; 101;\n      try&#123;\n         FileOutputStream fileOut &#x3D; new FileOutputStream(&quot;&#x2F;employee.ser&quot;);\n         ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut);\n         out.writeObject(e);\n         out.close();\n         fileOut.close();\n         System.out.printf(&quot;Serialized data is saved in &#x2F;employee.ser&quot;);\n      &#125;catch(IOException i)&#123;\n          i.printStackTrace();\n      &#125;\n   &#125;\n&#125;</code></pre>\n\n<h2 id=\"9-3-反序列化\"><a href=\"#9-3-反序列化\" class=\"headerlink\" title=\"9.3 反序列化\"></a>9.3 反序列化</h2><p><strong>下面的 DeserializeDemo 程序实例了反序列化，&#x2F;employee.ser 存储了 Employee 对象</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DeserializeDemo&#123;\n   public static void main(String [] args)&#123;\n      Employee e &#x3D; null;\n      try&#123;\n         FileInputStream fileIn &#x3D; new FileInputStream(&quot;&#x2F;employee.ser&quot;);\n         ObjectInputStream in &#x3D; new ObjectInputStream(fileIn);\n         e &#x3D; (Employee) in.readObject();\n         in.close();\n         fileIn.close();\n      &#125;catch(IOException i)&#123;\n         i.printStackTrace();\n         return;\n      &#125;catch(ClassNotFoundException c)&#123;\n         System.out.println(&quot;Employee class not found&quot;);\n         c.printStackTrace();\n         return;\n      &#125;\n      System.out.println(&quot;Deserialized Employee...&quot;); &#x2F;&#x2F; Deserialized Employee...\n      System.out.println(&quot;Name: &quot; + e.name); &#x2F;&#x2F; Name: Reyan Ali\n      System.out.println(&quot;Address: &quot; + e.address); &#x2F;&#x2F; Address: Phokka Kuan, Ambehta Peer\n      System.out.println(&quot;SSN: &quot; + e.SSN); &#x2F;&#x2F; SSN: 0\n      System.out.println(&quot;Number: &quot; + e.number); &#x2F;&#x2F; Number: 101\n    &#125;\n&#125;\n&#x2F;* 当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，\n该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。\n*&#x2F;</code></pre>\n\n<h1 id=\"10-Optional\"><a href=\"#10-Optional\" class=\"headerlink\" title=\"10. Optional\"></a>10. Optional</h1><p><strong>一个可以更加轻松的避免 NPE（空指针异常，NullPointException）的工具，Optional 是一个包装类，且不可变，不可序列化</strong></p>\n<h2 id=\"10-1-创建实例-of、ofNullable\"><a href=\"#10-1-创建实例-of、ofNullable\" class=\"headerlink\" title=\"10.1 创建实例 of、ofNullable\"></a>10.1 创建实例 of、ofNullable</h2><p>为了控制生成实例的方式，也是为了收紧空值 Optional 的定义，Optional 将构造函数定义为 private。想要创建 Optional 实例，可以借助 of 和 ofNullable 两个方法实现。<strong>of 方法传入的参数不能是 null 的，否则会抛出 NullPointerException。所以，对于可能是 null 的结果，一定使用 ofNullable</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">UserDemo userDemo &#x3D; UserDemo.builder().id(1).name(&quot;张三&quot;).build();\nOptional&lt;UserDemo&gt; userDemoOptional &#x3D; Optional.of(userDemo);\nOptional&lt;Object&gt; nullOptional &#x3D; Optional.ofNullable(null);</code></pre>\n\n<p>Optional 类中还有一个静态方法：empty，这个方法直接返回了内部定义的一个常量 Optional&lt;?&gt; EMPTY &#x3D; new Optional&lt;&gt;()，这个常量的 value 是 null。ofNullable 方法也是借助了 empty 实现 null 的包装：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;\n    return value &#x3D;&#x3D; null ? empty() : of(value);\n&#125;</code></pre>\n\n<p>所以说，对于 null 的 Optional 包装类，指向的都是相同的实例对象，Optional.empty() &#x3D;&#x3D; Optional.ofNullable(null) 返回的是 true。换句话说，<strong>空 Optional 是单例的，都是引用 Optional.EMPTY</strong></p>\n<h2 id=\"10-2-获取数据-get\"><a href=\"#10-2-获取数据-get\" class=\"headerlink\" title=\"10.2 获取数据 get\"></a>10.2 获取数据 get</h2><p>Optional 值为空时，使用 get 方法将抛出 NoSuchElementException 异常。如果不想抛出异常，或者能够  100% 确定不是空 Optional，或者使用 isPresent 方法判断</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public T get() &#123;\n    if (value &#x3D;&#x3D; null) &#123;\n        throw new NoSuchElementException(&quot;No value present&quot;);\n    &#125;\n    return value;\n&#125;</code></pre>\n\n<p><strong>使用 get 方法前，必须使用 isPresent 检查。但是使用 isPresent 前，可以先看是否可以使用 orElse、orElseGet 等方法代替实现。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">System.out.println(userDemoOptional.get().getName());</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419112144.png\"></p>\n<h2 id=\"10-3-值为空判断-isPresent、ifPresent\"><a href=\"#10-3-值为空判断-isPresent、ifPresent\" class=\"headerlink\" title=\"10.3 值为空判断 isPresent、ifPresent\"></a>10.3 值为空判断 isPresent、ifPresent</h2><p>isPresent 用来判断值是否为空，类似于obj !&#x3D; null，ifPresent 可以传入一个 Consumer 操作，当值不为空的时候，会执行 Consumer 函数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; if (userDemoOptional!&#x3D; null) &#123;\nif (userDemoOptional.isPresent()) &#123;\n\tSystem.out.println(1111);\n&#125;</code></pre>\n\n<p><strong>上面的方法等价于：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">userDemoOptional.ifPresent(userDemo1 -&gt; System.out.println(1111));</code></pre>\n\n<h2 id=\"10-4-值处理-map、flatMap\"><a href=\"#10-4-值处理-map、flatMap\" class=\"headerlink\" title=\"10.4 值处理 map、flatMap\"></a>10.4 值处理 map、flatMap</h2><p>map 和 flatMap 是对 Optional 的值进行操作的方法，区别在于，map 会将结果包装到 Optional 中返回， flatMap 不会。但是两个方法返回值都是 Optional 类型，这也就要求，flatMap 的方法函数返回值需要是 Optional 类型</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;\n    Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else &#123;\n        return Optional.ofNullable(mapper.apply(value));\n    &#125;\n&#125;</code></pre>\n\n<p>如果 Optional 的值为空，map 直接返回 Optional.EMPTY，否则会执行函数结果，并使用Optional.ofNullable 包装并返回</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Optional&lt;String&gt; stringOptional &#x3D; userDemoOptional.map(userDemo1 -&gt; userDemo1.getName()); &#x2F;&#x2F; abc\nOptional&lt;String&gt; stringOptional1 &#x3D; stringOptional.map(name -&gt; name.toUpperCase()); &#x2F;&#x2F; ABC\nString aDefault &#x3D; stringOptional1.orElse(&quot;default&quot;); &#x2F;&#x2F; 假如为空，则执行 else，有一个默认值\nSystem.out.println(aDefault); &#x2F;&#x2F; 有值为 abc，则 aDefault 为 ABC、值为空，则 aDefault 为 default\n\nString aDefault &#x3D; userDemoOptional.map(UserDemo::getName).map(String::toUpperCase).orElse(&quot;default&quot;);</code></pre>\n\n<h2 id=\"10-5-值为空的处理-orElse、orElseGet、orElseThrow\"><a href=\"#10-5-值为空的处理-orElse、orElseGet、orElseThrow\" class=\"headerlink\" title=\"10.5 值为空的处理 orElse、orElseGet、orElseThrow\"></a>10.5 值为空的处理 orElse、orElseGet、orElseThrow</h2><p><strong>当值为空时，orElse和orElseGet返回默认值，orElseThrow抛出指定的异常</strong></p>\n<p>orElse 和 orElseGet 的区别是 orElse 方法传入的参数是明确的默认值，orElseGet 方法传入的参数是获取默认值的函数。<strong>如果默认值的构造过程比较复杂，需要经过一系列的运算逻辑，那一定要使用 orElseGet</strong>，因为 orElseGet 是在值为空的时候，才会执行函数，并返回默认值，如果值不为空，则不会执行函数，<strong>相比于 orElse 而言，减少了一次构造默认值的过程</strong>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String aDefault &#x3D; userDemoOptional.map(UserDemo::getName)\n\t\t.map(String::toUpperCase)\n\t\t.orElse(null);\n\t\t&#x2F;&#x2F; .orElseGet(() -&gt; null);\n\t\t&#x2F;&#x2F; .orElseThrow(() -&gt; new IllegalArgumentException(&quot;clazz属性不合法&quot;));</code></pre>\n\n<h2 id=\"10-6-条件过滤-filter\"><a href=\"#10-6-条件过滤-filter\" class=\"headerlink\" title=\"10.6 条件过滤 filter\"></a>10.6 条件过滤 filter</h2><p><strong>filter 方法提供的是值验证，如果值验证为 true，返回当前值；否则，返回空 Optional</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 遍历 userDemos，找到姓名属性为空的，打印 id\nfor (UserDemos userDemo : userDemos) &#123;\n    Optional.of(userDemo )\n            .filter(x -&gt; x.getName() &#x3D;&#x3D; null)\n            .ifPresent(x -&gt; System.out.println(x.getId()));\n&#125;</code></pre>\n\n<h2 id=\"10-7-equals、hashCode、toString\"><a href=\"#10-7-equals、hashCode、toString\" class=\"headerlink\" title=\"10.7 equals、hashCode、toString\"></a>10.7 equals、hashCode、toString</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean equals(Object obj) &#123;\n    &#x2F;&#x2F; 同一对象判断\n    if (this &#x3D;&#x3D; obj) &#123;\n        return true;\n    &#125;\n\n    &#x2F;&#x2F; 类型判断\n    if (!(obj instanceof Optional)) &#123;\n        return false;\n    &#125;\n\n    Optional&lt;?&gt; other &#x3D; (Optional&lt;?&gt;) obj;\n    &#x2F;&#x2F; 最终还是值的判断\n    return Objects.equals(value, other.value);\n&#125;\n\npublic int hashCode() &#123;\n    &#x2F;&#x2F; 直接返回值的hashCode\n    return Objects.hashCode(value);\n&#125;\n\npublic String toString() &#123;\n    return value !&#x3D; null\n        ? String.format(&quot;Optional[%s]&quot;, value) &#x2F;&#x2F; 用到了值的toString结果\n        : &quot;Optional.empty&quot;;\n&#125;</code></pre>\n\n<ol>\n<li>equals 方法，Optional.of(s1).equals(Optional.of(s2)) 完全等价于 s1.equals(s2)</li>\n<li>hashCode 方法，直接返回的是值的 hashCode，如果是空Optional，返回的是0</li>\n<li>toString 方法，为了能够识别是 Optional，将打印数据包装了一下。如果是空 Optional，返回的是字符串“Optional.empty”；如果是非空，返回是 “Optional[值的toString]”</li>\n</ol>\n","feature":true,"text":"1. Asset 断言用于对值进行判断，为真则运行，否则报错，多用于调试 Assert.isNull(null, &quot;是否为空&quot;); &#x2F;&#x2F; 为空则运行 Assert.notNull(&quot;&quot;, &quot;是否不为空&quot...","link":"","photos":[],"count_time":{"symbolsCount":"45k","symbolsTime":"40 mins."},"categories":[{"name":"Java","slug":"Java","count":5,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":12,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Asset-%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">1. Asset 断言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-IDEA-%E5%BC%80%E5%90%AF-assert\"><span class=\"toc-text\">1.1 IDEA 开启 assert</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-assert-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.2 assert 使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">2. 泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">2.1 定义和使用泛型类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.2 定义和使用泛型方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.3 定义和使用泛型接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-1-%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%97%B6%E7%A1%AE%E5%AE%9A%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.3.1 定义实现类时确定泛型的类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-2-%E5%A7%8B%E7%BB%88%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.3.2 始终不确定泛型的类型，直到创建对象时，确定泛型的类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6-%EF%BC%9F\"><span class=\"toc-text\">2.4 泛型通配符 ？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-1-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.4.1 通配符基础使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-2-%E9%80%9A%E9%85%8D%E7%AC%A6%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E2%80%94-%E5%8F%97%E9%99%90%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">2.4.2 通配符高级使用—-受限泛型</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">3. 反射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.1 获取Class对象的方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Class%E5%AF%B9%E8%B1%A1%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">3.2 Class对象功能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Field-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">3.3 Field 成员变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-Constructor-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.4 Constructor 构造方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-Method-%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">3.5 Method 方法对象</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">4. 注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">4.2 作用分类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-JDK%E4%B8%AD%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">4.3 JDK中预定义的一些注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">4.4 自定义注解</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">5. 函数式接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">5.2 格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-FunctionalInterface-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">5.3 @FunctionalInterface 注解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">5.4 自定义函数式接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-Lambda-%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">5.5 Lambda 的延迟执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-Lambda-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">5.6 Lambda 作为参数和返回值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-6-1-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">5.6.1 作为参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-6-2-%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">5.6.2 作为返回值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-7-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">5.7 常用函数式接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-7-1-Supplier\"><span class=\"toc-text\">5.7.1 Supplier</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-7-2-Consumer\"><span class=\"toc-text\">5.7.2 Consumer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-7-3-Predicate\"><span class=\"toc-text\">5.7.3 Predicate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-7-4-Function\"><span class=\"toc-text\">5.7.4 Function</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">6. 网络编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">6.1 网络通信协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-%E5%8D%8F%E8%AE%AE%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">6.2 协议分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-1-TCP\"><span class=\"toc-text\">6.2.1 TCP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-2-UDP\"><span class=\"toc-text\">6.2.2 UDP</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">6.3  网络编程三要素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-1-%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">6.3.1 协议</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-2-IP%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">6.3.2 IP地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-3-%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><span class=\"toc-text\">6.3.3 端口号</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-TCP-%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">6.4 TCP 通信程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-1-Socket-%E7%B1%BB\"><span class=\"toc-text\">6.4.1 Socket 类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-2-ServerSocket-%E7%B1%BB\"><span class=\"toc-text\">6.4.2 ServerSocket 类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-3-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">6.4.3 通信流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-4-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">6.4.4 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-4-4-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">6.4.4.1 服务端和客户端案例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-4-4-2-B-x2F-S-%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">6.4.4.2 B&#x2F;S 案例</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-Stream-%E6%B5%81\"><span class=\"toc-text\">7. Stream 流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">7.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E8%8E%B7%E5%8F%96%E6%B5%81\"><span class=\"toc-text\">7.2 获取流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">7.3 常用方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-1-forEach\"><span class=\"toc-text\">7.3.1 forEach</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-2-filter\"><span class=\"toc-text\">7.3.2 filter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-3-map\"><span class=\"toc-text\">7.3.3 map</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-4-limit\"><span class=\"toc-text\">7.3.4 limit</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-5-count\"><span class=\"toc-text\">7.3.5 count</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-6-skip\"><span class=\"toc-text\">7.3.6 skip</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-7-collect-%E5%92%8C-Collectors\"><span class=\"toc-text\">7.3.7 collect 和 Collectors</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-8-concat\"><span class=\"toc-text\">7.3.8 concat</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">8. 方法引用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">9. 序列化与反序列化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">9.1 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">9.2 序列化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">9.3 反序列化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10-Optional\"><span class=\"toc-text\">10. Optional</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-1-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B-of%E3%80%81ofNullable\"><span class=\"toc-text\">10.1 创建实例 of、ofNullable</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-2-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-get\"><span class=\"toc-text\">10.2 获取数据 get</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-3-%E5%80%BC%E4%B8%BA%E7%A9%BA%E5%88%A4%E6%96%AD-isPresent%E3%80%81ifPresent\"><span class=\"toc-text\">10.3 值为空判断 isPresent、ifPresent</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-4-%E5%80%BC%E5%A4%84%E7%90%86-map%E3%80%81flatMap\"><span class=\"toc-text\">10.4 值处理 map、flatMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-5-%E5%80%BC%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%A4%84%E7%90%86-orElse%E3%80%81orElseGet%E3%80%81orElseThrow\"><span class=\"toc-text\">10.5 值为空的处理 orElse、orElseGet、orElseThrow</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-6-%E6%9D%A1%E4%BB%B6%E8%BF%87%E6%BB%A4-filter\"><span class=\"toc-text\">10.6 条件过滤 filter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-7-equals%E3%80%81hashCode%E3%80%81toString\"><span class=\"toc-text\">10.7 equals、hashCode、toString</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Spring Security 总结","uid":"84bebe9cd32f64471707a2ec9d7cecfe","slug":"BlogRepository/Spring/Spring Security 总结","date":"2022-03-15T09:18:25.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/Spring/Spring Security 总结.json","keywords":null,"cover":"https://cover.png","text":"1. 概要1.1 名词概念1.1.1 主体（principal）使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体 1.1.2 认证（authentication）权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。笼...","link":"","photos":[],"count_time":{"symbolsCount":"108k","symbolsTime":"1:38"},"categories":[{"name":"Spring","slug":"Spring","count":6,"path":"api/categories/Spring.json"}],"tags":[{"name":"Spring","slug":"Spring","count":8,"path":"api/tags/Spring.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{"title":"OAuth2.0 实践 Spring Authorization Server 搭建授权服务器 + Resource + Client","uid":"ae23336b494f1c2fc9ab2d53b8e53e8a","slug":"BlogRepository/开发实践/OAuth2.0 实践 Spring Authorization Server 搭建授权服务器 + Resource + Client","date":"2023-03-26T17:41:26.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/开发实践/OAuth2.0 实践 Spring Authorization Server 搭建授权服务器 + Resource + Client.json","keywords":null,"cover":"https://cover.png","text":"1. 授权服务器目前 Spring 生态中的 OAuth2 授权服务器是 Spring Authorization Server，原先的 Spring Security OAuth 已经停止更新 1.1 引入依赖这里的 spring-security-oauth2-authori...","link":"","photos":[],"count_time":{"symbolsCount":"54k","symbolsTime":"49 mins."},"categories":[{"name":"开发实践","slug":"开发实践","count":6,"path":"api/categories/开发实践.json"}],"tags":[{"name":"OAuth2.0","slug":"OAuth2-0","count":2,"path":"api/tags/OAuth2-0.json"},{"name":"Spring Authorization Server","slug":"Spring-Authorization-Server","count":1,"path":"api/tags/Spring-Authorization-Server.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}