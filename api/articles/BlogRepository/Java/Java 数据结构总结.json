{"title":"Java 数据结构总结","uid":"3dca1d49253087e654c27123d044ed56","slug":"BlogRepository/Java/Java 数据结构总结","date":"2022-08-05T07:14:42.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Java/Java 数据结构总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-链表\"><a href=\"#1-链表\" class=\"headerlink\" title=\"1. 链表\"></a>1. 链表</h1><p><strong>链表（LinkedList） 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据</strong></p>\n<p><strong>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n)</strong></p>\n<p><strong>使用链表结构可以克服数组需要预先知道数据大小的缺点</strong>，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，<strong>相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针</strong>。除此之外，<strong>链表不具有数组随机读取的优点</strong></p>\n<h2 id=\"1-1-单向链表\"><a href=\"#1-1-单向链表\" class=\"headerlink\" title=\"1.1 单向链表\"></a>1.1 单向链表</h2><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，<strong>链表这种数据结构通常在物理内存上是不连续的</strong>。我们习惯性地把**第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)**，通过头结点我们可以遍历整个链表。尾结点通常指向 null</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104637.png\"></p>\n<h3 id=\"1-1-1-定义节点类-Node\"><a href=\"#1-1-1-定义节点类-Node\" class=\"headerlink\" title=\"1.1.1 定义节点类 Node\"></a>1.1.1 定义节点类 Node</h3><p><strong>节点类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@NoArgsConstructor\n@AllArgsConstructor\npublic class Node&lt;T&gt; &#123;\n    T val;  &#x2F;&#x2F; 节点值\n    public Node next; &#x2F;&#x2F; 指向后续节点\n    Node(T val) &#123;\n        this.val &#x3D; val;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"1-1-2-直接对节点类操作\"><a href=\"#1-1-2-直接对节点类操作\" class=\"headerlink\" title=\"1.1.2 直接对节点类操作\"></a>1.1.2 直接对节点类操作</h3><p><strong>1. 生成链表</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        Node head &#x3D; new Node();\n        Node node1 &#x3D; new Node&lt;&gt;(&quot;王五&quot;);\n        Node node2 &#x3D; new Node&lt;&gt;(1);\n\n        Node node3 &#x3D; new Node&lt;&gt;(&quot;李四&quot;);\n        Node node4 &#x3D; new Node&lt;&gt;(2);\n\n        head.next &#x3D; node1;\n        node1.next &#x3D; node2;\n        node2.next &#x3D; node3;\n        node3.next &#x3D; node4;\n&#125;</code></pre>\n\n<p><strong>2. 遍历链表</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">queryAll(head);\n\npublic static void queryAll(Node node)&#123;\n        Node currentNode &#x3D; node;\n        while (currentNode.next !&#x3D; null)&#123;\n            currentNode &#x3D; currentNode.next;\n            System.out.println(currentNode.val);\n        &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104651.png\"><br><strong>3. 直接添加</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Node addNode &#x3D; new Node(&quot;赵六&quot;);\nhead &#x3D; add(head, addNode);\n\npublic static Node add(Node head, Node addNode)&#123;\n        Node currentNode &#x3D; head;\n\n\t\t&#x2F;&#x2F; 找到链表的最后一个节点\n        while (currentNode.next !&#x3D; null)&#123;\n            currentNode  &#x3D; currentNode.next;\n        &#125;\n        &#x2F;&#x2F; 让该节点的后一个节点为添加的节点，即将该节点添加到链表\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104708.png\"><br><strong>4. 添加到指定位置</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Node addIndexNode &#x3D; new Node(&quot;11&quot;);\nhead &#x3D; add(head, addIndexNode, 2);\n\npublic static Node add(Node head, Node addNode, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n\t\t&#x2F;&#x2F; 找到指定位置的上一个节点\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n\n\t\t&#x2F;&#x2F; 让添加节点的下一个节点为该节点的下一个节点\n        addNode.next &#x3D; currentNode.next;\n        &#x2F;&#x2F; 再让该节点的下一个节点为添加节点，即在指定位置插入一个节点\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104720.png\"><br><strong>5. 删除指定位置的元素</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">head &#x3D; delete(head, 4);\n\npublic static Node delete(Node head, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n\t\t&#x2F;&#x2F; 找到指定位置的上一个节点\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw  new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 该节点的下一个节点就是要删除的节点\n        Node delNode &#x3D; currentNode.next;\n        &#x2F;&#x2F; 让该节点的下一个节点为删除节点的下一个节点，指定位置的节点就被删除了\n        currentNode.next &#x3D; delNode.next;\n        return head;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104731.png\"></p>\n<p><strong>完整示例如下：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws Exception &#123;\n        Node head &#x3D; new Node();\n        Node node1 &#x3D; new Node&lt;&gt;(&quot;王五&quot;);\n        Node node2 &#x3D; new Node&lt;&gt;(1);\n\n        Node node3 &#x3D; new Node&lt;&gt;(&quot;李四&quot;);\n        Node node4 &#x3D; new Node&lt;&gt;(2);\n\n        head.next &#x3D; node1;\n        node1.next &#x3D; node2;\n        node2.next &#x3D; node3;\n        node3.next &#x3D; node4;\n\n        Node addNode &#x3D; new Node(&quot;赵六&quot;);\n        head &#x3D; add(head, addNode);\n\n        Node addIndexNode &#x3D; new Node(&quot;11&quot;);\n        head &#x3D; add(head, addIndexNode, 2);\n\n        head &#x3D; delete(head, 4);\n        queryAll(head);\n&#125;\n\npublic static Node delete(Node head, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw  new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n        Node delNode &#x3D; currentNode.next;\n        currentNode.next &#x3D; delNode.next;\n        return head;\n&#125;\n\npublic static Node add(Node head, Node addNode, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n\n        addNode.next &#x3D; currentNode.next;\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;\n\npublic static Node add(Node head, Node addNode) &#123;\n        Node currentNode &#x3D; head;\n\n        while (currentNode.next !&#x3D; null) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;\n\npublic static void queryAll(Node node) &#123;\n        Node currentNode &#x3D; node;\n        while (currentNode.next !&#x3D; null) &#123;\n            currentNode &#x3D; currentNode.next;\n            System.out.println(currentNode.val);\n        &#125;\n&#125;</code></pre>\n\n<h3 id=\"1-1-3-封装节点操作类\"><a href=\"#1-1-3-封装节点操作类\" class=\"headerlink\" title=\"1.1.3 封装节点操作类\"></a>1.1.3 封装节点操作类</h3><p><strong>定义一个类，封装对节点进行操作的方法。实现 Iterable 接口，用来遍历</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkNode&lt;T&gt; implements Iterable&lt;T&gt;&#123;\n    private Node headNode; &#x2F;&#x2F; 头结点，链表的 headNode 是不可以动的\n    private int length; &#x2F;&#x2F; 结点个数\n\n    public LinkNode()&#123;\n        headNode &#x3D; new Node();\n        length &#x3D; 0;\n    &#125;\n\n\t&#x2F;&#x2F; 清空\n    public void clear()&#123;\n        headNode.next &#x3D; null; &#x2F;&#x2F; 头节点 next 为 null 就是空链表\n        headNode.val &#x3D; null;\n        length &#x3D; 0;\n    &#125;\n\n\t&#x2F;&#x2F; 是否非空\n    public boolean isEmpty()&#123;\n        return length &#x3D;&#x3D; 0;\n    &#125;\n\n\t&#x2F;&#x2F; 获取长度\n    public int length()&#123;\n        return length;\n    &#125;\n\n    &#x2F;&#x2F; 读取链表第 i 位置的元素值并返回\n    public T get(int index)&#123;\n        if (index &lt; 0 || index &gt; length)&#123;\n            System.out.println(&quot;不存在该位置&quot;);\n        &#125;\n\n        &#x2F;&#x2F; 头指针不可以移动，不然就无法再找到链表\n        &#x2F;&#x2F; 定义一个临时的Node也指向头指针，通过该指针来进行操作\n        Node&lt;T&gt; currentNode &#x3D; headNode;\n        for (int i &#x3D; 0; i &lt; index; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        return currentNode.val;\n    &#125;\n\n    &#x2F;&#x2F; 插入到链表末尾\n    public void insert(T val)&#123;\n        Node&lt;T&gt; addNode &#x3D; new Node&lt;&gt;(val);\n\n        Node currentNode &#x3D; headNode;\n\n        &#x2F;&#x2F; 找到最后一个节点\n        while (currentNode.next !&#x3D; null)&#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        currentNode.next &#x3D; addNode;\n        length++;\n    &#125;\n\n    &#x2F;&#x2F; 插入到 i 位置\n    public void insert(T val, int index)&#123;\n        if (index &lt; 0 || index &gt; length)&#123;\n            System.out.println(&quot;不存在该位置&quot;);\n        &#125;\n\n        Node currentNode &#x3D; headNode;\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        Node&lt;T&gt; addNode &#x3D; new Node&lt;&gt;(val);\n        addNode.next &#x3D; currentNode.next;\n        currentNode.next &#x3D; addNode;\n        length++;\n    &#125;\n\n    &#x2F;&#x2F; 移除并返回 i 位置的元素值\n    public T remove(int index)&#123;\n        if (index &lt; 0 || index &gt; length)&#123;\n            System.out.println(&quot;不存在该位置&quot;);\n        &#125;\n\n        Node currentNode &#x3D; headNode;\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        &#x2F;&#x2F; 要删除的节点\n        Node&lt;T&gt; delCurrent &#x3D; currentNode.next;\n\n        currentNode.next &#x3D; delCurrent.next;\n        length --;\n        return delCurrent.val;\n    &#125;\n\n    &#x2F;&#x2F; 查找元素在链表中第一次出现的位置，索引值\n    public int indexOf(T value)&#123;\n        Node currentNode &#x3D; headNode;\n\n        for (int i &#x3D; 0; currentNode.next !&#x3D; null; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n            if (currentNode.val.equals(value))&#123;\n                return i;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n    @Override\n    public Iterator&lt;T&gt; iterator() &#123;\n        return new Iterator&lt;T&gt;() &#123;\n            Node currentNode &#x3D; headNode;\n\n            @Override\n            public boolean hasNext() &#123;\n                return currentNode.next !&#x3D; null;\n            &#125;\n\n            @Override\n            public T next() &#123;\n                currentNode &#x3D; currentNode.next;\n                return (T) currentNode.val;\n            &#125;\n        &#125;;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        LinkNode linkNode &#x3D; new LinkNode&lt;&gt;();\n&#x2F;&#x2F;        LinkNode&lt;String&gt; linkNode &#x3D; new LinkNode&lt;&gt;(); &#x2F;&#x2F; 限制泛型\n\n        linkNode.insert(&quot;张三11&quot;);\n        linkNode.insert(22);\n        linkNode.insert(&quot;王五33&quot;);\n\n        for (Object o : linkNode) &#123;\n            System.out.print(o + &quot; &quot;);\n        &#125;\n\n        System.out.println();\n\n        linkNode.insert(&quot;赵六&quot;, 2);\n        for (Object o : linkNode) &#123;\n            System.out.print(o + &quot; &quot;);\n        &#125;\n        System.out.println();\n\n        System.out.println(&quot;删除的元素：&quot; + linkNode.remove(3));\n        for (Object o : linkNode) &#123;\n            System.out.print(o + &quot; &quot;);\n        &#125;\n        System.out.println();\n\n        System.out.println(linkNode.indexOf(&quot;赵六&quot;));\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104746.png\"></p>\n<h2 id=\"1-2-双向链表\"><a href=\"#1-2-双向链表\" class=\"headerlink\" title=\"1.2 双向链表\"></a>1.2 双向链表</h2><p><strong>包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104755.png\"></p>\n<h3 id=\"1-2-1-定义节点类\"><a href=\"#1-2-1-定义节点类\" class=\"headerlink\" title=\"1.2.1 定义节点类\"></a>1.2.1 定义节点类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@AllArgsConstructor\n@NoArgsConstructor\npublic class DoubleNode&lt;T&gt; &#123;\n    T val;\n    DoubleNode prev;\n    DoubleNode next;\n\n    public DoubleNode(T val) &#123;\n        this.val &#x3D; val;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"1-2-2-封装节点操作类\"><a href=\"#1-2-2-封装节点操作类\" class=\"headerlink\" title=\"1.2.2 封装节点操作类\"></a>1.2.2 封装节点操作类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DoubleLinkNode&lt;T&gt; &#123;\n    private DoubleNode head;\n    private DoubleNode last;\n    private int length;\n\n    public DoubleLinkNode()&#123;\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 遍历\n    public void queryAll()&#123;\n        DoubleNode currentNode &#x3D; head;\n\n        while (currentNode !&#x3D; null)&#123;\n            System.out.print(currentNode.val + &quot; &quot;);\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 获取长度\n    public int getLength()&#123;\n        return length;\n    &#125;\n\n    &#x2F;&#x2F; 头插法\n    public void addFirst(T val)&#123;\n        &#x2F;&#x2F; 插入的节点\n        DoubleNode addNode &#x3D; new DoubleNode(val);\n\n        &#x2F;&#x2F; 加入链表为空，则插入的节点就是头节点和尾结点\n        if (head &#x3D;&#x3D; null)&#123;\n            head &#x3D; addNode;\n            last &#x3D; addNode;\n            length ++;\n        &#125; else &#123;\n            &#x2F;&#x2F; 让添加节点的下一个节点为头结点\n            addNode.next &#x3D; head;\n            &#x2F;&#x2F; 再让头结点的上一个为添加节点\n            head.prev &#x3D; addNode;\n            &#x2F;&#x2F; 再把头节点设为添加节点\n            head &#x3D; addNode;\n            length ++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 尾插法\n    public void addLast(T val)&#123;\n        DoubleNode addNode &#x3D; new DoubleNode(val);\n\n        if (head &#x3D;&#x3D; null)&#123;\n            head &#x3D; addNode;\n            last &#x3D; addNode;\n            length ++;\n        &#125; else &#123;\n            &#x2F;&#x2F; 让尾结点的下一个节点为添加节点\n            last.next &#x3D; addNode;\n            &#x2F;&#x2F; 再让添加节点的上一个为尾结点\n            addNode.prev &#x3D; last;\n            &#x2F;&#x2F; 再把尾结点设为添加节点\n            last &#x3D; addNode;\n            length ++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 在任意位置插入\n    public void addIndex(T val, int index) throws Exception &#123;\n        &#x2F;&#x2F; 假如添加位置为头结点位置，就是头插法\n        if (index &lt;&#x3D; 0)&#123;\n            addFirst(val);\n            return;\n        &#125;\n        &#x2F;&#x2F; 假如添加位置为尾结点的位置，就是尾插法\n        if (index &gt; length)&#123;\n            addLast(val);\n            return;\n        &#125;\n\n        DoubleNode addNode &#x3D; new DoubleNode(val);\n        DoubleNode currentNode &#x3D; head;\n        &#x2F;&#x2F; 找到指定位置的节点\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        &#x2F;&#x2F; 让添加节点的下一个节点为指定位置的节点\n        addNode.next &#x3D; currentNode;\n        &#x2F;&#x2F; 让指定位置节点的上一个节点的下一个节点为添加节点，即在指定位置插入添加节点\n        currentNode.prev.next &#x3D; addNode;\n        &#x2F;&#x2F; 再让添加节点的上一个节点为指定位置节点的上一个节点\n        addNode.prev &#x3D; currentNode.prev;\n        &#x2F;&#x2F; 再让指定位置的上一个节点为添加节点\n        currentNode.prev &#x3D; addNode;\n        length ++;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DoubleLinkNodeTest &#123;\n    public static void main(String[] args) throws Exception &#123;\n        DoubleLinkNode&lt;Object&gt; doubleLinkNode &#x3D; new DoubleLinkNode&lt;&gt;();\n        doubleLinkNode.addFirst(&quot;张三&quot;); &#x2F;&#x2F; 张三\n        doubleLinkNode.addFirst(1); &#x2F;&#x2F; 1 张三\n        doubleLinkNode.queryAll();\n\n        doubleLinkNode.addLast(&quot;李四&quot;); &#x2F;&#x2F; 1 张三 李四\n        doubleLinkNode.queryAll();\n\n        doubleLinkNode.addIndex(&quot;王五&quot;, 3); &#x2F;&#x2F; 1 张三 王五 李四\n\n        doubleLinkNode.queryAll();\n        System.out.println(&quot;长度：&quot; + doubleLinkNode.getLength());\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104811.png\"></p>\n<h2 id=\"1-3-循环列表与双向循环列表\"><a href=\"#1-3-循环列表与双向循环列表\" class=\"headerlink\" title=\"1.3 循环列表与双向循环列表\"></a>1.3 循环列表与双向循环列表</h2><p><strong>只需把单链表与双向链表的尾结点的下一个节点指向头结点即可</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104822.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104833.png\"></p>\n<h2 id=\"1-4-应用场景与数组比较\"><a href=\"#1-4-应用场景与数组比较\" class=\"headerlink\" title=\"1.4 应用场景与数组比较\"></a>1.4 应用场景与数组比较</h2><h3 id=\"1-4-1-应用场景\"><a href=\"#1-4-1-应用场景\" class=\"headerlink\" title=\"1.4.1 应用场景\"></a>1.4.1 应用场景</h3><ul>\n<li>如果需要支持随机访问的话，链表没办法做到</li>\n<li>如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适</li>\n<li>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适</li>\n</ul>\n<h3 id=\"1-4-2-与数组比较\"><a href=\"#1-4-2-与数组比较\" class=\"headerlink\" title=\"1.4.2 与数组比较\"></a>1.4.2 与数组比较</h3><ul>\n<li>数组支持随机访问，而链表不支持</li>\n<li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反</li>\n<li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的</li>\n</ul>\n<h1 id=\"2-栈\"><a href=\"#2-栈\" class=\"headerlink\" title=\"2. 栈\"></a>2. 栈</h1><p>栈 (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。在栈中，<strong>push 和 pop 的操作都发生在栈顶</strong></p>\n<p><strong>栈常用一维数组或链表来实现，用数组实现的栈叫作 数组栈（顺序栈），用链表实现的栈叫作 链式栈</strong>。其时间复杂度为：</p>\n<ul>\n<li><strong>访问：O（n）最坏情况</strong></li>\n<li><strong>插入删除：O（1）顶端插入和删除元素</strong></li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104846.png\"></p>\n<h2 id=\"2-1-数组栈\"><a href=\"#2-1-数组栈\" class=\"headerlink\" title=\"2.1 数组栈\"></a>2.1 数组栈</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyStack&lt;T&gt; &#123;\n    private T[] storage; &#x2F;&#x2F; 存放栈中元素的数组\n    private int capacity; &#x2F;&#x2F; 栈的容量\n    private int count; &#x2F;&#x2F; 栈中元素数量\n    private static final int GROW_FACTOR &#x3D; 2; &#x2F;&#x2F; 扩容倍数\n\n    &#x2F;&#x2F; 无参构造方法。默认容量为 8\n    public MyStack()&#123;\n        capacity &#x3D; 8;\n        storage &#x3D; (T[]) new Object[8];\n        count &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 带初始容量的构造方法\n    public MyStack(int initialCapacity)&#123;\n        if (initialCapacity &lt; 1) &#123;\n            throw new IllegalArgumentException(&quot;Capacity too small.&quot;);\n        &#125;\n        capacity &#x3D; initialCapacity;\n        storage &#x3D; (T[]) new Object[initialCapacity];\n        count &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 入栈\n    public void push(T val)&#123;\n        if (count &#x3D;&#x3D; capacity)&#123;\n            expansion();\n        &#125;\n        storage[count++] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 扩容，使用 Arrays.copyOf() 复制原数组并扩容\n    public void expansion()&#123;\n        int newCapacity &#x3D; capacity * GROW_FACTOR;\n        storage &#x3D; Arrays.copyOf(storage, newCapacity);\n        capacity &#x3D; newCapacity;\n    &#125;\n\n    &#x2F;&#x2F; 返回栈顶元素并出栈\n    public T pop()&#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            throw new IllegalArgumentException(&quot;Stack is empty.&quot;);\n        &#125;\n        return storage[--count];\n    &#125;\n\n    &#x2F;&#x2F; 返回栈顶元素不出栈\n    public T peek()&#123;\n        if (count &#x3D;&#x3D; 0)&#123;\n            throw new IllegalArgumentException(&quot;Stack is empty.&quot;);\n        &#125; else &#123;\n            return storage[count - 1];\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 判断栈是否为空\n    public boolean isEmpty()&#123;\n        return count &#x3D;&#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 返回栈中元素的个数\n    public int size()&#123;\n        return count;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        MyStack myStack &#x3D; new MyStack(3);\n        myStack.push(1);\n        myStack.push(&quot;张三&quot;);\n        myStack.push(2);\n        myStack.push(&quot;李四&quot;);\n\n        System.out.println(myStack.peek()); &#x2F;&#x2F; 李四\n        System.out.println(myStack.isEmpty()); &#x2F;&#x2F; false\n        System.out.println(myStack.size()); &#x2F;&#x2F; 4\n        for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n            System.out.println(myStack.pop());\n        &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104915.png\"></p>\n<h2 id=\"2-2-链栈\"><a href=\"#2-2-链栈\" class=\"headerlink\" title=\"2.2 链栈\"></a>2.2 链栈</h2><p><strong>与链表实现类似，入栈即使用头插法插入，出栈即把头结点指向下一个节点</strong><br><strong>定义节点类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@NoArgsConstructor\n@AllArgsConstructor\npublic class Node&lt;T&gt; &#123;\n    T val;  &#x2F;&#x2F; 节点值\n    public Node next; &#x2F;&#x2F; 指向后续节点\n\n    Node(T val) &#123;\n        this.val &#x3D; val;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>操作类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkStack&lt;T&gt; &#123;\n    private Node head;\n    private int length;\n\n    public LinkStack()&#123;\n        head &#x3D; new Node();\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 清空\n    public void clear()&#123;\n        head.next &#x3D; null;\n        head.val &#x3D; null;\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 入栈，头插法\n    public void push(T val)&#123;\n        Node addNode &#x3D; new Node&lt;&gt;(val);\n        if (head.val &#x3D;&#x3D; null)&#123;\n            head &#x3D; addNode;\n        &#125; else &#123;\n            addNode.next &#x3D; head;\n            head &#x3D; addNode;\n        &#125;\n        length ++;\n    &#125;\n\n    &#x2F;&#x2F; 出栈，将头结点指向下一个，并返回值\n    public T pop()&#123;\n        T val &#x3D; (T) head.val;\n        head &#x3D; head.next;\n        length --;\n        return val;\n    &#125;\n\n    public int getLength()&#123;\n        return length;\n    &#125;\n\n    public T peek()&#123;\n        return (T) head.val;\n    &#125;\n\n    public void queryAll()&#123;\n        Node currentNode &#x3D; head;\n\n        while (currentNode !&#x3D; null)&#123;\n            System.out.println(currentNode.val);\n            currentNode &#x3D; currentNode.next;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        LinkStack&lt;Object&gt; linkStack &#x3D; new LinkStack&lt;&gt;();\n        linkStack.push(&quot;张三&quot;);\n        linkStack.push(1);\n        linkStack.push(2);\n\n        linkStack.pop();\n        System.out.println(&quot;栈顶元素：&quot; + linkStack.peek());\n        System.out.println(&quot;链表长度：&quot; + linkStack.getLength());\n        linkStack.queryAll();\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104927.png\"></p>\n<h2 id=\"2-3-应用场景\"><a href=\"#2-3-应用场景\" class=\"headerlink\" title=\"2.3 应用场景\"></a>2.3 应用场景</h2><p><strong>当要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，就可以使用栈这个数据结构</strong></p>\n<h3 id=\"2-3-1-实现浏览器的回退和前进功能\"><a href=\"#2-3-1-实现浏览器的回退和前进功能\" class=\"headerlink\" title=\"2.3.1 实现浏览器的回退和前进功能\"></a>2.3.1 实现浏览器的回退和前进功能</h3><p>只需要使用两个栈(Stack1 和 Stack2)就能实现这个功能。比如按顺序查看了 1,2,3,4 这四个页面，依次把 1,2,3,4 这四个页面压入 Stack1 中。当想回头看 2 这个页面的时候，点击回退按钮，依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如又想回到页面 3，你点击前进按钮，将 3 页面从 Stack2 弹出，然后压入到 Stack1 中</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104935.png\"></p>\n<h3 id=\"2-3-2-检查符号是否成对出现\"><a href=\"#2-3-2-检查符号是否成对出现\" class=\"headerlink\" title=\"2.3.2 检查符号是否成对出现\"></a>2.3.2 检查符号是否成对出现</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断该字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。<br>比如 “()”、”()[]{}”、”{[]}” 都是有效字符串，而 “(]” 、”([)]” 则不是。</p></blockquote>\n<p><strong>首先将括号间的对应规则存放在 Map 中。然后将字符串转为数组进行遍历，假如是左符号，就直接压入栈中；右符号则将栈顶元素出栈进行比较。因为栈是后入先出，刚好可以与成对符号进行匹配。判断左右符号则由 Map 的 Key,Value 进行判断，Key 为右符号，Value 为左符号</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean isValid(String s)&#123;\n    &#x2F;&#x2F; 括号之间的对应规则\n    HashMap&lt;Character, Character&gt; mappings &#x3D; new HashMap&lt;Character, Character&gt;();\n    mappings.put(&#39;)&#39;, &#39;(&#39;);\n    mappings.put(&#39;&#125;&#39;, &#39;&#123;&#39;);\n    mappings.put(&#39;]&#39;, &#39;[&#39;);\n    Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();\n    char[] chars &#x3D; s.toCharArray();\n    for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n        if (mappings.containsKey(chars[i])) &#123;\n            char topElement &#x3D; stack.empty() ? &#39;#&#39; : stack.pop();\n            if (topElement !&#x3D; mappings.get(chars[i])) &#123;\n                return false;\n            &#125;\n        &#125; else &#123;\n            stack.push(chars[i]);\n        &#125;\n    &#125;\n    return stack.isEmpty();\n&#125;</code></pre>\n\n<h3 id=\"2-3-3-反转字符串\"><a href=\"#2-3-3-反转字符串\" class=\"headerlink\" title=\"2.3.3 反转字符串\"></a>2.3.3 反转字符串</h3><p>先压栈再出栈即可</p>\n<h3 id=\"2-3-4-维护函数调用\"><a href=\"#2-3-4-维护函数调用\" class=\"headerlink\" title=\"2.3.4 维护函数调用\"></a>2.3.4 维护函数调用</h3><p>最后一个被调用的函数必须先完成执行，符合栈的 后进先出（LIFO, Last In First Out） 特性</p>\n<h1 id=\"3-队列\"><a href=\"#3-队列\" class=\"headerlink\" title=\"3. 队列\"></a>3. 队列</h1><p>队列 是 <strong>先进先出( FIFO，First In, First Out) 的线性表</strong>。在具体应用中通常用链表或者数组来实现，<strong>用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列</strong> 。队列只允许在后端（rear）进行插入操作也就是 <strong>入队 enqueue</strong>，在前端（front）进行删除操作也就是<strong>出队 dequeue</strong></p>\n<p><strong>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419104950.png\"></p>\n<h2 id=\"3-1-单队列\"><a href=\"#3-1-单队列\" class=\"headerlink\" title=\"3.1 单队列\"></a>3.1 单队列</h2><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现） 和 链式队列（链表实现）</strong></p>\n<p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105000.png\"></p>\n<p>上图是一个顺序队列，将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 ”<strong>假溢出</strong>“ 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（<strong>越界</strong>）</p>\n<p><strong>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列</strong></p>\n<h3 id=\"3-1-1-数组单队列\"><a href=\"#3-1-1-数组单队列\" class=\"headerlink\" title=\"3.1.1 数组单队列\"></a>3.1.1 数组单队列</h3><p><strong>只能使用一次</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayQueue&lt;T&gt; &#123;\n    private T[] storage; &#x2F;&#x2F; 存放队列元素的数组\n    private int front; &#x2F;&#x2F; 队列头\n    private int rear; &#x2F;&#x2F; 队列尾\n    private int maxsize; &#x2F;&#x2F; 队列最大容量\n\n    &#x2F;&#x2F; 无参构造，默认大小为8\n    public ArrayQueue()&#123;\n        storage &#x3D; (T[]) new Object[8];\n        front &#x3D; -1;\n        rear &#x3D; -1;\n        maxsize &#x3D; 8;\n    &#125;\n\n    &#x2F;&#x2F; 带初始大小的构造方法\n    public ArrayQueue(int size)&#123;\n        storage &#x3D; (T[]) new Object[size];\n        front &#x3D; -1;\n        rear &#x3D; -1;\n        maxsize &#x3D; size;\n    &#125;\n\n    &#x2F;&#x2F; 判断是否队列已满\n    public boolean isFull()&#123;\n        return rear &#x3D;&#x3D; maxsize - 1;\n    &#125;\n\n    &#x2F;&#x2F; 判断队列是否为空\n    public boolean isEmpty()&#123;\n        return front &#x3D;&#x3D; rear;\n    &#125;\n\n    &#x2F;&#x2F; 入队\n    public void enqueue(T val)&#123;\n        if (isFull())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列已满&quot;);\n        &#125;\n        storage[++rear] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 遍历队列\n    public void queryQueue()&#123;\n        if (isEmpty())&#123;\n            System.out.println(&quot;队列为空&quot;);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; storage.length; i++) &#123;\n            if (storage[i] !&#x3D; null)&#123;\n                System.out.print(storage[i] + &quot; &quot;);\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 出队\n    public T dequeue()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        T result &#x3D; storage[++front];\n        storage[front] &#x3D; null;\n        return result;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列头元素\n    public T peek()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        return storage[front + 1];\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n    public static void main(String[] args) &#123;\n        ArrayQueue&lt;Object&gt; arrayQueue &#x3D; new ArrayQueue&lt;&gt;();\n        arrayQueue.enqueue(1); &#x2F;&#x2F; 1\n        arrayQueue.enqueue(&quot;张三&quot;); &#x2F;&#x2F; 张三 1\n        arrayQueue.enqueue(2); &#x2F;&#x2F; 2 张三 1\n        arrayQueue.enqueue(&quot;李四&quot;); &#x2F;&#x2F; 李四 2 张三 1\n\n        System.out.println(&quot;队列是否已满：&quot; + arrayQueue.isFull()); &#x2F;&#x2F; false\n\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;获取队头元素不出队：&quot; + arrayQueue.peek());\n\n        arrayQueue.queryQueue();\n\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;队列是否为空：&quot; + arrayQueue.isEmpty());\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105017.png\"></p>\n<h3 id=\"3-1-2-链式单队列\"><a href=\"#3-1-2-链式单队列\" class=\"headerlink\" title=\"3.1.2 链式单队列\"></a>3.1.2 链式单队列</h3><ul>\n<li>插入元素时：每次直接插到末尾即可（尾插法），新插入的元素即为新的尾结点（区别于栈的头插法）</li>\n<li>取出元素时：返回首结点指向的下一个元素即可。（先进先出），此时和弹栈一样</li>\n</ul>\n<p><strong>队列为尾插头取，栈为头插头取</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkQueue&lt;T&gt; &#123;\n    private Node head;\n    private Node last;\n    private int length;\n\n    public LinkQueue() &#123;\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 判断队列是否为空\n    public boolean isEmpty() &#123;\n        return length &#x3D;&#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 入队\n    public void enqueue(T val) &#123;\n        Node node &#x3D; new Node(val);\n\n        if (isEmpty()) &#123;\n            head &#x3D; node;\n            last &#x3D; node;\n        &#125; else &#123;\n            last.next &#x3D; node;\n        &#125;\n        last &#x3D; node;\n        length++;\n    &#125;\n\n    &#x2F;&#x2F; 遍历队列\n    public void queryQueue() &#123;\n        Node currentNode &#x3D; head;\n        while (currentNode !&#x3D; null) &#123;\n            System.out.print(currentNode.val + &quot; &quot;);\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 出队\n    public T dequeue() &#123;\n        if (isEmpty()) &#123;\n            return null;\n        &#125;\n        T val &#x3D; (T) head.val;\n        head &#x3D; head.next;\n        length--;\n        return val;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列长度\n    public int getLength() &#123;\n        return length;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列头元素\n    public T getHead() &#123;\n        if (isEmpty()) &#123;\n            return null;\n        &#125;\n        return (T) head.val;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列尾元素\n    public T getLast() &#123;\n        if (isEmpty()) &#123;\n            return null;\n        &#125;\n        return (T) last.val;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo05&#123;\n    public static void main(String[] args) &#123;\n        LinkQueue&lt;Object&gt; linkQueue &#x3D; new LinkQueue&lt;&gt;();\n        linkQueue.enqueue(1); &#x2F;&#x2F; 1\n        linkQueue.enqueue(&quot;张三&quot;); &#x2F;&#x2F; 张三 1\n        linkQueue.enqueue(2); &#x2F;&#x2F; 2 张三 1\n        linkQueue.enqueue(&quot;李四&quot;); &#x2F;&#x2F; 李四 2 张三 1\n\n        System.out.println(&quot;出队元素：&quot; + linkQueue.dequeue()); &#x2F;&#x2F; 1\n        System.out.println(&quot;队头元素：&quot; + linkQueue.getHead()); &#x2F;&#x2F; 张三\n        System.out.println(&quot;队尾元素：&quot; + linkQueue.getLast()); &#x2F;&#x2F; 李四\n        System.out.println(&quot;出队元素：&quot; + linkQueue.dequeue()); &#x2F;&#x2F; 张三\n\n        linkQueue.queryQueue();\n        System.out.println(&quot;队列长度：&quot; + linkQueue.getLength()); &#x2F;&#x2F; 2\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105027.png\"></p>\n<h2 id=\"3-2-循环队列\"><a href=\"#3-2-循环队列\" class=\"headerlink\" title=\"3.2 循环队列\"></a>3.2 循环队列</h2><p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当再向队列中添加元素的时候， rear 向后移动</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105035.png\"></p>\n<p>顺序队列中，front &#x3D;&#x3D; rear 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p>\n<ol>\n<li><p>可以设置一个标志变量 flag，当 <code>front == rear</code> 并且 flag&#x3D;0 的时候队列为空，当 <code>front == rear</code> 并且 flag&#x3D;1 的时候队列为满</p>\n</li>\n<li><p>队列为空的时候就是 <code>front == rear</code> ，队列满的时候，保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是：<code> (rear+1) % QueueSize= front</code></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105049.png\"></p>\n</li>\n</ol>\n<h3 id=\"3-2-1-数组循环队列\"><a href=\"#3-2-1-数组循环队列\" class=\"headerlink\" title=\"3.2.1 数组循环队列\"></a>3.2.1 数组循环队列</h3><ol>\n<li>front 变量的含义做一个调整：front 指向队列的第一个元素,也就是说 arr[front] 就是队列的第一个元素，front 的初始值&#x3D;0</li>\n<li>rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置，因为希望空出一个位置来进行判断，rear 的初始值&#x3D;0</li>\n<li>当队列满时，条件是 <code>(rear +1) % maxSize = front【满】</code></li>\n<li>对队列为空的条件，<code>rear == front 空</code></li>\n<li>队列中有效的数据的个数 <code>（rear + maxSize -front) % maxSize</code></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CircularQueue&lt;T&gt; &#123;\n    private T[] storage; &#x2F;&#x2F; 存放队列元素的数组\n    private int front; &#x2F;&#x2F; 队列头\n    private int rear; &#x2F;&#x2F; 队列尾\n    private int maxsize; &#x2F;&#x2F; 队列最大容量\n\n    &#x2F;&#x2F; 无参构造，默认大小为8\n    public CircularQueue()&#123;\n        storage &#x3D; (T[]) new Object[8];\n        maxsize &#x3D; 8;\n        &#x2F;&#x2F; front &#x3D; 0; 指向第一个元素,默认是0可以不写\n        &#x2F;&#x2F; rear &#x3D; 0;  指向最后一个元素的下一位，默认是0可以不写\n    &#125;\n\n    &#x2F;&#x2F; 带初始大小的构造方法\n    public CircularQueue(int size)&#123;\n        storage &#x3D; (T[]) new Object[size];\n        maxsize &#x3D; size;\n        &#x2F;&#x2F; front &#x3D; 0; 指向第一个元素,默认是0可以不写\n        &#x2F;&#x2F; rear &#x3D; 0;  指向最后一个元素的下一位，默认是0可以不写\n    &#125;\n\n    &#x2F;&#x2F; 判断是否队列已满\n    public boolean isFull()&#123;\n        return (rear + 1) % maxsize &#x3D;&#x3D; front;\n    &#125;\n\n    &#x2F;&#x2F; 判断队列是否为空\n    public boolean isEmpty()&#123;\n        return front &#x3D;&#x3D; rear;\n    &#125;\n\n    &#x2F;&#x2F; 入队\n    public void enqueue(T val)&#123;\n        if (isFull())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列已满&quot;);\n        &#125;\n        storage[rear] &#x3D; val;\n        rear &#x3D; (rear + 1) % maxsize;\n    &#125;\n\n    &#x2F;&#x2F; 求出当前有效数据\n    public int getEffectiveSize()&#123;\n        return (rear + maxsize - front) % maxsize;\n    &#125;\n\n    &#x2F;&#x2F;遍历\n    public void queryQueue() &#123;\n        if (isEmpty()) &#123;\n            System.out.println(&quot;队列为空&quot;);\n            return;\n        &#125;\n        for (int i &#x3D; front; i &lt; front + getEffectiveSize(); i++) &#123;\n            System.out.print(storage[i % maxsize] + &quot; &quot;);\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 出队\n    public T dequeue()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        T val &#x3D; storage[front];\n        storage[front] &#x3D; null;\n        front &#x3D; (front + 1) % maxsize;\n        return val;\n    &#125;\n\n    &#x2F;&#x2F; 取队首元素\n    public T getFront()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        return storage[front];\n    &#125;\n\n    &#x2F;&#x2F; 取队尾元素\n    public T getRear()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        return storage[(rear - 1 + maxsize) % maxsize];\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n    public static void main(String[] args) &#123;\n        CircularQueue&lt;Object&gt; circularQueue &#x3D; new CircularQueue&lt;&gt;(4);\n\n        circularQueue.enqueue(1); &#x2F;&#x2F; 1\n        circularQueue.enqueue(&quot;张三&quot;); &#x2F;&#x2F; 张三 1\n        circularQueue.enqueue(&quot;李四&quot;); &#x2F;&#x2F; 李四 张三 1\n\n        System.out.println(&quot;出队元素：&quot; + circularQueue.dequeue());\n        System.out.println(&quot;队头元素：&quot; + circularQueue.getFront());\n        System.out.println(&quot;出队元素：&quot; + circularQueue.dequeue());\n        circularQueue.queryQueue();\n\n        circularQueue.enqueue(&quot;王五&quot;); &#x2F;&#x2F; 王五 李四\n        circularQueue.enqueue(&quot;赵六&quot;); &#x2F;&#x2F; 赵六 王五 李四\n        circularQueue.queryQueue();\n\n        System.out.println(&quot;队尾元素：&quot; + circularQueue.getRear());\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105103.png\"></p>\n<h3 id=\"3-2-2-链式循环队列\"><a href=\"#3-2-2-链式循环队列\" class=\"headerlink\" title=\"3.2.2 链式循环队列\"></a>3.2.2 链式循环队列</h3><p><strong>在链式单队列的基础上，让尾结点的 next 指向头结点即可</strong></p>\n<h2 id=\"3-3-常见应用场景\"><a href=\"#3-3-常见应用场景\" class=\"headerlink\" title=\"3.3 常见应用场景\"></a>3.3 常见应用场景</h2><ul>\n<li><strong>阻塞队列</strong>： 阻塞队列可以看成在队列基础上加了阻塞操作的队列。<strong>当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现 “生产者 - 消费者“ 模型</strong></li>\n<li><strong>线程池中的请求 &#x2F; 任务队列</strong>： <strong>当线程池中没有空闲线程时，新的任务请求线程资源时，将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行</strong>。队列分为<strong>无界队列（基于链表）和有界队列（基于数组）</strong>。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务&#x2F;请求就会拒绝，在 Java 中的体现就是会抛出 <code>java.util.concurrent.RejectedExecutionException</code> 异常</li>\n<li>Linux 内核进程队列（按优先级排队）</li>\n<li>播放器上的播放列表</li>\n<li>消息队列</li>\n<li>等等……</li>\n</ul>\n<h1 id=\"4-树\"><a href=\"#4-树\" class=\"headerlink\" title=\"4. 树\"></a>4. 树</h1><p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。一棵树具有以下特点：</p>\n<ol>\n<li>一棵树中的任意两个结点有且仅有唯一的一条路径连通</li>\n<li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边</li>\n<li>一棵树不包含回路</li>\n</ol>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105114.png\"></p>\n<p><strong>树中的常用概念：</strong></p>\n<ul>\n<li>节点 ：树中的每个元素都可以统称为节点。</li>\n<li>根节点 ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li>\n<li>父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li>\n<li>子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li>\n<li>兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li>\n<li>叶子节点 ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li>\n<li>节点的高度 ：该节点到叶子节点的最长路径所包含的边数。</li>\n<li>节点的深度 ：根节点到该节点的路径所包含的边数</li>\n<li>节点的层数 ：节点的深度+1。</li>\n<li>树的高度 ：根节点的高度</li>\n</ul>\n<h2 id=\"4-1-二叉树的分类\"><a href=\"#4-1-二叉树的分类\" class=\"headerlink\" title=\"4.1 二叉树的分类\"></a>4.1 二叉树的分类</h2><ul>\n<li>二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构</li>\n<li>二叉树 的分支通常被称作 “左子树” 或 “右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒</li>\n<li>二叉树 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^(k+1) - 1</code> 个节点（满二叉树的情况），至少有 <code>2^(k)</code> 个节点</li>\n</ul>\n<h3 id=\"4-1-1-满二叉树\"><a href=\"#4-1-1-满二叉树\" class=\"headerlink\" title=\"4.1.1 满二叉树\"></a>4.1.1 满二叉树</h3><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 K，且结点总数是 <code>(2^k) -1</code> ，则它就是 满二叉树。如下图所示：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105127.png\"></p>\n<h3 id=\"4-1-2-完全二叉树\"><a href=\"#4-1-2-完全二叉树\" class=\"headerlink\" title=\"4.1.2 完全二叉树\"></a>4.1.2 完全二叉树</h3><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 完全二叉树 。</p>\n<p><strong>即一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层</strong>。如下图所示：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105139.png\"></p>\n<p><strong>完全二叉树有一个很好的性质：父结点和子节点的序号有着对应关系</strong></p>\n<p><strong>当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1</strong>。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点</p>\n<h3 id=\"4-1-3-二叉排序树\"><a href=\"#4-1-3-二叉排序树\" class=\"headerlink\" title=\"4.1.3 二叉排序树\"></a>4.1.3 二叉排序树</h3><p><strong>一棵空树，或者是具有下列性质的二叉树：</strong></p>\n<ol>\n<li>若左子树不空，则<strong>左子树上所有结点的值均小于它的根结点的值</strong></li>\n<li>若右子树不空，则<strong>右子树上所有结点的值均大于它的根结点的值</strong></li>\n<li><strong>左、右子树也分别为二叉排序树</strong></li>\n</ol>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105152.png\"></p>\n<p><strong>1. 查找 Find</strong></p>\n<ul>\n<li>查找的值 x 从根节点开始</li>\n<li>如果 x 小于根节点的值,则在左子树中继续查找</li>\n<li>如果 x 大于根节点的值,则在右子树中继续查找</li>\n<li>如果x等于根节点的值则返回该节点</li>\n<li>查不到就返回 null</li>\n</ul>\n<p><strong>查找的效率决定于树的高度，最大元素在树的最右支的节点，最小元素在树的最左支的节点上</strong><br><strong>2. 插入 Insert</strong></p>\n<ul>\n<li>插入的值从根节点开始查找</li>\n<li>如果 x 小于根节点的值,则在左子树中继续查找</li>\n<li>如果 x 大于根节点的值,则在右子树中继续查找</li>\n<li>如果该节点是叶节点，x 小于该节点值则插入左子节点，否则插入右节点</li>\n</ul>\n<p><strong>3. 删除 delete，删除节点分为3类</strong></p>\n<ul>\n<li>无儿子节点的节点,也就是叶子结点（<strong>删除节点分为左叶子节点和右叶子节点</strong>）<br><strong>找到要删除的节点及其父节点，然后判断删除节点是父节点的左节点还是右节点，再将对应的删除节点置为 null</strong><br><img src=\"http://img.fan223.cn/2023/04/20230419105207.png\"></li>\n<li>只有一个儿子的节点（<strong>删除节点分为只有一个左子节点或只有一个右子节点，同时删除节点也分为左节点和右节点</strong>）<br>找到要删除的节点及其父节点，<strong>判断删除节点拥有左子节点还是右子节点，再判断删除节点是父节点的左节点还是右节点，再将父亲节点链接删除节点的子节点</strong>，相当于删除要删除的节点<br><img src=\"http://img.fan223.cn/2023/04/20230419105218.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230419105228.png\"></li>\n<li>有两个儿子的节点（<strong>应考虑用哪个节点替换该节点的位置,并保证新的树也是个二叉排序树</strong>）<br>找到删除节点，<strong>再找到其右子树的最小值，即删除节点的右子节点的最左子节点，其为替换节点，同时找到替换节点的父节点，然后将删除节点与替换节点进行替换，再删掉替换节点，即置为 null。假如没有最左子节点，删除节点的右子节点就是替换节点</strong><br><img src=\"http://img.fan223.cn/2023/04/20230419105238.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230419105247.png\"></li>\n</ul>\n<p><strong>定义树节点：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class TreeNode &#123;\n    public Integer data;\n    public TreeNode leftChild;\n    public TreeNode rightChild;\n\n    public TreeNode(Integer data) &#123;\n        this.data &#x3D; data;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>二叉排序树操作类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BinarySortedTree &#123;\n\n    public TreeNode root;\n\n    &#x2F;&#x2F; 非递归构建二叉排序树\n    public void insert(int val) &#123;\n        TreeNode addTreeNode &#x3D; new TreeNode(val);\n\n        if (root &#x3D;&#x3D; null) &#123;\n            root &#x3D; addTreeNode;\n        &#125; else &#123;\n            TreeNode currentTreeNode &#x3D; root;\n            TreeNode parentTreeNode;\n\n            while (true) &#123;\n                parentTreeNode &#x3D; currentTreeNode;\n\n                if (addTreeNode.data &gt; currentTreeNode.data) &#123;\n                    currentTreeNode &#x3D; currentTreeNode.rightChild;\n\n                    if (currentTreeNode &#x3D;&#x3D; null) &#123;\n                        parentTreeNode.rightChild &#x3D; addTreeNode;\n                        return;\n                    &#125;\n                &#125; else &#123;\n                    currentTreeNode &#x3D; currentTreeNode.leftChild;\n\n                    if (currentTreeNode &#x3D;&#x3D; null) &#123;\n                        parentTreeNode.leftChild &#x3D; addTreeNode;\n                        return;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 递归构建二叉排序树\n    public TreeNode insert(TreeNode treeNode, int val) &#123;\n        TreeNode addTreeNode &#x3D; new TreeNode(val);\n\n        if (root &#x3D;&#x3D; null) &#123;\n            return root &#x3D; addTreeNode;\n        &#125;\n\n        if (val &gt; treeNode.data) &#123;\n            if (treeNode.rightChild &#x3D;&#x3D; null) &#123;\n                treeNode.rightChild &#x3D; addTreeNode;\n                return root;\n            &#125;\n            return insert(treeNode.rightChild, val);\n        &#125; else &#123;\n            if (treeNode.leftChild &#x3D;&#x3D; null) &#123;\n                treeNode.leftChild &#x3D; addTreeNode;\n                return root;\n            &#125;\n            return insert(treeNode.leftChild, val);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 先序遍历二叉排序树\n    public void preOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        System.out.print(treeNode.data + &quot; &quot;);\n        preOrder(treeNode.leftChild);\n        preOrder(treeNode.rightChild);\n    &#125;\n\n    &#x2F;&#x2F; 中序遍历二叉排序树\n    public void inOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        inOrder(treeNode.leftChild);\n        System.out.print(treeNode.data + &quot; &quot;);\n        inOrder(treeNode.rightChild);\n    &#125;\n\n    &#x2F;&#x2F; 后序遍历二叉排序树\n    public void postOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        postOrder(treeNode.leftChild);\n        postOrder(treeNode.rightChild);\n        System.out.print(treeNode.data + &quot; &quot;);\n    &#125;\n\n    &#x2F;&#x2F; 层序遍历二叉排序树\n    public void levelOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        LinkedList&lt;TreeNode&gt; linkedList &#x3D; new LinkedList&lt;&gt;();\n        linkedList.offer(treeNode);\n        TreeNode currentTreeNode;\n\n        while (!linkedList.isEmpty()) &#123;\n            currentTreeNode &#x3D; linkedList.poll();\n            System.out.print(currentTreeNode.data + &quot; &quot;);\n\n            if (currentTreeNode.leftChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.leftChild);\n            &#125;\n            if (currentTreeNode.rightChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.rightChild);\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 查找元素是否在二叉排序树中，如果在返回该节点，否则返回null\n    public TreeNode find(int val) &#123;\n        TreeNode currentTreeNode &#x3D; root;\n\n        while (currentTreeNode !&#x3D; null) &#123;\n            if (currentTreeNode.data &#x3D;&#x3D; val) &#123;\n                return currentTreeNode;\n            &#125; else if (currentTreeNode.data &gt; val) &#123;\n                currentTreeNode &#x3D; currentTreeNode.leftChild;\n            &#125; else &#123;\n                currentTreeNode &#x3D; currentTreeNode.rightChild;\n            &#125;\n        &#125;\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 查找二叉排序树中最小值\n    public int findMin() &#123;\n        TreeNode deleteTreeNode &#x3D; root;\n\n        while (deleteTreeNode.leftChild !&#x3D; null) &#123;\n            deleteTreeNode &#x3D; deleteTreeNode.leftChild;\n        &#125;\n        return deleteTreeNode.data;\n    &#125;\n\n    &#x2F;&#x2F; 删除节点\n    public void delete(int val) &#123;\n        TreeNode deleteTreeNode &#x3D; root;\n        TreeNode parentTreeNode &#x3D; root;\n\n        &#x2F;&#x2F; 找到要删除的节点\n        while (deleteTreeNode.data !&#x3D; val) &#123;\n            parentTreeNode &#x3D; deleteTreeNode;\n\n            if (deleteTreeNode.data &gt; val) &#123;\n                deleteTreeNode &#x3D; deleteTreeNode.leftChild;\n            &#125; else &#123;\n                deleteTreeNode &#x3D; deleteTreeNode.rightChild;\n            &#125;\n            if (deleteTreeNode &#x3D;&#x3D; null) &#123;\n                break;\n            &#125;\n        &#125;\n\n        if (deleteTreeNode !&#x3D; null) &#123;\n            if (deleteTreeNode.leftChild &#x3D;&#x3D; null &amp;&amp; deleteTreeNode.rightChild &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 叶子节点\n                if (deleteTreeNode &#x3D;&#x3D; root) &#123;\n                    root &#x3D; null;\n                &#125; else if (parentTreeNode.leftChild &#x3D;&#x3D; deleteTreeNode) &#123; &#x2F;&#x2F; 左子节点\n                    parentTreeNode.leftChild &#x3D; null;\n                &#125; else &#123; &#x2F;&#x2F; 右子节点\n                    parentTreeNode.rightChild &#x3D; null;\n                &#125;\n            &#125; else if (deleteTreeNode.leftChild &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 只有一个右子节点\n                if (deleteTreeNode &#x3D;&#x3D; root) &#123;\n                    root &#x3D; deleteTreeNode.rightChild;\n                &#125; else if (parentTreeNode.leftChild &#x3D;&#x3D; deleteTreeNode) &#123; &#x2F;&#x2F; 左子节点\n                    parentTreeNode.leftChild &#x3D; deleteTreeNode.rightChild;\n                &#125; else &#123; &#x2F;&#x2F; 右子节点\n                    parentTreeNode.rightChild &#x3D; deleteTreeNode.rightChild;\n                &#125;\n            &#125; else if (deleteTreeNode.rightChild &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 只有一个左子节点\n                if (deleteTreeNode &#x3D;&#x3D; root) &#123;\n                    root &#x3D; deleteTreeNode.leftChild;\n                &#125; else if (parentTreeNode.leftChild &#x3D;&#x3D; deleteTreeNode) &#123; &#x2F;&#x2F; 左子节点\n                    parentTreeNode.leftChild &#x3D; deleteTreeNode.leftChild;\n                &#125; else &#123; &#x2F;&#x2F; 右子节点\n                    parentTreeNode.rightChild &#x3D; deleteTreeNode.leftChild;\n                &#125;\n            &#125; else &#123; &#x2F;&#x2F; 有两个子节点\n                &#x2F;&#x2F; 先定义一个 替换节点 保存要删除节点的右子树的最小值\n                TreeNode replaceTreeNode &#x3D; deleteTreeNode.rightChild;\n                &#x2F;&#x2F; 定义一个 替换节点的父节点 保存要删除节点的右子树的最小值的父节点\n                TreeNode replaceParentTreeNode &#x3D; deleteTreeNode;\n\n                &#x2F;&#x2F; 找到删除节点的右节点的最左子节点，即右子树的最小值\n                while (replaceTreeNode.leftChild !&#x3D; null) &#123;\n                    &#x2F;&#x2F; 将其赋值给 替换节点的父节点\n                    replaceParentTreeNode &#x3D; replaceTreeNode;\n                    &#x2F;&#x2F; 将其 左节点 赋值给替换节点\n                    replaceTreeNode &#x3D; replaceTreeNode.leftChild;\n                &#125;\n                &#x2F;&#x2F; 将替换节点的值赋值给要删除节点\n                deleteTreeNode.data &#x3D; replaceTreeNode.data;\n                &#x2F;&#x2F; 如果替换节点的父节点的左节点是替换节点，则将替换节点的右节点赋值给替换节点的父节点的左节点\n                &#x2F;&#x2F; 即有最左子节点的情况\n                if (replaceParentTreeNode.leftChild &#x3D;&#x3D; replaceTreeNode) &#123;\n                    replaceParentTreeNode.leftChild &#x3D; replaceTreeNode.rightChild;\n                &#125; else &#123;\n                    &#x2F;&#x2F; 如果替换节点的父节点的右节点是替换节点，则将替换节点的右节点赋值给替换节点的父节点的右节点\n                    &#x2F;&#x2F; 即没有左子节点的情况，删除节点的右子节点就是替换节点，同时其并没有左子节点，所以使用替换节点的右节点\n                    replaceParentTreeNode.rightChild &#x3D; replaceTreeNode.rightChild;\n                &#125;\n            &#125;\n        &#125; else &#123;\n            System.out.println(&quot;要删除的节点不存在！&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        BinarySortedTree binarySortedTree &#x3D; new BinarySortedTree();\n\n        &#x2F;&#x2F; binarySortedTree.insert(binarySortedTree.root, 1);\n        binarySortedTree.insert(5);\n        binarySortedTree.insert(7);\n        binarySortedTree.insert(2);\n        binarySortedTree.insert(1);\n        binarySortedTree.insert(3);\n        binarySortedTree.insert(4);\n        binarySortedTree.insert(6);\n        binarySortedTree.insert(12);\n        binarySortedTree.insert(10);\n        binarySortedTree.insert(9);\n        binarySortedTree.insert(11);\n        binarySortedTree.insert(13);\n\n        System.out.print(&quot;先序遍历：&quot;);\n        binarySortedTree.preOrder(binarySortedTree.root); &#x2F;&#x2F; 5 2 4 8\n        System.out.println();\n        System.out.print(&quot;中序遍历：&quot;);\n        binarySortedTree.inOrder(binarySortedTree.root); &#x2F;&#x2F; 2 4 5 8\n        System.out.println();\n        System.out.print(&quot;后序遍历：&quot;);\n        binarySortedTree.postOrder(binarySortedTree.root); &#x2F;&#x2F; 1 4 2 6 9 8 5\n        System.out.println();\n        System.out.print(&quot;层次遍历：&quot;);\n        binarySortedTree.levelOrder(binarySortedTree.root); &#x2F;&#x2F; 5 2 8 1 4 6 9\n\n        System.out.println(&quot;查找值【3】对应的节点：&quot; + binarySortedTree.find(3));\n\n        binarySortedTree.delete(7);\n        System.out.print(&quot;删除值【7】后的二叉排序树：&quot;);\n        binarySortedTree.levelOrder(binarySortedTree.root);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105300.png\"></p>\n<h3 id=\"4-1-4-平衡二叉树\"><a href=\"#4-1-4-平衡二叉树\" class=\"headerlink\" title=\"4.1.4 平衡二叉树\"></a>4.1.4 平衡二叉树</h3><p><strong>平衡二叉树 是一棵二叉排序树</strong>，且具有以下性质：</p>\n<ol>\n<li>可以是一棵空树</li>\n<li><strong>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树（左右高度差小于等于 1）</strong></li>\n</ol>\n<p><strong>平衡二叉树的常用实现方法有：红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等</strong></p>\n<p><strong>如下这棵树已经退化为一个链表了，管它叫 斜树</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105314.png\"></p>\n<p><strong>二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得在树中对数据进行搜索和修改时，相对于链表更加快捷便利</strong></p>\n<p>但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，希望每个父结点分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105329.png\"></p>\n<h2 id=\"4-2-二叉树的存储\"><a href=\"#4-2-二叉树的存储\" class=\"headerlink\" title=\"4.2 二叉树的存储\"></a>4.2 二叉树的存储</h2><p><strong>二叉树的存储主要分为 链式存储 和 顺序存储 两种</strong></p>\n<h3 id=\"4-2-1-顺序存储\"><a href=\"#4-2-1-顺序存储\" class=\"headerlink\" title=\"4.2.1 顺序存储\"></a>4.2.1 顺序存储</h3><p>顺序存储就是利用数组进行存储，<strong>数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成</strong><br><strong>根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 <code>i</code> 的位置，那么它的左子节点就存储在 <code>2i</code> 的位置，它的右子节点存储在下标为 <code>2i+1</code> 的位置</strong></p>\n<p>一棵完全二叉树的数组顺序存储如下图所示：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105345.png\"></p>\n<p><strong>如果存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105403.png\"></p>\n<p><strong>简单实现</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayTree &#123;\n    private int[] storage;\n\n    public ArrayTree()&#123;\n        storage &#x3D; new int[8];\n    &#125;\n\n    public ArrayTree(int length)&#123;\n        storage &#x3D; new int[length];\n    &#125;\n\n    &#x2F;&#x2F; 添加根节点\n    public void addRoot(int val)&#123;\n        storage[1] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 添加左子节点\n    public void addLeft(int index, int val)&#123;\n        if(index &gt; storage.length || index &lt; 0)&#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n\n        storage[2 * index] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 添加右子节点\n    public void addRight(int index, int val)&#123;\n        storage[ 2 * index + 1] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 获取一个节点的父节点\n    public int getParent(int index)&#123;\n        if(index &gt; storage.length || index &lt; 0)&#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return storage[index &#x2F; 2];\n    &#125;\n\n    &#x2F;&#x2F; 遍历\n    public void query()&#123;\n        for(int i &#x3D; 1; i &lt; storage.length; i++)&#123;\n            System.out.print(storage[i] + &quot; &quot;);\n        &#125;\n        System.out.println();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo05 &#123;\n    public static void main(String[] args) &#123;\n        ArrayTree arrayTree &#x3D; new ArrayTree(10);\n        arrayTree.addRoot(1);\n        arrayTree.addLeft(1, 2);\n        arrayTree.addRight(1, 3);\n\n        arrayTree.addLeft(2, 4);\n        arrayTree.addLeft(4, 5);\n        arrayTree.query();\n\n        System.out.println(arrayTree.getParent(8));\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105418.png\"></p>\n<h3 id=\"4-2-2-链式存储\"><a href=\"#4-2-2-链式存储\" class=\"headerlink\" title=\"4.2.2 链式存储\"></a>4.2.2 链式存储</h3><p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。每个节点包括三个属性：</p>\n<ul>\n<li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据</li>\n<li>左节点指针 left</li>\n<li>右节点指针 right</li>\n</ul>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105428.png\"></p>\n<h2 id=\"4-3-二叉树的遍历\"><a href=\"#4-3-二叉树的遍历\" class=\"headerlink\" title=\"4.3 二叉树的遍历\"></a>4.3 二叉树的遍历</h2><h3 id=\"4-3-1-先序遍历\"><a href=\"#4-3-1-先序遍历\" class=\"headerlink\" title=\"4.3.1 先序遍历\"></a>4.3.1 先序遍历</h3><p>二叉树的<strong>先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树</strong>，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，可以递归实现先序遍历</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105438.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void preOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        System.out.print(treeNode.data + &quot; &quot;);\n        preOrder(treeNode.leftChild);\n        preOrder(treeNode.rightChild);\n    &#125;</code></pre>\n\n<h3 id=\"4-3-2-中序遍历\"><a href=\"#4-3-2-中序遍历\" class=\"headerlink\" title=\"4.3.2 中序遍历\"></a>4.3.2 中序遍历</h3><p>二叉树的<strong>中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树</strong>，可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105453.png\"></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105506.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void inOrder(TreeNode root)&#123;\n\tif(root &#x3D;&#x3D; null)&#123;\n\t\treturn;\n\t&#125;\n\tinOrder(root.left);\n\tsystem.out.println(root.data);\n\tinOrder(root.right);\n&#125;</code></pre>\n\n<h3 id=\"4-3-3-后序遍历\"><a href=\"#4-3-3-后序遍历\" class=\"headerlink\" title=\"4.3.3 后序遍历\"></a>4.3.3 后序遍历</h3><p><strong>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105518.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void postOrder(TreeNode root)&#123;\n\tif(root &#x3D;&#x3D; null)&#123;\n\t\treturn;\n\t&#125;\n\tpostOrder(root.left);\n\tpostOrder(root.right);\n\tsystem.out.println(root.data);\n&#125;</code></pre>\n\n<h3 id=\"4-3-4-层次遍历\"><a href=\"#4-3-4-层次遍历\" class=\"headerlink\" title=\"4.3.4 层次遍历\"></a>4.3.4 层次遍历</h3><p><strong>即一层一层往下遍历。使用链表，先将根节点加到链表中，然后再将根节点的左节点和右节点加入到链表中，这里定义一个 Current 节点，用来将左右节点加入到链表里以及遍历链表，这里用 poll 方式来给 Current 节点赋值</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void levelOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        LinkedList&lt;TreeNode&gt; linkedList &#x3D; new LinkedList&lt;&gt;();\n        linkedList.offer(treeNode);\n        TreeNode currentTreeNode;\n\n        while (!linkedList.isEmpty()) &#123;\n            currentTreeNode &#x3D; linkedList.poll();\n            System.out.print(currentTreeNode.data + &quot; &quot;);\n\n            if (currentTreeNode.leftChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.leftChild);\n            &#125;\n            if (currentTreeNode.rightChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.rightChild);\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105530.png\"></p>\n<h2 id=\"4-4-哈夫曼树（最优⼆叉树）\"><a href=\"#4-4-哈夫曼树（最优⼆叉树）\" class=\"headerlink\" title=\"4.4 哈夫曼树（最优⼆叉树）\"></a>4.4 哈夫曼树（最优⼆叉树）</h2><h3 id=\"4-4-1-概述\"><a href=\"#4-4-1-概述\" class=\"headerlink\" title=\"4.4.1 概述\"></a>4.4.1 概述</h3><ul>\n<li><strong>路径</strong>：<strong>在一棵树中，一个结点到另一个结点之间的通路，称为路径</strong>。如下图中，从根结点到结点 a 之间的通路就是一条路径</li>\n<li><strong>路径长度</strong>：<strong>在一条路径中，每经过一个结点，路径长度都要加 1</strong> 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。下图中从根结点到结点 c 的路径长度为 3</li>\n<li><strong>结点的权</strong>：<strong>给每一个结点赋予一个新的数值，被称为这个结点的权</strong>。例如，下图 中结点 a 的权为 7，结点 b 的权为 5</li>\n<li><strong>结点的带权路径长度</strong>：指的是<strong>从根结点到该结点之间的路径长度与该结点的权的乘积</strong>。例如，下图中结点 b 的带权路径长度为 2 * 5 &#x3D; 10</li>\n<li><strong>树的带权路径长度为树中所有叶子结点的带权路径长度之和</strong>。通常记作 <strong>“WPL”</strong> 。例如下图中所示的这颗树的带权路径长度为：<br><code>WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3</code><br><img src=\"http://img.fan223.cn/2023/04/20230419105618.png\"></li>\n</ul>\n<p><strong>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为 “最优二叉树”，有时也叫 “赫夫曼树” 或者 “哈夫曼树”</strong></p>\n<p>在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：<strong>权重越大的结点离树根越近。在上图中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。</strong></p>\n<p><strong>构建方法：</strong></p>\n<ol>\n<li><p>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且<strong>新二叉树的根结点的权值为左右孩子权值的和</strong></p>\n</li>\n<li><p>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推</p>\n</li>\n<li><p>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树</p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105703.png\"></p>\n</li>\n</ol>\n<h3 id=\"4-4-2-实现\"><a href=\"#4-4-2-实现\" class=\"headerlink\" title=\"4.4.2 实现\"></a>4.4.2 实现</h3><p><strong>定义节点类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TreeNode&lt;T&gt; &#123;\n    public T data;\n    public int weight;\n    public TreeNode&lt;T&gt; leftChild;\n    public TreeNode&lt;T&gt; rightChild;\n\n    public TreeNode(T data, int weight) &#123;\n        this.data &#x3D; data;\n        this.weight &#x3D; weight;\n    &#125;\n\n    public String toString()&#123;\n        return data + &quot; &quot; + weight;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>哈夫曼树构建：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HuffmanTree &#123;\n    &#x2F;&#x2F; 构建Huffman树\n    public &lt;T&gt; TreeNode&lt;T&gt; buildHuffmanTree(List&lt;TreeNode&gt; treeNodes) &#123;\n        while (treeNodes.size() &gt; 1)&#123;\n            sortTreeNode(treeNodes);\n\n            &#x2F;&#x2F; 左边比右边小\n            TreeNode left &#x3D; treeNodes.get(0);\n            TreeNode right &#x3D; treeNodes.get(1);\n\n            &#x2F;&#x2F; 生成一个新的节点,父结点权重为两个子结点之和\n            TreeNode parent &#x3D; new TreeNode(null, left.weight + right.weight);\n\n            &#x2F;&#x2F; 让子结点与父结点连接\n            parent.leftChild &#x3D; left;\n            parent.rightChild &#x3D; right;\n\n            &#x2F;&#x2F; 删除最小的\n            treeNodes.remove(0);\n            &#x2F;&#x2F; 删除第二小的\n            treeNodes.remove(0);\n            &#x2F;&#x2F; 把新的父结点加入到 list 中\n            treeNodes.add(parent);\n        &#125;\n        &#x2F;&#x2F; 返回哈夫曼树的根节点\n        return treeNodes.get(0);\n    &#125;\n\n    &#x2F;&#x2F; 对节点进行排序，从小到大\n    public void sortTreeNode(List&lt;TreeNode&gt; treeNodes) &#123;\n        for (int i &#x3D; 0; i &lt; treeNodes.size(); i++)&#123;\n            for (int j &#x3D; 0; j &lt; treeNodes.size() - 1 - i; j++)&#123;\n                if (treeNodes.get(j).weight &gt; treeNodes.get(j + 1).weight) &#123;\n                    TreeNode temp &#x3D; treeNodes.get(j + 1);\n                    treeNodes.set(j+1,treeNodes.get(j));\n                    treeNodes.set(j,temp);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 打印哈夫曼树\n    public void printTree(TreeNode root) &#123;\n        System.out.println(&quot;Node-&quot; + root.toString());\n        if(root.leftChild !&#x3D; null)&#123;\n            System.out.print(&quot;left:&quot;);\n            printTree(root.leftChild);\n        &#125;\n        if(root.rightChild !&#x3D;null)&#123;\n            System.out.print(&quot;right:&quot;);\n            printTree(root.rightChild);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        HuffmanTree huffmanTree &#x3D; new HuffmanTree();\n\n        List&lt;TreeNode&gt; treeNodes &#x3D; new ArrayList&lt;TreeNode&gt;();\n        &#x2F;&#x2F;把节点加入至list中\n        treeNodes.add(new TreeNode(&quot;张三&quot;, 10));\n        treeNodes.add(new TreeNode(1, 15));\n        treeNodes.add(new TreeNode(&quot;李四&quot;, 12));\n        treeNodes.add(new TreeNode(2, 3));\n        treeNodes.add(new TreeNode(&quot;王五&quot;, 4));\n        treeNodes.add(new TreeNode(3, 13));\n        treeNodes.add(new TreeNode(&quot;赵六&quot;, 1));\n\n        &#x2F;&#x2F; 进行哈夫曼树的构造\n        TreeNode root &#x3D; huffmanTree.buildHuffmanTree(treeNodes);\n        &#x2F;&#x2F; 打印哈夫曼树\n        huffmanTree.printTree(root);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105724.png\"></p>\n<h2 id=\"4-5-AVL-树\"><a href=\"#4-5-AVL-树\" class=\"headerlink\" title=\"4.5 AVL 树\"></a>4.5 AVL 树</h2><h3 id=\"4-5-1-概述\"><a href=\"#4-5-1-概述\" class=\"headerlink\" title=\"4.5.1 概述\"></a>4.5.1 概述</h3><p>AVL 树是严格的平衡二叉树，平衡条件必须满足（<strong>所有节点的左右子树高度差的绝对值不超过1</strong>），一般是用<strong>平衡因子差值判断是否平衡并通过旋转来实现平衡</strong>。不管是插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此 <strong>AVL 树适合用于插入与删除次数比较少，但查找多的情况</strong></p>\n<p><strong>由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多</strong>，更多的地方是<strong>用追求局部而不是非常严格整体平衡的红黑树</strong>。如果应用场景中对插入删除不频繁，只是对查找要求较高，那么 AVL 还是较优于红黑树（AVL 树查找比红黑树快）</p>\n<p><strong>二叉平衡树的调整：调整原则根据插入的节点和失衡节点的位置上关系来划分</strong></p>\n<ol>\n<li><strong>LL旋转，让失衡节点的左子节点成为新节点，让新节点的右子节点成为失衡节点的左子节点，再让失衡节点成为新节点的右子节点</strong><br><img src=\"http://img.fan223.cn/2023/04/20230419105737.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230419105747.png\"></li>\n<li><strong>RR旋转，让失衡节点的右子节点成为新节点，让新节点的左子节点成为失衡节点的右子节点，再让失衡节点成为新节点的左子节点</strong><br><img src=\"http://img.fan223.cn/2023/04/20230419105757.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230419105807.png\"></li>\n<li><strong>LR旋转，对失衡节点的左子树做一次RR旋转，再对失衡节点做一次LL旋转</strong><br><img src=\"http://img.fan223.cn/2023/04/20230419105818.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230419105826.png\"></li>\n<li><strong>RL旋转</strong><br><img src=\"http://img.fan223.cn/2023/04/20230419105836.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230419105846.png\"></li>\n</ol>\n<h3 id=\"4-5-2-实现\"><a href=\"#4-5-2-实现\" class=\"headerlink\" title=\"4.5.2 实现\"></a>4.5.2 实现</h3><p><strong>节点类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AVLTreeNode &#123;\n    Integer data; &#x2F;&#x2F; 数据\n    AVLTreeNode leftChild; &#x2F;&#x2F; 左子节点\n    AVLTreeNode rightChild; &#x2F;&#x2F; 右子节点\n    int height; &#x2F;&#x2F; 记录该节点所在的高度\n\n    public AVLTreeNode(int data) &#123;\n        this.data &#x3D; data;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>AVL树实现类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AVLTree &#123;\n    public AVLTreeNode root;\n    private int size;\n\n    public AVLTree() &#123;\n        this.root &#x3D; null;\n        this.size &#x3D; 0;\n    &#125;\n\n    public int getSize()&#123;\n        return size;\n    &#125;\n\n    &#x2F;&#x2F; 获取节点的高度，让空节点高度为-1\n    public int getHeight(AVLTreeNode avlTreeNode) &#123;\n        return avlTreeNode &#x3D;&#x3D; null ? -1 : avlTreeNode.height;\n    &#125;\n\n    &#x2F;&#x2F; 先序遍历\n    public void printTree(AVLTreeNode root) &#123;\n        System.out.print(root.data + &quot; &quot;);\n        if(root.leftChild !&#x3D; null)&#123;\n            printTree(root.leftChild);\n        &#125;\n        if(root.rightChild !&#x3D; null)&#123;\n            printTree(root.rightChild);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 插入节点\n    public AVLTreeNode insert(AVLTreeNode avlTreeNode, int val) &#123;\n        if (avlTreeNode &#x3D;&#x3D; null)&#123;\n            avlTreeNode &#x3D; new AVLTreeNode(val);\n            size ++;\n            return avlTreeNode;\n        &#125;\n\n        if (val &lt; avlTreeNode.data) &#123;\n            &#x2F;&#x2F; 如果插入的值小于当前节点的值，则插入到左子树中\n            avlTreeNode.leftChild &#x3D; insert(avlTreeNode.leftChild, val);\n            &#x2F;&#x2F; 如果左子树与右子树的高度差大于1，则需要进行平衡调整，这里使用左子树的高度减右子树的高度，节点为空高度为-1\n            if (getHeight(avlTreeNode.leftChild) - getHeight(avlTreeNode.rightChild) &gt; 1) &#123;\n                &#x2F;&#x2F; 如果插入的值小于当前节点（即失衡节点）的左子节点的值，即插入的节点在失衡节点的左子节点的左边，则进行LL型旋转\n                if (val &lt; avlTreeNode.leftChild.data) &#123;\n                    System.out.println(&quot;LL型旋转&quot;);\n                    avlTreeNode &#x3D; LLRotate(avlTreeNode);\n                &#125; else &#123; &#x2F;&#x2F; 如果插入的值不小于当前节点（即失衡节点）的左子节点的值，即插入的节点在失衡节点的左子节点的右边，则进行LR型旋转\n                    System.out.println(&quot;LR型旋转&quot;);\n                    avlTreeNode &#x3D; LRRotate(avlTreeNode);\n                &#125;\n            &#125;\n        &#125; else &#123; &#x2F;&#x2F; 如果插入的值不小于当前节点的值，则插入到右子树中\n            avlTreeNode.rightChild &#x3D; insert(avlTreeNode.rightChild, val);\n            &#x2F;&#x2F; 平衡调整\n            if (getHeight(avlTreeNode.rightChild) - getHeight(avlTreeNode.leftChild) &gt; 1)&#123;\n                &#x2F;&#x2F; 如果插入的值小于等于当前节点（即失衡节点）的右子节点的值，即插入的节点在失衡节点的右子节点的左边，则进行RL型旋转\n                if (val &lt; avlTreeNode.rightChild.data)&#123;\n                    System.out.println(&quot;RL型旋转&quot;);\n                    avlTreeNode &#x3D; RLRotate(avlTreeNode);\n                &#125; else &#123; &#x2F;&#x2F; 如果插入的值大于当前节点（即失衡节点）的右子节点的值，即插入的节点在失衡节点的右子节点的右边，则进行RR型旋转\n                    System.out.println(&quot;RR型旋转&quot;);\n                    avlTreeNode &#x3D; RRRotate(avlTreeNode);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 更新节点的高度，获取左子树与右子树的最大高度，叶子节点高度为0，再加1即为当前节点的高度\n        avlTreeNode.height &#x3D; Math.max(getHeight(avlTreeNode.leftChild), getHeight(avlTreeNode.rightChild)) + 1;\n        return avlTreeNode;\n    &#125;\n\n    &#x2F;**\n     * LL旋转,30为失衡点（左右子树高度差大于1），对失衡点的左子树，即对结点20进行左旋\n     *           30                        20\n     *          &#x2F;  \\                      &#x2F;  \\\n     *        20  40                   10   30\n     *       &#x2F;  \\      --LL旋转--       &#x2F;   &#x2F;  \\\n     *     10   25                   5   25   40\n     *    &#x2F;\n     *   56\n     *&#x2F;\n    private AVLTreeNode LLRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（30）的左子节点 20 作为新节点\n        AVLTreeNode newRoot &#x3D; avlTreeNode.leftChild;\n        &#x2F;&#x2F; 将新节点（20）的右子节点 25 作为失衡点（30）的左子节点\n        avlTreeNode.leftChild &#x3D; newRoot.rightChild;\n        &#x2F;&#x2F; 失衡点（30）作为新节点（20）的右子节点\n        newRoot.rightChild &#x3D; avlTreeNode;\n        &#x2F;&#x2F; 更新失衡点和新根节点的高度\n        avlTreeNode.height &#x3D; Math.max(getHeight(avlTreeNode.leftChild), getHeight(avlTreeNode.rightChild)) + 1;\n        newRoot.height &#x3D; Math.max(getHeight(newRoot.leftChild), getHeight(newRoot.rightChild)) + 1;\n        &#x2F;&#x2F; 新节点取代原失衡点\n        return newRoot;\n    &#125;\n\n    &#x2F;**\n     * RR旋转,20为失衡点（左右子树高度差大于1），对失衡点的右子树，即对结点30进行左旋\n     *      20                          30\n     *     &#x2F;  \\                        &#x2F;  \\\n     *    10  30                     20   40\n     *       &#x2F;  \\     --RR旋转--     &#x2F;  \\   \\\n     *      25  40                 10  25  50\n     *           \\\n     *           50\n     *&#x2F;\n    private AVLTreeNode RRRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（20）的右子节点 30 作为新节点\n        AVLTreeNode newRoot &#x3D; avlTreeNode.rightChild;\n        &#x2F;&#x2F; 将新节点（30）的左子节点 25 作为失衡点（20）的右子节点\n        avlTreeNode.rightChild &#x3D; newRoot.leftChild;\n        &#x2F;&#x2F; 失衡点（20）作为新节点（30）的左子节点\n        newRoot.leftChild &#x3D; avlTreeNode;\n        &#x2F;&#x2F; 更新失衡点和新根节点的高度\n        avlTreeNode.height &#x3D; Math.max(getHeight(avlTreeNode.leftChild), getHeight(avlTreeNode.rightChild)) + 1;\n        newRoot.height &#x3D; Math.max(getHeight(newRoot.leftChild), getHeight(newRoot.rightChild)) + 1;\n        &#x2F;&#x2F; 新节点取代原失衡点\n        return newRoot;\n    &#125;\n\n    &#x2F;**\n     * LR旋转，先将失衡点（30）的左子树（20）进行 RR 旋转，再将失衡点（30）进行 LL 旋转\n     *           30                         30                    25\n     *          &#x2F;  \\                       &#x2F;  \\                  &#x2F;  \\\n     *        20  40                     25   40                20  30\n     *       &#x2F;  \\      --先RR旋转--      &#x2F;  \\      --再LL旋转--   &#x2F;   &#x2F; \\\n     *     10   25                    20   28                 10  28  40\n     *            \\                  &#x2F;\n     *             28               10\n     *&#x2F;\n    private AVLTreeNode LRRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（30）的左子节点（20）进行 RR 旋转\n        avlTreeNode.leftChild &#x3D; RRRotate(avlTreeNode.leftChild);\n        &#x2F;&#x2F; 将失衡点（30）进行 LL 旋转，并返回新节点代替原失衡点\n        return LLRotate(avlTreeNode);\n    &#125;\n\n    &#x2F;**\n     * RL旋转，先将失衡点（20）的右子树（30）进行 LL 旋转，再将失衡点（20）进行 RR 旋转\n     *      20                          20                       25\n     *     &#x2F;  \\                        &#x2F;  \\                     &#x2F;  \\\n     *    10  30                     10   25                   20  30\n     *       &#x2F;  \\     --LL旋转--             \\    --RR旋转--    &#x2F;   &#x2F; \\\n     *      25  40                          30               10  28  40\n     *       \\                             &#x2F;  \\\n     *       28                           28  40\n     *&#x2F;\n    private AVLTreeNode RLRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（20）的右子节点（30）进行 LL 旋转\n        avlTreeNode.rightChild &#x3D; LLRotate(avlTreeNode.rightChild);\n        &#x2F;&#x2F; 将失衡点（20）进行 RR 旋转，并返回新节点代替原失衡点\n        return RRRotate(avlTreeNode);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>测试类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AVLTreeTest &#123;\n    public static void main(String[] args) &#123;\n        AVLTree avlTree &#x3D; new AVLTree();\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 20);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 10);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 30);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 25);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 40);\n        avlTree.printTree(avlTree.root);\n        System.out.println();\n\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 28);\n        avlTree.printTree(avlTree.root);\n        System.out.println();\n\n        System.out.println(&quot;树的高度：&quot; + avlTree.getHeight(avlTree.root));\n        System.out.println(&quot;树的节点数：&quot; + avlTree.getSize());\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105859.png\"></p>\n<h2 id=\"4-6-红黑树\"><a href=\"#4-6-红黑树\" class=\"headerlink\" title=\"4.6 红黑树\"></a>4.6 红黑树</h2><h3 id=\"4-6-1-概述\"><a href=\"#4-6-1-概述\" class=\"headerlink\" title=\"4.6.1 概述\"></a>4.6.1 概述</h3><ul>\n<li>节点非红即黑</li>\n<li><strong>根节点是黑色的</strong></li>\n<li><strong>所有 Null 节点称为叶节点，且颜色为黑色</strong></li>\n<li><strong>所有红色节点的子结点都是黑色，即从每个叶子到根的所有路径上不能有两个连续的红色结点</strong></li>\n<li>从<strong>任意节点到其叶节点的所有路径都包含相同数目的黑色节点</strong></li>\n</ul>\n<p><strong>AVL 所有节点的左右子树高度差的绝对值不超过1</strong>，由于红黑树每个红色节点都必须有两个黑色的子节点，并且从任一节点到叶子节点的所有路径都包含相同数目的黑色节点，<strong>则红黑树最差情况下高度比是2：1</strong></p>\n<p><strong>插入原则：假如插入节点的颜色为黑色的话，就破坏了红黑树的性质，所以每次插入的首先都是红节点。如果插入节点的父节点是黑色，能维持性质 。如果插入节点的父节点是红色，破坏了性质，需要通过重新着色或旋转，来维持性质</strong></p>\n<ol>\n<li><p><strong>为根节点</strong><br>根节点为空，则直接插入为根节点，颜色为黑色<br><img src=\"http://img.fan223.cn/2023/04/20230419105913.png\"></p>\n</li>\n<li><p><strong>插入节点的父结点为黑色</strong><br>直接插入<br><img src=\"http://img.fan223.cn/2023/04/20230419105924.png\"></p>\n</li>\n<li><p><strong>插入节点的父结点和叔父节点都是红色节点</strong>，先插入新节点(红色)，<strong>插入节点的父结点、叔父节点和祖父节点都要变色。假如祖父节点为根节点，则变为黑色，否则继续向上更新</strong><br><img src=\"http://img.fan223.cn/2023/04/20230419105935.png\"><br><img src=\"http://img.fan223.cn/2023/04/20230419105946.png\"></p>\n</li>\n<li><p><strong>插入节点的父结点是红色，同时叔父节点是黑色</strong>，同时<strong>插入节点是其父结点的左子节点，而父结点是祖父节点的左子节点</strong>，这时要进行一次LL旋转调整插入节点和其父节点的角色（以父结点为轴）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里由于旋转后根节点是红色所以进行了一次变色，为了满足红黑树的性质，叔父节点也进行一次变色</p></blockquote>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419105956.png\"></p>\n</li>\n<li><p><strong>插入节点的父结点是红色，同时叔父节点都是黑色</strong>，同时<strong>插入节点是其父节点的右子节点，而父结点是祖父节点的右子节点</strong>，此时需要对祖父节点进行一次RR旋转(以父结点为轴)，变色情况同 4<br><img src=\"http://img.fan223.cn/2023/04/20230419110005.png\"></p>\n</li>\n<li><p><strong>插入节点的父节点是红色，同时叔父节点都是黑色</strong>，同时<strong>插入节点是其父节点的右子节点，而父节点又是其父节点的左子节点（LR旋转）</strong>。先进行一次RR旋转调换新节点和其父节点的角色，旋转后发现节点符合情况 4，再进行一次LL旋转。变色情况同 4<br><img src=\"http://img.fan223.cn/2023/04/20230419110015.png\"></p>\n</li>\n<li><p><strong>插入节点的父结点是红色，同时叔父节点是黑色</strong>，同时<strong>插入节点是其父节点的左子节点，而父节点是祖父节点的右子节点（RL）</strong>，先进行一次LL旋转变成情况5，再进行一次RR旋转。变色情况同 4<br><img src=\"http://img.fan223.cn/2023/04/20230419110025.png\"></p>\n</li>\n</ol>\n<p><strong>整体构建过程</strong></p>\n<p><img src=\"http://img.fan223.cn/2023/04/20230419110034.png\"></p>\n<h3 id=\"4-6-2-实现\"><a href=\"#4-6-2-实现\" class=\"headerlink\" title=\"4.6.2 实现\"></a>4.6.2 实现</h3><p><strong>1、创建节点类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RBTreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;\n    boolean color; &#x2F;&#x2F; red or black\n    T key; &#x2F;&#x2F; 键\n    RBTreeNode leftChildren; &#x2F;&#x2F; 左子节点\n    RBTreeNode rightChildren; &#x2F;&#x2F; 右子节点\n    RBTreeNode parent; &#x2F;&#x2F; 父节点\n\n    public RBTreeNode(T key, boolean color) &#123;\n        this.key &#x3D; key;\n        this.color &#x3D; color;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>2、实现类（待改善）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;\n    private RBTreeNode&lt;T&gt; mRoot;    &#x2F;&#x2F; 根结点\n\n    private static final boolean RED   &#x3D; false;\n    private static final boolean BLACK &#x3D; true;\n\n    public RBTree() &#123;\n        mRoot&#x3D;null;\n    &#125;\n\n    private boolean isRed(RBTreeNode&lt;T&gt; node) &#123;\n        return ((node!&#x3D;null)&amp;&amp;(node.color&#x3D;&#x3D;RED)) ? true : false;\n    &#125;\n    private boolean isBlack(RBTreeNode&lt;T&gt; node) &#123;\n        return !isRed(node);\n    &#125;\n\n    &#x2F;&#x2F; 前序遍历&quot;红黑树&quot;\n    private void preOrder(RBTreeNode&lt;T&gt; tree) &#123;\n        if(tree !&#x3D; null) &#123;\n            System.out.print(tree.key+&quot;-&quot; + tree.color + &quot; &quot;);\n            preOrder(tree.leftChildren);\n            preOrder(tree.rightChildren);\n        &#125;\n    &#125;\n\n    public void preOrder() &#123;\n        preOrder(mRoot);\n    &#125;\n\n    &#x2F;&#x2F; 中序遍历&quot;红黑树&quot;\n    private void inOrder(RBTreeNode&lt;T&gt; tree) &#123;\n        if(tree !&#x3D; null) &#123;\n            inOrder(tree.leftChildren);\n            System.out.print(tree.key+&quot; &quot;);\n            inOrder(tree.rightChildren);\n        &#125;\n    &#125;\n\n    public void inOrder() &#123;\n        inOrder(mRoot);\n    &#125;\n\n\n    &#x2F;&#x2F; 后序遍历&quot;红黑树&quot;\n    private void postOrder(RBTreeNode&lt;T&gt; tree) &#123;\n        if(tree !&#x3D; null)\n        &#123;\n            postOrder(tree.leftChildren);\n            postOrder(tree.rightChildren);\n            System.out.print(tree.key+&quot; &quot;);\n        &#125;\n    &#125;\n\n    public void postOrder() &#123;\n        postOrder(mRoot);\n    &#125;\n\n\n    &#x2F;&#x2F; (递归实现)查找&quot;红黑树x&quot;中键值为key的节点\n    private RBTreeNode&lt;T&gt; search(RBTreeNode&lt;T&gt; x, T key) &#123;\n        if (x&#x3D;&#x3D;null)\n            return x;\n\n        int cmp &#x3D; key.compareTo(x.key);\n        if (cmp &lt; 0)\n            return search(x.leftChildren, key);\n        else if (cmp &gt; 0)\n            return search(x.rightChildren, key);\n        else\n            return x;\n    &#125;\n\n    public RBTreeNode&lt;T&gt; search(T key) &#123;\n        return search(mRoot, key);\n    &#125;\n\n    &#x2F;&#x2F;  (非递归实现)查找&quot;红黑树x&quot;中键值为key的节点\n    private RBTreeNode&lt;T&gt; iterativeSearch(RBTreeNode&lt;T&gt; x, T key) &#123;\n        while (x!&#x3D;null) &#123;\n            int cmp &#x3D; key.compareTo(x.key);\n\n            if (cmp &lt; 0)\n                x &#x3D; x.leftChildren;\n            else if (cmp &gt; 0)\n                x &#x3D; x.rightChildren;\n            else\n                return x;\n        &#125;\n\n        return x;\n    &#125;\n\n    public RBTreeNode&lt;T&gt; iterativeSearch(T key) &#123;\n        return iterativeSearch(mRoot, key);\n    &#125;\n\n    &#x2F;&#x2F; 查找最小结点：返回tree为根结点的红黑树的最小结点。\n    private RBTreeNode&lt;T&gt; minimum(RBTreeNode&lt;T&gt; tree) &#123;\n        if (tree &#x3D;&#x3D; null)\n            return null;\n\n        while(tree.leftChildren !&#x3D; null)\n            tree &#x3D; tree.leftChildren;\n        return tree;\n    &#125;\n\n    public T minimum() &#123;\n        RBTreeNode&lt;T&gt; p &#x3D; minimum(mRoot);\n        if (p !&#x3D; null)\n            return p.key;\n\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 查找最大结点：返回tree为根结点的红黑树的最大结点。\n    private RBTreeNode&lt;T&gt; maximum(RBTreeNode&lt;T&gt; tree) &#123;\n        if (tree &#x3D;&#x3D; null)\n            return null;\n\n        while(tree.rightChildren !&#x3D; null)\n            tree &#x3D; tree.rightChildren;\n        return tree;\n    &#125;\n\n    public T maximum() &#123;\n        RBTreeNode&lt;T&gt; p &#x3D; maximum(mRoot);\n        if (p !&#x3D; null)\n            return p.key;\n\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 找结点(x)的后继结点。即，查找&quot;红黑树中数据值大于该结点&quot;的&quot;最小结点&quot;。\n    public RBTreeNode&lt;T&gt; successor(RBTreeNode&lt;T&gt; x) &#123;\n        &#x2F;&#x2F; 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。\n        if (x.rightChildren !&#x3D; null)\n            return minimum(x.rightChildren);\n\n        &#x2F;&#x2F; 如果x没有右孩子。则x有以下两种可能：\n        &#x2F;&#x2F; (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。\n        &#x2F;&#x2F; (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。\n        RBTreeNode&lt;T&gt; y &#x3D; x.parent;\n        while ((y!&#x3D;null) &amp;&amp; (x&#x3D;&#x3D;y.rightChildren)) &#123;\n            x &#x3D; y;\n            y &#x3D; y.parent;\n        &#125;\n\n        return y;\n    &#125;\n\n    &#x2F;&#x2F; 找结点(x)的前驱结点。即，查找&quot;红黑树中数据值小于该结点&quot;的&quot;最大结点&quot;。\n    public RBTreeNode&lt;T&gt; predecessor(RBTreeNode&lt;T&gt; x) &#123;\n        &#x2F;&#x2F; 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。\n        if (x.leftChildren !&#x3D; null)\n            return maximum(x.leftChildren);\n\n        &#x2F;&#x2F; 如果x没有左孩子。则x有以下两种可能：\n        &#x2F;&#x2F; (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。\n        &#x2F;&#x2F; (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。\n        RBTreeNode&lt;T&gt; y &#x3D; x.parent;\n        while ((y!&#x3D;null) &amp;&amp; (x&#x3D;&#x3D;y.leftChildren)) &#123;\n            x &#x3D; y;\n            y &#x3D; y.parent;\n        &#125;\n\n        return y;\n    &#125;\n\n    &#x2F;*\n     * 对红黑树的节点(x)进行左旋转\n     *\n     * 左旋示意图(对节点x进行左旋)：\n     *      px                              px\n     *     &#x2F;                               &#x2F;\n     *    x                               y\n     *   &#x2F;  \\      --(左旋)-.             &#x2F; \\                #\n     *  lx   y                          x  ry\n     *     &#x2F;   \\                       &#x2F;  \\\n     *    ly   ry                     lx  ly\n     *\n     *\n     *&#x2F;\n    private void leftRotate(RBTreeNode&lt;T&gt; rbTreeNode) &#123;\n        &#x2F;&#x2F; 将当前节点的右子节点设为新节点\n        RBTreeNode&lt;T&gt; newRoot &#x3D; rbTreeNode.rightChildren;\n        &#x2F;&#x2F; 将新节点的左子节点设为当前节点的右子节点\n        rbTreeNode.rightChildren &#x3D; newRoot.leftChildren;\n\n        &#x2F;&#x2F; 将 “x的父亲” 设为 “y的父亲”\n        newRoot.parent &#x3D; rbTreeNode.parent;\n\n        if (rbTreeNode.parent &#x3D;&#x3D; null) &#123;\n            this.mRoot &#x3D; newRoot;            &#x2F;&#x2F; 如果 “x的父亲” 是空节点，则将y设为根节点\n        &#125; else &#123;\n            if (rbTreeNode.parent.leftChildren &#x3D;&#x3D; rbTreeNode)\n                rbTreeNode.parent.leftChildren &#x3D; newRoot;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”\n            else\n                rbTreeNode.parent.rightChildren &#x3D; newRoot;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”\n        &#125;\n\n        &#x2F;&#x2F; 将 “x” 设为 “y的左孩子”\n        newRoot.leftChildren &#x3D; rbTreeNode;\n    &#125;\n\n    &#x2F;*\n     * 对红黑树的节点(y)进行右旋转\n     *\n     * 右旋示意图(对节点y进行左旋)：\n     *            py                               py\n     *           &#x2F;                                &#x2F;\n     *          y                                x\n     *         &#x2F;  \\      --(右旋)-.            &#x2F;  \\                     #\n     *        x   ry                           lx   y\n     *       &#x2F; \\                                   &#x2F; \\                   #\n     *      lx  rx                                rx  ry\n     *\n     *&#x2F;\n    private void rightChildrenRotate(RBTreeNode&lt;T&gt; y) &#123;\n        &#x2F;&#x2F; 设置x是当前节点的左孩子。\n        RBTreeNode&lt;T&gt; x &#x3D; y.leftChildren;\n\n        &#x2F;&#x2F; 将 “x的右孩子” 设为 “y的左孩子”；\n        &#x2F;&#x2F; 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”\n        y.leftChildren &#x3D; x.rightChildren;\n        if (x.rightChildren !&#x3D; null)\n            x.rightChildren.parent &#x3D; y;\n\n        &#x2F;&#x2F; 将 “y的父亲” 设为 “x的父亲”\n        x.parent &#x3D; y.parent;\n\n        if (y.parent &#x3D;&#x3D; null) &#123;\n            this.mRoot &#x3D; x;            &#x2F;&#x2F; 如果 “y的父亲” 是空节点，则将x设为根节点\n        &#125; else &#123;\n            if (y &#x3D;&#x3D; y.parent.rightChildren)\n                y.parent.rightChildren &#x3D; x;    &#x2F;&#x2F; 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”\n            else\n                y.parent.leftChildren &#x3D; x;    &#x2F;&#x2F; (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”\n        &#125;\n\n        &#x2F;&#x2F; 将 “y” 设为 “x的右孩子”\n        x.rightChildren &#x3D; y;\n\n        &#x2F;&#x2F; 将 “y的父节点” 设为 “x”\n        y.parent &#x3D; x;\n    &#125;\n\n    &#x2F;&#x2F; 插入节点\n    public void insert(T key) &#123;\n        insert(new RBTreeNode&lt;T&gt;(key, BLACK));\n    &#125;\n\n    &#x2F;&#x2F; 插入节点后，修正红黑树\n    private void insert(RBTreeNode&lt;T&gt; node) &#123;\n        int cmp;\n        RBTreeNode&lt;T&gt; y &#x3D; null;\n        RBTreeNode&lt;T&gt; x &#x3D; this.mRoot;\n\n        &#x2F;&#x2F; 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。\n        while (x !&#x3D; null) &#123;\n            y &#x3D; x;\n            cmp &#x3D; node.key.compareTo(x.key); &#x2F;&#x2F;当前key h和插入的key进行比较\n            if (cmp &lt; 0)\n                x &#x3D; x.leftChildren;\n            else\n                x &#x3D; x.rightChildren;\n        &#125;\n\n        node.parent &#x3D; y;\n        if (y!&#x3D;null) &#123;\n            cmp &#x3D; node.key.compareTo(y.key); &#x2F;&#x2F;判断插入到左边还是右边\n            if (cmp &lt; 0)\n                y.leftChildren &#x3D; node;\n            else\n                y.rightChildren &#x3D; node;\n        &#125; else &#123;\n            this.mRoot &#x3D; node;\n        &#125;\n\n        &#x2F;&#x2F; 2. 设置节点的颜色为红色\n        node.color &#x3D; RED;\n\n        &#x2F;&#x2F; 3. 将它重新修正为一颗二叉查找树\n        insertFixUp(node);\n    &#125;\n\n    &#x2F;*\n     * 红黑树插入修正函数\n     *\n     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；\n     * 目的是将它重新塑造成一颗红黑树。\n     *1.Z是根节点（即Z插入前是一颗空树）\n     * 2.Z的叔节点是红色的\n     * 3.Z的叔节点是黑色的，并且局部呈现三角行（左右三角）\n     * 3.Z的叔节点是黑色的，并且局部呈现直线角行（左右直线）\n     *\n     * 参数说明：\n     *     node 插入的结点\n     *\n     *&#x2F;\n    private void insertFixUp(RBTreeNode&lt;T&gt; addNode) &#123;\n        RBTreeNode&lt;T&gt; parent, gparent;\n\n        &#x2F;&#x2F; 若“父节点存在，并且父节点的颜色是红色”\n        while (((parent &#x3D; addNode.parent)!&#x3D;null) &amp;&amp; isRed(parent)) &#123;\n            gparent &#x3D; parent.parent;\n\n            &#x2F;&#x2F;若“父节点”是“祖父节点的左孩子”\n            if (parent &#x3D;&#x3D; gparent.leftChildren) &#123;\n                &#x2F;&#x2F; Case 1条件：叔叔节点是红色\n                RBTreeNode&lt;T&gt; uncle &#x3D; gparent.rightChildren;\n                if ((uncle!&#x3D;null) &amp;&amp; isRed(uncle)) &#123;\n                    uncle.color &#x3D; BLACK;\n                    parent.color &#x3D; BLACK;\n                    gparent.color &#x3D; RED;\n                    addNode &#x3D; gparent;\n                    continue;\n                &#125;\n\n                &#x2F;&#x2F; Case 2条件：叔叔是黑色，且当前节点是右孩子\n                if (parent.rightChildren &#x3D;&#x3D; addNode) &#123;\n                    RBTreeNode&lt;T&gt; tmp;\n                    leftRotate(parent);\n                    tmp &#x3D; parent;\n                    parent &#x3D; addNode;\n                    addNode &#x3D; tmp;\n                &#125;\n\n                &#x2F;&#x2F; Case 3条件：叔叔是黑色，且当前节点是左孩子。\n                parent.color &#x3D; BLACK;\n                gparent.color &#x3D; RED;\n                rightChildrenRotate(gparent);\n            &#125; else &#123;    &#x2F;&#x2F;若“z的父节点”是“z的祖父节点的右孩子”\n                &#x2F;&#x2F; Case 1条件：叔叔节点是红色\n                RBTreeNode&lt;T&gt; uncle &#x3D; gparent.leftChildren;\n                if ((uncle!&#x3D;null) &amp;&amp; isRed(uncle)) &#123;\n                    uncle.color &#x3D; BLACK;\n                    parent.color &#x3D; BLACK;\n                    gparent.color &#x3D; RED;\n                    addNode &#x3D; gparent;\n                    continue;\n                &#125;\n\n                &#x2F;&#x2F; Case 2条件：叔叔是黑色，且当前节点是左孩子\n                if (parent.leftChildren &#x3D;&#x3D; addNode) &#123;\n                    RBTreeNode&lt;T&gt; tmp;\n                    rightChildrenRotate(parent);\n                    tmp &#x3D; parent;\n                    parent &#x3D; addNode;\n                    addNode &#x3D; tmp;\n                &#125;\n\n                &#x2F;&#x2F; Case 3条件：叔叔是黑色，且当前节点是右孩子。\n                parent.color &#x3D; BLACK;\n                gparent.color &#x3D; RED;\n                leftRotate(gparent);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 将根节点设为黑色\n        mRoot.color &#x3D; BLACK;\n    &#125;\n\n    &#x2F;*\n     * 红黑树删除修正函数\n     *\n     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；\n     * 目的是将它重新塑造成一颗红黑树。\n     *\n     *\n     *\n     * 参数说明：\n     *     node 待修正的节点\n     *&#x2F;\n    private void removeFixUp(RBTreeNode&lt;T&gt; fixNode, RBTreeNode&lt;T&gt; parent) &#123;\n        RBTreeNode&lt;T&gt; other;\n\n        while ((fixNode&#x3D;&#x3D;null || isBlack(fixNode)) &amp;&amp; (fixNode !&#x3D; this.mRoot)) &#123;\n            if (parent.leftChildren &#x3D;&#x3D; fixNode) &#123;&#x2F;&#x2F;删除的节点是左节点\n                other &#x3D; parent.rightChildren;\n                if (isRed(other)) &#123;\n                    &#x2F;&#x2F; Case 1: x的兄弟w是红色的\n                    other.color &#x3D; BLACK;\n                    parent.color &#x3D; RED;\n                    leftRotate(parent);\n                    other &#x3D; parent.rightChildren;\n                &#125;\n\n                if ((other.leftChildren&#x3D;&#x3D;null || isBlack(other.leftChildren)) &amp;&amp;\n                        (other.rightChildren&#x3D;&#x3D;null || isBlack(other.rightChildren))) &#123;\n                    &#x2F;&#x2F; Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的\n                    other.color &#x3D; RED;\n                    fixNode &#x3D; parent;\n                    parent &#x3D; fixNode.parent;\n                &#125; else &#123;\n\n                    if (other.rightChildren&#x3D;&#x3D;null || isBlack(other.rightChildren)) &#123;\n                        &#x2F;&#x2F; Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。\n                        other.leftChildren.color &#x3D; BLACK;\n                        other.color &#x3D; RED;\n                        rightChildrenRotate(other);\n                        other &#x3D; parent.rightChildren;\n                    &#125;\n                    &#x2F;&#x2F; Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。\n                    other.color &#x3D; parent.color;\n                    parent.color &#x3D; BLACK;\n                    other.rightChildren.color &#x3D; BLACK;\n                    leftRotate(parent);\n                    fixNode &#x3D; this.mRoot;\n                    break;\n                &#125;\n            &#125; else &#123; &#x2F;&#x2F;删除的节点是右节点\n\n                other &#x3D; parent.leftChildren;\n                if (isRed(other)) &#123;\n                    &#x2F;&#x2F; Case 1: x的兄弟w是红色的\n                    other.color &#x3D; BLACK;\n                    parent.color &#x3D; RED;\n                    rightChildrenRotate(parent);\n                    other &#x3D; parent.leftChildren;\n                &#125;\n\n                if ((other.leftChildren&#x3D;&#x3D;null || isBlack(other.leftChildren)) &amp;&amp;\n                        (other.rightChildren&#x3D;&#x3D;null || isBlack(other.rightChildren))) &#123;\n                    &#x2F;&#x2F; Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的\n                    other.color &#x3D; RED;\n                    fixNode &#x3D; parent;\n                    parent &#x3D; fixNode.parent;\n                &#125; else &#123;\n\n                    if (other.leftChildren&#x3D;&#x3D;null || isBlack(other.leftChildren)) &#123;\n                        &#x2F;&#x2F; Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。\n                        other.rightChildren.color &#x3D; BLACK;\n                        other.color &#x3D; RED;\n                        leftRotate(other);\n                        other &#x3D; parent.leftChildren;\n                    &#125;\n\n                    &#x2F;&#x2F; Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。\n                    other.color &#x3D; parent.color;\n\n\n                    parent.color &#x3D; BLACK;\n                    other.leftChildren.color &#x3D; BLACK;\n                    rightChildrenRotate(parent);\n                    fixNode &#x3D; this.mRoot;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n\n        if (fixNode!&#x3D;null)\n            fixNode.color &#x3D; BLACK;\n    &#125;\n\n    &#x2F;&#x2F; 删除结点(delNode)，并返回被删除的结点\n    private void remove(RBTreeNode&lt;T&gt; delNode) &#123;\n        RBTreeNode&lt;T&gt; child, parent;\n        boolean color;\n\n        &#x2F;&#x2F; 被删除节点的&quot;左右孩子都不为空&quot;的情况。\n        if ( (delNode.leftChildren!&#x3D;null) &amp;&amp; (delNode.rightChildren!&#x3D;null) ) &#123;\n            &#x2F;&#x2F; 被删节点的后继节点。(称为&quot;取代节点&quot;)\n            &#x2F;&#x2F; 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。\n            RBTreeNode&lt;T&gt; replace &#x3D; delNode;\n\n            &#x2F;&#x2F; 获取后继节点\n            replace &#x3D; replace.rightChildren;\n            while (replace.leftChildren !&#x3D; null)\n                replace &#x3D; replace.leftChildren;\n\n            &#x2F;&#x2F; &quot;node节点&quot;不是根节点(只有根节点不存在父节点)\n            if (delNode.parent!&#x3D;null) &#123;\n                if (delNode.parent.leftChildren &#x3D;&#x3D; delNode)\n                    delNode.parent.leftChildren &#x3D; replace;\n                else\n                    delNode.parent.rightChildren &#x3D; replace;\n            &#125; else &#123;\n                &#x2F;&#x2F; &quot;node节点&quot;是根节点，更新根节点。\n                this.mRoot &#x3D; replace;\n            &#125;\n\n            &#x2F;&#x2F; child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。\n            &#x2F;&#x2F; &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。\n            child &#x3D; replace.rightChildren;\n            parent &#x3D; replace.parent;\n            &#x2F;&#x2F; 保存&quot;取代节点&quot;的颜色\n            color &#x3D; replace.color;\n\n            &#x2F;&#x2F; &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;\n            if (parent &#x3D;&#x3D; delNode) &#123;\n                parent &#x3D; replace;\n            &#125; else &#123;\n                &#x2F;&#x2F; child不为空\n                if (child!&#x3D;null)\n                    child.parent &#x3D; parent;\n                parent.leftChildren &#x3D; child;\n\n                replace.rightChildren &#x3D; delNode.rightChildren;\n                delNode.rightChildren.parent &#x3D; replace;\n            &#125;\n\n            replace.parent &#x3D; delNode.parent;\n            replace.color &#x3D; delNode.color;\n            replace.leftChildren &#x3D; delNode.leftChildren;\n            delNode.leftChildren.parent &#x3D; replace;\n\n            if (color &#x3D;&#x3D; BLACK) &#x2F;&#x2F;红色直接删除 黑色删除后维护\n                removeFixUp(child, parent);\n\n            delNode &#x3D; null;\n            return ;\n        &#125;\n\n        if (delNode.leftChildren !&#x3D;null) &#123;\n            child &#x3D; delNode.leftChildren;\n        &#125; else &#123;\n            child &#x3D; delNode.rightChildren;\n        &#125;\n\n        parent &#x3D; delNode.parent;\n        &#x2F;&#x2F; 保存&quot;取代节点&quot;的颜色\n        color &#x3D; delNode.color;\n\n        if (child!&#x3D;null)\n            child.parent &#x3D; parent;\n\n        &#x2F;&#x2F; &quot;node节点&quot;不是根节点\n        if (parent!&#x3D;null) &#123;\n            if (parent.leftChildren &#x3D;&#x3D; delNode)\n                parent.leftChildren &#x3D; child;\n            else\n                parent.rightChildren &#x3D; child;\n        &#125; else &#123;\n            this.mRoot &#x3D; child;\n        &#125;\n\n        if (color &#x3D;&#x3D; BLACK)\n            removeFixUp(child, parent);\n        delNode &#x3D; null;\n    &#125;\n\n    &#x2F;*\n     * 删除结点(z)，并返回被删除的结点\n     *\n     * 参数说明：\n     *     tree 红黑树的根结点\n     *     z 删除的结点\n     *&#x2F;\n    public void remove(T key) &#123;\n        RBTreeNode&lt;T&gt; node;\n\n        if ((node &#x3D; search(mRoot, key)) !&#x3D; null)\n            remove(node);\n    &#125;\n\n    &#x2F;*\n     * 销毁红黑树\n     *&#x2F;\n    private void destroy(RBTreeNode&lt;T&gt; tree) &#123;\n        if (tree&#x3D;&#x3D;null)\n            return ;\n\n        if (tree.leftChildren !&#x3D; null)\n            destroy(tree.leftChildren);\n        if (tree.rightChildren !&#x3D; null)\n            destroy(tree.rightChildren);\n\n        tree&#x3D;null;\n    &#125;\n\n    public void clear() &#123;\n        destroy(mRoot);\n        mRoot &#x3D; null;\n    &#125;\n\n    &#x2F;*\n     * 打印&quot;红黑树&quot;\n     *\n     * key        -- 节点的键值\n     * direction  --  0，表示该节点是根节点;\n     *               -1，表示该节点是它的父结点的左孩子;\n     *                1，表示该节点是它的父结点的右孩子。\n     *&#x2F;\n    private void print(RBTreeNode&lt;T&gt; tree, T key, int direction) &#123;\n\n        if(tree !&#x3D; null) &#123;\n\n            if(direction&#x3D;&#x3D;0)    &#x2F;&#x2F; tree是根节点\n                System.out.printf(&quot;%2d(B) is root\\n&quot;, tree.key);\n            else                &#x2F;&#x2F; tree是分支节点\n                System.out.printf(&quot;%2d(%s) is %2d&#39;s %6s child\\n&quot;, tree.key, isRed(tree)?&quot;R&quot;:&quot;B&quot;, key, direction&#x3D;&#x3D;1?&quot;rightChildren&quot; : &quot;leftChildren&quot;);\n\n            print(tree.leftChildren, tree.key, -1);\n            print(tree.rightChildren,tree.key,  1);\n        &#125;\n    &#125;\n\n    public void print() &#123;\n        if (mRoot !&#x3D; null)\n            print(mRoot, mRoot.key, 0);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>3、测试类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RBTreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;\n    boolean color; &#x2F;&#x2F; red or black\n    T key; &#x2F;&#x2F; 键\n    RBTreeNode leftChildren; &#x2F;&#x2F; 左子节点\n    RBTreeNode rightChildren; &#x2F;&#x2F; 右子节点\n    RBTreeNode parent; &#x2F;&#x2F; 父节点\n\n    public RBTreeNode(T key, boolean color) &#123;\n        this.key &#x3D; key;\n        this.color &#x3D; color;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419110050.png\"></p>\n","feature":false,"text":"1. 链表链表（LinkedList） 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据 链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 使...","link":"","photos":[],"count_time":{"symbolsCount":"82k","symbolsTime":"1:15"},"categories":[{"name":"Java","slug":"Java","count":5,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":12,"path":"api/tags/Java.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">1. 链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">1.1 单向链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E5%AE%9A%E4%B9%89%E8%8A%82%E7%82%B9%E7%B1%BB-Node\"><span class=\"toc-text\">1.1.1 定义节点类 Node</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%8A%82%E7%82%B9%E7%B1%BB%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.1.2 直接对节点类操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-3-%E5%B0%81%E8%A3%85%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C%E7%B1%BB\"><span class=\"toc-text\">1.1.3 封装节点操作类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">1.2 双向链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-%E5%AE%9A%E4%B9%89%E8%8A%82%E7%82%B9%E7%B1%BB\"><span class=\"toc-text\">1.2.1 定义节点类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E5%B0%81%E8%A3%85%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C%E7%B1%BB\"><span class=\"toc-text\">1.2.2 封装节点操作类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%BE%AA%E7%8E%AF%E5%88%97%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">1.3 循环列表与双向循环列表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%95%B0%E7%BB%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">1.4 应用场景与数组比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">1.4.1 应用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-2-%E4%B8%8E%E6%95%B0%E7%BB%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">1.4.2 与数组比较</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%A0%88\"><span class=\"toc-text\">2. 栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%95%B0%E7%BB%84%E6%A0%88\"><span class=\"toc-text\">2.1 数组栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E9%93%BE%E6%A0%88\"><span class=\"toc-text\">2.2 链栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.3 应用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-1-%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E9%80%80%E5%92%8C%E5%89%8D%E8%BF%9B%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">2.3.1 实现浏览器的回退和前进功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-2-%E6%A3%80%E6%9F%A5%E7%AC%A6%E5%8F%B7%E6%98%AF%E5%90%A6%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0\"><span class=\"toc-text\">2.3.2 检查符号是否成对出现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-3-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">2.3.3 反转字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-4-%E7%BB%B4%E6%8A%A4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.3.4 维护函数调用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3. 队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%8D%95%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.1 单队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-%E6%95%B0%E7%BB%84%E5%8D%95%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.1.1 数组单队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-%E9%93%BE%E5%BC%8F%E5%8D%95%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.1.2 链式单队列</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.2 循环队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.2.1 数组循环队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E9%93%BE%E5%BC%8F%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.2.2 链式循环队列</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">3.3 常见应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E6%A0%91\"><span class=\"toc-text\">4. 树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">4.1 二叉树的分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-1-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">4.1.1 满二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-2-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">4.1.2 完全二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-3-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91\"><span class=\"toc-text\">4.1.3 二叉排序树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-4-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">4.1.4 平衡二叉树</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">4.2 二叉树的存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">4.2.1 顺序存储</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-2-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">4.2.2 链式存储</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">4.3 二叉树的遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">4.3.1 先序遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">4.3.2 中序遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">4.3.3 后序遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">4.3.4 层次遍历</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%88%E6%9C%80%E4%BC%98%E2%BC%86%E5%8F%89%E6%A0%91%EF%BC%89\"><span class=\"toc-text\">4.4 哈夫曼树（最优⼆叉树）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">4.4.1 概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-2-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.4.2 实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-AVL-%E6%A0%91\"><span class=\"toc-text\">4.5 AVL 树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">4.5.1 概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-2-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.5.2 实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-%E7%BA%A2%E9%BB%91%E6%A0%91\"><span class=\"toc-text\">4.6 红黑树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">4.6.1 概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-2-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.6.2 实现</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"轻量应用服务器使用总结","uid":"6381587c82bf912786d507cd9ab0bca2","slug":"BlogRepository/服务器/轻量应用服务器使用总结","date":"2022-08-14T18:33:49.000Z","updated":"2023-04-20T13:57:44.632Z","comments":true,"path":"api/articles/BlogRepository/服务器/轻量应用服务器使用总结.json","keywords":null,"cover":"https://cover.png","text":"本文使用系统为 CentOS 7.6，服务器为腾讯轻量应用服务器 1. 设置 root 密码初始化实例后，默认 root 是没有密码的，可以登录云服务器自带的 WebShell，通过 sudo passwd root 命令，设置密码 2. 宝塔面板服务器管理软件，支持 Windo...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"服务器","slug":"服务器","count":4,"path":"api/categories/服务器.json"}],"tags":[{"name":"服务器","slug":"服务器","count":5,"path":"api/tags/服务器.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"记创建 SpringBoot 项目时连接超时，Cannot download \"https://start.spring.io\"","uid":"47df2e1dd7b2541fd7b7ee483506bab6","slug":"BlogRepository/问题记录/记创建 SpringBoot 项目时连接超时，Cannot download httpsstart.spring.io","date":"2022-07-25T17:19:20.000Z","updated":"2023-04-20T13:57:44.648Z","comments":true,"path":"api/articles/BlogRepository/问题记录/记创建 SpringBoot 项目时连接超时，Cannot download httpsstart.spring.io.json","keywords":null,"cover":"https://cover.png","text":"1. 问题首先，在第一阶段，连接 start.spring.io 超时 假如运气好第一阶段刷新成功，第二阶段创建，下载时报错超时，无法创建 2. 解决将地址 https://start.spring.io/ 改为 https://start.springboot.io/ 即可成功...","link":"","photos":[],"count_time":{"symbolsCount":146,"symbolsTime":"1 mins."},"categories":[{"name":"问题记录","slug":"问题记录","count":7,"path":"api/categories/问题记录.json"}],"tags":[{"name":"IDEA","slug":"IDEA","count":8,"path":"api/tags/IDEA.json"},{"name":"SpringBoot","slug":"SpringBoot","count":4,"path":"api/tags/SpringBoot.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}