{"title":"Java实用总结","uid":"b3f4e6999373a71edd44de21348d01f5","slug":"BlogRepository/Java/Java实用总结","date":"2022-11-08T02:22:55.000Z","updated":"2023-04-20T13:57:44.601Z","comments":true,"path":"api/articles/BlogRepository/Java/Java实用总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-时间时区转换\"><a href=\"#1-时间时区转换\" class=\"headerlink\" title=\"1. 时间时区转换\"></a>1. 时间时区转换</h1><h2 id=\"1-1-UTC-转-LocalDateTime\"><a href=\"#1-1-UTC-转-LocalDateTime\" class=\"headerlink\" title=\"1.1 UTC 转 LocalDateTime\"></a>1.1 UTC 转 LocalDateTime</h2><p>将 UTC 时间（格林威治实际标准时间）转换为北京时间（UTC-东八区时间）。即将带有 T、Z 的日期字符串类型转为 LocalDateTime 类型。LocalDateTime 是没有时区的 date 时间，如果想要时区信息，需要使用 ZonedDateTime。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static LocalDateTime parseToLocalDateTime(String stringTime) &#123;\n\t&#x2F;&#x2F; stringTime &#x3D; &quot;2022-05-02T16:00:00.000Z&quot;，即 2022-05-02 16:00:00\n\tLocalDateTime parse &#x3D; LocalDateTime.parse(stringTime, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&quot;));\n\n\tZonedDateTime zonedDateTime &#x3D; parse.atZone(ZoneId.from(ZoneOffset.UTC));\n\tZonedDateTime convertTime  &#x3D; zonedDateTime.withZoneSameInstant(ZoneOffset.ofHours(8));\n\n\treturn convertTime.toLocalDateTime(); &#x2F;&#x2F; 2022-05-03T00:00，即 2022-05-03 00:00:00\n&#125;</code></pre>\n\n<h2 id=\"2-2-yyyy-MM-dd-等转-LocalDateTime\"><a href=\"#2-2-yyyy-MM-dd-等转-LocalDateTime\" class=\"headerlink\" title=\"2.2 yyyy-MM-dd 等转 LocalDateTime\"></a>2.2 yyyy-MM-dd 等转 LocalDateTime</h2><p>无法直接将 “2022-05-04” 转换为 LocalDateTime，因为字符串中没有时间信息，只有日期。可以先将其转换为 LocalDate，然后再转换为 LocalDateTime。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\tString time &#x3D; &quot;2022-05-04&quot;;\n\tLocalDate localDate &#x3D; LocalDate.parse(time); &#x2F;&#x2F; 2022-05-04\n\n\t&#x2F;&#x2F; 2022-05-04T00:00\n\tLocalDateTime localDateTime &#x3D; localDate.atStartOfDay(); \n\t&#x2F;&#x2F; 2022-05-04T13:22:16.266\n\tLocalDateTime localDateTime &#x3D; LocalDateTime.of(localDate, LocalDateTime.now().toLocalTime());\n\t&#x2F;&#x2F; 2022-05-04T00:00\n\tLocalDateTime localDateTime &#x3D; LocalDateTime.of(localDate, LocalDateTime.MIN.toLocalTime());\n\n\t&#x2F;&#x2F; 或构建动态解析器，可以适用于各种情况，直接设置缺少的默认值。\n\tDateTimeFormatter dateTimeFormatter &#x3D; new DateTimeFormatterBuilder().appendPattern(&quot;yyyy-MM-dd&quot;)\n                .parseDefaulting(ChronoField.HOUR_OF_DAY, 0)\n                .parseDefaulting(ChronoField.MINUTE_OF_HOUR, 0)\n                .parseDefaulting(ChronoField.SECOND_OF_MINUTE, 0)\n                .toFormatter();\n\t&#x2F;&#x2F; 2022-05-04T00:00\n\tLocalDateTime parse &#x3D; LocalDateTime.parse(time, dateTimeFormatter);\n&#125;</code></pre>\n\n<h1 id=\"2-常用方法\"><a href=\"#2-常用方法\" class=\"headerlink\" title=\"2. 常用方法\"></a>2. 常用方法</h1><h2 id=\"2-1-isDigit\"><a href=\"#2-1-isDigit\" class=\"headerlink\" title=\"2.1 isDigit()\"></a>2.1 isDigit()</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static boolean isDigit(char ch)</code></pre>\n\n<p><strong>判断指定字符是否为数字</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String args[]) &#123;\n\tSystem.out.println(Character.isDigit(&#39;c&#39;)); &#x2F;&#x2F; false\n\tSystem.out.println(Character.isDigit(&#39;5&#39;)); &#x2F;&#x2F; true\n&#125;</code></pre>\n\n<h2 id=\"2-2-matches\"><a href=\"#2-2-matches\" class=\"headerlink\" title=\"2.2 matches()\"></a>2.2 matches()</h2><p>正则匹配</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        String str &#x3D; &quot;*眼*&quot;;\n        String replace &#x3D; str.replace(&quot;*&quot;, &quot;.*&quot;);\n        System.out.println(&quot;一双眼睛&quot;.matches(replace)); &#x2F;&#x2F; true\n        System.out.println(&quot;一双睛&quot;.matches(replace)); &#x2F;&#x2F; false\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230419135304.png\"></p>\n<h1 id=\"3-获取-List、Map、Set-对象的泛型类\"><a href=\"#3-获取-List、Map、Set-对象的泛型类\" class=\"headerlink\" title=\"3. 获取 List、Map、Set 对象的泛型类\"></a>3. 获取 List、Map、Set 对象的泛型类</h1><p>获取 List 对象的泛型类，直接获取是获取不到的，类型被虚拟机擦除了，但利用子类实现父类的泛型是可以的，借助这一原理，利用了匿名内部类来获取 List 对象的泛型类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 匿名内部类写法 &#123;&#125;\n        ArrayList&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;() &#123;&#125;;\n\n        getGenerics(list);\n    &#125;\n\n    private static void getGenerics(Object object) &#123;\n        Class&lt;?&gt; aClass &#x3D; object.getClass();\n        &#x2F;&#x2F; class fan.utils.Demo$1\n        System.out.println(&quot;aClass：&quot; + aClass);\n\n        Type type &#x3D; aClass.getGenericSuperclass();\n        &#x2F;&#x2F; java.util.ArrayList&lt;fan.utils.User&gt;\n        System.out.println(&quot;type：&quot; + type);\n\n        &#x2F;&#x2F; 可直接强转：Type[] actualTypeArguments &#x3D; ((ParameterizedType) type).getActualTypeArguments();\n\n        ParameterizedType parameterizedType &#x3D; (ParameterizedType) type;\n        &#x2F;&#x2F; java.util.ArrayList&lt;fan.utils.User&gt;\n        System.out.println(&quot;parameterizedType：&quot; + parameterizedType);\n        Type[] actualTypeArguments &#x3D; parameterizedType.getActualTypeArguments();\n\n        for (int i &#x3D; 0; i &lt; actualTypeArguments.length; i++) &#123;\n            &#x2F;&#x2F; actualTypeArguments0：class fan.utils.User\n            Type actualTypeArgument &#x3D; actualTypeArguments[i];\n            System.out.println(&quot;actualTypeArguments&quot; + i + &quot;：&quot; + actualTypeArgument);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230414144644.png\"></p>\n<p>获取 Map 的泛型 Key，Value</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    HashMap&lt;String, List&lt;User&gt;&gt; map &#x3D; new HashMap&lt;String, List&lt;User&gt;&gt;() &#123;&#125;;\n\n    getGenerics(map);\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230414144656.png\"></p>\n<h1 id=\"4-正则特殊字符批量转义\"><a href=\"#4-正则特殊字符批量转义\" class=\"headerlink\" title=\"4. 正则特殊字符批量转义\"></a>4. 正则特殊字符批量转义</h1><p>在正则中，<code>[, (, |...</code> 等字符存在特殊意义，作为字符使用时需要转义</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        String str &#x3D; &quot;*多动脉炎伴有肺受累[丘格-斯特劳斯&quot;;\n\n        String s &#x3D; str.replaceAll(&quot;(?&#x3D;[]\\\\[+&amp;|!()&#123;&#125;^\\&quot;~*?:\\\\\\\\-])&quot;, &quot;\\\\\\\\&quot;);\n        System.out.println(s);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"http://img.fan223.cn/2023/04/20230414144708.png\"></p>\n","feature":false,"text":"1. 时间时区转换1.1 UTC 转 LocalDateTime将 UTC 时间（格林威治实际标准时间）转换为北京时间（UTC-东八区时间）。即将带有 T、Z 的日期字符串类型转为 LocalDateTime 类型。LocalDateTime 是没有时区的 date 时间，如果想...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":5,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":12,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E6%97%B6%E9%97%B4%E6%97%B6%E5%8C%BA%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">1. 时间时区转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-UTC-%E8%BD%AC-LocalDateTime\"><span class=\"toc-text\">1.1 UTC 转 LocalDateTime</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-yyyy-MM-dd-%E7%AD%89%E8%BD%AC-LocalDateTime\"><span class=\"toc-text\">2.2 yyyy-MM-dd 等转 LocalDateTime</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2. 常用方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-isDigit\"><span class=\"toc-text\">2.1 isDigit()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-matches\"><span class=\"toc-text\">2.2 matches()</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E8%8E%B7%E5%8F%96-List%E3%80%81Map%E3%80%81Set-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">3. 获取 List、Map、Set 对象的泛型类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E6%AD%A3%E5%88%99%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%89%B9%E9%87%8F%E8%BD%AC%E4%B9%89\"><span class=\"toc-text\">4. 正则特殊字符批量转义</span></a></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"基础微服务项目架构构建总结","uid":"1777dd13afd91a7e9bd508c03cf35724","slug":"BlogRepository/开发实践/基础微服务项目架构构建总结","date":"2022-11-16T06:08:04.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/开发实践/基础微服务项目架构构建总结.json","keywords":null,"cover":"https://cover.png","text":"1. Maven 依赖版本管理1.1 Maven 依赖的优先级1、最短路径优先 工程中依赖了 B、C 两个 jar 包 在 B jar 包内引用了 C jar 包版本为 1.0 在工程内直接引用的 C jar 包版本为 2.0 Project -&gt; B -&gt; C(1....","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"开发实践","slug":"开发实践","count":6,"path":"api/categories/开发实践.json"}],"tags":[{"name":"IDEA","slug":"IDEA","count":8,"path":"api/tags/IDEA.json"},{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"Vue3 总结","uid":"253be1f39f8482a0ee0e446a428827b1","slug":"BlogRepository/Vue/Vue3 总结（基础）","date":"2022-11-06T15:57:57.000Z","updated":"2023-04-20T13:57:44.617Z","comments":true,"path":"api/articles/BlogRepository/Vue/Vue3 总结（基础）.json","keywords":null,"cover":"https://cover.png","text":"Vue2 基础见：Vue2 总结（基础）_凡 223 的博客 Vue2 开发见：Vue2 总结（开发）_凡 223 的博客 1. 简介 性能的提升 打包大小减少41% 初次渲染快55%，更新渲染快133% 内存减少54%…… 源码的升级 使用Proxy代替defineProper...","link":"","photos":[],"count_time":{"symbolsCount":"42k","symbolsTime":"38 mins."},"categories":[{"name":"Vue","slug":"Vue","count":4,"path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","slug":"Vue","count":5,"path":"api/tags/Vue.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}