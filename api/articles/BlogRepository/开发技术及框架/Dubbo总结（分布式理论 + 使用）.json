{"title":"Dubbo总结（分布式理论 + 使用）","uid":"4e9d049749f532005151e72d3b86b285","slug":"BlogRepository/开发技术及框架/Dubbo总结（分布式理论 + 使用）","date":"2022-03-08T16:24:40.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/Dubbo总结（分布式理论 + 使用）.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-分布式基础理论\"><a href=\"#1-分布式基础理论\" class=\"headerlink\" title=\"1. 分布式基础理论\"></a>1. 分布式基础理论</h1><h2 id=\"1-1-什么是分布式系统？\"><a href=\"#1-1-什么是分布式系统？\" class=\"headerlink\" title=\"1.1 什么是分布式系统？\"></a>1.1 什么是分布式系统？</h2><p>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。分布式系统（distributed system）是建立在网络之上的软件系统</p>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个<strong>治理系统</strong>确保架构有条不紊的演进</p>\n<h2 id=\"1-2-发展演变\"><a href=\"#1-2-发展演变\" class=\"headerlink\" title=\"1.2 发展演变\"></a>1.2 发展演变</h2><p><img src=\"https://img-blog.csdnimg.cn/0801a932ce3a4a28acfac4cda0fcefff.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"1-3-第一时期（单一应用架构）\"><a href=\"#1-3-第一时期（单一应用架构）\" class=\"headerlink\" title=\"1.3 第一时期（单一应用架构）\"></a>1.3 第一时期（单一应用架构）</h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<strong>此时，用于简化增删改查工作量的数据访问框架（ORM）是关键</strong><br><img src=\"https://img-blog.csdnimg.cn/7098f743ae61478daa850873db21a8e1.png\" alt=\"在这里插入图片描述\"><br><strong>问题：</strong></p>\n<ol>\n<li>代码不具备可维护性</li>\n<li>容错性差</li>\n<li>当用户访问或某些原因发生异常，用户会直接看到异常信息，有些情况下，该错误可能会导致服务宕机</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>故障容许度（Fault tolerance），也称容错，容错性，是指系统在部分组件（一个或多个）发生故障时仍能正常运作的能力</p></blockquote>\n<h3 id=\"1-3-1-第一时期后阶段\"><a href=\"#1-3-1-第一时期后阶段\" class=\"headerlink\" title=\"1.3.1 第一时期后阶段\"></a>1.3.1 第一时期后阶段</h3><p><strong>解决方案：</strong></p>\n<ol>\n<li>分层开发</li>\n<li>MVC 架构（基于Java WEB 应用的设计模式）</li>\n<li>服务器分离部署</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/d2a83c0f5d884c17ad0835c79cad73f8.png\" alt=\"在这里插入图片描述\"><br><strong>特点：</strong></p>\n<ol>\n<li>MVC 分层开发（提高了维护性，解决了容错性问题）</li>\n<li>数据库和项目分离部署</li>\n</ol>\n<p><strong>问题：</strong> 随着用户的访问量持续增加，单台应用服务器以及无法满足需求（高并发问题）<br><strong>解决方案：</strong> 集群（集群方案解决）</p>\n<h3 id=\"1-3-2-会出现的如下问题\"><a href=\"#1-3-2-会出现的如下问题\" class=\"headerlink\" title=\"1.3.2 会出现的如下问题\"></a>1.3.2 会出现的如下问题</h3><p>在互联网项目下，因单个 Tomcat 默认并发量有限制。如果请求量过大，会产生如下问题：</p>\n<h4 id=\"1-3-2-1-高并发-High-Concurrency\"><a href=\"#1-3-2-1-高并发-High-Concurrency\" class=\"headerlink\" title=\"1.3.2.1 高并发( High Concurrency )\"></a>1.3.2.1 高并发( High Concurrency )</h4><p>是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。高并发相关常用的一些指标有<strong>响应时间（Response TIme )、吞吐量 (Throughput )、每秒查询率QPS ( QueryPer Second ) 、并发用户数</strong>等</p>\n<ul>\n<li><strong>响应时间</strong>：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要 200ms，这个 200ms 就是系统的响应时间</li>\n<li><strong>吞吐量</strong>：单位时间内处理的请求数量</li>\n<li><strong>QPS</strong>：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显</li>\n<li><strong>开发用户数</strong>：同时承载正常使用系统功能的用户数量</li>\n</ul>\n<h4 id=\"1-3-2-2-高可用-High-Availability\"><a href=\"#1-3-2-2-高可用-High-Availability\" class=\"headerlink\" title=\"1.3.2.2 高可用(High Availability )\"></a>1.3.2.2 高可用(High Availability )</h4><p>通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性</p>\n<p>(一直都能用 99.9999%)   –&gt;  docker  –&gt;  k8s<br><a href=\"https://www.idcbest.com/idcnews/11002927.html\">https://www.idcbest.com/idcnews/11002927.html</a></p>\n<h4 id=\"1-3-2-3-高性能\"><a href=\"#1-3-2-3-高性能\" class=\"headerlink\" title=\"1.3.2.3 高性能\"></a>1.3.2.3 高性能</h4><p>是指服务响应时间快，（CPU &#x2F; 处理器&#x2F;内存）特别是在高并发下响应时间不会急剧增加</p>\n<h3 id=\"1-3-3-提高系统的并发能力\"><a href=\"#1-3-3-提高系统的并发能力\" class=\"headerlink\" title=\"1.3.3 提高系统的并发能力\"></a>1.3.3 提高系统的并发能力</h3><p>提高系统并发能力的方式，方法论上主要有两种︰<strong>垂直扩展(Scale Up )与水平扩展( Scale Out )</strong></p>\n<h4 id=\"1-3-3-1-垂直扩展（提升单机处理能力）\"><a href=\"#1-3-3-1-垂直扩展（提升单机处理能力）\" class=\"headerlink\" title=\"1.3.3.1 垂直扩展（提升单机处理能力）\"></a>1.3.3.1 垂直扩展（提升单机处理能力）</h4><p>垂直扩展的方式又有两种：</p>\n<ol>\n<li>增强单机硬件性能，例如∶增加 CPU 核数如 32 核，升级更好的网卡如万兆，升级更好的硬盘如 SSD，扩充硬盘容量如 2T，扩充系统内存如 128 G</li>\n<li>提升单机架构性能，例如∶使用 Cache 来减少 IO 次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间</li>\n</ol>\n<p>在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法</p>\n<p>总结∶不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足∶单机性能总是有极限的。<strong>所以互联网分布式架构设计高并发终极解决方案还是水平扩展</strong></p>\n<h4 id=\"1-3-3-2-水平扩展\"><a href=\"#1-3-3-2-水平扩展\" class=\"headerlink\" title=\"1.3.3.2 水平扩展\"></a>1.3.3.2 水平扩展</h4><p><strong>水平扩展︰只要增加服务器数量，就能线性扩充系统性能。</strong> 水平扩展对系统架构设计是有要求的，难点在于：如何在架构各层进行可水平扩展的设计</p>\n<h3 id=\"1-3-4-集群操作\"><a href=\"#1-3-4-集群操作\" class=\"headerlink\" title=\"1.3.4 集群操作\"></a>1.3.4 集群操作</h3><p>集群：同一个业务，部署在多个服务器上<br><img src=\"https://img-blog.csdnimg.cn/16870871685d4c5bb6097f02e0d5e4b6.png\" alt=\"在这里插入图片描述\"><br><strong>特点：</strong> 项目采用集群（多台服务器部署）<br><strong>解决：</strong> 支持高并发、支持高可用<br><strong>问题：</strong></p>\n<ol>\n<li>（集群）用户的请求该往哪里进行转发？</li>\n<li>Session 如何共享</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/553c38acfdf242c6b4d5a026a83fc388.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"1-3-5-数据库压力变大\"><a href=\"#1-3-5-数据库压力变大\" class=\"headerlink\" title=\"1.3.5 数据库压力变大\"></a>1.3.5 数据库压力变大</h3><p>通过 Nginx + Tomcat 集群方案，支持高并发（应用的性能进行提升访问），但是数据库的负载能力慢慢增加</p>\n<p><strong>问题： 怎么减少数据库层面的访问压力？</strong><br><strong>解决方案：读写分离</strong><br><img src=\"https://img-blog.csdnimg.cn/9b50d449e660426cadb0b8ab799c7fb0.png\" alt=\"在这里插入图片描述\"><br><strong>主从数据库之间进行数据同步，Master 主要负责增删改操作，Slave 负责读（查询）操作。</strong> MySQL 本身就支持 Master + Slave 的功能（主从复制）</p>\n<h3 id=\"1-3-6-使用搜索引擎缓解数据库的访问压力-能力\"><a href=\"#1-3-6-使用搜索引擎缓解数据库的访问压力-能力\" class=\"headerlink\" title=\"1.3.6 使用搜索引擎缓解数据库的访问压力 + 能力\"></a>1.3.6 使用搜索引擎缓解数据库的访问压力 + 能力</h3><p>数据库本身对大数据量查询效率慢，对模糊查询支持不是特别优秀，像电商类网站。搜索是非常核心的功能。(即使做了数据库读写分离），很多功能也不能有效解决（分词技术），针对于该问题，有必要引入全文检索服务器功能</p>\n<p><strong>目前市场上主流的搜索引擎技术：Solr、ElasticSearch</strong><br><img src=\"https://img-blog.csdnimg.cn/ac5ce1d89eee4f92b8b2fb561ee62c91.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"1-3-7-引入缓存机制减轻数据库的访问压力\"><a href=\"#1-3-7-引入缓存机制减轻数据库的访问压力\" class=\"headerlink\" title=\"1.3.7 引入缓存机制减轻数据库的访问压力\"></a>1.3.7 引入缓存机制减轻数据库的访问压力</h3><p>随着访问量的持续增加（数据库的访问压力持续增大，甚至都无法满足需求），虽然做了主从复制，对于热点数据，如果每次都从数据中查询，数据库无法应对，导致无法对外提供服务</p>\n<p><strong>最住解决方案:Redis</strong></p>\n<ol>\n<li>读写性能非常好</li>\n<li>提供了丰富的数据类型</li>\n<li>原子性</li>\n</ol>\n<h3 id=\"1-3-8-数据库的表进行水平-x2F-垂直拆分\"><a href=\"#1-3-8-数据库的表进行水平-x2F-垂直拆分\" class=\"headerlink\" title=\"1.3.8 数据库的表进行水平 &#x2F; 垂直拆分\"></a>1.3.8 数据库的表进行水平 &#x2F; 垂直拆分</h3><p>—张表里面有1千条数据，查询的性能很高。如果有100万数据，查询的性能很慢。单个表性能做提升。(能力终归还有限的)</p>\n<h4 id=\"1-3-8-1-垂直拆分表\"><a href=\"#1-3-8-1-垂直拆分表\" class=\"headerlink\" title=\"1.3.8.1 垂直拆分表\"></a>1.3.8.1 垂直拆分表</h4><p>假设一张表里面用户表（有30个字段）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>id、姓名、年龄、身份证号、身高、体重、性别、手机号、家庭住址、爱好……</p></blockquote>\n<p>热数据 &#x2F; 冷数据</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>user（id，姓名，身份证号，年龄，性别，手机号）<br>user_info（id，身高，体重）</p></blockquote>\n<h4 id=\"1-3-8-2-水平拆分表\"><a href=\"#1-3-8-2-水平拆分表\" class=\"headerlink\" title=\"1.3.8.2 水平拆分表\"></a>1.3.8.2 水平拆分表</h4><p>按需求进行拆分（省份、时间）</p>\n<h4 id=\"1-3-8-3-分库分表\"><a href=\"#1-3-8-3-分库分表\" class=\"headerlink\" title=\"1.3.8.3 分库分表\"></a>1.3.8.3 分库分表</h4><p><strong>垂直拆分数据库：按照业务将表进行分类，不同的表分布到不同的数据库上</strong><br><strong>水平拆分数据库：将一个表拆分到不同的数据库上</strong><br>采用第三方数据库中间件：Mycat、Sharding-JDBC、DRDS<br><img src=\"https://img-blog.csdnimg.cn/964caf294f0c414a82d76e91365e8631.png\" alt=\"在这里插入图片描述\"><br>通过设计保证高并发、高可用。（不断对服务器进行扩容）<br><img src=\"https://img-blog.csdnimg.cn/3e11b7183d9c43069d0bfe9bd0c285e6.png\" alt=\"在这里插入图片描述\"><br><strong>问题：</strong></p>\n<ol>\n<li>服务器价钱（忙闲不均匀问题、服务器的维护、人工成本、大量运维工程师）</li>\n<li>可维护性差</li>\n<li>可扩展性差（服务器）</li>\n<li>协同开发不方便（大家都去修改相同业务代码，易发生代码冲突 &#x2F; 错误问题）</li>\n<li>单体架构（随着业务需求的不断增加，应用代码会变得越来越多）导致服务器部署时占用的硬盘也大</li>\n</ol>\n<h2 id=\"1-4-第二时期（垂直应用架构）\"><a href=\"#1-4-第二时期（垂直应用架构）\" class=\"headerlink\" title=\"1.4 第二时期（垂直应用架构）\"></a>1.4 第二时期（垂直应用架构）</h2><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<strong>此时，用于加速前端页面开发的 Web 框架（MVC）是关键</strong><br><img src=\"https://img-blog.csdnimg.cn/ecab4e098f1a4ebcab9393be57325f45.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"1-4-1-水平拆分（横着拆）\"><a href=\"#1-4-1-水平拆分（横着拆）\" class=\"headerlink\" title=\"1.4.1 水平拆分（横着拆）\"></a>1.4.1 水平拆分（横着拆）</h3><p>将一个大的应用拆分成多个小应用。project（controller、service、mapper、pojo……）</p>\n<p><strong>问题1：</strong> 现在网站分为前台(给用户使用），后台（给管理员使用），是否需要拆成2个项目独立部署?如果需要拆的话，有一些前后台都需要公用的代码，这些代码怎么办?</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>parent  pom   ———— 父工程（放所有的 pom.xml）</li>\n<li>common.jar ———— 公共库 相关工具类</li>\n<li>pojo.jar —————— Java Bean</li>\n<li>mapper.jar ————– 数据持久层</li>\n<li>service.jar ————— 业务逻辑层</li>\n<li>web.war —————— web 访问层</li>\n<li>manager.war ———— 后台管理</li>\n</ol></blockquote>\n<p><strong>解决问题：</strong></p>\n<ol>\n<li>模块复用</li>\n<li>减少了服务器内容部署</li>\n</ol>\n<h3 id=\"1-4-2-垂直拆分（竖着拆）\"><a href=\"#1-4-2-垂直拆分（竖着拆）\" class=\"headerlink\" title=\"1.4.2 垂直拆分（竖着拆）\"></a>1.4.2 垂直拆分（竖着拆）</h3><p><strong>按功能拆分</strong><br>将一个大的应用按功能拆分成多个互不相干的小应用。每个应用都是独立的 WEB 应用程序<br><img src=\"https://img-blog.csdnimg.cn/e79e2c5e4bb94100bf41033a035c6328.png\" alt=\"在这里插入图片描述\"><br><strong>解决问题：</strong></p>\n<ol>\n<li>维护性（如果发生需求变更，只需要调整某个应用模块即可）</li>\n<li>功能扩展（随着业务的不断增加，只需要创建新的WEB程序即可）</li>\n<li>协同开发方便(不同的团队修改不同的代码）</li>\n<li>部署内容大小（性能扩展），如果哪台访问量大，只需要对该服务多部署几台即可</li>\n</ol>\n<p><strong>问题：</strong></p>\n<ol>\n<li><strong>客户对页面的要求会越来越高，（修改频繁）需要重新部署后台应用程序(每一个应用从头到尾都完整的)</strong></li>\n<li><strong>随着业务需求不断增加，需要很多个互不相干应用部署，这些应用之间一定会需要业务交互</strong></li>\n</ol>\n<h2 id=\"1-5-第三时期（分布式服务架构）\"><a href=\"#1-5-第三时期（分布式服务架构）\" class=\"headerlink\" title=\"1.5 第三时期（分布式服务架构）\"></a>1.5 第三时期（分布式服务架构）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<strong>此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。</strong></p></blockquote>\n<p><strong>分布式：将一个业务拆分成多个子业务，部署在不用的服务器上</strong></p>\n<p><strong>问题：</strong></p>\n<ol>\n<li><strong>客户对页面的要求会越来越高，（修改频繁）需要重新部署后台应用程序(每一个应用从头到尾都完整的)</strong><br>答：页面 + 业务代码（前后端分离开发  &#x2F; 部署）</li>\n<li><strong>随着业务需求不断增加，需要很多个互不相干应用部署，这些应用之间一定会需要业务交互</strong><br><img src=\"https://img-blog.csdnimg.cn/1ff56a780db54fc987f9bf9efe330000.png\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<p><strong>分析：</strong><br>以前如果都在一台服务器上（模块之间通过依赖jar完成调用）。现在都是在不同的服务器上做的部署（分布式）。服务和服务之间通过进程间调用。</p>\n<p><strong>解决方案：</strong> RPC &#x2F; HTTP &#x2F; HttpClient</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>RPC ( Remote Procedure call ) -远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p></blockquote>\n<p><strong>架构的改变—定会带来—些新的技术和新的问题</strong><br><strong>问题：</strong></p>\n<ol>\n<li>分布式事务：两（二）阶段提交</li>\n<li>分布式锁：Redis SetNX（Zookeeper）</li>\n<li>分布式 Session：Redis Spring Session</li>\n<li>分布式日志：ELK</li>\n</ol>\n<p><strong>问题：</strong></p>\n<ol>\n<li><p><strong>当服务越来越多，服务和服务之间的调用非常的混乱（不知道你有哪些服务）</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现</p></blockquote>\n</li>\n<li><p><strong>例如∶支付管理访问量小，部署了100台服务器。物流管理访问量大，部署了50台服务器</strong></p>\n</li>\n</ol>\n<h2 id=\"1-8-第四时期（流动计算架构）\"><a href=\"#1-8-第四时期（流动计算架构）\" class=\"headerlink\" title=\"1.8 第四时期（流动计算架构）\"></a>1.8 第四时期（流动计算架构）</h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群量，提高集群利用率。<strong>此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键</strong></p>\n<p><strong>SOA（面向服务的架构）–&gt; 微服务架构</strong><br>单体应用拆分成多个互不相干的小应用，每一个小的应用称为微服务</p>\n<p><strong>分布式服务治理（解决方案）中间件：Dubbo（底层是 RPC 协议） &#x2F; SpringCloud（底层是 HTTP 协议）</strong><br>基于访问压力实时管理集群容量，提高集群利用率</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SOA ( Service oriented Architecture ) “面向服务的架构”：他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用。<strong>微服务架构 &#x3D; 80%的 SOA 服务架构思想＋100% 的组件化架构思想＋80% 的领域建模思想</strong></p>\n<p>以一个公司为例:有基层员工，有管理层，有老板。<br>最初大家都听老板指挥，谁干什么谁干什么，根据需要，你可能今天干A事情，明天干B事情，后来人越来越多了，事情也越来越多了，做事情的效率越来越多，管理也很混乱，<br>就开始做部门划分（服务化），专门部门做专门事情的，IT部门只做研发，人事部门只做招聘﹔这个时候就无法避免的发生跨部门协作（服务器调用），但是你怎么知道有这样一个部门可以做这个事情呢，就要依赖行政部门（注册中心），新成立的部门要在行政哪里做一个备案（服务注册），然后公布一下，让其他部门知道了（服务发布），大家就可以在新的工作秩序里面上班，这个时候依然是在公司的组织架构中运转</p></blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/fe807bb6f5a141bc9fe2c341b32f8282.png\" alt=\"在这里插入图片描述\"><br><strong>优点：</strong></p>\n<ol>\n<li>微服务对服务的拆分变的更细（复用性强），提高开发效率</li>\n<li>可根据需求使用最新的技术（选择新的技术）</li>\n<li>适用于互联网项目（迭代周期短。开发效率快)</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>微服务过多，服务的管理（治理）成本高。</li>\n<li>不利于服务的部署( Docker –&gt; K8S)</li>\n<li>技术难点在增加（分布式事务、锁、Session、日志）</li>\n<li>对程序员的技术要求也高（Dubbo &#x2F; SpringCloud）</li>\n</ol>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><h2 id=\"2-1-服务提供者\"><a href=\"#2-1-服务提供者\" class=\"headerlink\" title=\"2.1 服务提供者\"></a>2.1 服务提供者</h2><h3 id=\"2-1-1-POM\"><a href=\"#2-1-1-POM\" class=\"headerlink\" title=\"2.1.1 POM\"></a>2.1.1 POM</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- Dubbo 依赖--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- Dubbo 注解进 Nacos 的依赖--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;dubbo-registry-nacos&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"2-1-2-YML\"><a href=\"#2-1-2-YML\" class=\"headerlink\" title=\"2.1.2 YML\"></a>2.1.2 YML</h3><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">&#x2F;&#x2F; zookeeper\ndubbo:\n  application:\n    name: user-service-provider\n  registry:\n    address: zookeeper:&#x2F;&#x2F;127.0.0.1:2181\n  protocol:\n    name: dubbo\n    port: 20880\n\n&#x2F;&#x2F; nacos\ndubbo:\n  registry:\n    address: nacos:&#x2F;&#x2F;127.0.0.1:8848\n  protocol:\n    name: dubbo\n    port: 20880\n#  application:\n#    name: user-service-provider\nspring:\n  application:\n    name: user-service-provider # 也可以在 dubbo 里定义 application.name</code></pre>\n\n<h3 id=\"2-1-3-实现类\"><a href=\"#2-1-3-实现类\" class=\"headerlink\" title=\"2.1.3 实现类\"></a>2.1.3 实现类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import org.apache.dubbo.config.annotation.DubboService;\n\n@DubboService\npublic class UserServiceImpl implements UserService &#123;\n    @Override\n    public User getUser() &#123;\n        User user &#x3D; new User(1, &quot;七七&quot;);\n        return user;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"2-1-4-启动类\"><a href=\"#2-1-4-启动类\" class=\"headerlink\" title=\"2.1.4 启动类\"></a>2.1.4 启动类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;\n\n@SpringBootApplication\n@EnableDubbo\npublic class UserServiceProviderApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(UserServiceProviderApplication.class, args);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"2-2-服务消费者\"><a href=\"#2-2-服务消费者\" class=\"headerlink\" title=\"2.2 服务消费者\"></a>2.2 服务消费者</h2><h3 id=\"2-2-1-POM\"><a href=\"#2-2-1-POM\" class=\"headerlink\" title=\"2.2.1 POM\"></a>2.2.1 POM</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- Dubbo 依赖 --&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"2-2-2-YML\"><a href=\"#2-2-2-YML\" class=\"headerlink\" title=\"2.2.2 YML\"></a>2.2.2 YML</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">spring:\n  application:\n    name: user-service-consumer</code></pre>\n\n<h3 id=\"2-2-3-调用\"><a href=\"#2-2-3-调用\" class=\"headerlink\" title=\"2.2.3 调用\"></a>2.2.3 调用</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过 @DubboReference 注入，url 为服务提供者的地址和端口\n@Service\npublic class MeetingServiceImpl implements MeetingService &#123;\n\n    @DubboReference(url &#x3D; &quot;dubbo:&#x2F;&#x2F;127.0.0.1:20880&quot;)\n    private UserService userService;\n\n    @Override\n    public Meeting getMeeting() &#123;\n        User user &#x3D; userService.getUser(); &#x2F;&#x2F; 调用方法\n        Meeting meeting &#x3D; new Meeting(11, &quot;会议&quot;,&quot;Dubbo&quot;,user);\n        return meeting;\n    &#125;\n&#125;</code></pre>\n","feature":false,"text":"1. 分布式基础理论1.1 什么是分布式系统？分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。分布式系统（distributed system）是建立在网络之上的软件系统 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":8,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"Dubbo","slug":"Dubbo","count":1,"path":"api/tags/Dubbo.json"},{"name":"架构","slug":"架构","count":1,"path":"api/tags/架构.json"},{"name":"分布式","slug":"分布式","count":1,"path":"api/tags/分布式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">1. 分布式基础理论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9F\"><span class=\"toc-text\">1.1 什么是分布式系统？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98\"><span class=\"toc-text\">1.2 发展演变</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E7%AC%AC%E4%B8%80%E6%97%B6%E6%9C%9F%EF%BC%88%E5%8D%95%E4%B8%80%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%EF%BC%89\"><span class=\"toc-text\">1.3 第一时期（单一应用架构）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-1-%E7%AC%AC%E4%B8%80%E6%97%B6%E6%9C%9F%E5%90%8E%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">1.3.1 第一时期后阶段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-2-%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E5%A6%82%E4%B8%8B%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.3.2 会出现的如下问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-1-%E9%AB%98%E5%B9%B6%E5%8F%91-High-Concurrency\"><span class=\"toc-text\">1.3.2.1 高并发( High Concurrency )</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-2-%E9%AB%98%E5%8F%AF%E7%94%A8-High-Availability\"><span class=\"toc-text\">1.3.2.2 高可用(High Availability )</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-3-%E9%AB%98%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">1.3.2.3 高性能</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-3-%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">1.3.3 提高系统的并发能力</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-3-1-%E5%9E%82%E7%9B%B4%E6%89%A9%E5%B1%95%EF%BC%88%E6%8F%90%E5%8D%87%E5%8D%95%E6%9C%BA%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%EF%BC%89\"><span class=\"toc-text\">1.3.3.1 垂直扩展（提升单机处理能力）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-3-2-%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">1.3.3.2 水平扩展</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-4-%E9%9B%86%E7%BE%A4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.3.4 集群操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E5%8A%9B%E5%8F%98%E5%A4%A7\"><span class=\"toc-text\">1.3.5 数据库压力变大</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-6-%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BC%93%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8E%8B%E5%8A%9B-%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">1.3.6 使用搜索引擎缓解数据库的访问压力 + 能力</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-7-%E5%BC%95%E5%85%A5%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%87%8F%E8%BD%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8E%8B%E5%8A%9B\"><span class=\"toc-text\">1.3.7 引入缓存机制减轻数据库的访问压力</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%B0%B4%E5%B9%B3-x2F-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86\"><span class=\"toc-text\">1.3.8 数据库的表进行水平 &#x2F; 垂直拆分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-8-1-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%E8%A1%A8\"><span class=\"toc-text\">1.3.8.1 垂直拆分表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-8-2-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E8%A1%A8\"><span class=\"toc-text\">1.3.8.2 水平拆分表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-8-3-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8\"><span class=\"toc-text\">1.3.8.3 分库分表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E7%AC%AC%E4%BA%8C%E6%97%B6%E6%9C%9F%EF%BC%88%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%EF%BC%89\"><span class=\"toc-text\">1.4 第二时期（垂直应用架构）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-1-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%EF%BC%88%E6%A8%AA%E7%9D%80%E6%8B%86%EF%BC%89\"><span class=\"toc-text\">1.4.1 水平拆分（横着拆）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-2-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%EF%BC%88%E7%AB%96%E7%9D%80%E6%8B%86%EF%BC%89\"><span class=\"toc-text\">1.4.2 垂直拆分（竖着拆）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E7%AC%AC%E4%B8%89%E6%97%B6%E6%9C%9F%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%89\"><span class=\"toc-text\">1.5 第三时期（分布式服务架构）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-%E7%AC%AC%E5%9B%9B%E6%97%B6%E6%9C%9F%EF%BC%88%E6%B5%81%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%EF%BC%89\"><span class=\"toc-text\">1.8 第四时期（流动计算架构）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2. 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85\"><span class=\"toc-text\">2.1 服务提供者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-1-POM\"><span class=\"toc-text\">2.1.1 POM</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-2-YML\"><span class=\"toc-text\">2.1.2 YML</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-3-%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">2.1.3 实现类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-4-%E5%90%AF%E5%8A%A8%E7%B1%BB\"><span class=\"toc-text\">2.1.4 启动类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">2.2 服务消费者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-POM\"><span class=\"toc-text\">2.2.1 POM</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-YML\"><span class=\"toc-text\">2.2.2 YML</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-3-%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.2.3 调用</span></a></li></ol></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"OSI七层模型、TCP/IP四层和五层模型的各层作用及对应协议","uid":"6ce853e2be25e958aefcb6cbbd6efe7a","slug":"BlogRepository/计算机网络/OSI七层模型、TCP_IP四层和五层模型的各层作用及对应协议","date":"2022-03-10T11:46:56.000Z","updated":"2023-03-13T19:13:04.964Z","comments":true,"path":"api/articles/BlogRepository/计算机网络/OSI七层模型、TCP_IP四层和五层模型的各层作用及对应协议.json","keywords":null,"cover":"https://cover.png","text":"1. 各模型分层对应关系及协议 2. 各层作用2.1 物理层主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/categories/计算机网络.json"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","count":1,"path":"api/tags/TCP-IP.json"},{"name":"网络协议","slug":"网络协议","count":1,"path":"api/tags/网络协议.json"},{"name":"网络","slug":"网络","count":1,"path":"api/tags/网络.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"RedisTemplate常用方法总结（参考官方文档2.6.2）","uid":"7478131d527adbde00e55d0f806e6ef1","slug":"BlogRepository/Redis/RedisTemplate常用方法总结（参考官方文档2.6.2）","date":"2022-02-26T19:40:27.000Z","updated":"2023-03-13T19:13:04.933Z","comments":true,"path":"api/articles/BlogRepository/Redis/RedisTemplate常用方法总结（参考官方文档2.6.2）.json","keywords":null,"cover":"https://cover.png","text":"1. 简介RedisTemplate 是 Spring Data Redis 提供给用户的最高级的抽象客户端，用户可直接通过 RedisTemplate进行多种操作 1.1 类继承关系public class RedisTemplate&lt;K, V&gt; extends R...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Redis","slug":"Redis","count":3,"path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","slug":"Redis","count":5,"path":"api/tags/Redis.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}