{"title":"RestTemplate 以及 WebClient 调用第三方接口使用总结","uid":"b0fd76224154907cc8cb1e96045dc809","slug":"BlogRepository/开发技术及框架/RestTemplate 以及 WebClient 调用第三方接口使用总结","date":"2023-01-31T08:51:29.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/RestTemplate 以及 WebClient 调用第三方接口使用总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-RestTemplate\"><a href=\"#1-RestTemplate\" class=\"headerlink\" title=\"1. RestTemplate\"></a>1. RestTemplate</h1><h2 id=\"1-1-引入依赖\"><a href=\"#1-1-引入依赖\" class=\"headerlink\" title=\"1.1 引入依赖\"></a>1.1 引入依赖</h2><p>RestTemplate 在 spring-boot-starter-web 包下</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h2 id=\"1-2-配置类\"><a href=\"#1-2-配置类\" class=\"headerlink\" title=\"1.2 配置类\"></a>1.2 配置类</h2><p>注入 RestTemplate，并进行连接时间等配置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class RestTemplateConfig &#123;\n\n    @Bean\n    public RestTemplate restTemplate(ClientHttpRequestFactory factory) &#123;\n        return new RestTemplate(factory);\n    &#125;\n\n    @Bean\n    public ClientHttpRequestFactory simpleClientHttpRequestFactory() &#123;\n        SimpleClientHttpRequestFactory factory &#x3D; new SimpleClientHttpRequestFactory();\n        factory.setConnectTimeout(15000);\n        factory.setReadTimeout(5000);\n\n        return factory;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"1-3-工具类\"><a href=\"#1-3-工具类\" class=\"headerlink\" title=\"1.3 工具类\"></a>1.3 工具类</h2><p>RestTemplate 使用起来很简单，这里将 GET 方法和 POST 方法封装成了工具类，DELETE 和 PUT 方法使用方法相同，具体如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class RestTemplateUtil &#123;\n\n    private static RestTemplate restTemplate;\n\n    @Resource\n    private void setRestTemplate(RestTemplate restTemplate) &#123;\n        RestTemplateUtil.staticSetRestTemplate(restTemplate);\n    &#125;\n\n    &#x2F;**\n     * 静态注入方法, 解决多线程下可能出现的并发问题\n     *\n     * @param restTemplate RestTemplate\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:24\n     *&#x2F;\n    private static synchronized void staticSetRestTemplate(RestTemplate restTemplate) &#123;\n        RestTemplateUtil.restTemplate &#x3D; restTemplate;\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForEntity, 默认返回类型 String\n     *\n     * @param url 请求地址\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:18\n     *&#x2F;\n    public static String doGetWithEntity(String url) &#123;\n        ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.getForEntity(url, String.class);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForEntity, 指定返回类型\n     *\n     * @param url   请求地址\n     * @param clazz 返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:08\n     *&#x2F;\n    public static &lt;T&gt; T doGetWithEntity(String url, Class&lt;T&gt; clazz) &#123;\n        ResponseEntity&lt;T&gt; responseEntity &#x3D; restTemplate.getForEntity(url, clazz);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForObject, 返回值返回的是响应体, 省了再去 getBody(), 默认返回类型 String\n     *\n     * @param url 请求地址\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:19\n     *&#x2F;\n    public static String doGetWithObject(String url) &#123;\n        return restTemplate.getForObject(url, String.class);\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForObject, 返回值返回的是响应体, 省了再去 getBody(), 指定返回类型\n     *\n     * @param url   请求地址\n     * @param clazz 返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:16\n     *&#x2F;\n    public static &lt;T&gt; T doGetWithObject(String url, Class&lt;T&gt; clazz) &#123;\n        return restTemplate.getForObject(url, clazz);\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForEntity, 默认返回类型 String\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:28\n     *&#x2F;\n    public static String doPostWithEntity(String url, Object object) &#123;\n        ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.postForEntity(url, object, String.class);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForEntity, 指定返回类型\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @param clazz  返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:18\n     *&#x2F;\n    public static &lt;T&gt; T doPostWithEntity(String url, Object object, Class&lt;T&gt; clazz) &#123;\n        ResponseEntity&lt;T&gt; responseEntity &#x3D; restTemplate.postForEntity(url, object, clazz);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForObject, 返回值返回的是响应体, 省了再去 getBody(), 默认返回类型 String\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:29\n     *&#x2F;\n    public static String doPostWithObject(String url, Object object) &#123;\n        return restTemplate.postForObject(url, object, String.class);\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForObject, 返回值返回的是响应体, 省了再去 getBody(), 指定返回类型\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @param clazz  返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:19\n     *&#x2F;\n    public static &lt;T&gt; T doPostWithObject(String url, Object object, Class&lt;T&gt; clazz) &#123;\n        return restTemplate.postForObject(url, object, clazz);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"1-4-使用\"><a href=\"#1-4-使用\" class=\"headerlink\" title=\"1.4 使用\"></a>1.4 使用</h2><p>测试 Controller</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\npublic class RestTemplateTestController &#123;\n\n    @GetMapping(&quot;&#x2F;test&quot;)\n    public String test() &#123;\n        return RestTemplateUtil.doGetWithEntity(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>启动项目，这里更改了端口为 8888，访问 <code>http://localhost:8080/test</code></p>\n<p><img src=\"https://img-blog.csdnimg.cn/8713c8b815b44a4c878da2519a200a4b.png\" alt=\"在这里插入图片描述\"></p>\n<p>这里调用的是一言 API，调用成功</p>\n<h1 id=\"2-WebClient\"><a href=\"#2-WebClient\" class=\"headerlink\" title=\"2. WebClient\"></a>2. WebClient</h1><p>Spring3.0 引入了 RestTemplate，但是在后来的官方源码中介绍，RestTemplate 有可能在未来的版本中被弃用。替代 RestTemplate，在 Spring5 中引入了 WebClient 作为非阻塞式 Reactive Http 客户端</p>\n<h2 id=\"2-1-引入依赖\"><a href=\"#2-1-引入依赖\" class=\"headerlink\" title=\"2.1 引入依赖\"></a>2.1 引入依赖</h2><p>WebClient 在 spring-boot-starter-webflux 包中</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-webflux&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h2 id=\"2-2-使用\"><a href=\"#2-2-使用\" class=\"headerlink\" title=\"2.2 使用\"></a>2.2 使用</h2><p>WebClient 不需要注入，直接使用即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\npublic class WebClientSample &#123;\n\n    &#x2F;**\n     * WebClient.create() 方法\n     *\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:01\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;create&quot;)\n    public String create() &#123;\n        &#x2F;&#x2F; 一个 Mono 对象包含 0 个或 1 个元素\n        Mono&lt;String&gt; stringMono &#x3D; WebClient\n                &#x2F;&#x2F; 创建 WebClient 实例\n                .create()\n                &#x2F;&#x2F; 方法调用, 请求类型\n                .method(HttpMethod.GET)\n                &#x2F;&#x2F; 请求 uri\n                .uri(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                &#x2F;&#x2F; 获取响应结果\n                .retrieve()\n                &#x2F;&#x2F; 将结果转换为指定类型\n                .bodyToMono(String.class);\n\n        &#x2F;&#x2F; 返回最终调用结果，block 方法是阻塞的\n        return stringMono.block();\n    &#125;\n\n    &#x2F;**\n     * WebClient.create(String baseUrl): 指定 baseUrl, 使用该客户端发送请求都是基于 baseUrl\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 16:25\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;createWithBaseUrl&quot;)\n    public void createWithBaseUrl() &#123;\n        &#x2F;&#x2F; 一个 Flux 对象包含 1 个或多个元素\n        Flux&lt;String&gt; stringFlux &#x3D; WebClient.create(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                .get()\n                &#x2F;&#x2F; .uri(&quot;&quot;)\n                .retrieve()\n                .bodyToFlux(String.class);\n\n        &#x2F;&#x2F; 非阻塞式获取响应结果\n        stringFlux.subscribe(this::handleResponse);\n    &#125;\n\n    &#x2F;**\n     * 异步响应回调\n     *\n     * @param response 响应\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:25\n     *&#x2F;\n    private void handleResponse(String response) &#123;\n        LogUtil.info(response);\n    &#125;\n\n    &#x2F;**\n     * WebClient.builder(): 返回一个 WebClient.Builder, 该对象可以做链式调用, 传递更多的参数 &lt;br&#x2F;&gt;\n     * &lt;ul&gt;\n     *     &lt;li&gt;uriBuilderFactory: 自定义 UriBuilderFactory 灵活配置使用 Uri&lt;&#x2F;li&gt;\n     *     &lt;li&gt;defaultHeader: 为 HTTP 请求设置 Headers 请求头&lt;&#x2F;li&gt;\n     *     &lt;li&gt;defaultCookie: 为 HTTP 请求设置 Cookies&lt;&#x2F;li&gt;\n     *     &lt;li&gt;defaultRequest: 自定义 HttpRequest&lt;&#x2F;li&gt;\n     *     &lt;li&gt;filter: 为 HTTP 请求增加客户端过滤器&lt;&#x2F;li&gt;\n     *     &lt;li&gt;exchangeStrategies: HTTP 读写信息自定义&lt;&#x2F;li&gt;\n     *     &lt;li&gt;clientConnector: HTTP 客户端连接器设置&lt;&#x2F;li&gt;\n     * &lt;&#x2F;ul&gt;\n     *\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:02\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;build&quot;)\n    public String build() &#123;\n        return WebClient.builder()\n                .baseUrl(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                .defaultHeader(&quot;build&quot;, &quot;build&quot;)\n                .build()\n                .get()\n                &#x2F;&#x2F; .uri(&quot;&quot;)\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n\n    &#x2F;**\n     * exchange() 方法获取 HTTP 响应完整内容\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:40\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;exchange&quot;)\n    public String exchange() &#123;\n        return WebClient.create()\n                .get()\n                .uri(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                .exchangeToMono(clientResponse -&gt; &#123;\n                    &#x2F;&#x2F; 响应头\n                    ClientResponse.Headers headers &#x3D; clientResponse.headers();\n                    &#x2F;&#x2F; 响应状态\n                    HttpStatus httpStatus &#x3D; clientResponse.statusCode();\n                    &#x2F;&#x2F; 响应状态码\n                    int rawStatusCode &#x3D; clientResponse.rawStatusCode();\n                    &#x2F;&#x2F; 响应体\n                    return clientResponse.bodyToMono(String.class);\n                &#125;).block();\n    &#125;\n\n    &#x2F;**\n     * 数字占位符传参\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:50\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;numParam&quot;)\n    public String numParam() &#123;\n        return WebClient.create()\n                .method(HttpMethod.POST)\n                .uri(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;&#123;1&#125;&#x2F;&#123;2&#125;&quot;, ListUtil.list(false, 1, 2).toArray())\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n\n    &#x2F;**\n     * 参数名传参\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:53\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;nameParam&quot;)\n    public String nameParam() &#123;\n        return WebClient.create()\n                .method(HttpMethod.POST)\n                .uri(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;, &quot;id&quot;, &quot;name&quot;)\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n\n    &#x2F;**\n     * Map 传参\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:54\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;mapParam&quot;)\n    public String mapParam() &#123;\n        return WebClient.create()\n                .method(HttpMethod.POST)\n                .uri(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,\n                        MapUtil.ofEntries(false, MapUtil.entry(&quot;id&quot;, &quot;id&quot;), MapUtil.entry(&quot;name&quot;, &quot;name&quot;)))\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n&#125;</code></pre>\n\n<p>启动项目，这里更改了端口为 8888，访问 <code>http://localhost:8888/build</code></p>\n<p><img src=\"https://img-blog.csdnimg.cn/cd3f73403b5a4f49b4a39115b28ac365.png\" alt=\"在这里插入图片描述\"></p>\n","feature":false,"text":"1. RestTemplate1.1 引入依赖RestTemplate 在 spring-boot-starter-web 包下 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":8,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"开发技术及框架","slug":"开发技术及框架","count":1,"path":"api/tags/开发技术及框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-RestTemplate\"><span class=\"toc-text\">1. RestTemplate</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">1.1 引入依赖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E9%85%8D%E7%BD%AE%E7%B1%BB\"><span class=\"toc-text\">1.2 配置类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">1.3 工具类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.4 使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-WebClient\"><span class=\"toc-text\">2. WebClient</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">2.1 引入依赖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.2 使用</span></a></li></ol></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"Markdown 数学公式使用总结","uid":"0b3c1bd1993c2f547919285ec8bd717d","slug":"BlogRepository/其他实践/Markdown 数学公式使用总结","date":"2023-02-15T02:08:12.000Z","updated":"2023-03-13T19:13:04.948Z","comments":true,"path":"api/articles/BlogRepository/其他实践/Markdown 数学公式使用总结.json","keywords":null,"cover":"https://cover.png","text":"1. 语法1、行内公式 用 $...$ 表示行内公式，如 O_&#123;1 - \\left(\\vert a \\vert \\over 2 \\right)&#125;：$O_{1 - \\left(\\vert a \\vert \\over 2 \\right)}$ 2、多行公式 用 $$...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[{"name":"其他实践","slug":"其他实践","count":4,"path":"api/categories/其他实践.json"}],"tags":[{"name":"markdown","slug":"markdown","count":1,"path":"api/tags/markdown.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"Yarn 下载安装及常用配置和命令总结","uid":"db6eec5ece30b9e502959c9b69bfe8c5","slug":"BlogRepository/开发工具及环境/Yarn 下载安装及常用配置和命令总结","date":"2023-01-13T06:47:32.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发工具及环境/Yarn 下载安装及常用配置和命令总结.json","keywords":null,"cover":"https://cover.png","text":"1. Node.js建议先安装好 Node.js，见另一篇：Node.js 多版本安装及 NPM 镜像配置_凡 223 的博客 2. 下载安装由于 Node.js 自带了一个包管理器 NPM，所以安装 Yarn 更简单的方法是直接使用 npm install --location...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"开发工具及环境","slug":"开发工具及环境","count":11,"path":"api/categories/开发工具及环境.json"}],"tags":[{"name":"开发工具及环境","slug":"开发工具及环境","count":1,"path":"api/tags/开发工具及环境.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}