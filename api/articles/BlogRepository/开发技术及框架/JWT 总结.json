{"title":"JWT 总结","uid":"8c40486acfd1c17dcd4c39c1d08317e3","slug":"BlogRepository/开发技术及框架/JWT 总结","date":"2022-03-17T03:48:47.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/JWT 总结.json","keywords":null,"cover":"https://cover.png","content":"<h1 id=\"1-跨域身份验证\"><a href=\"#1-跨域身份验证\" class=\"headerlink\" title=\"1. 跨域身份验证\"></a>1. 跨域身份验证</h1><h2 id=\"1-1-传统的-session-流程\"><a href=\"#1-1-传统的-session-流程\" class=\"headerlink\" title=\"1.1 传统的 session 流程\"></a>1.1 传统的 session 流程</h2><ol>\n<li>浏览器发起请求登陆，向服务器发送用户名和密码</li>\n<li>服务端验证身份，生成身份验证信息（用户角色、登录时间等），存储在服务端 的 session 中</li>\n<li>服务器向用户返回 session_id，session 信息都会写入到用户的 Cookie</li>\n<li>用户的每个后续请求都将通过在 Cookie 中取出 session_id 传给服务器</li>\n<li>服务器收到 session_id 并对比之前保存的数据，确认用户的身份</li>\n<li>服务器返回用户请求的内容</li>\n</ol>\n<h2 id=\"1-2-JWT-流程\"><a href=\"#1-2-JWT-流程\" class=\"headerlink\" title=\"1.2 JWT 流程\"></a>1.2 JWT 流程</h2><ol>\n<li>浏览器发起请求登陆</li>\n<li>服务端验证身份，根据算法，将用户标识符打包生成 JWT, 并且返回给浏览器</li>\n<li>浏览器发起请求获取用户资料，把刚刚拿到的 JWT 一起发送给服务器</li>\n<li>服务器发现数据中有 JWT，进行验证</li>\n<li>服务器返回用户请求的内容</li>\n</ol>\n<h2 id=\"1-3-session-与-JWT-区别\"><a href=\"#1-3-session-与-JWT-区别\" class=\"headerlink\" title=\"1.3 session 与 JWT 区别\"></a>1.3 session 与 JWT 区别</h2><ol>\n<li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li>\n<li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险，而 JWT 则通过参数传递</li>\n<li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li>\n<li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li>\n</ol>\n<h2 id=\"1-4-JWT-工作原理\"><a href=\"#1-4-JWT-工作原理\" class=\"headerlink\" title=\"1.4 JWT 工作原理\"></a>1.4 JWT 工作原理</h2><p><img src=\"https://img-blog.csdnimg.cn/cbf148d7ee594c6ab2a4f888c456a417.png\" alt=\"在这里插入图片描述\"><br>在服务器身份验证之后，将生成一个 JSON 对象并将其发送回用户。之后，当用户与服务器通信时，客户在请求中发回 JSON 对象。服务器仅依赖于这个 JSON 对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名。<strong>服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展</strong></p>\n<h1 id=\"2-访问令牌的类型\"><a href=\"#2-访问令牌的类型\" class=\"headerlink\" title=\"2. 访问令牌的类型\"></a>2. 访问令牌的类型</h1><p><img src=\"https://img-blog.csdnimg.cn/90553af532be4e96a3d6097faf917766.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-JWT-的组成\"><a href=\"#3-JWT-的组成\" class=\"headerlink\" title=\"3. JWT 的组成\"></a>3. JWT 的组成</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">JWTString&#x3D;Base64(Header) + &quot;.&quot; + Base64(Payload).HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret)</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/7138b81b7ebc4633ab6789ff901cbaf2.png\" alt=\"在这里插入图片描述\"><br>该对象为一个很长的字符串，字符之间通过 “.” 分隔符分为三个子串。<br>每一个子串表示了一个功能块，总共有以下三个部分：JWT 头、有效载荷和签名</p>\n<h2 id=\"3-1-Header（JWT-头）\"><a href=\"#3-1-Header（JWT-头）\" class=\"headerlink\" title=\"3.1 Header（JWT 头）\"></a>3.1 Header（JWT 头）</h2><p>JWT 头部分是一个描述 JWT 元数据的 JSON 对象，通常如下所示：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n\t&quot;alg&quot;: &quot;HS256&quot;,\n\t&quot;typ&quot;: &quot;JWT&quot;\n&#125;</code></pre>\n\n<ul>\n<li><strong>alg：</strong> 表示签名使用的算法，默认为 HMAC SHA256（写为 HS256）</li>\n<li><strong>typ：</strong> 表示令牌的类型，JWT 令牌统一写为 JWT。</li>\n</ul>\n<p><strong>最后，使用 Base64URL 算法将上述 JSON 对象转换为字符串保存</strong></p>\n<h2 id=\"3-2-Payload（有效载荷）\"><a href=\"#3-2-Payload（有效载荷）\" class=\"headerlink\" title=\"3.2 Payload（有效载荷）\"></a>3.2 Payload（有效载荷）</h2><p>有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据，包含三个部分：</p>\n<ul>\n<li>标准声明</li>\n<li>公共声明</li>\n<li>私有声明</li>\n</ul>\n<h3 id=\"3-2-1-标准声明字段\"><a href=\"#3-2-1-标准声明字段\" class=\"headerlink\" title=\"3.2.1 标准声明字段\"></a>3.2.1 标准声明字段</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">interface Stantard &#123;\n  iss?: string; &#x2F;&#x2F; JWT的签发者，发行人\n  sub?: string; &#x2F;&#x2F; 主题\n  aud?: string; &#x2F;&#x2F; 接收JWT的一方，受众，用户\n  exp?: number; &#x2F;&#x2F; JWT的过期时间，这个过期时间必须要大于签发时间\n  nbf?: number; &#x2F;&#x2F; 定义在什么时间之前，该 JWT 都是不可用的\n  iat?: number; &#x2F;&#x2F; 该JWT签发的时间，发布时间\n  jti?: number; &#x2F;&#x2F;JWT的唯一身份标识，JWT ID\n&#125;</code></pre>\n\n<h3 id=\"3-2-2-公共声明的字段\"><a href=\"#3-2-2-公共声明的字段\" class=\"headerlink\" title=\"3.2.2 公共声明的字段\"></a>3.2.2 公共声明的字段</h3><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">interface Public &#123;\n\t[key: string]: any;\n&#125;</code></pre>\n\n<p>公共声明字段可以添加任意信息，但是因为可以被解密出来，所以不建议存放敏感信息。</p>\n<h3 id=\"3-2-3-私有声明的字段\"><a href=\"#3-2-3-私有声明的字段\" class=\"headerlink\" title=\"3.2.3 私有声明的字段\"></a>3.2.3 私有声明的字段</h3><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">interface Private &#123;\n\t[key: string]: any;\n&#125;</code></pre>\n\n<h3 id=\"3-2-4-示例\"><a href=\"#3-2-4-示例\" class=\"headerlink\" title=\"3.2.4 示例\"></a>3.2.4 示例</h3><p>一个JWT 的 payload 如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n\t&quot;ip&quot;: &quot;127.0.0.1&quot;,\n\t&quot;uuid&quot;: &quot;ff1212f5-d8d1-4496-bf41-d2dda73de19a&quot;,\n\t&quot;iat&quot;: 1527523017\n&#125;</code></pre>\n\n<p>通过 Base64URL 算法加密生成第二部分的 payload</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">const payloadBuffer &#x3D; Buffer.from(\n\tJSON.stringify(&#123;\n\t\tip: &quot;127.0.0.1&quot;,\n\t\tuuid: &quot;ff1212f5-d8d1-4496-bf41-d2dda73de19a&quot;,\n\t\tiat: 1527523017\n\t&#125;)\n);\nconst payload &#x3D; payloadBuffer.toString(&quot;base64&quot;);\n\nconsole.log(payload);\n&#x2F;&#x2F; eyJpcCI6IjEyNy4wLjAuMSIsInV1aWQiOiJmZjEyMTJmNS1kOGQxLTQ0OTYtYmY0MS1kMmRkYTczZGUxOWEiLCJpYXQiOjE1Mjc1MjMwMTd9</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>默认情况下 JWT 是未加密的，因为只是采用 Base64URL 算法，拿到 JWT 字符串后可以转换回原本的 JSON 数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到 JWT 中，以防止信息泄露。JWT 只是适合在网络中传输一些非敏感的信息。</p></blockquote>\n<h2 id=\"3-3-Signature（签名哈希）\"><a href=\"#3-3-Signature（签名哈希）\" class=\"headerlink\" title=\"3.3 Signature（签名哈希）\"></a>3.3 Signature（签名哈希）</h2><p>签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。首先，<strong>需要指定一个密钥（secret）。该密钥仅仅为保存在服务器中，并且不能向用户公开</strong>。然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）生成签名：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">signature &#x3D; 加密算法(header + &quot;.&quot; + payload, 密钥);\nsignature &#x3D; HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(claims), secret)</code></pre>\n\n<p><strong>在计算出签名哈希后，JWT 头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用 “.” 分隔，就构成整个 JWT 对象。</strong></p>\n<h2 id=\"3-4-Base64URL-算法\"><a href=\"#3-4-Base64URL-算法\" class=\"headerlink\" title=\"3.4 Base64URL 算法\"></a>3.4 Base64URL 算法</h2><p>JWT 头和有效载荷序列化的算法都用到了 Base64URL。该算法和常见 Base64 算法类似，稍有差别。作为令牌的 JWT 可以放在 URL 中（例如 api.example&#x2F;?token&#x3D;xxx）。Base64 中用的三个字符是 “+”，”&#x2F;“ 和 “&#x3D;”，由于在 URL 中有特殊含义，<strong>因此 Base64URL 中对他们做了替换：”&#x3D;” 去掉，”+” 用 “-“ 替换，”&#x2F;“ 用 “_” 替换，这就是 Base64URL 算法。</strong></p>\n<h1 id=\"4-JWT-安全性\"><a href=\"#4-JWT-安全性\" class=\"headerlink\" title=\"4. JWT 安全性\"></a>4. JWT 安全性</h1><h2 id=\"4-1-Token如何做身份验证？\"><a href=\"#4-1-Token如何做身份验证？\" class=\"headerlink\" title=\"4.1 Token如何做身份验证？\"></a>4.1 Token如何做身份验证？</h2><ol>\n<li>首先，JWT 的 Token 相当是明文，是可以解密的，任何存在 payload 的东西，都没有秘密可言，所以隐私数据不能签发 Token</li>\n<li>而服务端，拿到 Token 后解密，即可知道用户信息，例如示例中的 uuid</li>\n<li>有了 uuid，那么你就知道这个用户是谁，是否有权限进行下一步的操作</li>\n</ol>\n<h2 id=\"4-2-如何防止-Token-被串改？\"><a href=\"#4-2-如何防止-Token-被串改？\" class=\"headerlink\" title=\"4.2 如何防止 Token 被串改？\"></a>4.2 如何防止 Token 被串改？</h2><ol>\n<li>此时 signature 字段就是关键了，能被解密出明文的只有 header 和 payload</li>\n<li>假如被人串改了 payload，那么服务器可以<strong>通过 signature 去验证</strong>是否被篡改过，在<strong>服务端在执行一次 signature &#x3D; 加密算法(header + “.” + payload, 密钥);，然后对比 signature 是否一致</strong>，如果一致则说明没有被篡改。</li>\n<li>所以服务器的密钥不能被泄漏。如果泄漏，将存在以下风险：<br><strong>客户端可以自行签发 Token、其他人可以肆意篡改 Token</strong></li>\n</ol>\n<h2 id=\"4-3-问题\"><a href=\"#4-3-问题\" class=\"headerlink\" title=\"4.3 问题\"></a>4.3 问题</h2><ol>\n<li>JWT 默认不加密，但可以加密。生成原始令牌后，可以使用该令牌再次对其进行加密</li>\n<li>当 JWT 未加密方法时，一些私密数据无法通过 JWT 传输</li>\n<li>JWT 不仅可用于认证，还可用于信息交换。善用 JWT 有助于减少服务器请求数据库的次数</li>\n<li>JWT 的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦 JWT 签发，在有效期内将会一直有效</li>\n<li>JWT 本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，<strong>JWT 的有效期不宜设置太长</strong>。对于某些重要操作，用户在使用时应该每次都进行进行身份验证</li>\n<li>为了减少盗用和窃取，JWT 不建议使用 HTTP 协议来传输代码，而是<strong>使用加密的 HTTPS 协议进行传输</strong></li>\n</ol>\n<h1 id=\"5-JWT-种类\"><a href=\"#5-JWT-种类\" class=\"headerlink\" title=\"5. JWT 种类\"></a>5. JWT 种类</h1><p>JWT（JSON Web Token）指的是一种规范，这种规范允许我们使用 JWT 在两个组织之间传递安全可靠的信息，JWT 的具体实现可以分为以下几种：</p>\n<ul>\n<li>nonsecure JWT：未经过签名，不安全的 JWT</li>\n<li>JWS：经过签名的 JWT</li>\n<li>JWE：payload 部分经过加密的 JWT</li>\n</ul>\n<h2 id=\"5-1-nonsecure-JWT\"><a href=\"#5-1-nonsecure-JWT\" class=\"headerlink\" title=\"5.1 nonsecure JWT\"></a>5.1 nonsecure JWT</h2><p>经过签名，不安全的 JWT。其 header 部分没有指定签名算法</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n\t&quot;alg&quot;: &quot;none&quot;,\n\t&quot;typ&quot;: &quot;JWT&quot;\n&#125;</code></pre>\n\n<p>并且也没有 Signature 部分</p>\n<h2 id=\"5-2-JWS\"><a href=\"#5-2-JWS\" class=\"headerlink\" title=\"5.2 JWS\"></a>5.2 JWS</h2><h3 id=\"5-2-1-概念\"><a href=\"#5-2-1-概念\" class=\"headerlink\" title=\"5.2.1 概念\"></a>5.2.1 概念</h3><p>JWS ，也就是 JWT Signature，其结构就是<strong>在之前 nonsecure JWT 的基础上，在头部声明签名算法，并在最后添加上签名</strong>。创建签名，是保证 JWT 不能被他人随意篡改。我们通常使用的 JWT 一般都是 JWS。</p>\n<p>为了完成签名，除了用到 header 信息和 payload 信息外，还需要算法的密钥，也就是 secretKey。加密的算法一般有 2 类：</p>\n<ul>\n<li>对称加密：secretKey 指加密密钥，可以生成签名与验签</li>\n<li>非对称加密：secretKey 指私钥，只用来生成签名，不能用来验签（验签用的是公钥）</li>\n</ul>\n<p>JWT 的密钥或者密钥对，一般统一称为JSON Web Key，也就是JWK</p>\n<h3 id=\"5-2-2-JWT-签名算法\"><a href=\"#5-2-2-JWT-签名算法\" class=\"headerlink\" title=\"5.2.2 JWT 签名算法\"></a>5.2.2 JWT 签名算法</h3><p>到目前为止，JWT 的签名算法有三种：</p>\n<ul>\n<li><strong>HMAC【哈希消息验证码(对称)】：HS256&#x2F;HS384&#x2F;HS512</strong></li>\n<li><strong>RSASSA【RSA签名算法(非对称)】（RS256&#x2F;RS384&#x2F;RS512）</strong></li>\n<li><strong>ECDSA【椭圆曲线数据签名算法(非对称)】（ES256&#x2F;ES384&#x2F;ES512）</strong></li>\n</ul>\n<h2 id=\"5-3-JWE\"><a href=\"#5-3-JWE\" class=\"headerlink\" title=\"5.3 JWE\"></a>5.3 JWE</h2><p>JWS 是去验证数据的，而 JWE（JSON Web Encryption）是保护数据不被第三方的人看到的。通过 JWE，JWT 变得更加安全。</p>\n<ul>\n<li>JWE 和 JWS 的公钥私钥方案不相同，JWS 中，私钥持有者加密令牌，公钥持有者验证令牌。而 JWE 中，私钥一方应该是唯一可以解密令牌的一方。</li>\n<li>在 JWE 中，公钥持有可以将新的数据放入 JWT 中，但是 JWS 中，公钥持有者只能验证数据，不能引入新的数据。因此，对于公钥&#x2F;私钥的方案而言，JWS 和JWE 是互补的。</li>\n</ul>\n<h1 id=\"6-使用\"><a href=\"#6-使用\" class=\"headerlink\" title=\"6. 使用\"></a>6. 使用</h1><h2 id=\"6-1-java-jwt\"><a href=\"#6-1-java-jwt\" class=\"headerlink\" title=\"6.1 java-jwt\"></a>6.1 java-jwt</h2><p><strong>导入依赖</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n\t&lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.18.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"6-1-1-对称签名\"><a href=\"#6-1-1-对称签名\" class=\"headerlink\" title=\"6.1.1 对称签名\"></a>6.1.1 对称签名</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; Token的签名密钥\n    private final static String SECRET_KEY &#x3D; &quot;123456&quot;;\n\n\t&#x2F;&#x2F; 根据用户名生成 Token\n    public static String generateToken(String username)&#123;\n        Algorithm algorithm &#x3D; Algorithm.HMAC256(SECRET_KEY);\n        JWTCreator.Builder jwt &#x3D; JWT.create();\n\n        HashMap&lt;String, Object&gt; header &#x3D; new HashMap&lt;&gt;();\n        header.put(&quot;alg&quot;, &quot;HS256&quot;);\n        header.put(&quot;type&quot;, &quot;jwt&quot;);\n\n        &#x2F;&#x2F; jwt.withHeader(header)\n        &#x2F;&#x2F; JWT 的 header 部分,该 map 可以是空的,因为有默认值&#123;&quot;alg&quot;:HS256,&quot;typ&quot;:&quot;JWT&quot;&#125;\n        String token &#x3D; jwt.withHeader(new HashMap&lt;&gt;())\n                .withClaim(&quot;userId&quot;, 7)  &#x2F;&#x2F; Payload\n                .withClaim(&quot;username&quot;, username)\n                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN)) &#x2F;&#x2F; 过期时间\n                .sign(algorithm);&#x2F;&#x2F; 签名用的 secret\n\n        System.out.println(&quot;生成的 Token：&quot; + token);\n        return token;\n    &#125;\n\n\t&#x2F;&#x2F; 验证 Token\n    public static DecodedJWT verify(String token)&#123;\n        Algorithm algorithm &#x3D; Algorithm.HMAC256(SECRET_KEY);\n\n        Verification verification &#x3D; JWT.require(algorithm);\n        JWTVerifier jwtVerifier &#x3D; verification.build();\n\n        DecodedJWT decodedJWT &#x3D; jwtVerifier.verify(token); &#x2F;&#x2F; 通过密钥进行验证\n        return decodedJWT;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        DecodedJWT decodedJWT &#x3D; verify(token);\n\n        String header &#x3D; decodedJWT.getHeader();\n        System.out.println(&quot;JWT 头：&quot; + header);\n\n        Map&lt;String, Claim&gt; claims &#x3D; decodedJWT.getClaims();\n        System.out.println(&quot;有效负载：&quot; + claims);\n        Claim username &#x3D; decodedJWT.getClaim(&quot;username&quot;);\n        System.out.println(&quot;用户名：&quot; + username);\n\n        String signature &#x3D; decodedJWT.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n\n        Date expiresAt &#x3D; decodedJWT.getExpiresAt();\n        System.out.println(&quot;过期时间&quot; + expiresAt);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/1a1bbc0545bd4166baac2b63e0ba7890.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"6-1-2-非对称签名\"><a href=\"#6-1-2-非对称签名\" class=\"headerlink\" title=\"6.1.2 非对称签名\"></a>6.1.2 非对称签名</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; 使用 Hutool 构建 RSA，当使用无参构造时，将自动生成随机的公钥私钥密钥对\n    private final static RSA rsa &#x3D; new RSA();\n    &#x2F;&#x2F; private static final String RSA_PRIVATE_KEY &#x3D; &quot;...&quot;; 私钥\n    &#x2F;&#x2F; private static final String RSA_PUBLIC_KEY &#x3D; &quot;...&quot;;  公钥\n\n    &#x2F;&#x2F; 生成 Token\n    public static String generateToken(String username)&#123;\n    \t&#x2F;&#x2F; 获取 RSA 私钥\n        &#x2F;&#x2F; RSA rsa &#x3D; new RSA(RSA_PRIVATE_KEY, null);\n        &#x2F;&#x2F; RSAPrivateKey rsaPrivateKey &#x3D; (RSAPrivateKey) rsa.getPrivateKey();\n        RSAPrivateKey rsaPrivateKey &#x3D; (RSAPrivateKey) rsa.getPrivateKey();\n\n        String token &#x3D; JWT.create().withHeader(new HashMap&lt;&gt;())\n                .withClaim(&quot;username&quot;, username)\n                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n                .sign(Algorithm.RSA256(null, rsaPrivateKey)); &#x2F;&#x2F; 签名时传入私钥\n        return token;\n    &#125;\n\n    &#x2F;&#x2F; 验证 Token\n    public static DecodedJWT verify(String token)&#123;\n    \t&#x2F;&#x2F; 获取 RSA 公钥\n    \t&#x2F;&#x2F; RSA rsa &#x3D; new RSA(null, RSA_PUBLIC_KEY);\n   \t\t&#x2F;&#x2F; RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) rsa.getPublicKey();\n        RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) rsa.getPublicKey();\n      \n        &#x2F;&#x2F; 验签时传入公钥\n        JWTVerifier jwtVerifier &#x3D; JWT.require(Algorithm.RSA256(rsaPublicKey, null)).build();\n\n        DecodedJWT decodedJWT &#x3D; jwtVerifier.verify(token);\n        return decodedJWT;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        DecodedJWT decodedJWT &#x3D; verify(token);\n\n        String header &#x3D; decodedJWT.getHeader();\n        System.out.println(&quot;JWT 头：&quot; + header);\n\n        Map&lt;String, Claim&gt; claims &#x3D; decodedJWT.getClaims();\n        System.out.println(&quot;有效负载：&quot; + claims);\n        Claim username &#x3D; decodedJWT.getClaim(&quot;username&quot;);\n        System.out.println(&quot;用户名：&quot; + username);\n\n        String signature &#x3D; decodedJWT.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n\n        Date expiresAt &#x3D; decodedJWT.getExpiresAt();\n        System.out.println(&quot;过期时间&quot; + expiresAt);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/c8aa1322fde34796ad880ad22dde9fb6.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"6-2-jjwt\"><a href=\"#6-2-jjwt\" class=\"headerlink\" title=\"6.2 jjwt\"></a>6.2 jjwt</h2><p>导入依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.9.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<h3 id=\"6-2-1-对称签名\"><a href=\"#6-2-1-对称签名\" class=\"headerlink\" title=\"6.2.1 对称签名\"></a>6.2.1 对称签名</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; Token的密钥\n    private final static String SECRET_KEY &#x3D; &quot;123456&quot;;\n\n    &#x2F;&#x2F; 根据用户名生成 Token\n    public static String generateToken(String username)&#123;\n        JwtBuilder jwtBuilder &#x3D; Jwts.builder();\n\n        &#x2F;&#x2F; jwtBuilder.setHeader(new HashMap&lt;&gt;());\n        String token &#x3D; jwtBuilder.setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)\n                .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)\n                .setSubject(&quot;user&quot;)\n                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n                .claim(&quot;username&quot;, username)\n                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)\n                .compact();\n\t\tSystem.out.println(&quot;生成的 Token：&quot; + token);\n        return token;\n    &#125;\n\n    &#x2F;&#x2F; 验证 Token，从http请求头中获取 Token 字符串\n    public static Jws&lt;Claims&gt; verify(String token)&#123;\n        JwtParser jwtParser &#x3D; Jwts.parser();\n        Jws&lt;Claims&gt; claimsJws &#x3D; jwtParser.setSigningKey(SECRET_KEY).parseClaimsJws(token);\n        return claimsJws;\n    &#125;\n    public static Jws&lt;Claims&gt; verify(HttpServletRequest request)&#123;\n        String token &#x3D; request.getHeader(&quot;token&quot;);\n        JwtParser jwtParser &#x3D; Jwts.parser();\n        Jws&lt;Claims&gt; claimsJws &#x3D; jwtParser.setSigningKey(SECRET_KEY).parseClaimsJws(token);\n        return claimsJws;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        Jws&lt;Claims&gt; claimsJws &#x3D; verify(token);\n\n        JwsHeader header &#x3D; claimsJws.getHeader();\n        System.out.println(&quot;Header：&quot; + header);\n\n        Claims body &#x3D; claimsJws.getBody();\n        System.out.println(&quot;PayLoad：&quot; + body);\n        String subject &#x3D; body.getSubject();\n        System.out.println(&quot;主题：&quot; + subject);\n\n        String signature &#x3D; claimsJws.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://img-blog.csdnimg.cn/a81070a8298442d8b51d9667d48f80f0.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"6-2-2-jjwt-的-0-10版本以后\"><a href=\"#6-2-2-jjwt-的-0-10版本以后\" class=\"headerlink\" title=\"6.2.2 jjwt 的 0.10版本以后\"></a>6.2.2 jjwt 的 0.10版本以后</h3><p>pom依赖要引入多个</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.11.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt-impl&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.11.2&lt;&#x2F;version&gt;\n    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt-jackson&lt;&#x2F;artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt;\n    &lt;version&gt;0.11.2&lt;&#x2F;version&gt;\n    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>在 jjwt 0.10 版本之前，没有强制要求，secretKey 长度不满足要求时也可以签名成功。但是 0.10 版本后强制要求 secretKey 满足规范中的长度要求，否则生成 jws 时会抛出异常</p>\n<ul>\n<li>HS256：要求至少 256 bits (32 bytes)</li>\n<li>HS384：要求至少384 bits (48 bytes)</li>\n<li>HS512：要求至少512 bits (64 bytes)</li>\n<li>RS256 and PS256：至少2048 bits</li>\n<li>RS384 and PS384：至少3072 bits</li>\n<li>RS512 and PS512：至少4096 bits</li>\n<li>ES256：至少256 bits (32 bytes)</li>\n<li>ES384：至少384 bits (48 bytes)</li>\n<li>ES512：至少512 bits (64 bytes)</li>\n</ul>\n<p>之前的签名和验签方法都是传入密钥的字符串，已经过时。最新的方法需要传入 Key 对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static String generateToken(String username)&#123;\n\tString token &#x3D; Jwts.builder()\n\t\t.setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)\n\t\t.setSubject(&quot;user&quot;)\n\t\t.setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n\t\t.claim(&quot;username&quot;, username)\n\t\t&#x2F;&#x2F; 传入Key对象\n\t\t.signWith(Keys.hmacShaKeyFor(SECRET_KEY.getBytes(StandardCharsets.UTF_8)), SignatureAlgorithm.HS256)\n\t\t.compact();\n\treturn token;\n&#125;\n\n&#x2F;&#x2F; 验证 Token\npublic static Jws&lt;Claims&gt; verify(String token) &#123;\n\t&#x2F;&#x2F; 传入Key对象\n\tJws&lt;Claims&gt; claimsJws &#x3D; Jwts.parserBuilder().setSigningKey(Keys.hmacShaKeyFor(SECRET_KEY.getBytes(StandardCharsets.UTF_8))).build().parseClaimsJws(token);\n\treturn claimsJws;\n&#125;</code></pre>\n\n<h3 id=\"6-2-3-非对称签名\"><a href=\"#6-2-3-非对称签名\" class=\"headerlink\" title=\"6.2.3 非对称签名\"></a>6.2.3 非对称签名</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; 使用 Hutool 构建 RSA\n    private final static RSA rsa &#x3D; new RSA();\n\n    &#x2F;&#x2F; 根据用户名生成 Token\n    public static String generateToken(String username)&#123;\n        &#x2F;&#x2F; 获取 RSA 私钥\n        RSAPrivateKey rsaPrivateKey &#x3D; (RSAPrivateKey) rsa.getPrivateKey();\n\n        &#x2F;&#x2F; jwtBuilder.setHeader(new HashMap&lt;&gt;());\n        String token &#x3D; Jwts.builder().setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)\n                .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)\n                .setSubject(&quot;user&quot;)\n                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n                .claim(&quot;username&quot;, username)\n                .signWith(rsaPrivateKey, SignatureAlgorithm.RS256)\n                .compact();\n        System.out.println(&quot;生成的 Token：&quot; + token);\n        return token;\n    &#125;\n\n    &#x2F;&#x2F; 验证 Token\n    public static Jws&lt;Claims&gt; verify(String token)&#123;\n        RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) rsa.getPublicKey();\n        Jws&lt;Claims&gt; claimsJws &#x3D; Jwts.parserBuilder().setSigningKey(rsaPublicKey).build().parseClaimsJws(token);\n        return claimsJws;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        Jws&lt;Claims&gt; claimsJws &#x3D; verify(token);\n\n        JwsHeader header &#x3D; claimsJws.getHeader();\n        System.out.println(&quot;Header：&quot; + header);\n\n        Claims body &#x3D; claimsJws.getBody();\n        System.out.println(&quot;PayLoad：&quot; + body);\n        String subject &#x3D; body.getSubject();\n        System.out.println(&quot;主题：&quot; + subject);\n\n        String signature &#x3D; claimsJws.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"7-实际应用\"><a href=\"#7-实际应用\" class=\"headerlink\" title=\"7. 实际应用\"></a>7. 实际应用</h1><ol>\n<li>在登录验证通过后，给用户生成一个对应的随机 Token （注意这个 Token 不是指 JWT，可以用 UUID 等算法生成），然后将这个Token 作为 Key 的一部分，用户信息作为 Value 存入 Redis，并设置过期时间，这个过期时间就是登录失效的时间</li>\n<li>第1步中生成的随机 Token 作为 JWT 的 payload 生成 JWT 字符串返回给前端</li>\n<li>前端之后每次请求都在<strong>请求头中的 Authorization 字段</strong>中携带 JWT 字符串</li>\n<li>后端定义一个拦截器，每次收到前端请求时，都先从请求头中的 Authorization 字段中取出 JWT 字符串并进行验证，验证通过后解析出 payload 中的随机 Token，然后再用这个随机 Token 得到 Key，从 Redis 中获取用户信息，如果能获取到就说明用户已经登录</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JWTInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        String JWT &#x3D; request.getHeader(&quot;Authorization&quot;);\n        try &#123;\n            &#x2F;&#x2F; 1.校验JWT字符串\n            DecodedJWT decodedJWT &#x3D; JWTUtils.decode(JWT);\n            &#x2F;&#x2F; 2.取出JWT字符串载荷中的随机token，从Redis中获取用户信息\n            ...\n            return true;\n        &#125;catch (SignatureVerificationException e)&#123;\n            System.out.println(&quot;无效签名&quot;);\n            e.printStackTrace();\n        &#125;catch (TokenExpiredException e)&#123;\n            System.out.println(&quot;token已经过期&quot;);\n            e.printStackTrace();\n        &#125;catch (AlgorithmMismatchException e)&#123;\n            System.out.println(&quot;算法不一致&quot;);\n            e.printStackTrace();\n        &#125;catch (Exception e)&#123;\n            System.out.println(&quot;token无效&quot;);\n            e.printStackTrace();\n        &#125;\n        return false;\n    &#125;\n&#125;</code></pre>\n","feature":false,"text":"1. 跨域身份验证1.1 传统的 session 流程 浏览器发起请求登陆，向服务器发送用户名和密码 服务端验证身份，生成身份验证信息（用户角色、登录时间等），存储在服务端 的 session 中 服务器向用户返回 session_id，session 信息都会写入到用户的 Co...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":8,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"JWT","slug":"JWT","count":1,"path":"api/tags/JWT.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E8%B7%A8%E5%9F%9F%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">1. 跨域身份验证</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%BC%A0%E7%BB%9F%E7%9A%84-session-%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1.1 传统的 session 流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-JWT-%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1.2 JWT 流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-session-%E4%B8%8E-JWT-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.3 session 与 JWT 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-JWT-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.4 JWT 工作原理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2. 访问令牌的类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-JWT-%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">3. JWT 的组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Header%EF%BC%88JWT-%E5%A4%B4%EF%BC%89\"><span class=\"toc-text\">3.1 Header（JWT 头）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Payload%EF%BC%88%E6%9C%89%E6%95%88%E8%BD%BD%E8%8D%B7%EF%BC%89\"><span class=\"toc-text\">3.2 Payload（有效载荷）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E6%A0%87%E5%87%86%E5%A3%B0%E6%98%8E%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">3.2.1 标准声明字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E5%85%AC%E5%85%B1%E5%A3%B0%E6%98%8E%E7%9A%84%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">3.2.2 公共声明的字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E7%A7%81%E6%9C%89%E5%A3%B0%E6%98%8E%E7%9A%84%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">3.2.3 私有声明的字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-4-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">3.2.4 示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Signature%EF%BC%88%E7%AD%BE%E5%90%8D%E5%93%88%E5%B8%8C%EF%BC%89\"><span class=\"toc-text\">3.3 Signature（签名哈希）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-Base64URL-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3.4 Base64URL 算法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-JWT-%E5%AE%89%E5%85%A8%E6%80%A7\"><span class=\"toc-text\">4. JWT 安全性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-Token%E5%A6%82%E4%BD%95%E5%81%9A%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%9F\"><span class=\"toc-text\">4.1 Token如何做身份验证？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-Token-%E8%A2%AB%E4%B8%B2%E6%94%B9%EF%BC%9F\"><span class=\"toc-text\">4.2 如何防止 Token 被串改？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4.3 问题</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-JWT-%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">5. JWT 种类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-nonsecure-JWT\"><span class=\"toc-text\">5.1 nonsecure JWT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-JWS\"><span class=\"toc-text\">5.2 JWS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.2.1 概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-2-JWT-%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">5.2.2 JWT 签名算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-JWE\"><span class=\"toc-text\">5.3 JWE</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">6. 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-java-jwt\"><span class=\"toc-text\">6.1 java-jwt</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-1-%E5%AF%B9%E7%A7%B0%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">6.1.1 对称签名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-2-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">6.1.2 非对称签名</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-jjwt\"><span class=\"toc-text\">6.2 jjwt</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-1-%E5%AF%B9%E7%A7%B0%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">6.2.1 对称签名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-2-jjwt-%E7%9A%84-0-10%E7%89%88%E6%9C%AC%E4%BB%A5%E5%90%8E\"><span class=\"toc-text\">6.2.2 jjwt 的 0.10版本以后</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-3-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">6.2.3 非对称签名</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">7. 实际应用</span></a></li></ol>","author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"MapStruct 总结","uid":"489b1959aeda27687de88f48f1d87894","slug":"BlogRepository/开发技术及框架/MapStruct 总结","date":"2022-03-22T05:51:27.000Z","updated":"2023-03-13T19:13:04.956Z","comments":true,"path":"api/articles/BlogRepository/开发技术及框架/MapStruct 总结.json","keywords":null,"cover":"https://cover.png","text":"1. 概念在系统工程开发过程中，会有各个层之间的对象转换，比如 VO、DTO、PO、DO 等，如果都是手动 setter、getter 特别浪费时间，还可能操作错误，所以选择一个自动化工具会更加方便。常见的有 json2Json、Apache 和 Spring 的 BeanUti...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"开发技术及框架","slug":"开发技术及框架","count":8,"path":"api/categories/开发技术及框架.json"}],"tags":[{"name":"Java","slug":"Java","count":11,"path":"api/tags/Java.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false},"next_post":{"title":"Redis 启动报错 QForkMasterInit system error caught error code=0x000005af 解决","uid":"e7512e112eb3757deb99ae02ef8d3f9b","slug":"BlogRepository/问题记录/Redis 启动报错 QForkMasterInit_ system error caught. error code=0x000005af 解决","date":"2022-03-16T08:20:49.000Z","updated":"2023-03-13T19:13:04.973Z","comments":true,"path":"api/articles/BlogRepository/问题记录/Redis 启动报错 QForkMasterInit_ system error caught. error code=0x000005af 解决.json","keywords":null,"cover":"https://cover.png","text":"1. 问题直接用 redis-server.exe 启动时闪退，用脚本加上配置文件启动也闪退，用命令行启动时，报错： [23848] 16 Mar 16:10:32.565 # QForkMasterInit: system error caught. error code&#x...","link":"","photos":[],"count_time":{"symbolsCount":356,"symbolsTime":"1 mins."},"categories":[{"name":"问题记录","slug":"问题记录","count":7,"path":"api/categories/问题记录.json"}],"tags":[{"name":"Redis","slug":"Redis","count":5,"path":"api/tags/Redis.json"}],"author":{"name":"凡","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Fan223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":false}}