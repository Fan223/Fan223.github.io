[{"id":"3497c014929691d338a902c1115e19bb","title":"Navicat15 安装及激活总结","content":"1. 安装1、首先获取安装程序，另一个为注册机\n\n2、双击安装程序，下一步\n\n3、同意，下一步\n\n4、选择安装路径，下一步\n\n5、默认，下一步\n\n6、下一步\n\n7、开始安装\n\n8、完成\n\n2. 注册激活1、双击打开注册机\n\n2、选择匹配的版本，Patch\n\n3、选择 Navicat 安装目录的启动程序\n\n4、确定\n\n5、打开 Navicat，先点击试用，进入主界面\n\n6、点击注册\n\n\n7、回到注册机，这里可以选择对应的配置，一般是默认，然后点击 Generate\n\n会出现激活码\n\n8、复制到 Navicat 激活界面\n\n9、注意：把网断了，然后点击激活，选择手动激活\n\n复制请求码\n\n10、回到注册机界面，粘贴到 Request Code，点击 Generate 生成激活码\n\n11、复制激活码\n\n12、回到 Navicat 激活界面，将激活码粘贴进来，点击激活\n\n13、激活成功，确定\n\n14、确定\n\n至此已完成激活\n","slug":"BlogRepository/开发工具及环境/Navicat15 安装及激活总结","date":"2023-02-26T19:39:24.000Z","categories_index":"开发工具及环境","tags_index":"Navicat","author_index":"凡"},{"id":"84bebe9cd32f64471707a2ec9d7cecfe","title":"Spring Security 总结","content":"1. 概要1.1 名词概念1.1.1 主体（principal）使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体\n1.1.2 认证（authentication）权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。笼统的认为就是以前所做的登录操作\n1.1.3 授权（authorization）将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的能力。所以简单来说，授权就是给用户分配权限\n1.2 简介关于安全方面的两个主要区域是“认证”和“授权”（或者访问控制），一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization） 两个部分，这两点也是 Spring Security 重要核心功能\n\n用户认证： 验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。通俗点说就是系统认为用户是否能登录\n用户授权： 验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。通俗点讲就是系统判断用户是否有权限去做某些事情\n\n1.2.1 SpringSecurity 特点\n和 Spring 无缝整合\n全面的权限控制\n专门为 Web 开发而设计\n旧版本不能脱离 Web 环境使用\n新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独引入核心模块就可以脱离 Web 环境\n\n\n重量级，shiro 是轻量级的\n\n1.2.2 模块划分\n2. 过滤器Spring Security 采用的是责任链的设计模式，它有一条很长的过滤器链（15个），只有当前过滤器通过，才能进入下一个过滤器\nSpring Security 的过滤器链是配置在 SpringMVC 的核心组件 DispatcherServlet 运行之前。也就是说，请求通过 Spring Security 的所有过滤器，不意味着能够正常访问资源，该请求还需要通过 SpringMVC 的拦截器链\norg.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter\norg.springframework.security.web.context.SecurityContextPersistenceFilter \norg.springframework.security.web.header.HeaderWriterFilter\norg.springframework.security.web.csrf.CsrfFilter\norg.springframework.security.web.authentication.logout.LogoutFilter \norg.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter \norg.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter \norg.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter\norg.springframework.security.web.authentication.www.BasicAuthenticationFilter\norg.springframework.security.web.savedrequest.RequestCacheAwareFilter\norg.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter\norg.springframework.security.web.authentication.AnonymousAuthenticationFilter \norg.springframework.security.web.session.SessionManagementFilter \norg.springframework.security.web.access.ExceptionTranslationFilter \norg.springframework.security.web.access.intercept.FilterSecurityInterceptor\n\nOncePerRequestFilter在 Spring中，Filter 默认继承OncePerRequestFilter，作用是兼容各种请求，保证每次执行一个Filter\n2.1 WebAsyncManagerIntegrationFilter将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成\n2.2 SecurityContextPersistenceFilter2.2.1 SecurityContextRepository用于在请求之间保持 SecurityContext 的策略。 SecurityContextPersistenceFilter 使用它来获取应该用于当前执行线程的上下文，并在上下文从线程本地存储中删除并且请求完成后存储该上下文。使用的持久性机制将取决于实现，但最常见的是 HttpSession 将用于存储上下文\n2.2.2 概念在请求开始时从配置好的 SecurityContextRepository  中获取该请求相关的安全上下文信息 SecurityContext，然后加载到 SecurityContextHolder 中。然后在该次请求处理完成之后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 SecurityContextHolder 所持有的 SecurityContext\n2.3 HeaderWriterFilter向请求的 Header 中添加相应的信息，将头信息加入响应中，可在 http 标签内部使用 security:headers 来控制\n2.4 CsrfFilter用于处理跨站请求伪造，Spring Security会对 PATCH，POST，PUT 和 DELETE 方法进行防护，验证请求是否包含系统生成的 csrf 的 Token 信息，如果不包含，则报错\n2.5 LogoutFilter默认匹配 URL 为 &#x2F;logout 的请求，实现用户注销，清除认证信息\n2.6 UsernamePasswordAuthenticationFilter（重要）进行认证操作。用于处理基于表单的登录请求，默认会拦截前端提交的 URL 为 &#x2F;login 且必须为 POST 方式的登录表单请求，并进行身份认证，校验表单中用户名，密码。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的 usernameParameter 和 passwordParameter 两个参数的值进行修改。该过滤器的 doFilter() 方法实现在其抽象父类 AbstractAuthenticationProcessingFilter 中\n2.7 DefaultLoginPageGeneratingFilter如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录认证时生成一个登录表单页面\n2.8 DefaultLogoutPageGeneratingFilter生成默认的注销页面\n2.9 BasicAuthenticationFilter此过滤器会自动解析 HTTP 请求中头部名字为 Authentication，且以 Basic 开头的头信息，检测和处理 HTTP Basic 认证\n2.10 RequestCacheAwareFilter通过 HttpSessionRequestCache 内部维护了一个 RequestCache，用于缓存 HttpServletRequest，处理请求的缓存\n2.11 SecurityContextHolderAwareRequestFilter针对 ServletRequest 进行了—次包装，使得 request 具有更加丰富的API\n2.12 AnonymousAuthenticationFilter当 SecurityContextHolder 中 Authentication 对象（认证信息）为空,则会创建一个匿名用户存入到 SecurityContextHolder 中。Spring Security 为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份\n2.13 SessionManagementFilter管理 Session 的过滤器，SecurityContextRepository 限制同一用户开启多个会话的数量\n2.14 ExceptionTranslationFilter（重要）异常过滤器，处理 AccessDeniedException 和 AuthenticationException 异常，该过滤器不需要配置，对于前端提交的请求会直接放行，捕获后续抛出的异常并进行处理（如：权限访问限制）\npublic class ExceptionTranslationFilter extends GenericFilterBean &#123;\n\n\t&#x2F;&#x2F; ~ Instance fields\n\t&#x2F;&#x2F; ~ Methods\n\n\tpublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;\n\t\tHttpServletRequest request &#x3D; (HttpServletRequest) req;\n\t\tHttpServletResponse response &#x3D; (HttpServletResponse) res;\n\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 1. 对应前端提交的请求会直接放行，不进行拦截\n\t\t\tchain.doFilter(request, response);\n\n\t\t\tlogger.debug(&quot;Chain processed normally&quot;);\n\t\t&#125;\n\t\tcatch (IOException ex) &#123;\n\t\t\tthrow ex;\n\t\t&#125;\n\t\tcatch (Exception ex) &#123;\n\t\t\t&#x2F;&#x2F; Try to extract a SpringSecurityException from the stacktrace\n\t\t\t&#x2F;&#x2F; 2. 捕获后续出现的异常进行处理\n\t\t\tThrowable[] causeChain &#x3D; throwableAnalyzer.determineCauseChain(ex);\n\t\t\t&#x2F;&#x2F; 3. 访问需要认证的资源，但当前请求未认证所抛出的异常\n\t\t\tRuntimeException ase &#x3D; (AuthenticationException) throwableAnalyzer\n\t\t\t\t\t.getFirstThrowableOfType(AuthenticationException.class, causeChain);\n\n\t\t\tif (ase &#x3D;&#x3D; null) &#123;\n\t\t\t\t&#x2F;&#x2F; 访问权限受限的资源所抛出的异常\n\t\t\t\tase &#x3D; (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain);\n\t\t\t&#125;\n\n\t\t\tif (ase !&#x3D; null) &#123;\n\t\t\t\tif (response.isCommitted()) &#123;\n\t\t\t\t\tthrow new ServletException(&quot;Unable to handle the Spring Security Exception because the response is already committed.&quot;, ex);\n\t\t\t\t&#125;\n\t\t\t\thandleSpringSecurityException(request, response, chain, ase);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\t&#x2F;&#x2F; Rethrow ServletExceptions and RuntimeExceptions as-is\n\t\t\t\tif (ex instanceof ServletException) &#123;\n\t\t\t\t\tthrow (ServletException) ex;\n\t\t\t\t&#125;\n\t\t\t\telse if (ex instanceof RuntimeException) &#123;\n\t\t\t\t\tthrow (RuntimeException) ex;\n\t\t\t\t&#125;\n\n\t\t\t\t&#x2F;&#x2F; Wrap other Exceptions. This shouldn&#39;t actually happen\n\t\t\t\t&#x2F;&#x2F; as we&#39;ve already covered all the possibilities for doFilter\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;\n\n2.15 FilterSecurityInterceptor（重要）该过滤器是过滤器链的最后一个过滤器，前面解决了认证问题，接下来是是否可访问指定资源的问题，FilterSecurityInterceptor 用了 AccessDecisionManager 来进行鉴权。获取所配置资源访问的授权信息，根据 SecurityContextHolder 中存储的用户信息来判断当前请求是否有权限访问对应的资源。如果访问受限会抛出相关异常，最终所抛出的异常会由前一个过滤器 ExceptionTranslationFilter 过滤器进行捕获和处理\npublic class FilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123;\n\t&#x2F;&#x2F; ~ Static fields&#x2F;initializers\n\t&#x2F;&#x2F; ~ Instance fields\n\t&#x2F;&#x2F; ~ Methods\n\n\t&#x2F;&#x2F; 过滤器的 doFilter() 方法\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n\t\tFilterInvocation fi &#x3D; new FilterInvocation(request, response, chain);\n\t\t&#x2F;&#x2F; 调用 invoke() 方法\n\t\tinvoke(fi);\n\t&#125;\n\n\tpublic void invoke(FilterInvocation fi) throws IOException, ServletException &#123;\n\t\tif ((fi.getRequest() !&#x3D; null)\n\t\t\t\t&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) !&#x3D; null)\n\t\t\t\t&amp;&amp; observeOncePerRequest) &#123;\n\t\t\t&#x2F;&#x2F; filter already applied to this request and user wants us to observe\n\t\t\t&#x2F;&#x2F; once-per-request handling, so don&#39;t re-do security checking\n\t\t\tfi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n\t\t&#125;\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F; first time this request being called, so perform security checking\n\t\t\tif (fi.getRequest() !&#x3D; null &amp;&amp; observeOncePerRequest) &#123;\n\t\t\t\tfi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);\n\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; 1. 根据资源权限配置来判断当前请求是否有权限访问对应的资源，如果不能访问，则抛出响应的异常\n\t\t\tInterceptorStatusToken token &#x3D; super.beforeInvocation(fi);\n\n\t\t\ttry &#123;\n\t\t\t\t&#x2F;&#x2F; 2. 访问相关资源，通过 SpringMVC 的核心组件 DispatcherServlet 进行访问\n\t\t\t\tfi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n\t\t\t&#125;\n\t\t\tfinally &#123;\n\t\t\t\tsuper.finallyInvocation(token);\n\t\t\t&#125;\n\n\t\t\tsuper.afterInvocation(token, null);\n\t\t&#125;\n\t&#125;\n&#125;\n\nRememberMeAuthenticationFilter当用户没有登录而直接访问资源时, 从 Cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的 Remember Me Cookie, 用户将不必填写用户名和密码，而是直接登录进入系统，该过滤器默认不开启\n执行流程图\n3. 工作流程登录校验流程：类之间关系：\n3.1 认证流程\n3.1.1 AbstractAuthenticationProcessingFilter\n基于浏览器的基于 HTTP 的身份验证请求的抽象处理器。需要 AuthenticationManager 来处理由实现类创建的身份验证请求令牌\n如果身份验证成功，生成的 Authentication 对象将被放入当前线程的 SecurityContext 中。然后将调用配置的 AuthenticationSuccessHandler 以在成功登录后重定向到适当的目的地。默认行为在 SavedRequestAwareAuthenticationSuccessHandler 中实现，它将利用 ExceptionTranslationFilter 设置的任何 DefaultSavedRequest 并将用户重定向到其中包含的 URL\n如果身份验证失败，它将委托给配置的 AuthenticationFailureHandler 以允许将失败信息传达给客户端。默认实现是 SimpleUrlAuthenticationFailureHandler ，它向客户端发送 401 错误代码。它也可以配置一个失败的 URL 作为替代\n如果身份验证成功，将通过应用程序上下文发布一个 InteractiveAuthenticationSuccessEvent。如果身份验证不成功，则不会发布任何事件，因为这通常会通过 AuthenticationManager 特定的应用程序事件进行记录\n该类有一个可选的 SessionAuthenticationStrategy，它将在成功调用 attemptAuthentication() 后立即被调用。可以注入不同的实现来启用会话固定攻击预防或控制主体可能拥有的同时会话的数量\n\npublic abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware &#123;\n\n    &#x2F;&#x2F; 过滤器 doFilter() 方法\n\tpublic void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;\n\n\t\tHttpServletRequest request &#x3D; (HttpServletRequest) req;\n\t\tHttpServletResponse response &#x3D; (HttpServletResponse) res;\n\n\t\t&#x2F;&#x2F; 1. 判断该请求是否为 POST 方式的登录表单提交请求，如果不是则直接放行，进入下一个过滤器\n\t\tif (!requiresAuthentication(request, response)) &#123;\n\t\t\tchain.doFilter(request, response);\n\t\t\treturn;\n\t\t&#125;\n\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Request is to process authentication&quot;);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Authentication 是用来存储用户认证信息的类\n\t\tAuthentication authResult;\n\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 2. 调用子类 UsernamePasswordAuthenticationFilter 重写的方法进行身份认证\n\t\t\t&#x2F;&#x2F; 返回的 authResult 对象封装认证后的用户信息\n\t\t\tauthResult &#x3D; attemptAuthentication(request, response);\n\t\t\tif (authResult &#x3D;&#x3D; null) &#123;\n\t\t\t\t&#x2F;&#x2F; return immediately as subclass has indicated that it hasn&#39;t completed\n\t\t\t\t&#x2F;&#x2F; authentication\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; 3. Session 策略处理（如果配置了用户 Session 最大并发数，就是在此处进行判断并处理）\n\t\t\tsessionStrategy.onAuthentication(authResult, request, response);\n\t\t&#125;\n\t\tcatch (InternalAuthenticationServiceException failed) &#123;\n\t\t\tlogger.error(\n\t\t\t\t\t&quot;An internal error occurred while trying to authenticate the user.&quot;,\n\t\t\t\t\tfailed);\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\n\t\t\treturn;\n\t\t&#125;\n\t\tcatch (AuthenticationException failed) &#123;\n\t\t\t&#x2F;&#x2F; Authentication failed，4. 认证失败，调用认证失败的处理器\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\n\t\t\treturn;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Authentication success，4. 认证成功的处理\n\t\tif (continueChainBeforeSuccessfulAuthentication) &#123;\n\t\t\t&#x2F;&#x2F; 默认的 continueChainBeforeSuccessfulAuthentication 为 false，所以认证成功后不进入下一个过滤器\n\t\t\tchain.doFilter(request, response);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 调用认证成功的处理器\n\t\tsuccessfulAuthentication(request, response, chain, authResult);\n\t&#125;\n\n\t&#x2F;&#x2F; 认证成功后的处理\n\tprotected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;\n\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Authentication success. Updating SecurityContextHolder to contain: &quot; + authResult);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 1. 将认证成功的用户信息对象 Authentication 封装进 SecurityContext 对象中，并存入 SecurityContextHolder\n\t\t&#x2F;&#x2F; SecurityContextHolder 是对 ThreadLocal 的一个封装\n\t\tSecurityContextHolder.getContext().setAuthentication(authResult);\n\n\t\t&#x2F;&#x2F; 2. rememberMe 的处理\n\t\trememberMeServices.loginSuccess(request, response, authResult);\n\n\t\t&#x2F;&#x2F; Fire event\n\t\tif (this.eventPublisher !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; 3. 发布认证成功的事件\n\t\t\teventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 4. 调用认证成功处理器\n\t\tsuccessHandler.onAuthenticationSuccess(request, response, authResult);\n\t&#125;\n\t&#x2F;&#x2F; 认证失败后的处理\n\tprotected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;\n\t\t&#x2F;&#x2F; 1. 清除该线程在 SecurityContextHolder 中对应的 SecurityContext 对象\n\t\tSecurityContextHolder.clearContext();\n\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Authentication request failed: &quot; + failed.toString(), failed);\n\t\t\tlogger.debug(&quot;Updated SecurityContextHolder to contain null Authentication&quot;);\n\t\t\tlogger.debug(&quot;Delegating to authentication failure handler &quot; + failureHandler);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 2. rememberMe 的处理\n\t\trememberMeServices.loginFail(request, response);\n\n\t\t&#x2F;&#x2F; 3. 调用认证失败处理器\n\t\tfailureHandler.onAuthenticationFailure(request, response, failed);\n\t&#125;\n&#125;\n\n上面第二步调用了 UsernamePasswordAuthenticationFilter 的 attemptAuthentication() 方法，见 3.1.2\n3.1.2 UsernamePasswordAuthenticationFilter进行认证操作。用于处理身份验证表单提交，默认会拦截前端提交的 URL 为 &#x2F;login 且必须为 POST 方式的登录表单请求，并进行身份认证，校验表单中用户名和密码。从表单中获取用户名和密码时，登录表单必须向此过滤器提供两个参数：username 和 password。要使用的默认参数名称在静态字段中进行了定义。参数名称也可以通过设置 usernameParameter 和 passwordParameter 属性来更改。。该过滤器的 doFilter() 方法实现在 3.1.1 其抽象父类 AbstractAuthenticationProcessingFilter 中\npublic class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;\n\n\tpublic static final String SPRING_SECURITY_FORM_USERNAME_KEY &#x3D; &quot;username&quot;;\n\tpublic static final String SPRING_SECURITY_FORM_PASSWORD_KEY &#x3D; &quot;password&quot;;\n\n\t&#x2F;&#x2F;  默认表单用户名参数为 username\n\tprivate String usernameParameter &#x3D; SPRING_SECURITY_FORM_USERNAME_KEY;\n\t&#x2F;&#x2F;  默认表单密码参数为 password\n\tprivate String passwordParameter &#x3D; SPRING_SECURITY_FORM_PASSWORD_KEY;\n\t&#x2F;&#x2F; 默认请求方式只能为 POST\n\tprivate boolean postOnly &#x3D; true;\n\n\tpublic UsernamePasswordAuthenticationFilter() &#123;\n\t\t&#x2F;&#x2F; 默认登录表单提交路径为 &#x2F;login，POST 方式请求\n\t\tsuper(new AntPathRequestMatcher(&quot;&#x2F;login&quot;, &quot;POST&quot;));\n\t&#125;\n\n\t&#x2F;&#x2F; 上面的 doFilter() 方法调用此 attemptAuthentication() 进行身份认证\n\tpublic Authentication attemptAuthentication(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws AuthenticationException &#123;\n\t\tif (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;\n\t\t\t&#x2F;&#x2F; 1. 默认情况下，如果请求方式不是 POST，会抛出异常\n\t\t\tthrow new AuthenticationServiceException(\n\t\t\t\t\t&quot;Authentication method not supported: &quot; + request.getMethod());\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 2. 获取请求携带的 username 和 password\n\t\tString username &#x3D; obtainUsername(request);\n\t\tString password &#x3D; obtainPassword(request);\n\n\t\tif (username &#x3D;&#x3D; null) &#123;\n\t\t\tusername &#x3D; &quot;&quot;;\n\t\t&#125;\n\n\t\tif (password &#x3D;&#x3D; null) &#123;\n\t\t\tpassword &#x3D; &quot;&quot;;\n\t\t&#125;\n\n\t\tusername &#x3D; username.trim();\n\n\t\t&#x2F;&#x2F; 3. 使用前端传入的 username、password 构造 Authentication 对象，其中 authenticated 属性初始化默认为 false(也就还没通过身份验证)\n\t\tUsernamePasswordAuthenticationToken authRequest &#x3D; new UsernamePasswordAuthenticationToken(username, password);\n\n\t\t&#x2F;&#x2F; Allow subclasses to set the &quot;details&quot; property\n\t\t&#x2F;&#x2F; 4. 将请求中有关身份验证的其他属性信息设置到 Authentication 对象中，如 IP 地址、证书序列号等\n\t\tsetDetails(request, authRequest);\n\n\t\t&#x2F;&#x2F; 5. 调用 AuthenticationManager 的 authenticate() 方法进行身份认证\n\t\treturn this.getAuthenticationManager().authenticate(authRequest);\n\t&#125;\n&#125;\n\n上面第三步创建的 UsernamePasswordAuthenticationToken 是 Authentication 接口的实现类，见 3.1.4上面第五步将未认证的 Authentication 对象传入 AuthenticationManager 的 authenticate() 方法进行身份认证，见 3.1.5\n3.1.3 AuthenticationSpring Security 的认证主体，在Spring Security 中 Authentication 用来表示当前用户是谁，可以看作 authentication 就是一组用户名密码信息。接口定义如下：\npublic interface Authentication extends Principal, Serializable &#123;\n\n\t&#x2F;&#x2F; 获取用户权限集合\n\tCollection&lt;? extends GrantedAuthority&gt; getAuthorities();\n\n\t&#x2F;&#x2F; 获取用户认证信息，通常是密码等信息\n\tObject getCredentials();\n\n\t&#x2F;&#x2F; 存储有关身份验证请求的其他详细信息。如 IP 地址、证书序列号等\n\tObject getDetails();\n\n\t&#x2F;&#x2F; 获取用户的身份信息，未认证时获取到的是前端请求传入的用户名\n\t&#x2F;&#x2F; 认证成功后为封装用户信息的 UserDetails 对象\n\tObject getPrincipal();\n\n\t&#x2F;&#x2F; 获取当前 Authentication 是否已认证\n\tboolean isAuthenticated();\n\n\t&#x2F;&#x2F; 设置当前 Authentication 是否已认证\n\tvoid setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;\n&#125;\n\n获取当前登录用户信息\n&#x2F;&#x2F; 已登录，获取用户信息\nAuthentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication();\n\nString username &#x3D; authentication.getName(); &#x2F;&#x2F; 获取登录的用户名\nCollection&lt;? extends GrantedAuthority&gt; authorities &#x3D; authentication.getAuthorities(); &#x2F;&#x2F; 用户的所有权限\n&#x2F;&#x2F; 获取封装用户信息的 UserDetails 对象\nUser user &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n\n3.1.4 UsernamePasswordAuthenticationTokenAuthentication 的实现类，旨在简单地显示用户名和密码。principal 和 credentials 应设置为通过其 Object.toString() 方法提供相应属性的对象。最简单的此类对象是字符串\n\n该类有两个构造器，一个用于封装前端请求传入的未认证的用户信息，一个用于封装认证成功后的用户信息\n该类实现的 eraseCredentials() 方法，该方法实现在 3.1.8 其父类 AbstractAuthenticationToken 中\n\npublic class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123;\n\n\tprivate static final long serialVersionUID &#x3D; SpringSecurityCoreVersion.SERIAL_VERSION_UID;\n\tprivate final Object principal;\n\tprivate Object credentials;\n\n\t&#x2F;&#x2F; 用于封装前端请求传入的未认证的用户信息，前面的 authRequest 对象就是调用该构造器进行构造的\n\tpublic UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123;\n\t\tsuper(null); &#x2F;&#x2F; 用户权限为 null\n\t\tthis.principal &#x3D; principal; &#x2F;&#x2F; 前端传入的用户名\n\t\tthis.credentials &#x3D; credentials; &#x2F;&#x2F; 前端传入的密码\n\t\tsetAuthenticated(false); &#x2F;&#x2F; 标记未认证\n\t&#125;\n\n\t&#x2F;&#x2F; 用户封装认证成功后的用户信息\n\tpublic UsernamePasswordAuthenticationToken(Object principal, Object credentials,\n\t\t\tCollection&lt;? extends GrantedAuthority&gt; authorities) &#123;\n\t\tsuper(authorities); &#x2F;&#x2F; 用户权限集合\n\t\tthis.principal &#x3D; principal; &#x2F;&#x2F; 封装认证用户信息的 UserDetails 对象，不再是用户名\n\t\tthis.credentials &#x3D; credentials; &#x2F;&#x2F; 前端传入的密码\n\t\tsuper.setAuthenticated(true); &#x2F;&#x2F; must use super, as we override，标记认证成功\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;\n\n3.1.5 AuthenticationManager校验 Authentication，该接口是认证相关的核心接口，也是认证的入口。在实际开发中，可能有多种不同的认证方式，例如：用户名+密码、邮箱+密码、手机号+验证码等，而这些认证方式的入口始终只有一个，那就是 AuthenticationManager\n如果验证失败会抛出 AuthenticationException 异常。AuthenticationException 是一个抽象类，因此代码逻辑并不能实例化一个 AuthenticationException 异常并抛出，实际上抛出的异常通常是其实现类，如 DisabledException、LockedException、BadCredentialsException 等。接口定义如下，其中可以包含多个 AuthenticationProvider，见 3.1.11 和 3.1.12。通常使用其实现类 ProviderManager\npublic interface AuthenticationManager &#123;\n    Authentication authenticate(Authentication var1) throws AuthenticationException;\n&#125;\n\n\n3.1.6 ProviderManagerProviderManager 是 AuthenticationManager 接口的实现类在 AuthenticationManager 接口的常用实现类 ProviderManager 内部会维护一个 List&lt;AuthenticationProvider&gt; 列表，存放多种认证方式，实际上这是委托者模式（Delegate）的应用。每种认证方式对应着一个 AuthenticationProvider，AuthenticationManager 根据认证方式的不同（根据传入的 Authentication 类型判断）委托对应的 AuthenticationProvider 进行用户认证\npublic class ProviderManager implements AuthenticationManager, MessageSourceAware,\n\t\tInitializingBean &#123;\n\t&#x2F;&#x2F; ~ Static fields&#x2F;initializers\n\t&#x2F;&#x2F; ~ Instance fields\n\n\t&#x2F;&#x2F; 传入未认证的 Authentication 对象\n\tpublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;\n\t\t&#x2F;&#x2F; 1. 获取传入的 Authentication 类型，即 UsernamePasswordAuthenticationToken.class\n\t\tClass&lt;? extends Authentication&gt; toTest &#x3D; authentication.getClass();\n\t\tAuthenticationException lastException &#x3D; null;\n\t\tAuthenticationException parentException &#x3D; null;\n\t\tAuthentication result &#x3D; null;\n\t\tAuthentication parentResult &#x3D; null;\n\t\tboolean debug &#x3D; logger.isDebugEnabled();\n\n\t\t&#x2F;&#x2F; 2. 循环遍历认证方式列表 \n\t\tfor (AuthenticationProvider provider : getProviders()) &#123;\n\t\t\t&#x2F;&#x2F; 3. 判断当前 AuthenticationProvider 是否适用 UsernamePasswordAuthenticationToken.class 类型的 Authentication\n\t\t\tif (!provider.supports(toTest)) &#123;\n\t\t\t\tcontinue;\n\t\t\t&#125;\n\n\t\t\tif (debug) &#123;\n\t\t\t\tlogger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName());\n\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; 成功找到适配当前认证方式的 AuthenticationProvider ，此处为 DaoAuthenticationProvider\n\t\t\ttry &#123;\n\t\t\t\t&#x2F;&#x2F; 4. 调用 DaoAuthenticationProvider 的 authenticate() 方法进行认证\n\t\t\t\t&#x2F;&#x2F; 如果认证成功，会返回一个标记已认证的 Authentication 对象\n\t\t\t\tresult &#x3D; provider.authenticate(authentication);\n\n\t\t\t\tif (result !&#x3D; null) &#123;\n\t\t\t\t\t&#x2F;&#x2F; 5. 认证成功后，将传入的 Authentication 对象中的 details 信息拷贝到已认证的 Authentication 对象中\n\t\t\t\t\tcopyDetails(authentication, result);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tcatch (AccountStatusException | InternalAuthenticationServiceException e) &#123;\n\t\t\t\tprepareException(e, authentication);\n\t\t\t\t&#x2F;&#x2F; SEC-546: Avoid polling additional providers if auth failure is due to\n\t\t\t\t&#x2F;&#x2F; invalid account status\n\t\t\t\tthrow e;\n\t\t\t&#125; catch (AuthenticationException e) &#123;\n\t\t\t\tlastException &#x3D; e;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (result &#x3D;&#x3D; null &amp;&amp; parent !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; Allow the parent to try.\n\t\t\ttry &#123;\n\t\t\t\t&#x2F;&#x2F; 5. 认证失败，使用父类型 AuthenticationManager 进行验证\n\t\t\t\tresult &#x3D; parentResult &#x3D; parent.authenticate(authentication);\n\t\t\t&#125;\n\t\t\tcatch (ProviderNotFoundException e) &#123;\n\t\t\t\t&#x2F;&#x2F; ignore as we will throw below if no other exception occurred prior to\n\t\t\t\t&#x2F;&#x2F; calling parent and the parent\n\t\t\t\t&#x2F;&#x2F; may throw ProviderNotFound even though a provider in the child already\n\t\t\t\t&#x2F;&#x2F; handled the request\n\t\t\t&#125;\n\t\t\tcatch (AuthenticationException e) &#123;\n\t\t\t\tlastException &#x3D; parentException &#x3D; e;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (result !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; 6. 认证成功之后，去除 result 中的敏感信息，要求相关类实现 CredentialsContainer 接口\n\t\t\tif (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123;\n\t\t\t\t&#x2F;&#x2F; Authentication is complete. Remove credentials and other secret data\n\t\t\t\t&#x2F;&#x2F; from authentication\n\t\t\t\t&#x2F;&#x2F; 去除过程就是调用 CredentialsContainer 接口的 eraseCredentials() 方法\n\t\t\t\t((CredentialsContainer) result).eraseCredentials();\n\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; If the parent AuthenticationManager was attempted and successful than it will publish an AuthenticationSuccessEvent\n\t\t\t&#x2F;&#x2F; This check prevents a duplicate AuthenticationSuccessEvent if the parent AuthenticationManager already published it\n\t\t\t&#x2F;&#x2F; 7. 发布认证成功的事件\n\t\t\tif (parentResult &#x3D;&#x3D; null) &#123;\n\t\t\t\teventPublisher.publishAuthenticationSuccess(result);\n\t\t\t&#125;\n\t\t\treturn result;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Parent was null, or didn&#39;t authenticate (or throw an exception).\n\t\t&#x2F;&#x2F; 8. 认证失败之后，抛出失败的异常信息\n\t\tif (lastException &#x3D;&#x3D; null) &#123;\n\t\t\tlastException &#x3D; new ProviderNotFoundException(messages.getMessage(\n\t\t\t\t\t&quot;ProviderManager.providerNotFound&quot;,\n\t\t\t\t\tnew Object[] &#123; toTest.getName() &#125;,\n\t\t\t\t\t&quot;No AuthenticationProvider found for &#123;0&#125;&quot;));\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; If the parent AuthenticationManager was attempted and failed than it will publish an AbstractAuthenticationFailureEvent\n\t\t&#x2F;&#x2F; This check prevents a duplicate AbstractAuthenticationFailureEvent if the parent AuthenticationManager already published it\n\t\tif (parentException &#x3D;&#x3D; null) &#123;\n\t\t\tprepareException(lastException, authentication);\n\t\t&#125;\n\n\t\tthrow lastException;\n\t&#125;\n\t&#x2F;&#x2F; ~ Methods\n&#125;\n\n上面认证成功之后的第六步，调用 CredentialsContainer 接口定义的 eraseCredentials() 方法去除敏感信息，见 3.1.7\n3.1.7 CredentialsContainer表示实现对象包含敏感数据，可以使用 eraseCredentials 方法擦除这些数据。实现应该调用任何内部对象上的方法，这些对象也可以实现这个接口，仅供内部框架使用。编写自己的 AuthenticationProvider 实现的用户应该在那里创建并返回适当的 Authentication 对象，减去任何敏感数据，而不是使用此接口\npublic interface CredentialsContainer &#123;\n\tvoid eraseCredentials();\n&#125;\n\n实现类：\n3.1.8 AbstractAuthenticationToken身份验证对象的基类。使用此类的实现应该是不可变的\npublic abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer &#123;\n\t&#x2F;&#x2F; ~ Instance fields\n\t&#x2F;&#x2F; ~ Constructors\n\n\tpublic void eraseCredentials() &#123;\n\t\t&#x2F;&#x2F; credentials（前端传入的密码）会置为 null\n\t\teraseSecret(getCredentials());\n\t\t&#x2F;&#x2F; principal 在已认证的 Authentication 中是 UserDetails 的实现类，如果该实现类想要去除敏感信息，需要实现\n\t\t&#x2F;&#x2F; CredentialsContainer 的 eraseCredentials() 方法，由于自定义的 User 类没有实现该接口，所以不进行任何操作\n\t\teraseSecret(getPrincipal());\n\t\teraseSecret(details);\n\t&#125;\n\n\tprivate void eraseSecret(Object secret) &#123;\n\t\tif (secret instanceof CredentialsContainer) &#123;\n\t\t\t((CredentialsContainer) secret).eraseCredentials();\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;\n\n3.1.4 的 UsernamePasswordAuthenticationToken 是 AbstractAuthenticationToken 的子类，其 eraseCredentials 方法继承自 AbstractAuthenticationToken\n3.1.9 UserDetailsService加载用户特定数据的核心接口。它在整个框架中用作用户 DAO，并且是 DaoAuthenticationProvider 使用的策略。该接口只需要一种只读方法，这简化了对新数据访问策略的支持\n当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。要自定义逻辑，需要自定义一个实现类实现 UserDetailsService 接口，让 Spring Security 使用我们的 UserDetailsService 。我们自己的 UserDetailsService 可以从数据库中查询用户名和密码\npackage org.springframework.security.core.userdetails;\n\npublic interface UserDetailsService &#123;\n    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;\n&#125;\n\n3.1.9.1 UserDetails上面 loadUserByUsername() 方法的返回值 UserDetails，这个类是系统默认的用户“主体”。提供核心用户信息。出于安全目的，Spring Security 不直接使用实现。它们只是存储用户信息，这些信息随后被封装到 Authentication 对象中。这允许将非安全相关的用户信息（例如电子邮件地址、电话号码等）存储在方便的位置\n@Override\npublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n\treturn new UserDetails() &#123;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示获取登录用户所有权限\n\t\tpublic Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示获取密码\n\t\tpublic String getPassword() &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示获取用户名\n\t\tpublic String getUsername() &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示判断账户是否过期\n\t\tpublic boolean isAccountNonExpired() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示判断账户是否被锁定\n\t\tpublic boolean isAccountNonLocked() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示凭证&#123;密码&#125;是否过期\n\t\tpublic boolean isCredentialsNonExpired() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\t@Override\n\t\t&#x2F;&#x2F; 表示当前用户是否可用\n\t\tpublic boolean isEnabled() &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;;\n&#125;\n\n3.1.9.2 User\nUserDetails 实现类，对 UserDetailsService 检索的核心用户信息进行建模。可以直接使用这个类，或者自定义一个类实现 UserDetails\nequals 和 hashcode 实现仅基于 username 属性，因为其目的是查找相同的用户主体对象（例如，在用户注册表中）将匹配对象代表相同用户的位置，而不仅仅是当所有属性 (权限，例如密码）是相同的\n此实现不是一成不变的。实现了 CredentialsContainer 接口，以允许在身份验证后删除密码。如果将实例存储在内存中并重用它们，可能会导致副作用。如果是这样，要确保每次调用 UserDetailsService 时都返回一个副本可以使用 User 这个实现类返回用户名、密码和权限方法参数 username，表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 username，否则无法接收\n\n3.1.10 PasswordEncoder 接口用于编码密码的服务接口，首选实现是 BCryptPasswordEncoder\npackage org.springframework.security.crypto.password;\n\npublic interface PasswordEncoder &#123;\n\t&#x2F;&#x2F; 表示把参数按照特定的解析规则进行解析\n    String encode(CharSequence rawPassword);\n\n\t&#x2F;* 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；\n\t如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。 *&#x2F;\n    boolean matches(CharSequence rawPassword, String encodedPassword);\n\n\t&#x2F;&#x2F; 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。\n    default boolean upgradeEncoding(String encodedPassword) &#123;\n        return false;\n    &#125;\n&#125;\n\n接口实现类：BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10\n&#x2F;&#x2F; 使用\nBCryptPasswordEncoder bCryptPasswordEncoder &#x3D; new BCryptPasswordEncoder();\n&#x2F;&#x2F; 对密码进行加密\nString fan &#x3D; bCryptPasswordEncoder.encode(&quot;fan&quot;);\n&#x2F;&#x2F; 打印加密之后的数据\nSystem.out.println(&quot;加密之后数据：\\t&quot; + fan);\n&#x2F;&#x2F;判断原字符加密后和加密之前是否匹配\nboolean result &#x3D; bCryptPasswordEncoder.matches(&quot;fan&quot;, fan);\n&#x2F;&#x2F; 打印比较结果\nSystem.out.println(&quot;比较结果：\\t&quot;+result);\n\n\n3.1.11 AbstractUserDetailsAuthenticationProvider\n一个基本的 AuthenticationProvider，它允许子类覆盖和使用 UserDetails 对象。该类旨在响应 UsernamePasswordAuthenticationToken 身份验证请求\n成功验证后，将创建一个 UsernamePasswordAuthenticationToken 并将其返回给调用者。Token 将包括作为其主体的用户名的字符串表示形式或从身份验证存储库返回的 UserDetails\n如果正在使用容器适配器，则适合使用 String ，因为它需要 String 表示用户名。如果需要访问经过身份验证的用户的其他属性，例如电子邮件地址、人性化名称等，则适合使用 UserDetails。由于不建议使用容器适配器，并且 UserDetails 实现提供了额外的灵活性，默认情况下会返回 UserDetails。要覆盖此默认值，可以将 setForcePrincipalAsString 设置为 true\n通过存储放置在 UserCache 中的 UserDetails 对象来处理缓存。这确保了可以验证具有相同用户名的后续请求，而无需查询 UserDetailsService。但需要注意的是，如果用户出现密码错误，将查询 UserDetailsService 以确认是否使用了最新密码进行比较。只有无状态应用程序才可能需要缓存。例如，在普通的 Web 应用程序中，SecurityContext 存储在用户的会话中，并且用户不会在每个请求上重新进行身份验证。因此，默认缓存实现是 NullUserCache\n\npublic abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware &#123;\n\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;\n        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,\n                messages.getMessage(\n                        &quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;,\n                        &quot;Only UsernamePasswordAuthenticationToken is supported&quot;));\n\n        &#x2F;&#x2F; Determine username\n        String username &#x3D; (authentication.getPrincipal() &#x3D;&#x3D; null) ? &quot;NONE_PROVIDED&quot; : authentication.getName();\n\n        boolean cacheWasUsed &#x3D; true;\n\n        &#x2F;&#x2F; 1. 默认从缓存中获取 UserDetails 信息\n        UserDetails user &#x3D; this.userCache.getUserFromCache(username);\n\n        if (user &#x3D;&#x3D; null) &#123;\n            cacheWasUsed &#x3D; false;\n\n            try &#123;\n                &#x2F;&#x2F; 2. 缓存中拿不到就从数据库中获取 UserDetails 信息 默认实现是 DaoAuthenticationProvider 的 retrieveUser方法\n                user &#x3D; retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);\n            &#125;\n            catch (UsernameNotFoundException notFound) &#123;\n                logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;);\n\n                if (hideUserNotFoundExceptions) &#123;\n                    throw new BadCredentialsException(messages.getMessage(\n                            &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,\n                            &quot;Bad credentials&quot;));\n                &#125;\n                else &#123;\n                    throw notFound;\n                &#125;\n            &#125;\n\n            Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;);\n        &#125;\n\n        try &#123;\n            &#x2F;&#x2F; 3. 检查 User 的各种状态, 用户过期, 密码过期等\n            preAuthenticationChecks.check(user);\n            &#x2F;&#x2F; 4. 密码匹配校验, 调用加密类 PasswordEncoder (可以自己定义)\n            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);\n        &#125;\n        catch (AuthenticationException exception) &#123;\n            if (cacheWasUsed) &#123;\n                &#x2F;&#x2F; There was a problem, so try again after checking\n                &#x2F;&#x2F; we&#39;re using latest data (i.e. not from the cache)\n                cacheWasUsed &#x3D; false;\n                user &#x3D; retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);\n                preAuthenticationChecks.check(user);\n                additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);\n            &#125;\n            else &#123;\n                throw exception;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 5. 检查一下一些数据是否过期\n        postAuthenticationChecks.check(user);\n\n        if (!cacheWasUsed) &#123;\n            &#x2F;&#x2F; 6. 将 UserDetails 放入缓存\n            this.userCache.putUserInCache(user);\n        &#125;\n\n        Object principalToReturn &#x3D; user;\n\n        if (forcePrincipalAsString) &#123;\n            principalToReturn &#x3D; user.getUsername();\n        &#125;\n\n        &#x2F;&#x2F; 7. 将用户所有的所有合法角色放入 Token 中的 authorities 中 并且 authenticated 设置为true 表示验证通过了\n        return createSuccessAuthentication(principalToReturn, authentication, user);\n    &#125;\n&#125;\n\n上面第二步，从数据库中获取 UserDetails 信息，默认实现是 DaoAuthenticationProvider 的 retrieveUser方法，见 3.1.12\n3.1.12 DaoAuthenticationProvider从 UserDetailsService 检索用户详细信息的 AuthenticationProvider 实现，提供利用数据库进行身份验证的一个类\npublic class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider &#123;\n\n    protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;\n        prepareTimingAttackProtection();\n        try &#123;\n\n            &#x2F;&#x2F; 重要方法 调用自定义 UserDetailsService 的 loadUserByUsername 方法\n            UserDetails loadedUser &#x3D; this.getUserDetailsService().loadUserByUsername(username);\n            if (loadedUser &#x3D;&#x3D; null) &#123;\n                throw new InternalAuthenticationServiceException(\n                        &quot;UserDetailsService returned null, which is an interface contract violation&quot;);\n            &#125;\n            return loadedUser;\n        &#125;\n        catch (UsernameNotFoundException ex) &#123;\n            mitigateAgainstTimingAttack(authentication);\n            throw ex;\n        &#125;\n        catch (InternalAuthenticationServiceException ex) &#123;\n            throw ex;\n        &#125;\n        catch (Exception ex) &#123;\n            throw new InternalAuthenticationServiceException(ex.getMessage(), ex);\n        &#125;\n    &#125;\n&#125;\n\n3.1.13 AuthenticationEntryPoint 和 AccessDeniedHandler在 Spring Security 中，如果在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到。在 ExceptionTranslationFilter 中会去判断是认证失败还是授权失败出现的异常\n\n如果是认证过程中出现的异常会被封装成 AuthenticationExceptio，然后调用 AuthenticationEntryPoint 对象的方法去进行异常处理\n如果是授权过程中出现的异常会被封装成 AccessDeniedExceptio，然后调用 AccessDeniedHandler 对象的方法去进行异常处理\n\n所以如果需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint 和 AccessDeniedHandler，然后配置给 Spring Security 即可AuthenticationEntryPoint 实现类：AccessDeniedHandler 实现类：\n3.1.14 LoginUrlAuthenticationEntryPoint\n由 ExceptionTranslationFilter 用于通过 UsernamePasswordAuthenticationFilter 开始表单登录身份验证。在 loginFormUrl 属性中保存登录表单的位置，并使用它来构建到登录页面的重定向 URL，从而开始一个认证流程。 或者可以在此属性中设置绝对 URL，并将其专门使用\n使用相对 URL 时，可以将 forceHttps 属性设置为 true，以强制用于登录表单的协议为 HTTPS，即使原始截获的资源请求使用 HTTP 协议也是如此。发生这种情况时，在成功登录（通过 HTTPS）后，原始资源仍将通过原始请求 URL 作为 HTTP 访问。要使强制 HTTPS 功能正常工作，要咨询 PortMapper 以确定 HTTP:HTTPS 对。如果使用绝对 URL，则 forceHttps 的值将不起作用\n\npublic class LoginUrlAuthenticationEntryPoint implements AuthenticationEntryPoint, InitializingBean &#123;\n\n\tprivate static final Log logger &#x3D; LogFactory.getLog(LoginUrlAuthenticationEntryPoint.class);\n\tprivate PortMapper portMapper &#x3D; new PortMapperImpl();\n\tprivate PortResolver portResolver &#x3D; new PortResolverImpl();\n\tprivate String loginFormUrl;\n\n\t&#x2F;&#x2F; 是否强制使用 HTTPS 进行登录认证，默认 false\n\tprivate boolean forceHttps &#x3D; false;\n\n\t&#x2F;&#x2F; 指定是否要使用 forward，默认 false， \n\tprivate boolean useForward &#x3D; false;\n\n\t&#x2F;&#x2F; 跳转到登录页面的重定向策略\n\tprivate final RedirectStrategy redirectStrategy &#x3D; new DefaultRedirectStrategy();\n\n\t&#x2F;&#x2F; loginFormUrl 登录页面的url。使用相对路径（web-app context path 应用上下文路径，包括前缀 &#123;@code &#x2F;&#125;）或绝对 URL\n\tpublic LoginUrlAuthenticationEntryPoint(String loginFormUrl) &#123;\n\t\tAssert.notNull(loginFormUrl, &quot;loginFormUrl cannot be null&quot;);\n\t\tthis.loginFormUrl &#x3D; loginFormUrl;\n\t&#125;\n\n\t&#x2F;&#x2F; InitializingBean 接口定义的方法，在该bean创建后初始化阶段会调用该方法，主要是对属性 loginFormUrl进行格式检查和断言\n\t@Override\n\tpublic void afterPropertiesSet() &#123;\n\t\tAssert.isTrue(StringUtils.hasText(this.loginFormUrl) &amp;&amp; UrlUtils.isValidRedirectUrl(this.loginFormUrl), &quot;loginFormUrl must be specified and must be a valid redirect URL&quot;);\n\t\tAssert.isTrue(!this.useForward || !UrlUtils.isAbsoluteUrl(this.loginFormUrl), &quot;useForward must be false if using an absolute loginFormURL&quot;);\n\t\tAssert.notNull(this.portMapper, &quot;portMapper must be specified&quot;);\n\t\tAssert.notNull(this.portResolver, &quot;portResolver must be specified&quot;);\n\t&#125;\n\n\t&#x2F;&#x2F; Allows subclasses to modify the login form URL that should be applicable for a given request\n\t&#x2F;&#x2F; 确定登录页面的 URL，子类可以覆盖实现该方法修改最终要应用的 URL\n\tprotected String determineUrlToUseForThisRequest(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) &#123;\n\t\treturn getLoginFormUrl();\n\t&#125;\n\n\t&#x2F;&#x2F; Performs the redirect (or forward) to the login form URL.\n\t&#x2F;&#x2F; 执行到 login 表单 URL 的重定向（或转发）\n    @Override\n\tpublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;\n\t\t&#x2F;&#x2F; 是否使用 forward，默认值为 false，取非则为 true，所以不走转发而是重定向\n\t\tif (!this.useForward) &#123;\n\t\t\t&#x2F;&#x2F; redirect to login page. Use https if forceHttps true\n\t\t\t&#x2F;&#x2F; 重定向到 login 页面。如果 forceHttps 为真，则使用 https\n\t\t\tString redirectUrl &#x3D; buildRedirectUrlToLoginPage(request, response, authException);\n\t\t\t&#x2F;&#x2F; 使用 response.sendRedirect(redirectUrl);\n\t\t\tthis.redirectStrategy.sendRedirect(request, response, redirectUrl);\n\t\t\treturn;\n\t\t&#125;\n\t\tString redirectUrl &#x3D; null;\n\t\tif (this.forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) &#123;\n\t\t\t&#x2F;&#x2F; First redirect the current request to HTTPS. When that request is received,\n\t\t\t&#x2F;&#x2F; the forward to the login page will be used.\n\t\t\tredirectUrl &#x3D; buildHttpsRedirectUrlForRequest(request);\n\t\t&#125;\n\t\tif (redirectUrl !&#x3D; null) &#123;\n\t\t\tthis.redirectStrategy.sendRedirect(request, response, redirectUrl);\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 转发\n\t\tString loginForm &#x3D; determineUrlToUseForThisRequest(request, response, authException);\n\t\tlogger.debug(LogMessage.format(&quot;Server side forward to: %s&quot;, loginForm));\n\t\tRequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(loginForm);\n\t\tdispatcher.forward(request, response);\n\t\treturn;\n\t&#125;\n&#125;\n\n3.2 授权流程3.2.1 FilterSecurityInterceptorFilterSecurityInterceptor 是针对某个请求的层级进行拦截和安全检查，是比较常用的。还有支持方法层级的、AspectJ 层级的(更细的方法层级)。继承自AbstractSecurityInterceptor\npublic class FilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123;\n  \n    &#x2F;&#x2F; 权限鉴定入口，由 filter 链进行调用\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n        FilterInvocation fi &#x3D; new FilterInvocation(request, response, chain);\n        &#x2F;&#x2F; 调用开始\n        invoke(fi);\n    &#125;\n  \n    public void invoke(FilterInvocation fi) throws IOException, ServletException &#123;\n  \n        &#x2F;&#x2F; fi.getRequest()一定不为null，observeOncePerRequest 默认为 true\n        &#x2F;&#x2F; getAttribute(FILTER_APPLIED)第一次进来没有值\n        if ((fi.getRequest() !&#x3D; null)\n                &amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) !&#x3D; null)\n                &amp;&amp; observeOncePerRequest) &#123;\n            &#x2F;&#x2F; 进来这里表示已经处理过一次请求了，不需要重新做安全检查\n            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n        &#125;\n        else &#123;\n            &#x2F;&#x2F; 进到这里表示第一次请求，需要进行安全检查\n            if (fi.getRequest() !&#x3D; null &amp;&amp; observeOncePerRequest) &#123;\n                &#x2F;&#x2F;将FILTER_APPLIED标识放入request中\n                fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);\n            &#125;\n\n            InterceptorStatusToken token &#x3D; super.beforeInvocation(fi);\n\n            try &#123;\n                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());\n            &#125;\n            finally &#123;\n                super.finallyInvocation(token);\n            &#125;\n\n            super.afterInvocation(token, null);\n        &#125;\n    &#125;\n&#125;\n\n3.2.2 FilterInvocation保存与 HTTP 过滤器关联的对象，保证请求对象和响应对象是 HttpServletRequest 的实例和 HttpServletResponse 的实例，并且没有 null 对象。为了 Security 框架内的类才能获得对过滤器环境的访问权，以及请求和响应\npublic class FilterInvocation &#123;\n  \n    public FilterInvocation(ServletRequest request, ServletResponse response,\n            FilterChain chain) &#123;\n        &#x2F;&#x2F; 保证获取到非 null 的 request 和 response\n        if ((request &#x3D;&#x3D; null) || (response &#x3D;&#x3D; null) || (chain &#x3D;&#x3D; null)) &#123;\n            throw new IllegalArgumentException(&quot;Cannot pass null values to constructor&quot;);\n        &#125;\n\n        this.request &#x3D; (HttpServletRequest) request;\n        this.response &#x3D; (HttpServletResponse) response;\n        this.chain &#x3D; chain;\n    &#125;\n&#125;\n\n3.2.3 AbstractSecurityInterceptor\n为安全对象实现安全拦截的抽象类。 AbstractSecurityInterceptor 将确保安全拦截器的正确启动配置。它还将实现对安全对象调用的正确处理，即： 从 SecurityContextHolder 中获取 Authentication 对象。通过针对 SecurityMetadataSource 查找安全对象请求来确定请求是与安全调用还是公共调用相关\n对于受保护的调用（有一个用于安全对象调用的 ConfigAttributes 列表）：如果 Authentication.isAuthenticated() 返回 false，或者 alwaysReauthenticate 为 true，则根据配置的 AuthenticationManager 验证请求\n通过身份验证后，将 SecurityContextHolder 上的 Authentication 对象替换为返回的值。根据配置的 AccessDecisionManager 授权请求。通过配置的 RunAsManager 执行任何运行方式替换。将控制权交还给具体的子类，该子类实际上将继续执行对象。返回一个 InterceptorStatusToken，以便在子类完成执行对象后，其 finally 子句可以确保重新调用 AbstractSecurityInterceptor 并使用 finallyInvocation(InterceptorStatusToken) 正确整理\n具体子类将通过 afterInvocation(InterceptorStatusToken, Object) 方法重新调用 AbstractSecurityInterceptor。如果 RunAsManager 替换了 Authentication 对象，则将 SecurityContextHolder 返回到调用 AuthenticationManager 后存在的对象。如果定义了 AfterInvocationManager，则调用调用管理器并允许它替换因返回给调用者的对象。对于公开的调用（安全对象调用没有 ConfigAttributes）：如上所述，具体子类将返回一个 InterceptorStatusToken，随后在执行安全对象后将其重新呈现给 AbstractSecurityInterceptor。当调用其 afterInvocation(InterceptorStatusToken, Object) 时，AbstractSecurityInterceptor 不会采取进一步的行动。控制再次返回到具体的子类，连同应该返回给调用者的对象。然后子类将该结果或异常返回给原始调用者\n\npublic abstract class AbstractSecurityInterceptor implements InitializingBean,ApplicationEventPublisherAware, MessageSourceAware &#123;\n\n\t&#x2F;&#x2F; object为 FilterInvocation\n    protected InterceptorStatusToken beforeInvocation(Object object) &#123;\n        &#x2F;&#x2F; 省略次要代码\n\n        &#x2F;&#x2F; 在此处获取ConfigAttribute集合,是通过调用SecurityMetadataSource的getAttributes方法获取的,\n        &#x2F;&#x2F; 可以使用的自定义的 FilterInvocationSecurityMetadataSource\n        Collection&lt;ConfigAttribute&gt; attributes &#x3D; this.obtainSecurityMetadataSource().getAttributes(object);\n\n        &#x2F;&#x2F; 第一次进来会会获取到 AnonymousAuthenticationToken，是在 AnonymousAuthenticationFilter 中初始化的，也就是匿名请求\n        if (SecurityContextHolder.getContext().getAuthentication() &#x3D;&#x3D; null) &#123;\n            credentialsNotFound(messages.getMessage(\n                    &quot;AbstractSecurityInterceptor.authenticationNotFound&quot;,\n                    &quot;An Authentication object was not found in the SecurityContext&quot;),\n                    object, attributes);\n        &#125;\n\n        &#x2F;&#x2F; 判断是否检查当前身份,验证 Token，并返回 Authentication 对象\n        &#x2F;&#x2F; 第一次进去不符合条件直接返回匿名Token 对象\n        Authentication authenticated &#x3D; authenticateIfRequired();\n\n        &#x2F;&#x2F; 尝试进行授权\n        try &#123;\n            &#x2F;&#x2F; 真正进行鉴定权限的地方通过的方法是在 AccessDecisionManager中的，可以自定义实现类进行使用\n            &#x2F;&#x2F; 第一次进来是匿名Token对象,角色也是 &quot;ROLE_anonymous&quot; 没有一定会抛异常\n            this.accessDecisionManager.decide(authenticated, object, attributes);\n        &#125;\n        catch (AccessDeniedException accessDeniedException) &#123;\n            publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated, accessDeniedException));\n\n            throw accessDeniedException;\n        &#125;\n\n        if (debug) &#123;\n            logger.debug(&quot;Authorization successful&quot;);\n        &#125;\n\n        if (publishAuthorizationSuccess) &#123;\n            publishEvent(new AuthorizedEvent(object, attributes, authenticated));\n        &#125;\n\n        &#x2F;&#x2F; Attempt to run as a different user\n        Authentication runAs &#x3D; this.runAsManager.buildRunAs(authenticated, object, attributes);\n\n        if (runAs &#x3D;&#x3D; null) &#123;\n            if (debug) &#123;\n                logger.debug(&quot;RunAsManager did not change Authentication object&quot;);\n            &#125;\n\n            &#x2F;&#x2F; no further work post-invocation\n            return new InterceptorStatusToken(SecurityContextHolder.getContext(), false, attributes, object);\n        &#125;\n        else &#123;\n            if (debug) &#123;\n                logger.debug(&quot;Switching to RunAs Authentication: &quot; + runAs);\n            &#125;\n\n            SecurityContext origCtx &#x3D; SecurityContextHolder.getContext();\n            SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());\n            SecurityContextHolder.getContext().setAuthentication(runAs);\n\n            &#x2F;&#x2F; need to revert to token.Authenticated post-invocation\n            return new InterceptorStatusToken(origCtx, true, attributes, object);\n        &#125;\n        this.logger.trace(&quot;Did not switch RunAs authentication since RunAsManager returned null&quot;);\n\t\t&#x2F;&#x2F; no further work post-invocation\n\t\treturn new InterceptorStatusToken(SecurityContextHolder.getContext(), false, attributes, object);\n    &#125;\n\n\t&#x2F;** 在安全对象调用完成后完成 AbstractSecurityInterceptor 的工作。\n\tParams：token - 由 beforeInvocation(Object) 方法返回 returnedObject - 从安全对象调用返回的任何对象（可能为 null） \n\tReturns：安全对象调用最终应返回给其调用者的对象（可能为 null）\n\t*&#x2F;\n\tprotected Object afterInvocation(InterceptorStatusToken token, Object returnedObject) &#123;\n\t\tif (token &#x3D;&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; public object\n\t\t\treturn returnedObject;\n\t\t&#125;\n\t\tfinallyInvocation(token); &#x2F;&#x2F; continue to clean in this method for passivity\n\t\tif (this.afterInvocationManager !&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; Attempt after invocation handling\n\t\t\ttry &#123;\n\t\t\t\treturnedObject &#x3D; this.afterInvocationManager.decide(token.getSecurityContext().getAuthentication(),\n\t\t\t\t\t\ttoken.getSecureObject(), token.getAttributes(), returnedObject);\n\t\t\t&#125;\n\t\t\tcatch (AccessDeniedException ex) &#123;\n\t\t\t\tpublishEvent(new AuthorizationFailureEvent(token.getSecureObject(), token.getAttributes(),\n\t\t\t\t\t\ttoken.getSecurityContext().getAuthentication(), ex));\n\t\t\t\tthrow ex;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn returnedObject;\n\t&#125;\n\n\t&#x2F;**\n    如果 Authentication.isAuthenticated() 返回 false 或属性 alwaysReauthenticate 已设置为 true，\n    则检查当前身份验证令牌并将其传递给 AuthenticationManager。返回经过身份验证的 Authentication 对象。\n    *&#x2F;\n\tprivate Authentication authenticateIfRequired() &#123;\n\t\tAuthentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication();\n\t\tif (authentication.isAuthenticated() &amp;&amp; !this.alwaysReauthenticate) &#123;\n\t\t\tif (this.logger.isTraceEnabled()) &#123;\n\t\t\t\tthis.logger.trace(LogMessage.format(&quot;Did not re-authenticate %s before authorizing&quot;, authentication));\n\t\t\t&#125;\n\t\t\treturn authentication;\n\t\t&#125;\n\t\tauthentication &#x3D; this.authenticationManager.authenticate(authentication);\n\t\t&#x2F;&#x2F; Don&#39;t authenticated.setAuthentication(true) because each provider does that\n\t\tif (this.logger.isDebugEnabled()) &#123;\n\t\t\tthis.logger.debug(LogMessage.format(&quot;Re-authenticated %s before authorizing&quot;, authentication));\n\t\t&#125;\n\t\tSecurityContext context &#x3D; SecurityContextHolder.createEmptyContext();\n\t\tcontext.setAuthentication(authentication);\n\t\tSecurityContextHolder.setContext(context);\n\t\treturn authentication;\n\t&#125;\n&#125;\n\n3.2.4 SecurityMetadataSource由存储并可以识别应用于给定安全对象调用的 ConfigAttributes 的类实现\npublic interface SecurityMetadataSource extends AopInfrastructureBean &#123;\n\n\t&#x2F;&#x2F; 访问适用于给定安全对象的 ConfigAttributes\n\tCollection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException;\n\n\t&#x2F;&#x2F; 如果可用，则返回实现类定义的所有 ConfigAttributes\n\t&#x2F;&#x2F; AbstractSecurityInterceptor 使用它来执行针对它配置的每个 ConfigAttribute 的启动时间验证\n\tCollection&lt;ConfigAttribute&gt; getAllConfigAttributes();\n\n\t&#x2F;&#x2F; 指示 SecurityMetadataSource 实现是否能够为指示的安全对象类型提供 ConfigAttributes\n\tboolean supports(Class&lt;?&gt; clazz);\n\n&#125;\n\n继承关系：\n3.2.5 FilterInvocationSecurityMetadataSource继承 SecurityMetadataSource 接口，旨在执行在 FilterInvocations 上键入的查找\npublic interface FilterInvocationSecurityMetadataSource extends SecurityMetadataSource &#123;\n\n&#125;\n\n自定义实现类：\n&#x2F;&#x2F; 自定义认证数据源\n@Service\npublic class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123;\n\n    &#x2F;&#x2F; ant风格的URL匹配\n    AntPathMatcher antPathMatcher &#x3D; new AntPathMatcher();\n\n    @Autowired\n    MenuMapper menuMapper;\n\n    &#x2F;**\n     * @param object  一个FilterInvocation\n     * @return  Collection&lt;ConfigAttribute&gt; 当前请求URL所需的角色\n     * @throws IllegalArgumentException\n     *&#x2F;\n    @Override\n    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;\n        &#x2F;&#x2F; 从FilterInvocation中获取当前请求的URL\n        String requestUrl &#x3D; ((FilterInvocation) object).getRequestUrl();\n        &#x2F;&#x2F; 从数据库中获取所有的资源(角色和menu都查询)信息,可以缓存\n        List&lt;Menu&gt; allMenus &#x3D; menuMapper.getAllMenus();\n        &#x2F;&#x2F; 遍历获取当前请求的URL所需要的角色信息\n        for (Menu menu : allMenus) &#123;\n            if (antPathMatcher.match(menu.getPattern(), requestUrl)) &#123;\n                List&lt;Role&gt; roles &#x3D; menu.getRoles();\n                String[] roleArr &#x3D; new String[roles.size()];\n                for (int i &#x3D; 0; i &lt; roleArr.length; i++) &#123;\n                    roleArr[i] &#x3D; roles.get(i).getName();\n                &#125;\n                return SecurityConfig.createList(roleArr);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 假设不存在URL对应的角色,则登录后即可访问\n        return SecurityConfig.createList(&quot;ROLE_LOGIN&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 获取所有定义好的权限资源\n    @Override\n    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 返回类对象是否支持校验\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) &#123;\n        return FilterInvocation.class.isAssignableFrom(clazz);\n    &#125;\n&#125;\n\n3.2.6 ConfigAttribute存储与安全系统相关的配置属性。设置 org.springframework.security.access.intercept.AbstractSecurityInterceptor 时，会为安全对象模式定义配置属性列表。这些配置属性对 RunAsManager、AccessDecisionManager 或 AccessDecisionManager 的继承类具有特殊意义。在运行时与同一安全对象目标的其他 ConfigAttributes 一起存储。对于AccessDecisionManager 可以用这个列表进行决定访问的对象是否符合安全样式\npublic interface ConfigAttribute extends Serializable &#123;\n\t&#x2F;** 如果 ConfigAttribute 可以表示为字符串，并且该字符串的精度足以被 RunAsManager、AccessDecisionManager 或 AccessDecisionManager 的继承类作为配置参数依赖，\n\t则此方法应返回这样的字符串。如果 ConfigAttribute 不能以足够的精度表示为字符串，则应返回 null。\n\t返回 null 将需要任何依赖类专门支持 ConfigAttribute 实现，因此除非确实需要，否则应避免返回 null。\n\t*&#x2F;\n    String getAttribute();\n&#125;\n\n3.2.7 SecurityConfig将 ConfigAttribute 存储为字符串\npublic class SecurityConfig implements ConfigAttribute &#123;\n\n\tprivate final String attrib;\n\n\tpublic SecurityConfig(String config) &#123;\n\t\tAssert.hasText(config, &quot;You must provide a configuration attribute&quot;);\n\t\tthis.attrib &#x3D; config;\n\t&#125;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;\n\n3.2.8 AccessDecisionManager进行最终的访问控制（授权）决定。当一个请求走完 FilterInvocationSecurityMetadataSource 中的 getAttributes 方法后就会到 AccessDecisionManager 中进行角色信息的对比\npublic interface AccessDecisionManager &#123;\n\n\t&#x2F;&#x2F; Resolves an access control decision for the passed parameters.\n\t&#x2F;&#x2F; 解决传递参数的访问控制决策。\n\tvoid decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException;\n\n\t&#x2F;&#x2F; 指示此 AccessDecisionManager 是否能够处理使用传递的 ConfigAttribute 呈现的授权请求\n\t&#x2F;&#x2F; 这允许 AbstractSecurityInterceptor 检查每个配置属性可以被配置的 AccessDecisionManager and&#x2F;or RunAsManager and&#x2F;or AfterInvocationManager 使用\n\tboolean supports(ConfigAttribute attribute);\n\n\t&#x2F;&#x2F; 指示 AccessDecisionManager 实现是否能够为指示的安全对象类型提供访问控制决策\n\tboolean supports(Class&lt;?&gt; clazz);\n&#125;\n\n自定义实现类：\n@Service\npublic class CustomAccessDecisionManager implements AccessDecisionManager &#123;\n\n\n    &#x2F;* 取当前用户的权限与这次请求的这个url需要的权限作对比，决定是否放行\n     * auth 包含了当前的用户信息，包括拥有的权限,即之前UserDetailsService登录时候存储的用户对象\n     * object 就是FilterInvocation对象，可以得到request等web资源。\n     * configAttributes 是本次访问需要的权限。即上一步的 MyFilterInvocationSecurityMetadataSource 中查询核对得到的权限列表 \n     *&#x2F;\n    @Override\n    public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123;\n        for (ConfigAttribute configAttribute : configAttributes) &#123;\n            if (authentication &#x3D;&#x3D; null)&#123;\n                throw new AccessDeniedException(&quot;当前访问没有权限&quot;);\n            &#125;\n            &#x2F;&#x2F; 当前请求需要的权限\n            String needRole &#x3D; configAttribute.getAttribute();\n            if (&quot;ROLE_LOGIN&quot;.equals(needRole))&#123;\n                if (authentication instanceof AnonymousAuthenticationToken)&#123;\n                    throw new  BadCredentialsException(&quot;未登录&quot;);\n                &#125;\n                return;\n            &#125;\n            &#x2F;&#x2F; 当前用户所具有的权限\n            Collection&lt;? extends GrantedAuthority&gt; authorities &#x3D; authentication.getAuthorities();\n            for (GrantedAuthority authority : authorities) &#123;\n                if (authority.getAuthority().equals(needRole))&#123;\n                    return;\n                &#125;\n            &#125;\n        &#125;\n        throw new AccessDeniedException(&quot;权限不足&quot;);\n    &#125;\n\n    @Override\n    public boolean supports(ConfigAttribute attribute) &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) &#123;\n        return true;\n    &#125;\n&#125;\n\n3.3 整体流程\n\n查看 SecurityContext 接口及其实现类 SecurityContextImpl ， 该类其实就是 对Authentication 的封装\n查看 SecurityContextHolder 类 ，该类其实是对 ThreadLocal 的封装 ， 存储 SecurityContext 对象\n\n在 UsernamePasswordAuthenticationFilter 过滤器认证成功之后，会在认证成功的处理方法中将已认证的用户信息对象 Authentication 封装进 SecurityContext，并存入 SecurityContextHolder。之后，响应会通过 SecurityContextPersistenceFilter 过滤器，将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository（一般用 HttpSession 进行存储），同时清除 SecurityContextHolder 所持有的 SecurityContext\n认证成功的响应通过 SecurityContextPersistenceFilter 过滤器时，从配置好的 SecurityContextRepository 中获取该请求相关的安全上下文信息 SecurityContext，然后加载到 SecurityContextHolder 中。当请求再次到来时，请求首先经过该过滤器，该过滤器会判断当前请求是否存有 SecurityContext 对象，如果有则将该对象取出再次放入 SecurityContextHolder 中，之后该请求所在的线程获得认证用户信息，后续的资源访问不需要进行身份认证；当响应再次返回时，该过滤器同样将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository（一般用 HttpSession 进行存储），同时清除 SecurityContextHolder 所持有的 SecurityContext\n3.3.1 SecurityContext安全上下文，用户通过 Spring Security 的校验之后，验证信息 Authentication 存储在 SecurityContext 中，SecurityContext 存储在 SecurityContextHolder 中。接口定义如下：\npublic interface SecurityContext extends Serializable &#123;\n    &#x2F;&#x2F; 获取当前经过身份验证的主体，或身份验证请求令牌\n    Authentication getAuthentication();\n\n\t&#x2F;&#x2F; 更改当前经过身份验证的主体，或删除身份验证信息\n    void setAuthentication(Authentication var1);\n&#125;\n\n这里只定义了两个方法，主要都是用来获取或修改认证信息（Authentication），Authentication 是用来存储着认证用户的信息，所以这个接口可以间接获取到用户的认证信息\nSecurityContext securityContext &#x3D; SecurityContextHolder.getContext();\nAuthentication authentication &#x3D; securityContext.getAuthentication();\nUser user &#x3D; (User) authentication.getPrincipal();\n\n实现类：\n3.3.2 SecurityContextHolder\n将给定的 SecurityContext 与当前执行线程相关联。此类提供了一系列委托给 SecurityContextHolderStrategy 实例的静态方法。该类的目的是提供一种方便的方法来指定应该用于给定 JVM 的策略。这是 JVM 范围的设置，因为此类中的所有内容都是静态的，以便于调用代码时使用。\n要指定应使用哪种策略，必须提供模式设置。模式设置是定义为静态最终字段的三个有效 MODE_ 设置之一，或者是提供公共无参数构造函数的 SecurityContextHolderStrategy 具体实现的完全限定类名。\n有两种方法可以指定所需的策略模式字符串。第一种是通过在 SYSTEM_PROPERTY 上键入的系统属性来指定它。第二种是在使用类之前调用 setStrategyName(String)。如果这两种方法都没有使用，则该类将默认使用 MODE_THREADLOCAL，它向后兼容，具有较少的 JVM 不兼容性并且适用于服务器（而 MODE_GLOBAL 绝对不适合服务器使用）\n\npublic class SecurityContextHolder &#123;\n\n\tpublic static final String MODE_THREADLOCAL &#x3D; &quot;MODE_THREADLOCAL&quot;;\n\n\tpublic static final String MODE_INHERITABLETHREADLOCAL &#x3D; &quot;MODE_INHERITABLETHREADLOCAL&quot;;\n\n\tpublic static final String MODE_GLOBAL &#x3D; &quot;MODE_GLOBAL&quot;;\n\n\tprivate static final String MODE_PRE_INITIALIZED &#x3D; &quot;MODE_PRE_INITIALIZED&quot;;\n\n\tpublic static final String SYSTEM_PROPERTY &#x3D; &quot;spring.security.strategy&quot;;\n\n\tprivate static String strategyName &#x3D; System.getProperty(SYSTEM_PROPERTY);\n\n\tprivate static SecurityContextHolderStrategy strategy;\n\n\tprivate static int initializeCount &#x3D; 0;\n\n\t&#x2F;&#x2F; ~ Methods\n&#125;\n\n在典型的 Web 应用程序中，用户登录一次，然后由其会话ID标识。服务器缓存持续时间会话的主体信息。但是在 Spring Security 中，在请求之间存储 SecurityContext 的责任落在 SecurityContextPersistenceFilter 上，默认情况下，该过滤器将上下文存储为HTTP请求之间的 HttpSession 属性。请求访问时它会为每个请求恢复上下文 SecurityContextHolder，并且最重要的是，在请求完成时清除 SecurityContextHolder\n4. SpringSecurity Web 权限Spring Security 的核心配置类是 WebSecurityConfigurerAdapter 抽象类，这是权限管理启动的入口\n在 Spring Security 5.7.1 或 SpringBoot 2.7.0 之后，该类被弃用了，改动见 4.8\n4.1 设置登录系统的账号、密码4.1.1 YMLspring:\n  security:\n    user:\n      name: fan\n      password: fan\n\n4.1.2 配置基于内存的角色授权和认证信息继承 WebSecurityConfigurerAdapter，重写 configure(AuthenticationManagerBuilder auth) 方法\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        BCryptPasswordEncoder bCryptPasswordEncoder &#x3D; new BCryptPasswordEncoder();\n        &#x2F;&#x2F; 对密码进行加密\n        String encode &#x3D; bCryptPasswordEncoder.encode(&quot;fan223&quot;);\n        &#x2F;&#x2F; 设置用户名、加密后的密码、权限\n        auth.inMemoryAuthentication().withUser(&quot;fan223&quot;).password(encode).roles(&quot;admin&quot;);\n    &#125;\n\n\t&#x2F;&#x2F; 需要注入一个 PasswordEncoder 的 Bean，不然会报错，找不到 PasswordEncoder\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        &#x2F;&#x2F; return new BCryptPasswordEncoder();\n        return new PasswordEncoder() &#123;\n            @Override\n            public String encode(CharSequence charSequence) &#123;\n            \t&#x2F;&#x2F; 加密\n                return charSequence.toString();\n            &#125;\n\n            @Override\n            public boolean matches(CharSequence charSequence, String s) &#123;\n            \t&#x2F;&#x2F; 比对\n                return Objects.equals(charSequence.toString(), s);\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n4.1.3 配置基于数据库的认证信息和角色授权1、编写实现类，实现 UserDetailsService 接口，实现其 loadUserByUsername(String username) 方法，返回一个 UserDetails 接口的实现类 User 对象，包括用户名、密码、权限2、配置类里将实现类注入进入\n&#x2F;&#x2F; 实现类\n@Service\npublic class MyUserDetailsServiceImpl implements UserDetailsService &#123;\n    @Resource\n    private UserDAO userDAO;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        &#x2F;&#x2F; 通过用户名从数据库查询用户信息\n        fan.springsecuritytest.entity.User selectOne &#x3D; userDAO.selectOne(new QueryWrapper&lt;fan.springsecuritytest.entity.User&gt;().eq(&quot;username&quot;, username));\n        if (ObjectUtils.isEmpty(selectOne))&#123;\n            throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F; 权限列表，应从数据库中查\n        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role, ROLE_sale&quot;);\n        &#x2F;&#x2F; 给用户设置权限和角色\n        return new User(selectOne.getUsername(), new BCryptPasswordEncoder().encode(selectOne.getPassword()), authorities);\n    &#125;\n&#125;\n&#x2F;&#x2F; 配置类，注入 UserDetailsServiceImpl\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n\t&#x2F;&#x2F; 注入 PasswordEncoder 类到 Spring 容器中，用来对密码进行加密\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n\n4.2 自定义表单认证登录（重要）4.2.1 配置类&#x2F;&#x2F; 配置类\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl; &#x2F;&#x2F; UserDetailsService 实现类\n\n\t@Resource\n    private AuthenticationSuccessHandler loginSuccessHandler; &#x2F;&#x2F; 认证成功结果处理器\n    &#x2F;&#x2F; 或 private LoginSuccessHandler loginSuccessHandler;\n    @Resource\n    private AuthenticationFailureHandler loginFailureHandler; &#x2F;&#x2F; 认证失败结果处理器\n    &#x2F;&#x2F; 或 private LoginFailureHandler loginFailureHandler;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n\t&#x2F;&#x2F; 注入 PasswordEncoder 类到 Spring 容器中，用来对密码进行加密\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.csrf().disable() &#x2F;&#x2F; 关闭跨站 csrf 攻击防护\n            &#x2F;&#x2F; 1.配置权限认证\n            .authorizeRequests()\n                &#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n                .antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;login&quot;, &quot;&#x2F;user&#x2F;login&quot;).permitAll()\n                &#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要 admin 权限才能访问该路径\n                .antMatchers(&quot;&#x2F;web&#x2F;admin&#x2F;**&quot;).hasAnyAuthority(&quot;admin&quot;)\n                .anyRequest() &#x2F;&#x2F; 任何其他请求\n                .authenticated(); &#x2F;&#x2F; 都需要认证\n                .and()\n            &#x2F;&#x2F; 2. 配置登录表单认证方式\n            .formLogin()\n                &#x2F;* 用户未登录时，访问任何资源都跳转到该路径，即登录页面，需要将这个地址设置为不认证也可以访问。如果不这样设置，\n                页面会提示“重定向次数过多”。因为登录的时候会访问 &quot;login&quot; 路径，设置新的登录地址后，一直来访问新的这个地址，\n                但是这个地址必须登录才可以访问，所以一直循环这样调用，就会出现重定向次数过多。需要在 Controller 中映射。 *&#x2F;\n                .loginPage(&quot;&#x2F;login&quot;)\n                &#x2F;&#x2F; 登录表单 form 中 action 的地址，也就是处理认证请求的路径，这个路径也需要放开，但不需要在 Controller 中映射\n                .loginProcessingUrl(&quot;&#x2F;user&#x2F;login&quot;)\n                &#x2F;&#x2F; 登录表单 form 中用户名输入框 input 的 name 名， 不改的话默认是 username\n                .usernameParameter(&quot;uname&quot;)\n                &#x2F;&#x2F; form 中密码输入框 input 的 name 名，不改默认是 password\n                .passwordParameter(&quot;pword&quot;)\n                &#x2F;&#x2F; .defaultSuccessUrl(&quot;&#x2F;success&quot;) &#x2F;&#x2F;登录认证成功后默认转跳的路径，与 successForwardUrl同效果\n                &#x2F;&#x2F; 登录成功跳转路径，假如不是直接访问 &#x2F;login，而是其他请求被拦截跳转到 &#x2F;login，则登录成功会转发到拦截的请求路径，不会跳转到该路径\n                .successForwardUrl(&quot;&#x2F;success&quot;)\n                .failureForwardUrl(&quot;&#x2F;error&quot;) &#x2F;&#x2F; 登录失败跳转路径，假如不设置就默认跳转到登录页\n                 &#x2F;&#x2F; 使用自定义的登录成功结果处理器\n                .successHandler(loginSuccessHandler)\n                &#x2F;&#x2F; 使用自定义登录失败的结果处理器\n                .failureHandler(loginFailureHandler)\n                .and()\n            &#x2F;&#x2F; 3. 注销\n            .logout()\n                .logoutUrl(&quot;&#x2F;logout&quot;) &#x2F;&#x2F; 配置注销登录请求URL为 &quot;&#x2F;logout&quot;（默认也就是 &#x2F;logout）\n                &#x2F;&#x2F; 使用自定义的注销成功结果处理器（优先级高）\n                .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n                &#x2F;&#x2F; 退出成功后跳转的路径\n                .logoutSuccessUrl(&quot;&#x2F;login&quot;)\n                .clearAuthentication(true) &#x2F;&#x2F; 清除身份认证信息\n                .invalidateHttpSession(true) &#x2F;&#x2F;使Http会话无效\n                .permitAll() &#x2F;&#x2F; 允许访问登录表单、登录接口\n                .and()\n            &#x2F;&#x2F; 4. session管理\n            .sessionManagement()\n                .invalidSessionUrl(&quot;&#x2F;login&quot;) &#x2F;&#x2F;失效后跳转到登陆页面\n                &#x2F;&#x2F;单用户登录，如果有一个登录了，同一个用户在其他地方登录将前一个剔除下线\n                &#x2F;&#x2F;.maximumSessions(1).expiredSessionStrategy(expiredSessionStrategy())\n                &#x2F;&#x2F;单用户登录，如果有一个登录了，同一个用户在其他地方不能登录\n                &#x2F;&#x2F;.maximumSessions(1).maxSessionsPreventsLogin(true);\n\t\thttp.headers().frameOptions().disable(); &#x2F;&#x2F; 开启运行iframe嵌套页面\n    &#125;\n  \n\t@Override\n\tpublic void configure(WebSecurity web) throws Exception &#123;\n\t\t&#x2F;&#x2F; 不进行认证的路径，可以直接访问，可以配置静态资源路径\n        web.ignoring().antMatchers(&quot;&#x2F;static&#x2F;**&quot;);\n\t&#125;\n&#125;\n\n4.2.2 配置静态资源仅仅通过 Spring Security 配置是不够的，还需要去重写 addResourceHandlers 方法去映射静态资源。写一个类 WebMvcConfig 继承 WebMvcConfigurationSupport\n@Configuration\npublic class WebMvcConfig extends WebMvcConfigurationSupport &#123;\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        registry.addResourceHandler(&quot;&#x2F;static&#x2F;**&quot;)\n                .addResourceLocations(&quot;classpath:&#x2F;static&#x2F;&quot;);\n        super.addResourceHandlers(registry);\n    &#125;\n&#125;\n\n4.2.3 配置错误页面（非必要）可以不进行配置，只需对应错误页面放在 &#x2F;error 文件夹下即可\n@Configuration\npublic class ErrorPageConfig &#123;\n\n    @Bean\n    public WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer() &#123;\n        WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer &#x3D; new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123;\n            @Override\n            public void customize(ConfigurableWebServerFactory factory) &#123;\n                ErrorPage[] errorPages &#x3D; new ErrorPage[] &#123;\n                        new ErrorPage(HttpStatus.FORBIDDEN, &quot;&#x2F;403&quot;),\n                        new ErrorPage(HttpStatus.NOT_FOUND, &quot;&#x2F;404&quot;),\n                        new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;&#x2F;500&quot;),\n                &#125;;\n                factory.addErrorPages(errorPages);\n            &#125;\n        &#125;;\n        return webServerFactoryCustomizer;\n    &#125;\n&#125;\n\n4.2.4 Controller&#x2F;&#x2F; Controller\n@Controller\npublic class TestController &#123;\n    @GetMapping(&quot;&#x2F;login&quot;) &#x2F;&#x2F; 登录页面映射 .loginPage(&quot;&#x2F;login&quot;)\n    public String login()&#123;\n        return &quot;login&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;error&quot;) &#x2F;&#x2F; 错误页面映射 .failureForwardUrl(&quot;&#x2F;error&quot;) &#x2F;&#x2F; 登录失败跳转路径\n    public String error()&#123;\n        return &quot;error&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;success&quot;) &#x2F;&#x2F; 成功页面映射 .successForwardUrl(&quot;&#x2F;success&quot;) &#x2F;&#x2F; 登录成功跳转路径\n    public String success()&#123;\n        return &quot;success&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;hello&quot;) &#x2F;&#x2F; 不需要认证即可访问页面映射\n    public String hello()&#123;\n        return &quot;&#x2F;hello&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;test&quot;) &#x2F;&#x2F; 需要认证才可访问，访问该路径会自动跳转到 &#x2F;login，登录成功后才会转发到该路径\n    @ResponseBody\n    public String test()&#123;\n        return &quot;test 请求&quot;;\n    &#125;\n&#125;\n\n4.2.5 自定义权限决策管理器@Component\npublic class CustomAccessDecisionManager implements AccessDecisionManager &#123;\n\n    &#x2F;* 取当前用户的权限与这次请求的这个url需要的权限作对比，决定是否放行\n     * auth 包含了当前的用户信息，包括拥有的权限,即之前UserDetailsService登录时候存储的用户对象\n     * object 就是FilterInvocation对象，可以得到request等web资源。\n     * configAttributes 是本次访问需要的权限。即上一步的 MyFilterInvocationSecurityMetadataSource 中查询核对得到的权限列表 \n     *&#x2F;\n    @Override\n    public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123;\n        for (ConfigAttribute configAttribute : configAttributes) &#123;\n            if (authentication &#x3D;&#x3D; null)&#123;\n                throw new AccessDeniedException(&quot;当前访问没有权限&quot;);\n            &#125;\n            &#x2F;&#x2F; 当前请求需要的权限\n            String needRole &#x3D; configAttribute.getAttribute();\n            if (&quot;ROLE_LOGIN&quot;.equals(needRole))&#123;\n                if (authentication instanceof AnonymousAuthenticationToken)&#123;\n                    throw new  BadCredentialsException(&quot;未登录&quot;);\n                &#125;\n                return;\n            &#125;\n            &#x2F;&#x2F; 当前用户所具有的权限\n            Collection&lt;? extends GrantedAuthority&gt; authorities &#x3D; authentication.getAuthorities();\n            for (GrantedAuthority authority : authorities) &#123;\n                if (authority.getAuthority().equals(needRole))&#123;\n                    return;\n                &#125;\n            &#125;\n        &#125;\n        throw new AccessDeniedException(&quot;权限不足&quot;);\n    &#125;\n\n    @Override\n    public boolean supports(ConfigAttribute attribute) &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) &#123;\n        return true;\n    &#125;\n&#125;\n\n4.2.6 登录认证成功处理器在 UsernamePasswordAuthenticationFilter 进行登录认证的时候，如果登录成功了会调用 AuthenticationSuccessHandler 的方法进行认证成功后的处理。AuthenticationSuccessHandler 就是登录成功处理器\n@Component\n&#x2F;&#x2F; 继承实现类 public class LoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler &#123;\n&#x2F;&#x2F; 实现接口\npublic class LoginSuccessHandler implements AuthenticationSuccessHandler &#123;\n    @Resource\n    private ObjectMapper objectMapper;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;\n        &#x2F;&#x2F; 获取前端传到后端的全部参数\n        Enumeration&lt;String&gt; parameterNames &#x3D; request.getParameterNames();\n        while (parameterNames.hasMoreElements()) &#123;\n            String paraName &#x3D; parameterNames.nextElement();\n            System.out.println(&quot;参数- &quot; + paraName + &quot; : &quot; + request.getParameter(paraName));\n        &#125;\n        &#x2F;&#x2F; 这里写登录成功后的逻辑，可以验证其他信息，如验证码等。\n&#x2F;&#x2F;        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);\n&#x2F;&#x2F;        JSONObject jsonObject &#x3D; new JSONObject();\n&#x2F;&#x2F;        jsonObject.putOnce(&quot;code&quot;, HttpStatus.OK.value());\n&#x2F;&#x2F;        jsonObject.putOnce(&quot;msg&quot;,&quot;登录成功&quot;);\n&#x2F;&#x2F;        jsonObject.putOnce(&quot;authentication&quot;,objectMapper.writeValueAsString(authentication));\n\t\t&#x2F;&#x2F; 返回响应信息\n&#x2F;&#x2F;\t\tresponse.getWriter().write(jsonObject.toString());\n        try &#123;\n        \t&#x2F;&#x2F; 重定向，等同于 .successForwardUrl(&quot;&#x2F;success&quot;)\n            this.getRedirectStrategy().sendRedirect(request, response, &quot;&#x2F;success&quot;);\n        &#125; catch (JsonProcessingException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n4.2.7 登录认证失败处理器在 UsernamePasswordAuthenticationFilter 进行登录认证的时候，如果认证失败了会调用 AuthenticationFailureHandler 的方法进行认证失败后的处理。AuthenticationFailureHandler 就是登录失败处理器\n@Component\n&#x2F;&#x2F; public class LoginFailureHandler extends SimpleUrlAuthenticationFailureHandler &#123;\npublic class LoginFailureHandler implements AuthenticationFailureHandler &#123;\n\n\t@Resource\n    private ObjectMapper objectMapper;\n\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) &#123;\n        this.saveException(request, exception);\n&#x2F;&#x2F;        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);\n        &#x2F;&#x2F; 这里写登录失败后的逻辑，可加验证码验证等\n&#x2F;&#x2F;        String errorInfo &#x3D; &quot;&quot;;\n&#x2F;&#x2F;        if (exception instanceof BadCredentialsException ||\n&#x2F;&#x2F;                exception instanceof UsernameNotFoundException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户名或者密码输入错误!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof LockedException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户被锁定，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof CredentialsExpiredException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;密码过期，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof AccountExpiredException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户过期，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else if (exception instanceof DisabledException) &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;账户被禁用，请联系管理员!&quot;;\n&#x2F;&#x2F;        &#125; else &#123;\n&#x2F;&#x2F;            errorInfo &#x3D; &quot;登录失败!&quot;;\n&#x2F;&#x2F;        &#125;\n        &#x2F;&#x2F; ajax请求认证方式\n&#x2F;&#x2F;        JSONObject resultObj &#x3D; new JSONObject();\n&#x2F;&#x2F;        resultObj.putOnce(&quot;code&quot;, HttpStatus.UNAUTHORIZED.value());\n&#x2F;&#x2F;        resultObj.putOnce(&quot;msg&quot;,errorInfo);\n&#x2F;&#x2F;        resultObj.putOnce(&quot;exception&quot;,objectMapper.writeValueAsString(exception));\n&#x2F;&#x2F;        response.getWriter().write(resultObj.toString());\n        try &#123;\n            this.getRedirectStrategy().sendRedirect(request, response, &quot;&#x2F;login&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n4.2.8 注销成功处理器\npublic class CustomLogoutSuccessHandler implements LogoutSuccessHandler &#123;\n\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication) &#123;\n        &#x2F;&#x2F; 返回响应信息\n        response.setStatus(HttpStatus.OK.value());\n        response.setContentType(&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);\n        try &#123;\n            response.getWriter().write(&quot;注销成功!&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n4.2.9 登录页面的 Form 表单&lt;form action&#x3D;&quot;&#x2F;user&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt; &lt;!-- action 与配置类的 loginProcessingUrl 对应 --&gt;\n\t&lt;!-- name 与配置类设置的 usernameParameter 对应，不设置默认为 username --&gt;\n\t用户名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;uname&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n\t&lt;!-- name 与配置类设置的 passwordParameter 对应，不设置默认为 password --&gt;\n\t密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pword&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n\t&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n4.3 基于角色或权限进行访问控制4.3.1 hasAuthority() 方法如果当前的主体具有指定的权限，则返回 true，否则返回 false\n&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体带有 admin 权限才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasAuthority(&quot;admin&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;\n&#x2F;&#x2F; 实现类\n@Service\npublic class MyUserDetailsServiceImpl implements UserDetailsService &#123;\n    @Resource\n    private UserDAO userDAO;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        fan.springsecuritytest.entity.User selectOne &#x3D; userDAO.selectOne(new QueryWrapper&lt;fan.springsecuritytest.entity.User&gt;().eq(&quot;username&quot;, username));\n        if (ObjectUtils.isEmpty(selectOne))&#123;\n            throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F; 设置权限，为 role，不可访问需要 admin 权限的路径\n        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;);\n        return new User(selectOne.getUsername(), new BCryptPasswordEncoder().encode(selectOne.getPassword()), authorities);\n    &#125;\n&#125;\n\n无权限访问， Forbidden 403\n4.3.2 hasAnyAuthority() 方法如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回 true\n&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体带有 admin或role 权限才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasAnyAuthority(&quot;admin&quot;, &quot;role&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;\n\n\n4.3.3 hasRole() 方法如果用户具备给定角色就允许访问，否则出现 403。如果当前主体具有指定的角色，则返回 true由于底层源码给设定的 role 加上了前缀 “ROLE_”，所以给主体设定角色时，也要加上前缀\n&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体为 sale 角色才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasRole(&quot;sale&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;\n&#x2F;&#x2F; 实现类\n@Service\npublic class MyUserDetailsServiceImpl implements UserDetailsService &#123;\n    @Resource\n    private UserDAO userDAO;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        fan.springsecuritytest.entity.User selectOne &#x3D; userDAO.selectOne(new QueryWrapper&lt;fan.springsecuritytest.entity.User&gt;().eq(&quot;username&quot;, username));\n        if (ObjectUtils.isEmpty(selectOne))&#123;\n            throw new UsernameNotFoundException(&quot;用户名不存在！&quot;);\n        &#125;\n        &#x2F;&#x2F; 角色加上前缀\n        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role, ROLE_sale&quot;);\n        return new User(selectOne.getUsername(), new BCryptPasswordEncoder().encode(selectOne.getPassword()), authorities);\n    &#125;\n&#125;\n\n4.3.4 hasAnyRole() 方法表示用户具备任何一个角色都可以访问\n&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\thttp.authorizeRequests()\n\t\t&#x2F;&#x2F; 不需要通过登录验证就可以被访问到的资源路径\n\t\t.antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;hello&quot;, &quot;&#x2F;login&quot;).permitAll()\n\t\t&#x2F;&#x2F; 前面是资源的访问路径，后面是资源的名称或资源 ID，需要主体为 sale或sale1 角色才可访问\n\t\t.antMatchers(&quot;&#x2F;test&quot;).hasAnyRole(&quot;sale&quot;, &quot;sale1&quot;)\n\t\t.anyRequest().authenticated(); &#x2F;&#x2F; 其他请求需要认证\n&#125;\n\n3.3.5 自定义没有权限访问页面（非必要）&#x2F;&#x2F; 配置类\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\t&#x2F;&#x2F; 没有权限访问跳转到该路径\n\thttp.exceptionHandling().accessDeniedPage(&quot;&#x2F;forbidden&quot;);\n&#125;\n\n4.4 注解使用4.4.1 @Secured开启注解\n\n\n\n\n\n\n\n\n\n@EnableGlobalMethodSecurity(securedEnabled&#x3D;true)\n可以加在启动类上，也可以在配置类上@Secured 判断是否具有角色，只有具有该角色才可以进行访问，这里匹配的字符串需要添加前缀 “ROLE_“\n&#x2F;&#x2F; Controller 方法\n@GetMapping(&quot;&#x2F;demo01&quot;)\n@ResponseBody\n@Secured(value &#x3D; &#123;&quot;ROLE_sale&quot;, &quot;ROLE_sale1&quot;&#125;) &#x2F;&#x2F; 加上注解\npublic String demo01()&#123;\n\treturn &quot;demo01 请求&quot;;\n&#125;\n\n4.4.2 @PreAuthorize进入方法前的权限验证， @PreAuthorize 可以将登录用户的 roles&#x2F;permissions 参数传到方法中\n\n\n\n\n\n\n\n\n\n@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)\n&#x2F;&#x2F; Controller 方法\n@GetMapping(&quot;&#x2F;demo01&quot;)\n@ResponseBody\n@PreAuthorize(&quot;hasAnyAuthority(&#39;role&#39;)&quot;)\npublic String demo01()&#123;\n\treturn &quot;demo01 请求&quot;;\n&#125;\n\n4.4.3 @PostAuthorize\n\n\n\n\n\n\n\n\n@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)\n@PostAuthorize 注解使用并不多，在方法执行后再进行权限验证，适合验证带有返回值的权限\n@GetMapping(&quot;&#x2F;demo02&quot;)\n@ResponseBody\n@PostAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;)&quot;)\npublic String demo02()&#123;\n\tSystem.out.println(&quot;返回前执行的方法！&quot;);\n\treturn &quot;demo02 请求&quot;;\n&#125;\n\n4.4.4 @PreFilter进入控制器之前对数据进行过滤，假如值取模 2 为 0，则输出\n@RequestMapping(&quot;getTestPreFilter&quot;)\n@PreAuthorize(&quot;hasRole(&#39;ROLE_管理员&#39;)&quot;)\n@PreFilter(value &#x3D; &quot;filterObject.id%2&#x3D;&#x3D;0&quot;)\n@ResponseBody\npublic List&lt;UserInfo&gt; getTestPreFilter(@RequestBody List&lt;UserInfo&gt; list)&#123;\n\tlist.forEach(t -&gt; &#123;\n\t\tSystem.out.println(t.getId() + &quot;\\t&quot; + t.getUsername());\n\t&#125;);\n\treturn list;\n&#125;\n\n4.4.5 @PostFilter权限验证之后对数据进行过滤 留下用户名是 admin1 的数据，表达式中的 filterObject 引用的是方法返回值 List 中的某一个元素\n@GetMapping(&quot;&#x2F;demo01&quot;)\n@PreAuthorize(&quot;hasRole(&#39;ROLE_sale&#39;)&quot;)\n@PostFilter(&quot;filterObject.username &#x3D;&#x3D; &#39;admin1&#39;&quot;)\n@ResponseBody\npublic List&lt;UserInfo&gt; getAllUser()&#123;\n\tArrayList&lt;UserInfo&gt; list &#x3D; new ArrayList&lt;&gt;();\n\tlist.add(new UserInfo(1l,&quot;admin1&quot;,&quot;6666&quot;));\n\tlist.add(new UserInfo(2l,&quot;admin2&quot;,&quot;888&quot;));\n\treturn list;\n&#125;\n\n4.5 基于数据库的记住我\n4.5.1 SQL\n\n\n\n\n\n\n\n\njdbcTokenRepository.setCreateTableOnStartup(true);\n该语句会自动在数据库中创建一个存放 Token 及相关信息的一个表，表名为 persistent_logins，也可以手动创建该表，不执行该语句。只有数据库中不存在该表需要创建表才执行。\nCREATE TABLE &#96;persistent_logins&#96; (\n  &#96;username&#96; varchar(64) NOT NULL,\n  &#96;series&#96; varchar(64) NOT NULL,\n  &#96;token&#96; varchar(64) NOT NULL,\n  &#96;last_used&#96; timestamp NOT NULL,\n  PRIMARY KEY (&#96;series&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\n\n4.5.2 添加记住我功能\nimport org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl;\n\n\t&#x2F;&#x2F; 注入数据源\n    @Resource\n    private DataSource dataSource;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n\t@Bean\n    public PersistentTokenRepository persistentTokenRepository()&#123;\n        JdbcTokenRepositoryImpl jdbcTokenRepository &#x3D; new JdbcTokenRepositoryImpl();\n        &#x2F;&#x2F; 赋值数据源\n        jdbcTokenRepository.setDataSource(dataSource);\n        &#x2F;&#x2F; 自动创建表, 第一次执行会创建，以后要执行就要删除掉！\n        jdbcTokenRepository.setCreateTableOnStartup(true);\n        return jdbcTokenRepository;\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n    \t&#x2F;&#x2F; 开启记住我功能\n        http.rememberMe()\n\t        .userDetailsService(myUserDetailsServiceImpl)\n\t        .tokenRepository(persistentTokenRepository());\n    &#125;\n&#125;\n\n4.5.3 登录页面&lt;form action&#x3D;&quot;&#x2F;user&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt;\n  用户名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;uname&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n  密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pword&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n  &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;\n  &lt;!-- 设置 name 为 remeber-me --&gt;\n  记住我：&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;remember-me&quot; title&#x3D;&quot;记住密码&quot;&#x2F;&gt;&lt;br&#x2F;&gt;\n&lt;&#x2F;form&gt;\n\n4.5.4 设置有效期@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n\t&#x2F;&#x2F; 开启记住我功能\n\thttp.rememberMe()\n\t\t.userDetailsService(myUserDetailsServiceImpl)\n\t\t.tokenRepository(persistentTokenRepository())\n\t\t.tokenValiditySeconds(100); &#x2F;&#x2F; 设置过期时间为 100 秒，单位为秒\n&#125;\n\n4.6 用户注销4.6.1 退出链接&lt;!-- 与配置类的 .logoutUrl(&quot;&#x2F;logout&quot;) 对应 --&gt;\n&lt;a href&#x3D;&quot;&#x2F;logout&quot;&gt;退出&lt;&#x2F;a&gt;\n\n4.6.2 配置类@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    @Resource\n    private UserDetailsService myUserDetailsServiceImpl;\n  \n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(myUserDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n    @Bean\n    PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n    \t&#x2F;&#x2F; 添加退出映射地址\n        http.logout()\n\t\t\t.logoutUrl(&quot;&#x2F;logout&quot;) &#x2F;&#x2F; 与退出链接对应\n\t\t\t&#x2F;&#x2F; 退出成功后跳转的地址，可以使用自定义退出成功处理器\n\t\t\t.logoutSuccessUrl(&quot;&#x2F;login&quot;).permitAll();\n    &#125;\n&#125;\n\n4.7 CSRF4.7.1 概念跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任\n跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的\n从 Spring Security 4.0 开始，默认情况下会启用 CSRF 保护，以防止 CSRF 攻击应用程序，Spring Security CSRF 会针对 PATCH，POST，PUT 和 DELETE 方法进行防护\n4.7.2 Spring Security 防御机制4.7.2.1 Csrf Token用户登录时，系统发放一个 CsrfToken 值，用户携带该 CsrfToken 值与用户名、密码等参数完成登录。系统记录该会话的 CsrfToken 值，之后在用户的任何请求中，都必须带上该 CsrfToken 值，并由系统进行校验\n4.7.2.2 SpringSecurity 中使用 Csrf TokenSpring Security 通过注册一个 CsrfFilter 来专门处理 CSRF 攻击，在 Spring Security 中，CsrfToken 是一个用于描述 Token 值，以及验证时应当获取哪个请求参数或请求头字段的接口\npublic interface CsrfToken extends Serializable &#123;\n\t&#x2F;&#x2F; 获取 _csrf 参数的 key\n    String getHeaderName();\n    String getParameterName();\n\n\t&#x2F;&#x2F; 获取 _csrf 参数的 value\n    String getToken();\n&#125;\npublic interface CsrfTokenRepository &#123;\n\t&#x2F;&#x2F; CsrfToken 的生成过程\n    CsrfToken generateToken(HttpServletRequest request);\n\n\t&#x2F;&#x2F; 保存 CsrfToken\n    void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response);\n\n\t&#x2F;&#x2F; 如何加载 CsrfToken\n    CsrfToken loadToken(HttpServletRequest request);\n&#125;\n\n实现类：默认使用的是 DefaultCsrfToken默认使用的是 HttpSessionCsrfTokenRepository\n4.7.2.3 HttpSessionCsrfTokenRepository在默认情况下，Spring Security 加载的是一个HttpSessionCsrfTokenRepository，将 CsrfToken 值存储在 HttpSession 中，并指定前端把 CsrfToken 值放在名为 “_csrf” 的请求参数或名为 “X-CSRF-TOKEN” 的请求头字段里（可以调用相应的设置方法来重新设定）。校验时，通过对比 HttpSession 内存储的 CsrfToken 值与前端携带的 CsrfToken 值是否一致，便能断定本次请求是否为 CSRF 攻击\npublic final class HttpSessionCsrfTokenRepository implements CsrfTokenRepository &#123;\n    private static final String DEFAULT_CSRF_PARAMETER_NAME &#x3D; &quot;_csrf&quot;;\n    private static final String DEFAULT_CSRF_HEADER_NAME &#x3D; &quot;X-CSRF-TOKEN&quot;;\n    private static final String DEFAULT_CSRF_TOKEN_ATTR_NAME &#x3D; HttpSessionCsrfTokenRepository.class.getName().concat(&quot;.CSRF_TOKEN&quot;);\n    private String parameterName &#x3D; &quot;_csrf&quot;;\n    private String headerName &#x3D; &quot;X-CSRF-TOKEN&quot;;\n    private String sessionAttributeName;\n\n    public HttpSessionCsrfTokenRepository() &#123;\n        this.sessionAttributeName &#x3D; DEFAULT_CSRF_TOKEN_ATTR_NAME;\n    &#125;\n\n    public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) &#123;\n        HttpSession session;\n        if (token &#x3D;&#x3D; null) &#123;\n            session &#x3D; request.getSession(false);\n            if (session !&#x3D; null) &#123;\n                session.removeAttribute(this.sessionAttributeName);\n            &#125;\n        &#125; else &#123;\n            session &#x3D; request.getSession();\n            session.setAttribute(this.sessionAttributeName, token);\n        &#125;\n\n    &#125;\n\n    public CsrfToken loadToken(HttpServletRequest request) &#123;\n        HttpSession session &#x3D; request.getSession(false);\n        return session &#x3D;&#x3D; null ? null : (CsrfToken)session.getAttribute(this.sessionAttributeName);\n    &#125;\n\n    public CsrfToken generateToken(HttpServletRequest request) &#123;\n        return new DefaultCsrfToken(this.headerName, this.parameterName, this.createNewToken());\n    &#125;\n\n    public void setParameterName(String parameterName) &#123;\n        Assert.hasLength(parameterName, &quot;parameterName cannot be null or empty&quot;);\n        this.parameterName &#x3D; parameterName;\n    &#125;\n\n    public void setHeaderName(String headerName) &#123;\n        Assert.hasLength(headerName, &quot;headerName cannot be null or empty&quot;);\n        this.headerName &#x3D; headerName;\n    &#125;\n\n    public void setSessionAttributeName(String sessionAttributeName) &#123;\n        Assert.hasLength(sessionAttributeName, &quot;sessionAttributename cannot be null or empty&quot;);\n        this.sessionAttributeName &#x3D; sessionAttributeName;\n    &#125;\n\n    private String createNewToken() &#123;\n        return UUID.randomUUID().toString();\n    &#125;\n&#125;\n\n\nsaveToken 方法将 CsrfToken 保存在 HttpSession 中，将来再从 HttpSession 中取出和前端传来的参数做比较\nloadToken 方法当然就是从 HttpSession 中读取 CsrfToken 出来\ngenerateToken 是生成 CsrfToken 的过程，可以看到，生成的默认载体就是 DefaultCsrfToken，而 CsrfToken 的值则通过 createNewToken 方法生成，是一个 UUID 字符串\n在构造 DefaultCsrfToken 是还有两个参数 headerName 和 parameterName，这两个参数是前端保存参数的 key\n\n适用于前后端不分离的开发\n&lt;input type&#x3D;&quot;hidden&quot; th:if&#x3D;&quot;$&#123;_csrf&#125;!&#x3D;null&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; name&#x3D;&quot;_csrf&quot;&#x2F;&gt;\n或者&lt;input type&#x3D;&quot;hidden&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; th:name&#x3D;&quot;$&#123;_csrf.parameterName&#125;&quot;&gt; \n\n4.7.2.4 CookieCsrfTokenRepository前后端分离开发需要 CsrfTokenRepository 的另一个实现类 CookieCsrfTokenRepository ，是一种更加灵活可行的方案，它将 CsrfToken 值存储在用户的 cookie 内。减少了服务器 HttpSession 存储的内存消耗，并且当用 cookie 存储 CsrfToken 值时，前端可以用 JavaScript 读取（需要设置该 cookie 的 httpOnly 属性为 false），而不需要服务器注入参数，在使用方式上更加灵活\n存储在 cookie 中是不会被 CSRF 利用的，cookie 只有在同域的情况下才能被读取，所以杜绝了第三方站点跨域获取 CsrfToken 值的可能。同时 CSRF 攻击本身是不知道 cookie 内容的，只是利用了当请求自动携带 cookie 时可以通过身份验证的漏洞。但服务器对 CsrfToken 值的校验并非取自 cookie，而是需要前端从 Cookie 中自己提取出来 _csrf 参数，然后拼接成参数传递给后端，单纯的将 Cookie 中的数据传到服务端是没用的\n\n配置的时候通过 withHttpOnlyFalse 方法获取 CookieCsrfTokenRepository 的实例，该方法会设置 Cookie 中的 HttpOnly 属性为 false，也就是允许前端通过 JS 操作 Cookie（否则就没有办法获取到 _csrf)\n@Override \nprotected void configure(HttpSecurity http) throws Exception &#123; \n    http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); \n&#125; \n可以采用 header 或者 param 的方式添加 csrf_token，下面示范从 cookie 中获取 token\n&lt;form action&#x3D;&quot;&#x2F;executeLogin&quot; method&#x3D;&quot;post&quot;&gt;\n\t&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_csrf&quot;&gt;\n\t用户名&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; class&#x3D;&quot;lowin-input&quot;&gt;\n\t密码&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;lowin-input&quot;&gt;\n\t记住我&lt;input name&#x3D;&quot;remember-me&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n\t&lt;input class&#x3D;&quot;lowin-btn login-btn&quot; type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n&lt;script&gt;\n    $(function () &#123;\n        var aCookie &#x3D; document.cookie.split(&quot;; &quot;);\n        console.log(aCookie);\n        for (var i&#x3D;0; i &lt; aCookie.length; i++)&#123;\n            var aCrumb &#x3D; aCookie[i].split(&quot;&#x3D;&quot;);\n            if (&quot;XSRF-TOKEN&quot; &#x3D;&#x3D; aCrumb[0])\n                $(&quot;input[name&#x3D;&#39;_csrf&#39;]&quot;).val(aCrumb[1]);\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n4.7.2.5 LazyCsrfTokenRepository对于常见的 GET 请求实际上是不需要 CSRF 攻击校验的，但是，每当 GET 请求到来时，下面这段代码都会执行：\nif (missingToken) &#123;\n     csrfToken &#x3D; this.tokenRepository.generateToken(request);\n     this.tokenRepository.saveToken(csrfToken, request, response);\n&#125;\n\n生成 CsrfToken 并保存，但实际上却没什么用，因为 GET 请求不需要 CSRF 攻击校验。所以，Spring Security 官方又推出了 LazyCsrfTokenRepository\nLazyCsrfTokenRepository 实际上不能算是一个真正的 CsrfTokenRepository，它是一个代理，可以用来增强 HttpSessionCsrfTokenRepository 或者 CookieCsrfTokenRepository 的功能：\npublic final class LazyCsrfTokenRepository implements CsrfTokenRepository &#123;\n    private static final String HTTP_RESPONSE_ATTR &#x3D; HttpServletResponse.class.getName();\n    private final CsrfTokenRepository delegate;\n\n    public LazyCsrfTokenRepository(CsrfTokenRepository delegate) &#123;\n        Assert.notNull(delegate, &quot;delegate cannot be null&quot;);\n        this.delegate &#x3D; delegate;\n    &#125;\n\n    public CsrfToken generateToken(HttpServletRequest request) &#123;\n        return this.wrap(request, this.delegate.generateToken(request));\n    &#125;\n\n    public void saveToken(CsrfToken token, HttpServletRequest request, HttpServletResponse response) &#123;\n        if (token &#x3D;&#x3D; null) &#123;\n            this.delegate.saveToken(token, request, response);\n        &#125;\n\n    &#125;\n\n    public CsrfToken loadToken(HttpServletRequest request) &#123;\n        return this.delegate.loadToken(request);\n    &#125;\n\n    private CsrfToken wrap(HttpServletRequest request, CsrfToken token) &#123;\n        HttpServletResponse response &#x3D; this.getResponse(request);\n        return new LazyCsrfTokenRepository.SaveOnAccessCsrfToken(this.delegate, request, response, token);\n    &#125;\n\n    private HttpServletResponse getResponse(HttpServletRequest request) &#123;\n        HttpServletResponse response &#x3D; (HttpServletResponse)request.getAttribute(HTTP_RESPONSE_ATTR);\n        Assert.notNull(response, () -&gt; &#123;\n            return &quot;The HttpServletRequest attribute must contain an HttpServletResponse for the attribute &quot; + HTTP_RESPONSE_ATTR;\n        &#125;);\n        return response;\n    &#125;\n\n    private static final class SaveOnAccessCsrfToken implements CsrfToken &#123;\n        private transient CsrfTokenRepository tokenRepository;\n        private transient HttpServletRequest request;\n        private transient HttpServletResponse response;\n        private final CsrfToken delegate;\n\n        SaveOnAccessCsrfToken(CsrfTokenRepository tokenRepository, HttpServletRequest request, HttpServletResponse response, CsrfToken delegate) &#123;\n            this.tokenRepository &#x3D; tokenRepository;\n            this.request &#x3D; request;\n            this.response &#x3D; response;\n            this.delegate &#x3D; delegate;\n        &#125;\n\n        public String getHeaderName() &#123;\n            return this.delegate.getHeaderName();\n        &#125;\n\n        public String getParameterName() &#123;\n            return this.delegate.getParameterName();\n        &#125;\n\n        public String getToken() &#123;\n            this.saveTokenIfNecessary();\n            return this.delegate.getToken();\n        &#125;\n\n        public boolean equals(Object obj) &#123;\n            if (this &#x3D;&#x3D; obj) &#123;\n                return true;\n            &#125; else if (obj !&#x3D; null &amp;&amp; this.getClass() &#x3D;&#x3D; obj.getClass()) &#123;\n                LazyCsrfTokenRepository.SaveOnAccessCsrfToken other &#x3D; (LazyCsrfTokenRepository.SaveOnAccessCsrfToken)obj;\n                if (this.delegate &#x3D;&#x3D; null) &#123;\n                    if (other.delegate !&#x3D; null) &#123;\n                        return false;\n                    &#125;\n                &#125; else if (!this.delegate.equals(other.delegate)) &#123;\n                    return false;\n                &#125;\n\n                return true;\n            &#125; else &#123;\n                return false;\n            &#125;\n        &#125;\n\n        public int hashCode() &#123;\n            int prime &#x3D; true;\n            int result &#x3D; 1;\n            int result &#x3D; 31 * result + (this.delegate &#x3D;&#x3D; null ? 0 : this.delegate.hashCode());\n            return result;\n        &#125;\n\n        public String toString() &#123;\n            return &quot;SaveOnAccessCsrfToken [delegate&#x3D;&quot; + this.delegate + &quot;]&quot;;\n        &#125;\n\n        private void saveTokenIfNecessary() &#123;\n            if (this.tokenRepository !&#x3D; null) &#123;\n                synchronized(this) &#123;\n                    if (this.tokenRepository !&#x3D; null) &#123;\n                        this.tokenRepository.saveToken(this.delegate, this.request, this.response);\n                        this.tokenRepository &#x3D; null;\n                        this.request &#x3D; null;\n                        this.response &#x3D; null;\n                    &#125;\n\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\ngenerateToken 方法，该方法用来生成 CsrfToken，默认 CsrfToken 的载体是 DefaultCsrfToken，现在换成了 SaveOnAccessCsrfToken\nSaveOnAccessCsrfToken 和 DefaultCsrfToken 并没有太大区别，主要是 getToken 方法有区别，在 SaveOnAccessCsrfToken 中，当开发者调用 getToken 想要去获取 csrfToken 时，才会去对 csrfToken 做保存操作（调用 HttpSessionCsrfTokenRepository 或者 CookieCsrfTokenRepository 的 saveToken 方法）\nLazyCsrfTokenRepository 自己的 saveToken 则做了修改，相当于放弃了 saveToken 的功能，调用该方法并不会做保存操作\n\n在使用 Spring Security 时，如果对 csrf 不做任何配置，默认其实就是 LazyCsrfTokenRepository + HttpSessionCsrfTokenRepository 组合\n4.7.3 参数校验校验主要是通过 CsrfFilter 过滤器来进行，核心为 doFilterInternal() 方法\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n        request.setAttribute(HttpServletResponse.class.getName(), response);\n        CsrfToken csrfToken &#x3D; this.tokenRepository.loadToken(request);\n        boolean missingToken &#x3D; csrfToken &#x3D;&#x3D; null;\n        if (missingToken) &#123;\n            csrfToken &#x3D; this.tokenRepository.generateToken(request);\n            this.tokenRepository.saveToken(csrfToken, request, response);\n        &#125;\n\n        request.setAttribute(CsrfToken.class.getName(), csrfToken);\n        request.setAttribute(csrfToken.getParameterName(), csrfToken);\n        if (!this.requireCsrfProtectionMatcher.matches(request)) &#123;\n            if (this.logger.isTraceEnabled()) &#123;\n                this.logger.trace(&quot;Did not protect against CSRF since request did not match &quot; + this.requireCsrfProtectionMatcher);\n            &#125;\n\n            filterChain.doFilter(request, response);\n        &#125; else &#123;\n            String actualToken &#x3D; request.getHeader(csrfToken.getHeaderName());\n            if (actualToken &#x3D;&#x3D; null) &#123;\n                actualToken &#x3D; request.getParameter(csrfToken.getParameterName());\n            &#125;\n\n            if (!equalsConstantTime(csrfToken.getToken(), actualToken)) &#123;\n                this.logger.debug(LogMessage.of(() -&gt; &#123;\n                    return &quot;Invalid CSRF token found for &quot; + UrlUtils.buildFullRequestUrl(request);\n                &#125;));\n                AccessDeniedException exception &#x3D; !missingToken ? new InvalidCsrfTokenException(csrfToken, actualToken) : new MissingCsrfTokenException(actualToken);\n                this.accessDeniedHandler.handle(request, response, (AccessDeniedException)exception);\n            &#125; else &#123;\n                filterChain.doFilter(request, response);\n            &#125;\n        &#125;\n    &#125;\n\n\n首先调用 tokenRepository.loadToken 方法读取 CsrfToken 出来，这个 tokenRepository 就是配置的 CsrfTokenRepository 实例，CsrfToken 存在 HttpSession 中，这里就从 HttpSession 中读取，CsrfToken 存在 Cookie 中，这里就从 Cookie 中读取\n如果调用 tokenRepository.loadToken 方法没有加载到 CsrfToken，那说明这个请求可能是第一次发起，则调用 tokenRepository.generateToken 方法生成 CsrfToken ，并调用 tokenRepository.saveToken 方法保存 CsrfToken\n这里还调用 request.setAttribute 方法存了一些值进去，这就是默认情况下，通过 JSP 或者 Thymeleaf 标签渲染 _csrf 的数据来源\nrequireCsrfProtectionMatcher.matches() 方法则使用用来判断哪些请求方法需要做校验，默认情况下，”GET”, “HEAD”, “TRACE”, “OPTIONS” 方法是不需要校验的\n接下来获取请求中传递来的 CSRF 参数，先从请求头中获取，获取不到再从请求参数中获取\n获取到请求传来的 CSRF 参数之后，再和一开始加载到的 csrfToken 做比较，如果不同的话，就抛出异常\n\n4.7.4 CSRF 注销开启 CSRF 后，不仅登录受到保护，注销也同样受到保护，因此同样需要带上 CsrfToken\n&lt;form action&#x3D;&quot;&#x2F;logout&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type&#x3D;&quot;hidden&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; name&#x3D;&quot;_csrf&quot;&#x2F;&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;退出&quot;&gt;\n&lt;&#x2F;form&gt;\n\n4.8 新版本 WebSecurityConfigurerAdapter 被弃用官方地址：Spring Security without the WebSecurityConfigurerAdapter\n原写法：\n@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n            .authorizeHttpRequests((authz) -&gt; authz\n                .anyRequest().authenticated()\n            )\n            .httpBasic(withDefaults());\n    &#125;\n\n    @Override\n    public void configure(WebSecurity web) &#123;\n        web.ignoring().antMatchers(&quot;&#x2F;ignore1&quot;, &quot;&#x2F;ignore2&quot;);\n    &#125;\n\n    @Bean\n    public DataSource dataSource() &#123;\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    &#125;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        UserDetails user &#x3D; User.withDefaultPasswordEncoder()\n            .username(&quot;user&quot;)\n            .password(&quot;password&quot;)\n            .roles(&quot;USER&quot;)\n            .build();\n        auth.jdbcAuthentication()\n            .withDefaultSchema()\n            .dataSource(dataSource())\n            .withUser(user);\n    &#125;\n&#125;\n\n改动后写法，由重写改为注入 Bean：\n@Configuration\npublic class SecurityConfiguration &#123;\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;\n        http\n            .authorizeHttpRequests((authz) -&gt; authz\n                .anyRequest().authenticated()\n            )\n            .httpBasic(withDefaults());\n        return http.build();\n    &#125;\n\n    @Bean\n    public WebSecurityCustomizer webSecurityCustomizer() &#123;\n        return (web) -&gt; web.ignoring().antMatchers(&quot;&#x2F;ignore1&quot;, &quot;&#x2F;ignore2&quot;);\n    &#125;\n\n    @Bean\n    public DataSource dataSource() &#123;\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)\n            .build();\n    &#125;\n\n    @Bean\n    public UserDetailsManager users(DataSource dataSource) &#123;\n        UserDetails user &#x3D; User.withDefaultPasswordEncoder()\n            .username(&quot;user&quot;)\n            .password(&quot;password&quot;)\n            .roles(&quot;USER&quot;)\n            .build();\n        JdbcUserDetailsManager users &#x3D; new JdbcUserDetailsManager(dataSource);\n        users.createUser(user);\n        return users;\n    &#125;\n&#125;\n\n具体详见官方文档示例\n5. Spring Security 微服务权限方案微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。微服务的目的是有效的拆分应用，实现敏捷开发和部署\n5.1 认证授权过程分析1、如果是基于 Session，那么 Spring Security 会对 cookie 里的 sessionid 进行解析，找到服务器存储的 session 信息，然后判断当前用户是否符合请求的要求\n2、如果是 token，则是解析出 token，然后将当前请求加入到 Spring Security 管理的权限信息中去\n\n如果系统的模块众多，每个模块都需要进行授权与认证，所以选择基于 token 的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为 key，权限列表为 value 的形式存入 redis 缓存中，根据用户名相关信息生成 token 返回，浏览器将 token 记录到 cookie 中，每次调用 api 接口都默认将 token 携带到 header 请求头中，Spring Security 解析 header 头获取 token 信息，解析 token 获取当前用户名，根据用户名就可以从 redis 中获取权限列表，这样 Spring Security 就能够判断当前请求是否有权限访问\n5.2 RBAC 模型和权限5.2.1 RBAC这里的权限管理使用的是 RBAC（Role-Based Access Control）模型，基于角色的访问控制，现在主流的权限管理系统的权限设计都是 RBAC 模型，或者是 RBAC 模型的变形\n主要通过用户关联角色，角色关联权限，来间接的为用户赋予权限，用户不直接关联权限\n\n为什么要增加角色这一层关系呢？直接用户关联权限不可以吗？\n假如有一些用户具有相同的权限，增加时需要为这些用户增加相同的权限，修改时同样也要全部修改相应的权限，管理起来十分复杂。这时候通过引入角色这一概念，给角色赋予对应的权限，然后再直接给用户分配角色，通过角色来管理权限，增加时只需要为用户绑定角色就行，修改时只需要修改这一个角色就行，大大简化了权限的管理，同时这也符合现实生活中的场景\nRBAC 模型又分为 RBAC0、RBAC1、RBAC2、RBAC3\n1、RBAC0 模型\n最简单的用户、角色、权限模型。这里面包含两种：\n\n用户和角色是多对一关系。即：一个用户只对应一个角色，一个角色可以对应多个用户\n用户和角色是多对多关系。即：一个用户可以对应多个角色，一个角色可以对应多个用户\n\n如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。一般来说尽量使用多对多的权限体系，保证系统的可扩展性，如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限\n2、RBAC1 模型\n在 RBAC0 的基础上引入了角色继承的概念。即：子角色可以继承父角色的所有权限\n如某个业务部门，有经理、主管、专员，专员的权限不能大于主管，主管的权限不能大于经理。如果采用 RBAC0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况\n而 RBAC1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限\n3、RBAC2 模型\n基于 RBAC0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等\n\n角色互斥 ：同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。如：财务系统中一个用户不能同时被指派给会计角色和审计员角色\n基数约束 ：一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 CEO 创建的，那这个角色的数量是有限的\n先决条件角色 ：指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限\n运行时互斥 ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色\n\n4、RBAC3 模型\n称为统一模型，它包含了 RBAC1 和 RBAC2，利用传递性，也把 RBAC0 包括在内。即综合了 RBAC0、RBAC1 和 RBAC2 的所有特点\n5.2.2 用户组当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候就可以引入一个概念“用户组”，就是将相同属性的用户归类到一起\n例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量\n同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限\n用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分\n除了减少工作量，还有更便于理解。比如按部门建立用户组的例子。一位用户从 A 部门异动到了 B 部门，这是实际发生的情况。如果没有用户组，那么我们要拿掉 A 部门的所有角色，换上 B 部门的所有角色。这种操作的本质没有区别，但是与实际情况的表现形式就有些差别了，不容易理解。加上用户组之后，只需要操作用户离开 A 组而加入 B 组就行了。这与实际情况很贴近\n5.2.3 权限权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，一般来说可以将权限分为：页面权限、操作权限和数据权限\n\n页面权限 ：所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限\n操作权限 ：用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等\n数据权限 ：一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。比如京东广东地区的负责人，他可以看到广东地区的仓库信息，但他看不到北京地区的仓库信息，因为这不是他的数据权限范围\n\n5.3 具体实现详见：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;124464590\n5.3.1 自定义 UsernamePasswordAuthenticationFilter可以使用 Spring Security 默认的 UsernamePasswordAuthenticationFilter。假如需要在里面自定义认证逻辑的话，可以自定义类继承该过滤器\n通过 AuthenticationManager 的 authenticate 方法来进行用户认证，所以需要把 AuthenticationManager 注入容器或者直接传入 authenticationManager() 方法。jwtAuthenticationFilter 为 JWT 过滤器\n\n\n\n\n\n\n\n\n\nhttp.addFilter(new TokenLoginFilter(authenticationManager(), jwtAuthenticationFilter , redisTemplate);\n认证成功的话生成一个 JWT 并返回。同时将 JWT 存入 Redis\npublic class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123;\n\n    private JWTUtil jwtUtil; &#x2F;&#x2F; JWT 工具类\n    private RedisTemplate redisTemplate;\n    private AuthenticationManager authenticationManager; &#x2F;&#x2F; 用来认证\n\n    public TokenLoginFilter(AuthenticationManager authenticationManager, JwtAuthenticationFilter  jwtAuthenticationFilter , RedisTemplate redisTemplate) &#123;\n        this.authenticationManager &#x3D; authenticationManager;\n        this.jwtAuthenticationFilter &#x3D; jwtAuthenticationFilter ;\n        this.redisTemplate &#x3D; redisTemplate;\n        this.setPostOnly(false);\n        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;&#x2F;hrms&#x2F;login&quot;,&quot;POST&quot;));\n    &#125;\n\n    &#x2F;&#x2F; 1. 获取表单提交用户名和密码\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;\n        try &#123;\n        \t&#x2F;&#x2F; 获取表单提交的数据\n            User user &#x3D; new ObjectMapper().readValue(request.getInputStream(), User.class);\n            &#x2F;&#x2F; 将用户名和密码传给 UserDetailsService 进行认证，认证成功返回认证信息 Authentication \n            Authentication authenticate &#x3D; authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;()));\n            return authenticate;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace(); throw new RuntimeException();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 2. 认证成功之后调用的方法\n    @Override\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;\n        &#x2F;&#x2F; 认证成功，得到认证成功之后的用户信息\n        SecurityUser user &#x3D; (SecurityUser)authResult.getPrincipal();\n        &#x2F;&#x2F; 根据用户名生成 jwt\n  \n        &#x2F;&#x2F; 把用户名称和用户权限列表放到 Redis\n  \n        &#x2F;&#x2F; 返回 jwt\n  \n    &#125;\n\n    &#x2F;&#x2F; 3. 认证失败调用的方法\n    @Override\n    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;\n  \n    &#125;\n&#125;\n","slug":"BlogRepository/Spring/Spring Security 总结","date":"2022-03-15T09:18:25.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"凡"},{"id":"9f7419bdbcee20c9483c8a0576ef5202","title":"Java进阶使用记录","content":"1. Asset 断言用于对值进行判断，为真则运行，否则报错，多用于调试\nAssert.isNull(null, &quot;是否为空&quot;); &#x2F;&#x2F; 为空则运行\nAssert.notNull(&quot;&quot;, &quot;是否不为空&quot;); &#x2F;&#x2F; 不为空则运行\nAssert.notEmpty(new ArrayList&lt;&gt;(), &quot;数组是否不为空&quot;); &#x2F;&#x2F; 不为空则运行\n\n可以使用 assert 进行更多判断操作，使用原则：\n\n使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。\n使用断言对函数的参数进行确认。\n在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。\n一般教科书都鼓励程序员们进行防错性的程序设计，但要这种编程风格会隐瞒错误。当进行防错性编程时，如果”不可能发生”的事情的确发生了，则要使用断言进行报警。\n\n1.1 IDEA 开启 assert新版 IDEA 默认把 VM Options 去掉了，需要手动加进来在 VM Options 里输入 -ea 开启断言\n1.2 assert 使用public static void main(String[] args) &#123;\n\tint num &#x3D; 10;\n\t&#x2F;&#x2F; 判断 num 是否大于 12，不大于则为假，报错；大于则为真，继续运行\n\tassert num &gt; 12;\n\tSystem.out.println(&quot;运行&quot;);\n&#125;\n\n也可以在后面定义错误信息\npublic static void main(String[] args) &#123;\n\tint i &#x3D; 10;\n\t&#x2F;&#x2F; 假如 i &lt; 10，则 i++，否则则报错\n\tassert (i++ &lt; 10) : &quot;num 大于等于 10&quot;;\n\tSystem.out.println(i);\n&#125;\n\n\n2. 泛型\n？ 表示不确定的 Java类型\nT  （type）表示 Java类型\nK  代表 Java 键值中的 Key\nV  代表 Java 键值中的Value\nE  代表 Element\n\n2.1 定义和使用泛型类\n\n\n\n\n\n\n\n\n[修饰符] class 类名&lt;代表泛型的变量&gt; {  }\n&#x2F;&#x2F; 定义泛型类\nclass User&lt;Fan&gt;&#123;\n    private Fan type;\n\n    public User(Fan type) &#123;\n        this.type &#x3D; type;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;type&#x3D;&quot; + type +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public Fan getType() &#123;\n        return type;\n    &#125;\n\n    public void setType(Fan type) &#123;\n        this.type &#x3D; type;\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tUser&lt;String&gt; stringUser &#x3D; new User&lt;&gt;(&quot;String&quot;);  &#x2F;&#x2F; 可以限制泛型为 String\n\tSystem.out.println(stringUser); &#x2F;&#x2F; 输出 String\n\n\tUser user &#x3D; new User&lt;&gt;(1); &#x2F;&#x2F; 不进行限制\n\tSystem.out.println(user); &#x2F;&#x2F; 输出 1\n\tuser.setType(&quot;类型&quot;); \n\tSystem.out.println(user); &#x2F;&#x2F; 输出 类型\n&#125;\n\n\n2.2 定义和使用泛型方法\n\n\n\n\n\n\n\n\n修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) {  }\n&#x2F;&#x2F; 定义泛型方法\nclass Person&#123;\n    public &lt;Fan&gt; void show(Fan fan)&#123;\n        System.out.println(fan);\n    &#125;\n    public &lt;Fan&gt; Fan showFan(Fan fan)&#123;\n        return fan;\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tPerson person &#x3D; new Person();\n\tperson.show(&quot;String&quot;); &#x2F;&#x2F; 无返回，直接输出\n\n\t&#x2F;&#x2F; 传入一个 List 的 User泛型对象，User 的泛型又为 List\n\tArrayList&lt;User&lt;List&lt;String&gt;&gt;&gt; users &#x3D; person.showFan(new ArrayList&lt;User&lt;List&lt;String&gt;&gt;&gt;()&#123;\n\t\t&#123;\n\t\t\tthis.add(new User&lt;&gt;(new ArrayList&lt;String&gt;()&#123;\n\t\t\t\t&#123;\n\t\t\t\t\tthis.add(&quot;array11&quot;);\n\t\t\t\t\tthis.add(&quot;array12&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;));\n\t\t\tthis.add(new User&lt;&gt;(new ArrayList&lt;String&gt;()&#123;\n\t\t\t\t&#123;\n\t\t\t\t\tthis.add(&quot;array21&quot;);\n\t\t\t\t\tthis.add(&quot;array22&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;));\n\t\t&#125;\n\t&#125;);\n\tSystem.out.println(users); &#x2F;&#x2F; 输出返回值\n&#125;\n\n\n2.3 定义和使用泛型接口\n\n\n\n\n\n\n\n\n修饰符 interface 接口名&lt;代表泛型的变量&gt; {  }\ninterface MyInterface&lt;Fan&gt;&#123;\n    void add(Fan fan);\n\n    Fan get(Fan fan);\n&#125;\n\n2.3.1 定义实现类时确定泛型的类型class MyInterfaceImpl implements MyInterface&lt;String&gt;&#123;\n    @Override\n    public void add(String s) &#123;\n    \tSystem.out.println(s + &quot;，fan&quot;);\n    &#125;\n\n    @Override\n    public String get(String s) &#123;\n        return s;\n    &#125;\n&#125;\n\n2.3.2 始终不确定泛型的类型，直到创建对象时，确定泛型的类型&#x2F;&#x2F; 实现类\nclass MyInterfaceImpl&lt;Fan&gt; implements MyInterface&lt;Fan&gt;&#123;\n\n    @Override\n    public void add(Fan fan) &#123;\n        System.out.println(fan + &quot;，fan&quot;);\n    &#125;\n\n    @Override\n    public Fan get(Fan fan) &#123;\n        return fan;\n    &#125;\n&#125;\n&#x2F;&#x2F; 主启动类\npublic static void main(String[] args)&#123;\n\tMyInterface myInterface &#x3D; new MyInterfaceImpl(); &#x2F;&#x2F; 不限制泛型\n\tmyInterface.add(1);\n\tMyInterface&lt;String&gt; myInterface1 &#x3D; new MyInterfaceImpl&lt;&gt;(); &#x2F;&#x2F; 限制泛型为 String\n\tSystem.out.println(myInterface1.get(&quot;String&quot;));\n&#125;\n\n2.4 泛型通配符 ？当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符 &lt;?&gt; 表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用\n2.4.1 通配符基础使用泛型的通配符：不知道使用什么类型来接收的时候，此时可以使用 ?,? 表示未知通配符。此时只能接受数据,不能往该集合中存储数据。\npublic static void main(String[] args) &#123;\n\tget(new ArrayList&lt;Integer&gt;()&#123;\n\t\t&#123;\n\t\t\tthis.add(1);\n\t\t\tthis.add(2);\n\t\t&#125;\n\t&#125;);\n\tget(new LinkedList&lt;String&gt;()&#123;\n\t\t&#123;\n\t\t\tthis.add(&quot;String1&quot;);\n\t\t\tthis.add(&quot;String1&quot;);\n\t\t&#125;\n\t&#125;);\n&#125;\npublic static void get(Collection&lt;?&gt; collection)&#123; &#x2F;&#x2F; 可以传入任意的 Collection 下的类型\n\tcollection.stream().forEach(o -&gt; &#123;\n\t\tSystem.out.println(o);\n\t&#125;);\n&#125;\n\n\n2.4.2 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限\n泛型的上限：\n\n格式： 类型名称 &lt;? extends 类 &gt; 对象名称\n意义： 只能接收该类型及其子类\n\n泛型的下限：\n\n格式： 类型名称 &lt;? super 类 &gt; 对象名称\n意义： 只能接收该类型及其父类型\n\n&#x2F;&#x2F; 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类\n&#x2F;&#x2F; Collection 可以换为 ArrayList 等其他类型\npublic static void getElement1(Collection&lt;? extends Number&gt; collection)&#123;\n\n&#125;\n&#x2F;&#x2F; 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类\npublic static void getElement2(Collection&lt;? super Number&gt; collection)&#123;\n\n&#125;\n&#x2F;&#x2F; 现已知 Object 类，String 类，Number 类，Integer 类，其中 Number 是 Integer 的父类\npublic static void main(String[] args) &#123;\n    Collection&lt;Integer&gt; integer &#x3D; new ArrayList&lt;Integer&gt;();\n    Collection&lt;String&gt; string &#x3D; new ArrayList&lt;String&gt;();\n    Collection&lt;Number&gt; number &#x3D; new ArrayList&lt;Number&gt;();\n    Collection&lt;Object&gt; object &#x3D; new ArrayList&lt;Object&gt;();\n  \n    getElement1(integer);\n    getElement1(string);&#x2F;&#x2F;报错\n    getElement1(number);\n    getElement1(object);&#x2F;&#x2F;报错\n  \n    getElement2(integer);&#x2F;&#x2F;报错\n    getElement2(string);&#x2F;&#x2F;报错\n    getElement2(number);\n    getElement2(object);\n&#125;\n\n3. 反射\n框架：半成品软件。可以在框架的基础上进行软件开发，简化编码\n\n反射：将类的各个组成部分封装为其他对象，这就是反射机制好处：\n\n可以在程序运行过程中，操作这些对象\n可以解耦，提高程序的可扩展性\n\n\n\n3.1 获取Class对象的方式\nClass.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象多用于配置文件，将类名定义在配置文件中。读取文件，加载类\n类名.class：通过类名的属性 class 获取多用于参数的传递\n对象.getClass()：getClass()方法是Object类中的方法，Object类是所有类的父类，所有创建的对象都有该方法.多用于对象的获取字节码的方式\n通过类加载器 xxxClassLoader.loadClass() 传入类路径获取\n\n结论：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个\n3.2 Class对象功能获取功能：\n\n获取成员变量&#x2F;&#x2F; 获取所有 public 的成员变量，包括继承的\nField[] getFields() \n&#x2F;&#x2F; 获取指定名称的 public 成员变量\nField getField(String name) \n&#x2F;&#x2F; 获取所有的成员变量，不考虑修饰符，不包括继承的（这里只能获取到 private 的属性，但并不能访问该 private 字段的值,除非加上 setAccessible(true)）\nField[] getDeclaredFields() \n&#x2F;&#x2F; 获取指定名称的所有成员变量，不考虑修饰符\nField getDeclaredField(String name) \n获取构造方法&#x2F;&#x2F; 获取所有 public 的构造方法\nConstructor&lt;?&gt;[] getConstructors() \n&#x2F;&#x2F; 获取传入数据类型的对应构造方法，Constructor&lt;UserTest&gt; constructor &#x3D; userTestClass.getConstructor(String.class, Integer.class);\nConstructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)  \n&#x2F;&#x2F; 不考虑修饰符获取\nConstructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)   \n&#x2F;&#x2F; 不考虑修饰符获取\nConstructor&lt;?&gt;[] getDeclaredConstructors()  \n获取成员方法&#x2F;&#x2F; 获取所有 public 的成员方法，包括继承的\nMethod[] getMethods() \n&#x2F;&#x2F; 获取指定名称和传入参数类型的 public 成员方法，Method test &#x3D; userTestClass.getMethod(&quot;test&quot;, String.class);\nMethod getMethod(String name, 类&lt;?&gt;... parameterTypes) \n&#x2F;&#x2F; 获取所有的成员方法，不包括继承的\nMethod[] getDeclaredMethods() \n&#x2F;&#x2F; 获取指定名称和传入参数类型的所有成员方法\nMethod getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) \n获取全类名String getName()  \n\n3.3 Field 成员变量操作：\n\n设置值void set(Object obj, Object value)\n获取值get(Object obj)\n忽略访问权限修饰符的安全检查（可以获取 private 的成员变量的值）setAccessible(true)：暴力反射\n\n&#x2F;&#x2F; 示例类\nclass UserTest&#123;\n    private String name;\n    private Integer age;\n    public String birthday;\n\n    public UserTest() &#123;\n    &#125;\n\n    public UserTest(String name, Integer age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public void test()&#123;\n        System.out.println(&quot;test&quot;);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;UserTest&#123;&quot; +\n                &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age&#x3D;&quot; + age +\n                &quot;, birthday&#x3D;&#39;&quot; + birthday + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception &#123;\n\tUserTest userTest &#x3D; new UserTest(); &#x2F;&#x2F; 新建一个对象\n\tClass&lt;? extends UserTest&gt; aClass &#x3D; userTest.getClass(); &#x2F;&#x2F; 通过对象.getClass() 的方式获取字节码\n\tField[] fields &#x3D; aClass.getFields(); &#x2F;&#x2F; 获取 public 的成员变量\n\tfor (Field field : fields) &#123;\n\t    &#x2F;&#x2F; public java.lang.String fan.demo02.UserTest.birthday\n\t\tSystem.out.println(field);\n\t\tSystem.out.println(field.getName()); &#x2F;&#x2F; birthday\n\t\n\t\tSystem.out.println(field.get(userTest)); &#x2F;&#x2F; 获取值 null\n\t\tfield.set(userTest,&quot;2001&quot;); &#x2F;&#x2F; 设置值，传入对象和设置的值\n\t\tSystem.out.println(field.get(userTest)); &#x2F;&#x2F; 2001\n\t&#125;\n&#125;\n\n\n3.4 Constructor 构造方法创建对象：\n\n\n\n\n\n\n\n\n\nT newInstance(Object… initargs)\n注：如果使用空参数构造方法创建对象，操作可以简化：Class对象.newInstance方法\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception &#123;\n\t&#x2F;&#x2F; 无参构造创建对象\n\tClass&lt;UserTest&gt; userTestClass &#x3D; UserTest.class;  &#x2F;&#x2F; 通过类名.class 的方式获取字节码\n\tUserTest userTest &#x3D; userTestClass.newInstance(); &#x2F;&#x2F; 直接通过Class对象.newInstance() 方法创建对象\n\tUserTest userTest &#x3D; userTestClass.getConstructor().newInstance(); &#x2F;&#x2F; 获取构造方法再调用 newInstance 方法\n\n\t&#x2F;&#x2F; 有参构造创建对象，传入对应的数据类型\n\tConstructor&lt;UserTest&gt; constructor &#x3D; userTestClass.getConstructor(String.class, Integer.class);\n    UserTest userTest &#x3D; constructor.newInstance(&quot;张三&quot;,1);\n&#125;\n\n3.5 Method 方法对象执行方法：\n\n\n\n\n\n\n\n\n\nObject invoke(Object obj, Object… args) ：调用 obj 对象的成员方法，参数是args，返回值是 Object 类型\n获取方法名称：\n\n\n\n\n\n\n\n\n\nString getName:获取方法名\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception &#123;\n\tClass&lt;UserTest&gt; userTestClass &#x3D; UserTest.class;\n\tMethod test &#x3D; userTestClass.getMethod(&quot;test&quot;, String.class);\n\tSystem.out.println(test); &#x2F;&#x2F; public void fan.demo02.UserTest.test(java.lang.String)\n\tSystem.out.println(test.getName()); &#x2F;&#x2F; test\n\n\tUserTest userTest &#x3D; userTestClass.newInstance(); &#x2F;&#x2F; 创建对象\n\t&#x2F;&#x2F; 调用对象的 test 方法，有传参，传入参数 “李四”，有返回值，输出 “李四”\n    System.out.println(test.invoke(userTest,&quot;李四&quot;));\n\n\t&#x2F;&#x2F; 调用对象的 test1 方法，无传参，无返回值，输出为 null\n    Method test1 &#x3D; aClass.getMethod(&quot;test1&quot;);\n    System.out.println(test1.invoke(userTest));\n&#125;\n\n\n4. 注解4.1 概念注解（Annotation），也叫元数据。一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。\n\n注解：说明程序的。给计算机看的。@注解名称\n注释：用文字描述程序的。给程序员看的\n\n4.2 作用分类\n编写文档：通过代码里标识的注解生成文档【生成文档doc文档】\n代码分析：通过代码里标识的注解对代码进行分析【使用反射】\n编译检查：通过代码里标识的注解让编译器能够实现基本的编译 【Override】\n\n4.3 JDK中预定义的一些注解\n@Override\t：检测被该注解标注的方法是否是继承自父类(接口)的\n@Deprecated：该注解标注的内容，表示已过时\n@SuppressWarnings：压制警告一般传递参数 all  @SuppressWarnings(“all”)\n\n4.4 自定义注解\n格式：\n&#x2F;&#x2F; 元注解\npublic @interface 注解名称&#123;\n \t属性列表;\n &#125;\n本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口\n\n\n\n\n\n\n\n\n\npublic interface MyAnnotation  extends java.lang.annotation.Annotation { }\n\n属性：接口中的抽象方法\n\n1、属性的返回值类型有下列取值\n基本数据类型\nString\n枚举\n注解\n以上类型的数组\n\n\n2、定义了属性，在使用时需要给属性赋值\n如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值\n如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可\n数组赋值时，值使用 { } 包裹。如果数组中只有一个值，则 { } 可以省略\n\n\n\n\n元注解：用于描述注解的注解\n\n@Target：描述注解能够作用的位置\nElementType取值：\nTYPE：可以作用于类上\nMETHOD：可以作用于方法上\nFIELD：可以作用于成员变量上\n\n\n\n\n@Retention：描述注解被保留的阶段（存活阶段）\n@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到 class 字节码文件中，并被 JVM 读取到\n\n\n@Documented：描述注解是否被抽取到 api 文档中\n@Inherited：所标记的类的子类也会拥有这个注解\n\n\n\n&#x2F;&#x2F; 自定义一个注解\n@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;) &#x2F;&#x2F; 作用在变量和方法上\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface MyAnnotation &#123;\n    String value() default &quot;fan&quot;; &#x2F;&#x2F; 设置默认值\n    boolean isNull(); &#x2F;&#x2F; 不设置默认值，通过标注注解时传入\n&#125;\n&#x2F;&#x2F; 配置注解\n@MyAnnotation(isNull &#x3D; true)\n@Data\nclass Person &#123;\n    private String name;\n    private int age;\n    private boolean isDelete;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) throws Exception&#123;\n\tPerson person &#x3D; new Person();\n\tClass&lt;? extends Person&gt; personClass &#x3D; person.getClass();\n\n\t&#x2F;&#x2F; 通过反射，获取作用在类上的注解\n\tMyAnnotation annotation &#x3D; personClass.getAnnotation(MyAnnotation.class); \n\t&#x2F;&#x2F; @fan.annotation.MyAnnotation(value&#x3D;fan, isNull&#x3D;true)\n\tSystem.out.println(annotation);\n\n\tperson.setName(annotation.value()); &#x2F;&#x2F; 注入从注解里获取到的值\n\tperson.setDelete(annotation.isNull());\n\tSystem.out.println(person);  &#x2F;&#x2F; Person(name&#x3D;fan, age&#x3D;0, isDelete&#x3D;true)\n&#125;\n\n\n5. 函数式接口5.1 概念函数式接口在Java中是指：有且仅有一个抽象方法的接口\n函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导\n\n\n\n\n\n\n\n\n\n备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的 for-each 语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java 中的 Lambda 可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的\n5.2 格式只要确保接口中有且仅有一个抽象方法即可\n修饰符 interface 接口名称 &#123;\n\tpublic abstract 返回值类型 方法名称(可选参数信息);\n\t&#x2F;&#x2F; 其他非抽象方法内容\n&#125;\n\n5.3 @FunctionalInterface 注解与 @Override 注解的作用类似，Java 8 中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注解可用于一个接口的定义上：\n@FunctionalInterface\npublic interface MyFunctionalInterface &#123;\n\tvoid myMethod();\n&#125;\n\n一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样\n5.4 自定义函数式接口&#x2F;&#x2F; 定义一个函数式接口\n@FunctionalInterface\npublic interface MyFunction &#123;\n    String myMethod(String name); &#x2F;&#x2F; public abstract 可以省略\n    default void hidden() &#123; &#125;;\n&#125;\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 最基础写法\n\ttest(new MyFunction() &#123;\n\t\t@Override\n\t\tpublic String myMethod(String name) &#123;\n\t\t\tSystem.out.println(&quot;myMethod方法执行！&quot;);\n\t\t\treturn name;\n\t\t&#125;\n\t&#125;);\n\t&#x2F;&#x2F; 使用 Lambda 表达式\n\ttest(name -&gt; &#123;\n\t\tSystem.out.println(&quot;myMethod方法执行！&quot;);\n\t\treturn name;\n\t&#125;);\n\t&#x2F;&#x2F; 假如没有其他语句直接返回值，可以省略大括号和 return\n\ttest(name -&gt; name);\n&#125;\n\npublic static void test(MyFunction myFunction)&#123;\n\tString name &#x3D; myFunction.myMethod(&quot;fan&quot;);\n\tSystem.out.println(name);\n&#125;\n\n\n5.5 Lambda 的延迟执行当 flag 为 false 的时候，Lambda将不会执行。从而达到节省性能的效果\npublic static void main(String[] args) &#123;\n\ttest(false, name -&gt; &#123;\n\t\tSystem.out.println(&quot;myMethod方法执行！&quot;);\n\t\treturn name;\n\t&#125;);\n&#125;\npublic static void test(Boolean flag, MyFunction myFunction)&#123;\n\tif (flag &#x3D;&#x3D; true)&#123;\n\t\tString s &#x3D; myFunction.myMethod(&quot;fan&quot;);\n\t\tSystem.out.println(s);\n\t&#125;else &#123;\n\t\tSystem.out.println(&quot;未执行&quot;);\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的\n5.6 Lambda 作为参数和返回值如果抛开实现原理不说，Java 中的 Lambda 表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用 Lambda 表达式进行替代。使用 Lambda 表达式作为方法参数，其实就是使用函数式接口作为方法参数\n5.6.1 作为参数例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就可以使用 Lambda 进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别\npublic class Demo04Runnable &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tstartThread(() ‐&gt; System.out.println(&quot;线程任务执行！&quot;));\n\t&#125;\n\tprivate static void startThread(Runnable runnable) &#123;\n\t\tnew Thread(runnable).start();\n\t&#125;\n&#125;\n\n5.6.2 作为返回值类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个 Lambda 表达式。当需要通过一个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取\npublic class Demo06Comparator &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tString[] array &#x3D; &#123; &quot;abc&quot;, &quot;ab&quot;, &quot;abcd&quot; &#125;;\n\t\tSystem.out.println(Arrays.toString(array));\n\t\tArrays.sort(array, newComparator());\n\t\tSystem.out.println(Arrays.toString(array));\n\t&#125;\n\tprivate static Comparator&lt;String&gt; newComparator() &#123;\n\t\treturn (a, b) ‐&gt; b.length() ‐ a.length();\n\t&#125;\n&#125;\n\n5.7 常用函数式接口JDK 提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在 java.util.function 包中被提供\n5.7.1 Supplierjava.util.function.Supplier 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的 Lambda 表达式需要“对外提供”一个符合泛型类型的对象数据\npublic static void main(String[] args) &#123;\n\tSystem.out.println(test(new Supplier&lt;String&gt;() &#123;\n\t\t@Override\n\t\tpublic String get() &#123; &#x2F;&#x2F; 参数类型为使用 Supplier 时指定的数据类型\n\t\t\treturn &quot;fan&quot;;\n\t\t&#125;\n\t&#125;));\n\tSystem.out.println(test(() -&gt; &quot;fan&quot;));\n&#125;\npublic static String test(Supplier&lt;String&gt; supplier)&#123;\n\treturn supplier.get();\n&#125;\n\n\n5.7.2 Consumerjava.util.function.Consumer&lt;T&gt; 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定\n\n抽象方法：acceptConsumer 接口中包含抽象方法 void accept(T t) ，意为消费一个指定泛型的数据public static void main(String[] args) &#123;\n    test(&quot;fan&quot;, new Consumer&lt;String&gt;() &#123;\n        @Override\n        public void accept(String  name) &#123;\n            System.out.println(name);\n        &#125;\n    &#125;);\n    test(&quot;fan&quot;, name -&gt; System.out.println(name));\n&#125;\n\npublic static void test(String name, Consumer&lt;String&gt; consumer)&#123;\n    consumer.accept(name);\n&#125;\n\n\n默认方法：andThen如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的 default 方法 andThen public static void main(String[] args) &#123;\n    test(&quot;fan&quot;, one -&gt; System.out.println(one.toLowerCase()), \n            two -&gt; System.out.println(two.toUpperCase()));\n&#125;\n\npublic static void test(String name, Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)&#123;\n    Consumer&lt;String&gt; stringConsumer &#x3D; one.andThen(two);\n    stringConsumer.accept(name);\n\n    one.andThen(two).accept(name);\n&#125;\n\n\n\n5.7.3 Predicate有时候我们需要对某种类型的数据进行判断，从而得到一个 boolean 值结果。这时可以使用 java.util.function.Predicate&lt;T&gt; 接口\n\n抽象方法：testPredicate 接口中包含一个抽象方法： boolean test(T t) 。用于条件判断的场景public static void main(String[] args) &#123;\n    test(&quot;false&quot;, new Predicate&lt;String&gt;() &#123;\n        @Override\n        public boolean test(String s) &#123;\n            return s.length() &gt; 4; &#x2F;&#x2F; 返回一个判断\n        &#125;\n    &#125;);\n    &#x2F;&#x2F; 判断字符串长度是否小于 4\n    test(&quot;false&quot;, s -&gt; s.length() &lt; 4);\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; predicate)&#123;\n    boolean test &#x3D; predicate.test(str);\n    System.out.println(test);\n&#125;\n\n\n默认方法：and既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用  default 方法 andpublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 判断字符串是否存在 H 并且存在 W\n    test(&quot;fanHW&quot;, one -&gt; one.contains(&quot;H&quot;), two -&gt; two.contains(&quot;W&quot;));\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)&#123;\n    boolean test &#x3D; one.and(two).test(str);\n    System.out.println(test);\n&#125;\n\n\n默认方法：or与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”public static void main(String[] args) &#123;\n    &#x2F;&#x2F; 判断字符串是否存在 H 或存在 W\n    test(&quot;fanH&quot;, one -&gt; one.contains(&quot;H&quot;), two -&gt; two.contains(&quot;W&quot;));\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)&#123;\n    boolean test &#x3D; one.or(two).test(str);\n    System.out.println(test);\n&#125;\n\n\n默认方法：negate它是执行了test方法之后，对结果 boolean 值进行 “!” 取反。一定要在 test 方法调用之前调用 negate 方法，正如 and 和 or 方法一样public static void main(String[] args) &#123;\n    test(&quot;fanH&quot;, one -&gt; one.contains(&quot;H&quot;), two -&gt; two.contains(&quot;W&quot;));\n&#125;\n\npublic static void test(String str, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)&#123;\n    boolean test &#x3D; one.or(two).negate().test(str); &#x2F;&#x2F; 对结果取反\n    System.out.println(test);\n&#125;\n\n\n\n5.7.4 Functionjava.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件\n\n抽象方法：applyFunction 接口中最主要的抽象方法为：R apply(T t) ，根据类型 T 的参数获取类型R的结果&#x2F;&#x2F; 将 String 类型转换为 Integer 类型\npublic static void main(String[] args) &#123;\n    test(&quot;1234&quot;, new Function&lt;String, Integer&gt;() &#123;\n        @Override\n        public Integer apply(String s) &#123;\n            System.out.println(&quot;apply方法执行！&quot;);\n            return Integer.parseInt(s); &#x2F;&#x2F; 返回转换后的类型\n        &#125;\n    &#125;);\n    test(&quot;1234&quot;, s -&gt; Integer.parseInt(s));\n&#125;\n\npublic static void test(String str, Function&lt;String, Integer&gt; function)&#123;\n    Integer apply &#x3D; function.apply(str);\n    System.out.println(apply);\n&#125;\n\n\n默认方法：andThenFunction 接口中有一个默认的 andThen 方法，用来进行组合操作，用于“先做什么，再做什么”的场景public static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 先进行类型转换，然后再将转换后的类型的值乘以 10\n    test(&quot;1234&quot;, one -&gt; Integer.parseInt(one), two -&gt; two *&#x3D; 10);\n&#125;\n\npublic static void test(String str, Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)&#123;\n    Integer apply &#x3D; one.andThen(two).apply(str);\n    System.out.println(apply);\n&#125;\n\n\n\n6. 网络编程网络编程，就是在一定的协议下，实现两台计算机的通信的程序\n6.1 网络通信协议\n网络通信协议：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。\nTCP&#x2F;IP协议：传输控制协议&#x2F;因特网互联协议( Transmission Control Protocol&#x2F;Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。\n模型各分层作用及对应协议\n\n6.2 协议分类通信的协议还是比较复杂的， java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。java.net 包中提供了两种常见的网络协议的支持\n6.2.1 TCP传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输\n三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠\n\n第一次握手，客户端向服务器端发出连接请求，等待服务器确认\n第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求\n第三次握手，客户端再次向服务器端发送确认信息，确认连接\n\n完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等\n6.2.2 UDP用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在 64k 以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等\n6.3  网络编程三要素6.3.1 协议计算机网络通信必须遵守的规则\n6.3.2 IP地址指互联网协议地址（Internet Protocol Address），俗称 IP。IP 地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”\nIP地址分类\n\nIPv4：是一个 32 位的二进制数，通常被分为 4 个字节，表示成 a.b.c.d 的形式，例如 192.168.65.100 。其中 a、b、c、d 都是0~255之间的十进制整数，那么最多可以表示42亿个\nIPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。有资料显示，全球 IPv4 地址在2011年2月分配完毕。为了扩大地址空间，拟通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 ，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题\n\n常用命令\n\n查看本机IP地址ipconfig\n检查网络是否连通ping IP地址\n\n6.3.3 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？\n如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了\n\n端口号：用两个字节表示的整数，它的取值范围是 0-65535。其中，0~1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败\n\n利用 协议 + IP地址 + 端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互Window 和 Linux 查看端口常用命令\n6.4 TCP 通信程序TCP 通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。两端通信时步骤：\n\n服务端程序，需要事先启动，等待客户端的连接\n客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端\n\n在Java中，提供了两个类用于实现 TCP 通信程序：\n\n客户端： java.net.Socket 类表示创建 Socket 对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信\n服务端： java.net.ServerSocket 类表示创建 ServerSocket 对象，相当于开启一个服务，并等待客户端的连接\n\n6.4.1 Socket 类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点\n构造方法：public Socket(String host, int port)\nSocket client &#x3D; new Socket(&quot;127.0.0.1&quot;, 6666);\n\n创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的 host 是 null ，则相当于指定地址为回送地址\n\n\n\n\n\n\n\n\n\n注：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输\n成员方法\n\npublic InputStream getInputStream() ： 返回此套接字的输入流。\n如果此 Scoket 具有相关联的通道，则生成的 InputStream 的所有操作也关联该通道\n关闭生成的 InputStream 也将关闭相关的 Socket\n\n\npublic OutputStream getOutputStream() ： 返回此套接字的输出流。\n如果此 Scoket 具有相关联的通道，则生成的 OutputStream 的所有操作也关联该通道\n关闭生成的 OutputStream 也将关闭相关的 Socket\n\n\npublic void close() ：关闭此套接字。\n一旦一个 Socket 被关闭，它不可再使用。\n关闭此 Socket 也将关闭相关的 InputStream 和 OutputStream\n\n\npublic void shutdownOutput() ： 禁用此套接字的输出流\n任何先前写出的数据将被发送，随后终止输出流\n\n\n\n6.4.2 ServerSocket 类ServerSocket 类：这个类实现了服务器套接字，该对象等待通过网络的请求\n构造方法：public ServerSocket(int port)\nServerSocket server &#x3D; new ServerSocket(6666);\n\n使用该构造方法在创建 ServerSocket 对象时，就可以将其绑定到一个指定的端口号上，参数 port 就是端口号\n成员方法\n\npublic Socket accept()侦听并接受连接，返回一个新的 Socket 对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接\n\n6.4.3 通信流程\n【服务端】启动，创建 ServerSocket 对象，等待连接\n【客户端】启动，创建 Socket 对象，请求连接\n【服务端】接收连接，调用 accept 方法，并返回一个 Socket 对象\n【客户端】Socket 对象，获取 OutputStream，向服务端写出数据\n【服务端】Scoket 对象，获取 InputStream，读取客户端发送的数据\n\n\n\n\n\n\n\n\n\n\n到此，客户端向服务端发送数据成功。\n\n\n\n\n\n\n\n\n\n\n自此，服务端向客户端回写数据。\n\n【服务端】Socket 对象，获取 OutputStream，向客户端回写数据\n【客户端】Scoket 对象，获取 InputStream，解析回写数据\n【客户端】释放资源，断开连接\n\n6.4.4 使用6.4.4.1 服务端和客户端案例&#x2F;&#x2F; 服务端\npublic static void main(String[] args) throws IOException &#123;\n\tSystem.out.println(&quot;服务端启动 , 等待连接 .... &quot;);\n\t&#x2F;&#x2F; 1.创建 ServerSocket对象，绑定端口，开始等待连接\n\tServerSocket serverSocket &#x3D; new ServerSocket(6666);\n\t&#x2F;&#x2F; 2.接收连接 accept 方法, 返回 socket 对象\n\tSocket server &#x3D; serverSocket.accept();\n\t&#x2F;&#x2F; 3.通过socket 获取输入流\n\tInputStream inputStream &#x3D; server.getInputStream();\n\t&#x2F;&#x2F; 4.一次性读取数据\n\t&#x2F;&#x2F; 4.1 创建字节数组\n\tbyte[] bytes &#x3D; new byte[1024];\n\t&#x2F;&#x2F; 4.2 据读取到字节数组中.\n\tint len &#x3D; inputStream.read(bytes);\n\t&#x2F;&#x2F; 4.3 解析数组,打印字符串信息\n\tString str &#x3D; new String(bytes, 0, len);\n\tSystem.out.println(str);\n\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 回写数据 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t&#x2F;&#x2F; 5. 通过 socket 获取输出流\n\tOutputStream outputStream &#x3D; server.getOutputStream();\n\t&#x2F;&#x2F; 6. 回写数据\n\toutputStream.write(&quot;服务端回复给客户端，数据 111 已收到&quot;.getBytes());\n\t&#x2F;&#x2F; 7.关闭资源.\n\tinputStream.close();\n\toutputStream.close();\n\tserver.close();\n&#125;\n&#x2F;&#x2F; 客户端\npublic static void main(String[] args) throws Exception &#123;\n\tSystem.out.println(&quot;客户端开始发送数据&quot;);\n\t&#x2F;&#x2F; 1.创建 Socket ( ip , port ) , 确定连接到哪里\n\tSocket client &#x3D; new Socket(&quot;localhost&quot;, 6666);\n\t&#x2F;&#x2F; 2.获取流对象 . 输出流\n\tOutputStream outputStream &#x3D; client.getOutputStream();\n\t&#x2F;&#x2F; 3.写出数据.\n\toutputStream.write(&quot;客户端发送到服务端的数据 111&quot;.getBytes());\n\n\t&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 获取回写数据 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\t&#x2F;&#x2F; 4. 通过 Scoket 获取输入流对象\n\tInputStream inputStream &#x3D; client.getInputStream();\n\t&#x2F;&#x2F; 5. 读取数据数据\n\tbyte[] bytes &#x3D; new byte[1024];\n\tint len &#x3D; inputStream.read(bytes);\n\tString str &#x3D; new String(bytes, 0, len);\n\tSystem.out.println(str);\n\t&#x2F;&#x2F; 6. 关闭资源\n\toutputStream.close();\n\tinputStream.close();\n\tclient.close();\n&#125;\n\n\n6.4.4.2 B&#x2F;S 案例访问文件位置，web&#x2F;index.html\n&#x2F;&#x2F; 服务端\npublic static void main(String[] args) throws IOException &#123;\n\tSystem.out.println(&quot;服务端启动 , 等待连接 .... &quot;);\n\t&#x2F;&#x2F; 1. 创建ServerSocket 对象，监听端口\n\tServerSocket server &#x3D; new ServerSocket(8888);\n\t&#x2F;&#x2F; 2. 接收连接 accept 方法, 返回 socket 对象\n\tSocket socket &#x3D; server.accept();\n\t&#x2F;&#x2F; 3. 转换流读取浏览器的请求消息\n\tBufferedReader bufferedReader &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\tString requst &#x3D; bufferedReader.readLine(); &#x2F;&#x2F; 读取一行，GET &#x2F;web&#x2F;index.html HTTP&#x2F;1.1\n\t&#x2F;&#x2F; 3.1 取出请求资源的路径\n\tString[] strArr &#x3D; requst.split(&quot; &quot;); &#x2F;&#x2F;\n\t&#x2F;&#x2F; 3.2 去掉 web 前面的 &#x2F;\n\tString path &#x3D; strArr[1].substring(1); &#x2F;&#x2F; web&#x2F;index.html\n\t&#x2F;&#x2F; 4. 读取客户端请求的资源文件\n\t&#x2F;&#x2F; 通过从字节码获取文件位置\n\t&#x2F;&#x2F; InputStream fis &#x3D; SocketTest.class.getClassLoader().getResourceAsStream(path);\n\t&#x2F;&#x2F; 通过从项目根路径获取文件位置\n\tFileInputStream fileInputStream &#x3D; new FileInputStream(&quot;src&#x2F;main&#x2F;resources&#x2F;&quot; + path);\n\tbyte[] bytes&#x3D; new byte[1024];\n\tint len &#x3D; 0 ;\n\t&#x2F;&#x2F; 5. 字节输出流,将文件写回客户端\n\tOutputStream out &#x3D; socket.getOutputStream();\n\t&#x2F;&#x2F; 5.1 写入HTTP协议响应头,固定写法\n\tout.write(&quot;HTTP&#x2F;1.1 200 OK\\r\\n&quot;.getBytes());\n\tout.write(&quot;Content‐Type:text&#x2F;html\\r\\n&quot;.getBytes());\n\t&#x2F;&#x2F; 5.2 必须要写入空行,否则浏览器不解析\n\tout.write(&quot;\\r\\n&quot;.getBytes());\n\twhile((len &#x3D; fileInputStream.read(bytes)) !&#x3D; -1)&#123;\n\t\tout.write(bytes, 0, len);\n\t&#125;\n\tfileInputStream.close();\n\tout.close();\n\tbufferedReader.close();\n\tsocket.close();\n\tserver.close();\n&#125;\n\n浏览器地址输入 localhost:8888&#x2F;web&#x2F;index.html 进行访问，浏览器请求消息：\n7. Stream 流\n可以以一种声明的方式处理数据，Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象\n这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等\n元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作（terminal operation）得到前面处理的结果\n\n\n\n\n\n\n\n\n\n\n\n\n“Stream流” 其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）\n这里的 filter 、sorted、map 等都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 collect 执行的时候，整个模型才会按照指定策略执行操作。而这得益于 Lambda 的延迟执行特性\n\n7.1 概念Stream（流）是一个来自数据源的元素队列并支持聚合操作\n\n元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算\n数据源流的来源。 可以是集合，数组，I&#x2F;O channel， 产生器 generator 等\n聚合操作类似SQL语句一样的操作， 比如 filter, map, reduce, find, match, sorted 等\n\n特征：\n\nPipelining： 中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行（laziness）和短路（short-circuiting）\n内部迭代： 以前对集合遍历都是通过 Iterator 或者 For-Each 的方式，显式的在集合外部进行迭代， 这叫做外部迭代。Stream提供了内部迭代的方式，通过访问者模式（Visitor）实现\n\n7.2 获取流java.util.stream.Stream 是Java 8 新加入的最常用的流接口。（这并不是一个函数式接口）\n\nstream() ：为集合创建串行流，所有的 Collection 集合都可以通过 stream 默认方法获取流\nparallelStream() ：为集合创建并行流并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。使用并行流并不是一定会提高效率，因为 JVM 对数据进行切片和切换线程也需要时间。所以数据量越小，串行操作越快；数据量越大，并行操作效果越好。\nStream 接口的静态方法 of 可以获取数组对应的流，或者使用 Arrays.stream()\n\n7.3 常用方法\nIntermediate（中间操作）\n一个流可以后面跟随 0 个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历\nmap (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered\n\n\nTerminal（终端操作）\n一个流只能有一个 terminal 操作，当这个操作执行后，返回的不是一个流，无法再被操作。所以这必定是流的最后一个操作。多个 intermediate 操作只会在 Terminal 操作的时候融合起来，一次循环完成，Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果。\nforEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator\n\n\nshort-circuiting（短路操作）\n对于一个 intermediate 操作，如果它接受的是一个无限大的 Stream，但返回一个有限的新Stream\n对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果\nanyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit\n\n\n\n7.3.1 forEachvoid forEach(Consumer&lt;? super T&gt; action);\n\n该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 以下都用这个 ArrayList 进行操作\n\tArrayList&lt;User&gt; users &#x3D; new ArrayList&lt;&gt;();\n\tusers.add(User.builder().name(&quot;张三&quot;).age(19).build());\n\tusers.add(User.builder().name(&quot;李四&quot;).age(20).build());\n\tusers.add(User.builder().name(&quot;王五&quot;).age(21).build());\n\tusers.add(User.builder().name(&quot;赵六&quot;).age(22).build());\n\n\tusers.stream().forEach(new Consumer&lt;User&gt;() &#123;\n\t\t@Override\n\t\tpublic void accept(User user) &#123;\n\t\t\tSystem.out.println(user);\n\t\t&#125;\n\t&#125;);\n\tusers.stream().forEach(user -&gt; System.out.println(user));\n&#125;\n\n\n7.3.2 filter可以通过 filter 方法将一个流转换成另一个子集流\nStream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);\n\n该接口接收一个 Predicate 函数式接口参数（可以是一个 Lambda 或方法引用）作为筛选条件\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 返回名字里含有 “三” 的 user\n\tusers.stream().filter(new Predicate&lt;User&gt;() &#123;\n\t\t@Override\n\t\tpublic boolean test(User user) &#123;\n\t\t\treturn user.getName().contains(&quot;三&quot;);\n\t\t&#125;\n\t&#125;).forEach(user -&gt; System.out.println(user));\n\tusers.stream().filter(user -&gt; user.getName().contains(&quot;三&quot;)).forEach(user -&gt; System.out.println(user));\n&#125;\n\n\n7.3.3 map将流中的元素映射到另一个流中\n&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);\n\n该接口需要一个 Function 函数式接口参数，可以将当前流中的 T 类型数据转换为另一种 R 类型的流\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 将 user 转换为获取 user中的 name\n\tusers.stream().map(new Function&lt;User, String&gt;() &#123;\n\t\t@Override\n\t\tpublic String apply(User user) &#123;\n\t\t\treturn user.getName();\n\t\t&#125;\n\t&#125;).forEach(s -&gt; System.out.println(s));\n\tusers.stream().map(user -&gt; user.getName()).forEach(s -&gt; System.out.println(s));\n&#125;\n\n\n7.3.4 limitlimit 方法可以对流进行截取，只取用前 n 个\nStream&lt;T&gt; limit(long maxSize);\n\n参数是一个 long 型，如果集合当前长度大于参数则进行截取，否则不进行操作\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tusers.stream().limit(3).forEach(user -&gt; System.out.println(user));\n&#125;\n\n\n7.3.5 countlong count();\n\n统计个数，该方法返回一个 long 值代表元素个数\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tlong count &#x3D; users.stream().count();\n\tSystem.out.println(count);\n&#125;\n\n\n7.3.6 skip跳过前几个元素，使用 skip 方法获取一个截取之后的新流\nStream&lt;T&gt; skip(long n);\n\n如果流的当前长度大于 n，则跳过前 n 个；否则将会得到一个长度为 0 的空流\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tusers.stream().skip(2).forEach(user -&gt; System.out.println(user));\n&#125;\n\n\n7.3.7 collect 和 Collectorscollect 可以收集流中的数据到【集合】或者【数组】中\n&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);\n&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);\n\nCollectors 类实现了很多归约操作，例如将流转换成集合和聚合元素\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; 转换为 List\n\tList&lt;User&gt; collect &#x3D; users.stream().collect(Collectors.toList());\n\tSystem.out.println(collect);\n\t&#x2F;&#x2F; 转换为 Map，Key 为 name，Value 为 age\n\tMap&lt;String, Integer&gt; collect1 &#x3D; users.stream().collect(Collectors.toMap(user -&gt; user.getName(), user -&gt; user.getAge()));\n\tSystem.out.println(collect1);\n\t&#x2F;&#x2F; 合并字符串，添加分隔符\n\tString collect2 &#x3D; users.stream().map(user -&gt; user.getName()).collect(Collectors.joining(&quot;, &quot;));\n\tSystem.out.println(collect2);\n&#125;\n\nCollectors 的操作：\n\ncounting：统计聚合结果的元素数量\naveragingDouble、averagingInt、averagingLong：计算聚合元素的平均值，返回值都是 Double 类型\nsummingDouble、summingInt、summingLong：和上面的平均值方法类似，在需要类型转换时，需要强制转换。summingDouble 返回的是 Double 类型、summingInt 返回的是 Integer 类型，summingLong 返回的是 Long 类型\nmaxBy、minBy：求聚合元素中指定比较器中的最大&#x2F;最小元素\nsummarizingDouble、summarizingInt、summarizingLong：统计结果，summarizingDouble 返回 DoubleSummaryStatistics 类型，summarizingInt 返回 IntSummaryStatistics 类型，summarizingLong 返回 LongSummaryStatistics 类型\ntoList、toSet、toCollection：将聚合之后的元素，重新封装到队列中，然后返回，toList 方法返回的是 List 子类，toSet 返回的是 Set 子类，toCollection 返回的是 Collection 子类。Collection 的子类包括 List、Set 等众多子类，所以 toCollection 更加灵活\ntoMap、toConcurrentMap：将聚合元素，重新组装为 Map 结构，toMap 返回的是 Map，toConcurrentMap 返回 ConcurrentMap，也就是说，toConcurrentMap 返回的是线程安全的 Map 结构\ngroupingBy、groupingByConcurrent：roupingBy 与 toMap 都是将聚合元素进行分组，区别是，toMap 结果是 1:1 的 k-v 结构，groupingBy 的结果是 1:n 的 k-v 结构\npartitioningBy：partitioningBy 与 groupingBy 的区别在于，partitioningBy 借助 Predicate 断言，可以将集合元素分为 true 和 false 两部分\njoining：对 String 类型的元素进行聚合，拼接成一个字符串返回\ncollectingAndThen：先对集合进行一次聚合操作，然后通过 Function 定义的函数，对聚合后的结果再次处理\nmapping：先通过 Function 函数处理数据，然后通过 Collector 方法聚合元素\nreducing：提供了三个重载方法，maxBy 和 minBy 这两个函数就是通过 reducing 实现的：\npublic static  Collector&lt;T, ?, Optional&gt; reducing(BinaryOperator op)：直接通过 BinaryOperator 操作，返回值是 Optional\npublic static  Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator op)：预定默认值，然后通过 BinaryOperator 操作\npublic static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator op)：预定默认值，通过 Function 操作元素，然后通过 BinaryOperator 操作\n\n\n\n7.3.8 concat如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat\nstatic &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)\n\n\n\n\n\n\n\n\n\n\n注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\tStream&lt;String&gt; stringStream &#x3D; users.stream().map(user -&gt; user.getName());\n\tStream&lt;Integer&gt; integerStream &#x3D; users.stream().map(user -&gt; user.getAge());\n\t&#x2F;&#x2F; 将包含 name 和 age 的两个流合成一个\n\tStream.concat(stringStream, integerStream).forEach(serializable -&gt; System.out.println(serializable));\n&#125;\n\n\n8. 方法引用双冒号 :: 为引用运算符，而它所在的表达式被称为方法引用。如果 Lambda 要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为 Lambda 的替代者。如：\n\nLambda 表达式写法： s -&gt; System.out.println(s)拿到参数之后经 Lambda 之手，继而传递给 System.out.println 方法去处理。\n方法引用写法： System.out::println直接让 System.out 中的 println 方法来取代 Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。\n\n使用 Lambda，根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。函数式接口是 Lambda 的基础，而方法引用是 Lambda 的孪生兄弟。\n&#x2F;&#x2F; 使用\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; Lambda 写法\n\tusers.stream().map(user -&gt; user).forEach(user -&gt; System.out.println(user));\n\t&#x2F;&#x2F; 方法引用\n\tusers.stream().map(User::toString).forEach(System.out::println);\n\tusers.stream().map(User::getName).forEach(System.out::println);\n&#125;\n\n\n9. 序列化与反序列化9.1 概念\nJava 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型\n将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象\n整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象\n类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法\n\n9.2 序列化一个类的对象要想序列化成功，必须满足两个条件：\n\n该类必须实现 java.io.Serializable 接口\n该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须用 transient 注明是短暂的\n\nObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。该程序执行后，就创建了一个名为 employee.ser 文件\npublic class Employee implements java.io.Serializable&#123;\n   public String name;\n   public String address;\n   public transient int SSN; &#x2F;&#x2F; 短暂的\n   public int number;\n   public void mailCheck()&#123;\n      System.out.println(&quot;Mailing a check to &quot; + name + &quot; &quot; + address);\n   &#125;\n&#125;\n\npublic class SerializeDemo&#123;\n   public static void main(String [] args)&#123;\n      Employee e &#x3D; new Employee();\n      e.name &#x3D; &quot;Reyan Ali&quot;;\n      e.address &#x3D; &quot;Phokka Kuan, Ambehta Peer&quot;;\n      e.SSN &#x3D; 11122333;\n      e.number &#x3D; 101;\n      try&#123;\n         FileOutputStream fileOut &#x3D; new FileOutputStream(&quot;&#x2F;employee.ser&quot;);\n         ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOut);\n         out.writeObject(e);\n         out.close();\n         fileOut.close();\n         System.out.printf(&quot;Serialized data is saved in &#x2F;employee.ser&quot;);\n      &#125;catch(IOException i)&#123;\n          i.printStackTrace();\n      &#125;\n   &#125;\n&#125;\n\n9.3 反序列化下面的 DeserializeDemo 程序实例了反序列化，&#x2F;employee.ser 存储了 Employee 对象\npublic class DeserializeDemo&#123;\n   public static void main(String [] args)&#123;\n      Employee e &#x3D; null;\n      try&#123;\n         FileInputStream fileIn &#x3D; new FileInputStream(&quot;&#x2F;employee.ser&quot;);\n         ObjectInputStream in &#x3D; new ObjectInputStream(fileIn);\n         e &#x3D; (Employee) in.readObject();\n         in.close();\n         fileIn.close();\n      &#125;catch(IOException i)&#123;\n         i.printStackTrace();\n         return;\n      &#125;catch(ClassNotFoundException c)&#123;\n         System.out.println(&quot;Employee class not found&quot;);\n         c.printStackTrace();\n         return;\n      &#125;\n      System.out.println(&quot;Deserialized Employee...&quot;); &#x2F;&#x2F; Deserialized Employee...\n      System.out.println(&quot;Name: &quot; + e.name); &#x2F;&#x2F; Name: Reyan Ali\n      System.out.println(&quot;Address: &quot; + e.address); &#x2F;&#x2F; Address: Phokka Kuan, Ambehta Peer\n      System.out.println(&quot;SSN: &quot; + e.SSN); &#x2F;&#x2F; SSN: 0\n      System.out.println(&quot;Number: &quot; + e.number); &#x2F;&#x2F; Number: 101\n    &#125;\n&#125;\n&#x2F;* 当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，\n该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。\n*&#x2F;\n\n10. Optional一个可以更加轻松的避免 NPE（空指针异常，NullPointException）的工具，Optional 是一个包装类，且不可变，不可序列化\n10.1 创建实例 of、ofNullable为了控制生成实例的方式，也是为了收紧空值 Optional 的定义，Optional 将构造函数定义为 private。想要创建 Optional 实例，可以借助 of 和 ofNullable 两个方法实现。of 方法传入的参数不能是 null 的，否则会抛出 NullPointerException。所以，对于可能是 null 的结果，一定使用 ofNullable\nUserDemo userDemo &#x3D; UserDemo.builder().id(1).name(&quot;张三&quot;).build();\nOptional&lt;UserDemo&gt; userDemoOptional &#x3D; Optional.of(userDemo);\nOptional&lt;Object&gt; nullOptional &#x3D; Optional.ofNullable(null);\n\nOptional 类中还有一个静态方法：empty，这个方法直接返回了内部定义的一个常量 Optional&lt;?&gt; EMPTY &#x3D; new Optional&lt;&gt;()，这个常量的 value 是 null。ofNullable 方法也是借助了 empty 实现 null 的包装：\npublic static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;\n    return value &#x3D;&#x3D; null ? empty() : of(value);\n&#125;\n\n所以说，对于 null 的 Optional 包装类，指向的都是相同的实例对象，Optional.empty() &#x3D;&#x3D; Optional.ofNullable(null) 返回的是 true。换句话说，空 Optional 是单例的，都是引用 Optional.EMPTY\n10.2 获取数据 getOptional 值为空时，使用 get 方法将抛出 NoSuchElementException 异常。如果不想抛出异常，或者能够  100% 确定不是空 Optional，或者使用 isPresent 方法判断\npublic T get() &#123;\n    if (value &#x3D;&#x3D; null) &#123;\n        throw new NoSuchElementException(&quot;No value present&quot;);\n    &#125;\n    return value;\n&#125;\n\n使用 get 方法前，必须使用 isPresent 检查。但是使用 isPresent 前，可以先看是否可以使用 orElse、orElseGet 等方法代替实现。\nSystem.out.println(userDemoOptional.get().getName());\n\n\n10.3 值为空判断 isPresent、ifPresentisPresent 用来判断值是否为空，类似于obj !&#x3D; null，ifPresent 可以传入一个 Consumer 操作，当值不为空的时候，会执行 Consumer 函数。\n&#x2F;&#x2F; if (userDemoOptional!&#x3D; null) &#123;\nif (userDemoOptional.isPresent()) &#123;\n\tSystem.out.println(1111);\n&#125;\n\n上面的方法等价于：\nuserDemoOptional.ifPresent(userDemo1 -&gt; System.out.println(1111));\n\n10.4 值处理 map、flatMapmap 和 flatMap 是对 Optional 的值进行操作的方法，区别在于，map 会将结果包装到 Optional 中返回， flatMap 不会。但是两个方法返回值都是 Optional 类型，这也就要求，flatMap 的方法函数返回值需要是 Optional 类型\npublic&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;\n    Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else &#123;\n        return Optional.ofNullable(mapper.apply(value));\n    &#125;\n&#125;\n\n如果 Optional 的值为空，map 直接返回 Optional.EMPTY，否则会执行函数结果，并使用Optional.ofNullable 包装并返回\nOptional&lt;String&gt; stringOptional &#x3D; userDemoOptional.map(userDemo1 -&gt; userDemo1.getName()); &#x2F;&#x2F; abc\nOptional&lt;String&gt; stringOptional1 &#x3D; stringOptional.map(name -&gt; name.toUpperCase()); &#x2F;&#x2F; ABC\nString aDefault &#x3D; stringOptional1.orElse(&quot;default&quot;); &#x2F;&#x2F; 假如为空，则执行 else，有一个默认值\nSystem.out.println(aDefault); &#x2F;&#x2F; 有值为 abc，则 aDefault 为 ABC、值为空，则 aDefault 为 default\n\nString aDefault &#x3D; userDemoOptional.map(UserDemo::getName).map(String::toUpperCase).orElse(&quot;default&quot;);\n\n10.5 值为空的处理 orElse、orElseGet、orElseThrow当值为空时，orElse和orElseGet返回默认值，orElseThrow抛出指定的异常\norElse 和 orElseGet 的区别是 orElse 方法传入的参数是明确的默认值，orElseGet 方法传入的参数是获取默认值的函数。如果默认值的构造过程比较复杂，需要经过一系列的运算逻辑，那一定要使用 orElseGet，因为 orElseGet 是在值为空的时候，才会执行函数，并返回默认值，如果值不为空，则不会执行函数，相比于 orElse 而言，减少了一次构造默认值的过程。\nString aDefault &#x3D; userDemoOptional.map(UserDemo::getName)\n\t\t.map(String::toUpperCase)\n\t\t.orElse(null);\n\t\t&#x2F;&#x2F; .orElseGet(() -&gt; null);\n\t\t&#x2F;&#x2F; .orElseThrow(() -&gt; new IllegalArgumentException(&quot;clazz属性不合法&quot;));\n\n10.6 条件过滤 filterfilter 方法提供的是值验证，如果值验证为 true，返回当前值；否则，返回空 Optional\n&#x2F;&#x2F; 遍历 userDemos，找到姓名属性为空的，打印 id\nfor (UserDemos userDemo : userDemos) &#123;\n    Optional.of(userDemo )\n            .filter(x -&gt; x.getName() &#x3D;&#x3D; null)\n            .ifPresent(x -&gt; System.out.println(x.getId()));\n&#125;\n\n10.7 equals、hashCode、toStringpublic boolean equals(Object obj) &#123;\n    &#x2F;&#x2F; 同一对象判断\n    if (this &#x3D;&#x3D; obj) &#123;\n        return true;\n    &#125;\n\n    &#x2F;&#x2F; 类型判断\n    if (!(obj instanceof Optional)) &#123;\n        return false;\n    &#125;\n\n    Optional&lt;?&gt; other &#x3D; (Optional&lt;?&gt;) obj;\n    &#x2F;&#x2F; 最终还是值的判断\n    return Objects.equals(value, other.value);\n&#125;\n\npublic int hashCode() &#123;\n    &#x2F;&#x2F; 直接返回值的hashCode\n    return Objects.hashCode(value);\n&#125;\n\npublic String toString() &#123;\n    return value !&#x3D; null\n        ? String.format(&quot;Optional[%s]&quot;, value) &#x2F;&#x2F; 用到了值的toString结果\n        : &quot;Optional.empty&quot;;\n&#125;\n\n\nequals 方法，Optional.of(s1).equals(Optional.of(s2)) 完全等价于 s1.equals(s2)\nhashCode 方法，直接返回的是值的 hashCode，如果是空Optional，返回的是0\ntoString 方法，为了能够识别是 Optional，将打印数据包装了一下。如果是空 Optional，返回的是字符串“Optional.empty”；如果是非空，返回是 “Optional[值的toString]”\n\n","slug":"BlogRepository/Java/Java进阶使用记录","date":"2022-03-08T16:26:17.000Z","categories_index":"Java","tags_index":"Java","author_index":"凡"},{"id":"878ce4a7484c5bfa2f502a7b39598d2b","title":"JetBrains 全家桶及 Jrebel 激活总结","content":"1. JetBrains 全家桶1、首先需要下载 ja-netfilter-all 补丁文件\n\n2、如果之前使用过其他激活教程，那么先重置一下，打开重置脚本文件夹，选择对应系统的脚本，sh 为 Linux 系统脚本，vbs 为 Windows 系统脚本\n\n3、然后打开 scripts 这个文件夹，同样选择对应系统的脚本\n\n4、然后打开 IDEA 或 Pycharm、DataGrip 等，输入激活码\n获取激活码网址：intellij idea 注册码在线生成 (javatiku.cn)\n\n即可激活成功\n2. Jrebel1、首先下载 Jrebel 插件\n\n2、在 Jrebel 界面点击激活\n\n\n3、下载 ilanyu 的 windows 反向代理工具，GitHub 地址：**ilanyu&#x2F;ReverseProxy**\n4、下载完成后，得到一个 exe 文件，双击打开\n\n\n5、回到 Jrebel 的激活界面，URL 为：http://127.0.0.1:8888/&#123;GUID&#125;，邮箱随便填，不需要验证\n在线 GUID 地址：Generate GUIDs online (guidgen.com)\n\n6、点击 Activate Jrebel，等待几秒后，可以看到已经激活，点击右下角的 Next &gt; enable Jrebel for Project\n\n7、选择同意\n\n8、使用 Jrebel 需要开启自动编译和运行时编译\n\n按快捷键 Ctrl+Shift+Alt+&#x2F; ，选择 Registry，该项在新版 IDEA 似乎是默认开启的\n\n同时在 Jrebel 界面将 Automatic compilation 设置为 enable，后面的状态就会有一把绿勾\n\n可以把上面未开启的配置都开启\n\n9、设置成离线工作模式，在设置里找到 Jrebel，点击 Work offline\n\n点击后的配置如下\n\n","slug":"BlogRepository/开发工具及环境/JetBrains 全家桶及 Jrebel 激活总结","date":"2023-02-26T16:45:11.000Z","categories_index":"开发工具及环境","tags_index":"IDEA,Jrebel","author_index":"凡"},{"id":"0b3c1bd1993c2f547919285ec8bd717d","title":"Markdown 数学公式使用总结","content":"1. 语法1、行内公式\n用 $...$ 表示行内公式，如  O_&#123;1 - \\left(\\vert a \\vert \\over 2 \\right)&#125;：$O_{1 - \\left(\\vert a \\vert \\over 2 \\right)}$\n2、多行公式\n用 $$...$$ 表示多行公式，如 \\sum_&#123;i=0&#125;^\\infty x^2 = x_1 + x_2 + x_3 + ... + x_n\n$$\\sum_{i&#x3D;0}^\\infty x^2 &#x3D; x_1 + x_2 + x_3 + … + x_n$$\n2. 上标、下标、分组上标和下标\n\n上标： ^，如 x^y：$x^y$\n下标：_，如 a_i：$a_i$\n\n分组\n符号：&#123;&#125;，例：C_n^2 ：$C_n^2$、C_&#123;n^2&#125;：$C_{n^2}$\n3. 希腊字母\n\n\n公式\n小写\n公式\n大写\n\n\n\n\\alpha\n$\\alpha$\n\\Alpha\n$\\Alpha$\n\n\n\\beta\n$\\beta$\n\\Beta\n$\\Beta$\n\n\n\\delta\n$\\delta$\n\\Delta\n$\\Delta$\n\n\n\\epsilon\n$\\epsilon$\n\\Epsilon\n$\\Epsilon$\n\n\n\\zeta\n$\\zeta$\n\\Zeta\n$\\Zeta$\n\n\n\\eta\n$\\eta$\n\\Eta\n$\\Eta$\n\n\n\\theta\n$\\theta$\n\\Theta\n$\\Theta$\n\n\n\\iota\n$\\iota$\n\\Iota\n$\\Iota$\n\n\n\\kappa\n$\\kappa$\n\\Kappa\n$\\Kappa$\n\n\n\\lambda\n$\\lambda$\n\\Lambda\n$\\Lambda$\n\n\n\\mu\n$\\mu$\n\\Mu\n$\\Mu$\n\n\n\\nu\n$\\nu$\n\\Nu\n$\\Nu$\n\n\n\\xi\n$\\xi$\n\\Xi\n$\\Xi$\n\n\n\\pi\n$\\pi$\n\\Pi\n$\\Pi$\n\n\n\\rho\n$\\rho$\n\\Rho\n$\\Rho$\n\n\n\\sigma\n$\\sigma$\n\\Sigma\n$\\Sigma$\n\n\n\\tau\n$\\kappa$\n\\Tau\n$\\Tau$\n\n\n\\phi\n$\\phi$\n\\Phi\n$\\Phi$\n\n\n\\psi\n$\\psi$\n\\Psi\n$\\Psi$\n\n\n\\omega\n$\\omega$\n\\omega\n$\\Omega$\n\n\n\\omicron\n$\\omicron$\n\\Omicron\n$\\Omicron$\n\n\n\\gamma\n$\\gamma$\n\\Gamma\n$\\Gamma$\n\n\n斜体字母加上前缀 var，\\varDelta：$\\varDelta$\n4. 算数运算\n\n\n公式\n符号\n\n\n\n\\times\n$\\times$\n\n\n\\div\n$\\div$\n\n\n\\cdot\n$\\cdot$\n\n\n&lt;\n$&lt;$\n\n\n&gt;\n$&gt;$\n\n\n\\ll\n$\\ll$\n\n\n\\gg\n$\\gg$\n\n\n\\lll\n$\\lll$\n\n\n\\pm\n$\\pm$\n\n\n\\le 、\\leq\n$\\le$ 、$\\leq$\n\n\n\\ge 、\\geq\n$\\ge$ 、$\\geq$\n\n\n\\mp\n$\\mp$\n\n\n\\leqq\n$\\leqq$\n\n\n\\geqq\n$\\geqq$\n\n\n\\neq\n$\\neq$\n\n\n\\leqslant\n$\\leqslant$\n\n\n\\geqslant\n$\\geqslant$\n\n\n\\approx\n$\\approx$\n\n\n5. 集合\n\n\n公式\n符号\n\n\n\n\\complement\n$\\complement$\n\n\n\\in\n$\\in$\n\n\n\\notin\n$\\notin$\n\n\n/subset\n$\\subset$\n\n\n\\subseteq\n$\\subseteq$\n\n\n\\subsetneq\n$\\subsetneq$\n\n\n\\cap\n$\\cap$\n\n\n\\cup\n$\\cup$\n\n\n\\varnothing\n$\\varnothing$\n\n\n\\emptyset\n$\\emptyset$\n\n\n6. 逻辑运算\n\n\n公式\n符号\n\n\n\n\\land 、\\wedge\n$\\land$ 、$\\wedge$\n\n\n\\lor 、\\vee\n$\\lor$ 、$\\vee$\n\n\n\\lnot 、\\neg\n$\\lnot$ 、$\\neg$\n\n\n\\forall\n$\\forall$\n\n\n\\exists\n$\\exists$\n\n\n\\bot\n$\\bot$\n\n\n/top\n$\\top$\n\n\n\\vdash\n$\\vdash$\n\n\n\\Vdash\n$\\Vdash$\n\n\n\\vDash\n$\\vDash$\n\n\n\\models\n$\\models$\n\n\n7.括号\n\n\n公式\n符号\n\n\n\n(x)\n$(x)$\n\n\n\\Bigg(x \\Bigg)\n$\\Bigg(x \\Bigg)$\n\n\n\\bigg(x \\bigg)\n$\\bigg(x \\bigg)$\n\n\n\\Big(x \\Big)\n$\\Big( x \\Big)$\n\n\n\\big(x \\big)\n$\\big(x \\big)$\n\n\n\\&#123;x \\&#125; 、\\lbrace x \\rbrace\n${x }$ 、$\\lbrace x \\rbrace$\n\n\n[x]\n$[x]$\n\n\n\\vert x \\vert\n$\\vert x \\vert$\n\n\n\\Vert x \\Vert\n$\\Vert x \\Vert$\n\n\n\\langle x \\rangle\n$\\langle x \\rangle$\n\n\n\\lceil x \\rceil\n$\\lceil x \\rceil$\n\n\n\\lfloor x \\rfloor\n$\\lfloor x \\rfloor$\n\n\n二项式系数：\\dbinom nr\n$\\dbinom nr$\n\n\n\\binom nr 、n \\choose r\n$\\binom nr$ 、$n \\choose r$\n\n\n8. 空格\n\n\n公式\n符号\n\n\n\n无视空格：a b\n$a b$\n\n\na \\qquad b\n$a \\qquad b$\n\n\na \\quad b\n$a \\quad b$\n\n\na \\ b\n$a \\ b$\n\n\na \\, b\n$a , b$\n\n\na \\; b\n$a ; b$\n\n\na \\! b\n$a ! b$\n\n\n9. 求和、积分、微分\n\n\n公式\n符号\n\n\n\n\\sum_1^n\n$\\sum_1^n$\n\n\n\\sum_&#123;i=0&#125;^\\infty x^2\n$\\sum_{i&#x3D;0}^\\infty x^2$\n\n\n\\int\n$\\int$\n\n\n\\iint\n$\\iint$\n\n\n\\iiint\n$\\iiint$\n\n\n\\oint\n$\\oint$\n\n\n\\prod\n$\\prod$\n\n\n\\coprod\n$\\coprod$\n\n\n\\bigcap\n$\\bigcap$\n\n\n\\bigcup\n$\\bigcup$\n\n\n\\bigvee\n$\\bigvee$\n\n\n\\bigwedge\n$\\bigwedge$\n\n\n\\infty\n$\\infty$\n\n\n\\nabla\n$\\nabla$\n\n\n\\partial x\n$\\partial x$\n\n\n\\mathrm&#123;d&#125; x\n$\\mathrm{d} x$\n\n\n\\dot x\n$\\dot x$\n\n\n\\ddot x\n$\\ddot x$\n\n\n10. 分式、根号、函数\n\n\n公式\n符号\n\n\n\n\\frac 12\n$\\frac 12$\n\n\n强制分式为显示模式：\\dfrac 12\n$\\dfrac 12$\n\n\n强制分式为文本模式：\\tfrac 12\n$\\tfrac 12$\n\n\n用于连续分式：\\cfrac 12\n$\\cfrac 12$\n\n\n\\frac &#123;x^2&#125;&#123;1+x&#125;\n$\\frac {x^2}{1+x}$\n\n\n用于复杂分式：x^2 \\over 1+x\n$x^2 \\over 1+x$\n\n\n\\sqrt &#123;x^3&#125;\n$\\sqrt {x^3}$\n\n\n\\sqrt[3] &#123;\\frac xy&#125;\n$\\sqrt[3] {\\frac xy}$\n\n\n\\sin x\n$\\sin x$\n\n\n\\lim_&#123;x \\to 0&#125;\n$\\lim_{x \\to 0}$\n\n\n\\varinjlim\n$\\varinjlim$\n\n\n\\varprojlim\n$\\varprojlim$\n\n\n\\varliminf\n$\\varliminf$\n\n\n\\varlimsup\n$\\varlimsup$\n\n\n11. 箭头符号\n\n\n公式\n符号\n\n\n\n\\rightarrow\n$\\rightarrow$\n\n\n\\leftarrow\n$\\leftarrow$\n\n\n\\Rightarrow\n$\\Rightarrow$\n\n\n\\Leftarrow\n$\\Leftarrow$\n\n\n\\longrightarrow\n$\\longrightarrow$\n\n\n\\longleftarrow\n$\\longleftarrow$\n\n\n\\Leftrightarrow\n$\\Leftrightarrow$\n\n\n\\leftrightarrow\n$\\leftrightarrow$\n\n\n\\Longleftrightarrow\n$\\Longleftrightarrow$\n\n\n\\longleftrightarrow\n$\\longleftrightarrow$\n\n\n\\xrightarrow[y&gt;0] &#123;x+y&#125;\n$\\xrightarrow[y&gt;0] {x+y}$\n\n\na \\to b\n$a \\to b$\n\n\na \\gets b\n$a \\gets b$\n\n\na \\implies b\n$a \\implies b$\n\n\na \\impliedby b\n$a \\impliedby b$\n\n\n\\lim_&#123;x \\to 0&#125;\n$\\lim_{x \\to 0}$\n\n\n\\longmapsto\n$\\longmapsto$\n\n\n\\hookleftarrow\n$\\hookleftarrow$\n\n\n12. 几何和向量\n\n\n公式\n符号\n\n\n\n\\triangle\n$\\triangle$\n\n\n\\Diamond\n$\\Diamond$\n\n\n\\Box\n$\\Box$\n\n\n\\odot\n$\\odot$\n\n\n\\angle ABC\n$\\angle ABC$\n\n\n30^\\circ\n$30^\\circ$\n\n\n\\perp\n$\\perp$\n\n\n\\sim\n$\\sim$\n\n\n\\cong\n$\\cong$\n\n\n\\\\hat&#123;a&#125;\n$\\hat{a}$\n\n\n\\vec&#123;a&#125;\n$\\vec{a}$\n\n\n\\overrightarrow&#123;AB&#125;\n$\\overrightarrow{AB}$\n\n\n\\overleftarrow&#123;AB&#125;\n$\\overleftarrow{AB}$\n\n\n\\overleftrightarrow&#123;AB&#125;\n$\\overleftrightarrow{AB}$\n\n\n\\widehat&#123;e f g&#125;\n$\\widehat{e f g}$\n\n\n13. 上、下划线和上、下括号\n\n\n公式\n符号\n\n\n\n\\overline&#123;h i j&#125;\n$\\overline{h i j}$\n\n\n\\underline&#123;h i j&#125;\n$\\underline{h i j}$\n\n\n\\underbrace&#123;a+b+\\cdots+z&#125;_&#123;10&#125;\n$\\underbrace{a+b+\\cdots+z}_{10}$\n\n\n\\overbrace&#123;a+b+\\cdots+z&#125;_&#123;10&#125;\n$\\overbrace{a+b+\\cdots+z}_{10}$\n\n\n13. 特殊字符\n\n\n公式\n符号\n\n\n\n\\eth\n$\\eth$\n\n\n\\S\n$\\S$\n\n\n\\%\n$%$\n\n\n/dagger\n$\\dagger$\n\n\n\\ddagger\n$\\ddagger$\n\n\n\\ast 、*\n$\\ast$ 、$*$\n\n\n\\circ\n$\\circ$\n\n\n\\bullet\n$\\bullet$\n\n\n\\ldots\n$\\ldots$\n\n\n\\cdots\n$\\cdots$\n\n\n\\vdots\n$\\vdots$\n\n\n\\ddots\n$\\ddots$\n\n\n\\smile\n$\\smile$\n\n\n\\frown\n$\\frown$\n\n\n\\wr\n$\\wr$\n\n\n\\oplus\n$\\oplus$\n\n\n\\bigoplus\n$\\bigoplus$\n\n\n\\otimes\n$\\otimes$\n\n\n\\bigotimes\n$\\bigotimes$\n\n\n\\bigodot\n$\\bigodot$\n\n\n\\boxtimes\n$\\boxtimes$\n\n\n\\boxplus\n$\\boxplus$\n\n\n\\triangleleft\n$\\triangleleft$\n\n\n\\triangleright\n$\\triangleright$\n\n\n\\imath\n$\\imath$\n\n\n\\hbar\n$\\hbar$\n\n\n\\ell\n$\\ell$\n\n\n\\mho\n$\\mho$\n\n\n\\Finv\n$\\Finv$\n\n\n\\Re\n$\\Re$\n\n\n\\Im\n$\\Im$\n\n\n\\wp\n$\\wp$\n\n\n\\diamondsuit\n$\\diamondsuit$\n\n\n\\heartsuit\n$\\heartsuit$\n\n\n\\clubsuit\n$\\clubsuit$\n\n\n\\spadesuit\n$\\spadesuit$\n\n\n\\Game\n$\\Game$\n\n\n\\flat\n$\\flat$\n\n\n\\natural\n$\\natural$\n\n\n\\sharp\n$\\sharp$\n\n\n14. 阵列、矩阵、等式对齐、分段函数、编号1、阵列\n语法： $$\\begin&#123;array&#125; … \\end&#123;array&#125;$$，r 右对齐，l 左对齐，c 居中，| 垂直线，\\hline 横线，\\\\ 换行，元素之间以 &amp; 间隔\n$$\n  \\begin&#123;array&#125; &#123;c|lcr&#125;\n    n &amp; \\text&#123;Left&#125; &amp; \\text&#123;Center&#125; &amp; \\text&#123;Right&#125; \\\\\n    \\hline\n    1 &amp; 0.24 &amp; 1 &amp; 125 \\\\\n    2 &amp; -1 &amp; 189 &amp; -8 \\\\\n    3 &amp; -20 &amp; 2000 &amp; 1+10i\n  \\end&#123;array&#125;\n$$\n\n$$\\begin{array} {c|lcr}n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\2 &amp; -1 &amp; 189 &amp; -8 \\3 &amp; -20 &amp; 2000 &amp; 1+10i\\end{array}$$\n2、矩阵\n语法： $$\\begin&#123;matrix&#125; … \\end&#123;matrix&#125;$$，每行以 \\\\ 结尾，元素之间以 &amp; 间隔\n$$\n  \\begin&#123;matrix&#125;\n    1 &amp; x &amp; x^2 \\\\\n    1 &amp; y &amp; y^2 \\\\\n    1 &amp; z &amp; z^2 \\\\\n  \\end&#123;matrix&#125;\n$$\n\n$$\\begin{matrix}    1 &amp; x &amp; x^2 \\    1 &amp; y &amp; y^2 \\    1 &amp; z &amp; z^2 \\  \\end{matrix}$$\n添加括号：\n\npmatrix ：()\nbmatrix ：[ ]\nBmatrix ：{ }\nvmatrix ：| |\nVmatrix ：‖ ‖\n\n添加省略号：\n$$\n\\begin&#123;pmatrix&#125;\n  1 &amp; a_1^2 &amp; a_1^2 &amp; \\cdots &amp; a_1^2 \\\\\n  1 &amp; a_2^2 &amp; a_2^2 &amp; \\cdots &amp; a_2^2 \\\\\n  \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\n  1 &amp; a_n^2 &amp; a_n^2 &amp; \\cdots &amp; a_n^2 \\\\\n\\end&#123;pmatrix&#125;\n$$\n\n$$\\begin{pmatrix}1 &amp; a_1^2 &amp; a_1^2 &amp; \\cdots &amp; a_1^2 \\1 &amp; a_2^2 &amp; a_2^2 &amp; \\cdots &amp; a_2^2 \\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\1 &amp; a_n^2 &amp; a_n^2 &amp; \\cdots &amp; a_n^2 \\\\end{pmatrix}$$\n水平增广矩阵，使用阵列语法：\n$$ \n  \\left[\n    \\begin&#123;array&#125;&#123;cc|c&#125;\n      1&amp;2&amp;3\\\\\n      4&amp;5&amp;6\n    \\end&#123;array&#125;\n  \\right] \n$$\n\n$$\\left[\\begin{array}{cc|c}1&amp;2&amp;3\\4&amp;5&amp;6\\end{array}\\right]$$\n垂直增广矩阵：\n$$\n  \\begin&#123;pmatrix&#125;\n    a &amp; b\\\\\n    c &amp; d\\\\\n    \\hline\n    1 &amp; 0\\\\\n    0 &amp; 1\n  \\end&#123;pmatrix&#125;\n$$\n\n$$\\begin{pmatrix}a &amp; b\\c &amp; d\\\\hline1 &amp; 0\\0 &amp; 1\\end{pmatrix}$$\n3、等式对齐\n语法： \\begin&#123;align&#125; … \\end&#123;align&#125;，每行以 \\\\ 结尾，元素之间以 &amp; 间隔\n$$\n  \\begin&#123;align&#125;\n    \\sqrt&#123;37&#125; &amp; &#x3D; \\sqrt&#123;\\frac&#123;73^2-1&#125;&#123;12^2&#125;&#125; \\\\\n     &amp; &#x3D; \\sqrt&#123;\\frac&#123;73^2&#125;&#123;12^2&#125;\\cdot\\frac&#123;73^2-1&#125;&#123;73^2&#125;&#125; \\\\ \n     &amp; &#x3D; \\sqrt&#123;\\frac&#123;73^2&#125;&#123;12^2&#125;&#125;\\sqrt&#123;\\frac&#123;73^2-1&#125;&#123;73^2&#125;&#125; \\\\\n     &amp; &#x3D; \\frac&#123;73&#125;&#123;12&#125;\\sqrt&#123;1 - \\frac&#123;1&#125;&#123;73^2&#125;&#125; \\\\ \n     &amp; \\approx \\frac&#123;73&#125;&#123;12&#125;\\left(1 - \\frac&#123;1&#125;&#123;2\\cdot73^2&#125;\\right)\n  \\end&#123;align&#125;\n$$\n\n$$\\begin{align}\\sqrt{37} &amp; &#x3D; \\sqrt{\\frac{73^2-1}{12^2}} \\&amp; &#x3D; \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\&amp; &#x3D; \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\&amp; &#x3D; \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\&amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\\end{align}$$\n4、分段函数\n语法： \\begin&#123;cases&#125; … \\end&#123;cases&#125;，每行以 \\\\ 结尾，元素之间以 &amp; 间隔\n$$\n  f(n) &#x3D;\n    \\begin&#123;cases&#125;\n      n&#x2F;2,  &amp; \\text&#123;if $n$ is even&#125; \\\\\n      3n+1, &amp; \\text&#123;if $n$ is odd&#125;\n    \\end&#123;cases&#125;\n$$\n\n$$f(n) &#x3D;\\begin{cases}n&#x2F;2,  &amp; \\text{if $n$ is even} \\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$\n$$  \n  \\left.\n    \\begin&#123;array&#125;&#123;l&#125;\n    \\text&#123;if $n$ is even:&#125;&amp;n&#x2F;2\\\\\n    \\text&#123;if $n$ is odd:&#125;&amp;3n+1\n    \\end&#123;array&#125;\n  \\right\\&#125;\n  &#x3D;f(n)\n$$\n\n$$\\left.\\begin{array}{l}\\text{if $n$ is even:}&amp;n&#x2F;2\\\\text{if $n$ is odd:}&amp;3n+1\\end{array}\\right}&#x3D;f(n)$$\n5、编号\n语法：\\tag\n$$ \n  y&#x3D;x^2        \\tag&#123;1.5a&#125;\n$$\n\n$$y&#x3D;x^2        \\tag{1.5a}$$\n","slug":"BlogRepository/其他实践/Markdown 数学公式使用总结","date":"2023-02-15T02:08:12.000Z","categories_index":"其他实践","tags_index":"markdown","author_index":"凡"},{"id":"b0fd76224154907cc8cb1e96045dc809","title":"RestTemplate 以及 WebClient 调用第三方接口使用总结","content":"1. RestTemplate1.1 引入依赖RestTemplate 在 spring-boot-starter-web 包下\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n1.2 配置类注入 RestTemplate，并进行连接时间等配置\n@Configuration\npublic class RestTemplateConfig &#123;\n\n    @Bean\n    public RestTemplate restTemplate(ClientHttpRequestFactory factory) &#123;\n        return new RestTemplate(factory);\n    &#125;\n\n    @Bean\n    public ClientHttpRequestFactory simpleClientHttpRequestFactory() &#123;\n        SimpleClientHttpRequestFactory factory &#x3D; new SimpleClientHttpRequestFactory();\n        factory.setConnectTimeout(15000);\n        factory.setReadTimeout(5000);\n\n        return factory;\n    &#125;\n&#125;\n\n1.3 工具类RestTemplate 使用起来很简单，这里将 GET 方法和 POST 方法封装成了工具类，DELETE 和 PUT 方法使用方法相同，具体如下：\n@Component\npublic class RestTemplateUtil &#123;\n\n    private static RestTemplate restTemplate;\n\n    @Resource\n    private void setRestTemplate(RestTemplate restTemplate) &#123;\n        RestTemplateUtil.staticSetRestTemplate(restTemplate);\n    &#125;\n\n    &#x2F;**\n     * 静态注入方法, 解决多线程下可能出现的并发问题\n     *\n     * @param restTemplate RestTemplate\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:24\n     *&#x2F;\n    private static synchronized void staticSetRestTemplate(RestTemplate restTemplate) &#123;\n        RestTemplateUtil.restTemplate &#x3D; restTemplate;\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForEntity, 默认返回类型 String\n     *\n     * @param url 请求地址\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:18\n     *&#x2F;\n    public static String doGetWithEntity(String url) &#123;\n        ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.getForEntity(url, String.class);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForEntity, 指定返回类型\n     *\n     * @param url   请求地址\n     * @param clazz 返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:08\n     *&#x2F;\n    public static &lt;T&gt; T doGetWithEntity(String url, Class&lt;T&gt; clazz) &#123;\n        ResponseEntity&lt;T&gt; responseEntity &#x3D; restTemplate.getForEntity(url, clazz);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForObject, 返回值返回的是响应体, 省了再去 getBody(), 默认返回类型 String\n     *\n     * @param url 请求地址\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:19\n     *&#x2F;\n    public static String doGetWithObject(String url) &#123;\n        return restTemplate.getForObject(url, String.class);\n    &#125;\n\n    &#x2F;**\n     * 以 Get 方式请求第三方接口, getForObject, 返回值返回的是响应体, 省了再去 getBody(), 指定返回类型\n     *\n     * @param url   请求地址\n     * @param clazz 返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:16\n     *&#x2F;\n    public static &lt;T&gt; T doGetWithObject(String url, Class&lt;T&gt; clazz) &#123;\n        return restTemplate.getForObject(url, clazz);\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForEntity, 默认返回类型 String\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:28\n     *&#x2F;\n    public static String doPostWithEntity(String url, Object object) &#123;\n        ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.postForEntity(url, object, String.class);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForEntity, 指定返回类型\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @param clazz  返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:18\n     *&#x2F;\n    public static &lt;T&gt; T doPostWithEntity(String url, Object object, Class&lt;T&gt; clazz) &#123;\n        ResponseEntity&lt;T&gt; responseEntity &#x3D; restTemplate.postForEntity(url, object, clazz);\n\n        return responseEntity.getBody();\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForObject, 返回值返回的是响应体, 省了再去 getBody(), 默认返回类型 String\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 16:29\n     *&#x2F;\n    public static String doPostWithObject(String url, Object object) &#123;\n        return restTemplate.postForObject(url, object, String.class);\n    &#125;\n\n    &#x2F;**\n     * 以 Post 方式请求第三方接口, postForObject, 返回值返回的是响应体, 省了再去 getBody(), 指定返回类型\n     *\n     * @param url    请求地址\n     * @param object 请求参数\n     * @param clazz  返回类型\n     * @return &#123;@link T&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;13 17:19\n     *&#x2F;\n    public static &lt;T&gt; T doPostWithObject(String url, Object object, Class&lt;T&gt; clazz) &#123;\n        return restTemplate.postForObject(url, object, clazz);\n    &#125;\n&#125;\n\n1.4 使用测试 Controller\n@RestController\npublic class RestTemplateTestController &#123;\n\n    @GetMapping(&quot;&#x2F;test&quot;)\n    public String test() &#123;\n        return RestTemplateUtil.doGetWithEntity(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;);\n    &#125;\n&#125;\n\n启动项目，这里更改了端口为 8888，访问 http://localhost:8080/test\n\n这里调用的是一言 API，调用成功\n2. WebClientSpring3.0 引入了 RestTemplate，但是在后来的官方源码中介绍，RestTemplate 有可能在未来的版本中被弃用。替代 RestTemplate，在 Spring5 中引入了 WebClient 作为非阻塞式 Reactive Http 客户端\n2.1 引入依赖WebClient 在 spring-boot-starter-webflux 包中\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-webflux&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2.2 使用WebClient 不需要注入，直接使用即可\n@RestController\npublic class WebClientSample &#123;\n\n    &#x2F;**\n     * WebClient.create() 方法\n     *\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:01\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;create&quot;)\n    public String create() &#123;\n        &#x2F;&#x2F; 一个 Mono 对象包含 0 个或 1 个元素\n        Mono&lt;String&gt; stringMono &#x3D; WebClient\n                &#x2F;&#x2F; 创建 WebClient 实例\n                .create()\n                &#x2F;&#x2F; 方法调用, 请求类型\n                .method(HttpMethod.GET)\n                &#x2F;&#x2F; 请求 uri\n                .uri(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                &#x2F;&#x2F; 获取响应结果\n                .retrieve()\n                &#x2F;&#x2F; 将结果转换为指定类型\n                .bodyToMono(String.class);\n\n        &#x2F;&#x2F; 返回最终调用结果，block 方法是阻塞的\n        return stringMono.block();\n    &#125;\n\n    &#x2F;**\n     * WebClient.create(String baseUrl): 指定 baseUrl, 使用该客户端发送请求都是基于 baseUrl\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 16:25\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;createWithBaseUrl&quot;)\n    public void createWithBaseUrl() &#123;\n        &#x2F;&#x2F; 一个 Flux 对象包含 1 个或多个元素\n        Flux&lt;String&gt; stringFlux &#x3D; WebClient.create(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                .get()\n                &#x2F;&#x2F; .uri(&quot;&quot;)\n                .retrieve()\n                .bodyToFlux(String.class);\n\n        &#x2F;&#x2F; 非阻塞式获取响应结果\n        stringFlux.subscribe(this::handleResponse);\n    &#125;\n\n    &#x2F;**\n     * 异步响应回调\n     *\n     * @param response 响应\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:25\n     *&#x2F;\n    private void handleResponse(String response) &#123;\n        LogUtil.info(response);\n    &#125;\n\n    &#x2F;**\n     * WebClient.builder(): 返回一个 WebClient.Builder, 该对象可以做链式调用, 传递更多的参数 &lt;br&#x2F;&gt;\n     * &lt;ul&gt;\n     *     &lt;li&gt;uriBuilderFactory: 自定义 UriBuilderFactory 灵活配置使用 Uri&lt;&#x2F;li&gt;\n     *     &lt;li&gt;defaultHeader: 为 HTTP 请求设置 Headers 请求头&lt;&#x2F;li&gt;\n     *     &lt;li&gt;defaultCookie: 为 HTTP 请求设置 Cookies&lt;&#x2F;li&gt;\n     *     &lt;li&gt;defaultRequest: 自定义 HttpRequest&lt;&#x2F;li&gt;\n     *     &lt;li&gt;filter: 为 HTTP 请求增加客户端过滤器&lt;&#x2F;li&gt;\n     *     &lt;li&gt;exchangeStrategies: HTTP 读写信息自定义&lt;&#x2F;li&gt;\n     *     &lt;li&gt;clientConnector: HTTP 客户端连接器设置&lt;&#x2F;li&gt;\n     * &lt;&#x2F;ul&gt;\n     *\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:02\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;build&quot;)\n    public String build() &#123;\n        return WebClient.builder()\n                .baseUrl(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                .defaultHeader(&quot;build&quot;, &quot;build&quot;)\n                .build()\n                .get()\n                &#x2F;&#x2F; .uri(&quot;&quot;)\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n\n    &#x2F;**\n     * exchange() 方法获取 HTTP 响应完整内容\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:40\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;exchange&quot;)\n    public String exchange() &#123;\n        return WebClient.create()\n                .get()\n                .uri(&quot;https:&#x2F;&#x2F;v1.hitokoto.cn&quot;)\n                .exchangeToMono(clientResponse -&gt; &#123;\n                    &#x2F;&#x2F; 响应头\n                    ClientResponse.Headers headers &#x3D; clientResponse.headers();\n                    &#x2F;&#x2F; 响应状态\n                    HttpStatus httpStatus &#x3D; clientResponse.statusCode();\n                    &#x2F;&#x2F; 响应状态码\n                    int rawStatusCode &#x3D; clientResponse.rawStatusCode();\n                    &#x2F;&#x2F; 响应体\n                    return clientResponse.bodyToMono(String.class);\n                &#125;).block();\n    &#125;\n\n    &#x2F;**\n     * 数字占位符传参\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:50\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;numParam&quot;)\n    public String numParam() &#123;\n        return WebClient.create()\n                .method(HttpMethod.POST)\n                .uri(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;&#123;1&#125;&#x2F;&#123;2&#125;&quot;, ListUtil.list(false, 1, 2).toArray())\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n\n    &#x2F;**\n     * 参数名传参\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:53\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;nameParam&quot;)\n    public String nameParam() &#123;\n        return WebClient.create()\n                .method(HttpMethod.POST)\n                .uri(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;, &quot;id&quot;, &quot;name&quot;)\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n\n    &#x2F;**\n     * Map 传参\n     *\n     * @author Fan\n     * @since 2023&#x2F;1&#x2F;31 14:54\n     *&#x2F;\n    @GetMapping(&quot;&#x2F;mapParam&quot;)\n    public String mapParam() &#123;\n        return WebClient.create()\n                .method(HttpMethod.POST)\n                .uri(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,\n                        MapUtil.ofEntries(false, MapUtil.entry(&quot;id&quot;, &quot;id&quot;), MapUtil.entry(&quot;name&quot;, &quot;name&quot;)))\n                .retrieve()\n                .bodyToMono(String.class)\n                .block();\n    &#125;\n&#125;\n\n启动项目，这里更改了端口为 8888，访问 http://localhost:8888/build\n\n","slug":"BlogRepository/开发技术及框架/RestTemplate 以及 WebClient 调用第三方接口使用总结","date":"2023-01-31T08:51:29.000Z","categories_index":"开发技术及框架","tags_index":"开发技术及框架","author_index":"凡"},{"id":"db6eec5ece30b9e502959c9b69bfe8c5","title":"Yarn 下载安装及常用配置和命令总结","content":"1. Node.js建议先安装好 Node.js，见另一篇：Node.js 多版本安装及 NPM 镜像配置_凡 223 的博客\n2. 下载安装由于 Node.js 自带了一个包管理器 NPM，所以安装 Yarn 更简单的方法是直接使用 npm install --location=global yarn 即可\n\n如果想要升级 Yarn 版本，可以先从网上查询 Yarn 最新版本号，一般 Yarn 有新版本控制台会自动提示，然后使用指定版本号的命令即可升级，npm install yarn@1.22.19 --location=global\n\n3. 修改 Yarn 全局包与缓存的安装位置\n检查当前 Yarn 的 bin 的位置：yarn global bin\n检查当前 Yarn 的全局安装位置：yarn global dir\n检查当前 Yarn 的全局缓存位置：yarn cache dir\n修改当前 Yarn 的全局安装位置：yarn config set global-folder &quot;自定义路径&quot;，修改后如果用 Yarn 安装的全局目录没有生效，重新打开 cmd 再用 Yarn 安装即可\n相应修改 Yarn 的缓存：yarn config set cache-folder &quot;自定义路径&quot;\n清除全局缓存：yarn cache clean\n\n4. 基本命令\n\n\nNPM\nYarn\n\n\n\nnpm install\nyarn\n\n\nnpm install xxx –save\nyarn add xxx\n\n\nnpm uninstall xxx –save\nyarn remove xxx\n\n\nnpm install xxx –save-dev\nyarn add xxx –dev\n\n\nnpm update –save\nyarn upgrade\n\n\n\n安装包：yarn [global] add [package]@[version]\n更新包：yarn upgrade [package | package@tag | package@version | @scope/]... [--ignore-engines] [--pattern]\n删除包：yarn remove &lt;package...&gt;\n列出所有包和它们的依赖：yarn list [--depth] [--pattern]\n运行脚本：yarn run [script] [&lt;args&gt;]\n\n","slug":"BlogRepository/开发工具及环境/Yarn 下载安装及常用配置和命令总结","date":"2023-01-13T06:47:32.000Z","categories_index":"开发工具及环境","tags_index":"开发工具及环境","author_index":"凡"},{"id":"f1cea3ae9e9660834ef5c504249979bd","title":"Spring Cloud 以及 Spring Cloud Alibaba 使用总结","content":"1. 版本对应官网版本说明：版本说明 · alibaba&#x2F;spring-cloud-alibaba Wiki (github.com)\n\n这里使用 Spring Boot 2.7.7、Spring Cloud 2021.0.4、Spring Cloud Alibaba 2021.0.4.0，搭配 JDK 8\n&lt;properties&gt;\n        &lt;spring.cloud.version&gt;2021.0.4&lt;&#x2F;spring.cloud.version&gt;\n        &lt;spring.cloud.alibaba.version&gt;2021.0.4.0&lt;&#x2F;spring.cloud.alibaba.version&gt;\n&lt;&#x2F;properties&gt;\n\n&lt;dependencyManagement&gt;\n            &lt;!-- Spring Cloud Dependencies--&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;!-- Spring Cloud Alibaba Dependencies --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;&#x2F;version&gt;\n                &lt;type&gt;pom&lt;&#x2F;type&gt;\n                &lt;scope&gt;import&lt;&#x2F;scope&gt;\n            &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencyManagement&gt;\n\n2. Nacos见另一篇：服务器 Nacos 集群搭建及使用总结_凡 223 的博客\n3. Gateway3.1 引入依赖包括 Gateway 网关依赖和 Nacos 服务注册发现的依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n3.2 配置将 Gateway 注册进 Nacos，同时进行 Gateway 相关的配置\nserver:\n  port: 9000\nspring:\n  application:\n    name: gateway\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 124.222.xxx.90:8848\n    gateway:\n      routes:\n        - id: provider1 # 路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http:&#x2F;&#x2F;localhost:8000  # 匹配提供服务的路由地址\n          # 网关断言匹配\n          predicates:\n            - Path&#x3D;&#x2F;user&#x2F;**    # 路径相匹配的进行路由\n\n3.3 启动类启动类添加 @EnableDiscoveryClient 注解\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class GatewayApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(GatewayApplication.class, args);\n    &#125;\n&#125;\n\n3.4 服务 Provider-11、POM\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2、YAML\n这里的端口与前面 Gateway 的配置文件里的 uri 端口一致\nserver:\n  port: 8000\nspring:\n  application:\n    name: provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 124.222.xxx.90:8848\n\n3、启动类\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class Service1Application &#123;\n    public static void main( String[] args ) &#123;\n        SpringApplication.run(Service1Application.class, args);\n    &#125;\n&#125;\n\n4、Controller\n@RestController\npublic class UserController &#123;\n\n    @GetMapping(&quot;&#x2F;user&#x2F;get&quot;)\n    public String get() &#123;\n        return &quot;provider-1 user get&quot;;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;test&quot;)\n    public String test() &#123;\n        return &quot;provider-1 test&quot;;\n    &#125;\n&#125;\n\n3.5 查看路由转发分别启动 Gateway 和 Service，可以看到两个服务都注册了进来\n\n访问 localhost:9000/user/get，通过网关的端口成功调用到服务 Provider-1\n\n测试一下 Predicates 的效果，访问 /test，访问失败，路径不匹配\n\n3.6 动态路由与负载均衡将 3.4 的服务 Provider-1 再复制一份，为 Provider-2，这时就存在了两个服务\n\n\n在 3.2 的配置中，uri 是固定的地址，那如何让 Gateway 转发两个服务或以上呢？\n1、修改配置文件\n开启动态路由，通过服务名来匹配服务\nserver:\n  port: 9000\nspring:\n  application:\n    name: gateway\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 124.222.118.90:8848\n    gateway:\n      discovery:\n        locator:\n          enabled: true # 开启从注册中心动态创建路由的功能, 利用微服务名进行路由\n      routes:\n        - id: provider1 # 路由的ID, 没有固定规则但要求唯一, 建议配合服务名\n          uri: lb:&#x2F;&#x2F;provider  # 匹配提供服务的路由地址\n          # 网关断言匹配\n          predicates:\n            - Path&#x3D;&#x2F;user&#x2F;**    # 路径相匹配的进行路由\n        - id: provider2\n          uri: lb:&#x2F;&#x2F;provider\n          predicates:\n            - Path&#x3D;&#x2F;user&#x2F;**\n\n2、配置中 uri 的协议为 lb，表示启用 Gateway 的负载均衡功能，此时需要引入 spring-cloud-starter-loadbalancer 依赖，版本在最开始已统一定义\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n3、查看路由转发\n\n\n4. OpenFeign4.1 引入依赖这里同样需要引入 spring-cloud-starter-loadbalancer 依赖来实现 OpenFeign 自带的负载均衡\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n4.2 配置服务注册进 Nacos，同时进行 OpenFeign 的相关配置，断路器的配置可见 5.2.2 服务降级的服务调用方部分\nserver:\n  port: 7000\nspring:\n  application:\n    name: consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 124.222.xxx.90:8848\nfeign:\n  client:\n    config:\n      default:\n        # 日志等级\n        logger-level: full\n        # 超时时间\n        connect-timeout: 1500\n        read-timeout: 1500\n  # 断路器\n  circuitbreaker:\n    enabled: true\n\n\n4.3 启动类添加 @EnableFeignClients 注解开启 OpenFeign\n@SpringBootApplication\n@EnableFeignClients\n@EnableDiscoveryClient\npublic class Consumer1Application &#123;\n    public static void main( String[] args ) &#123;\n        SpringApplication.run(Consumer1Application.class, args);\n    &#125;\n&#125;\n\n4.4 FeignService新建一个接口，用于进行调用，在接口上添加 @FeignClient 注解，值为提供服务的服务名，在调用方法上添加对应的地址映射\n@FeignClient(&quot;provider&quot;)\npublic interface FeignService &#123;\n\n    @GetMapping(&quot;&#x2F;user&#x2F;get&quot;)\n    String get();\n&#125;\n\n4.5 ConsumerController将 FeignService 注入进来，然后调用方法\n@RestController\npublic class ConsumerController &#123;\n\n    @Resource\n    private FeignService consumerService;\n\n    @GetMapping(&quot;&#x2F;user&#x2F;get&quot;)\n    public String get() &#123;\n        return consumerService.get();\n    &#125;\n\n    @GetMapping(&quot;&#x2F;test&quot;)\n    public String test() &#123;\n        return &quot;consumer-1 test&quot;;\n    &#125;\n&#125;\n\n4.6 查看远程调用自带负载均衡功能\n\n\n5. HystrixHystrix 已经停止更新进入维护阶段\n5.1 前期准备5.1.1 引入依赖该版本为 Hystrix 的最后一个版本\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n5.1.2 配置server:\n  port: 8002\n\nspring:\n  application:\n    name: provider-hystrix\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 124.222.xxx.90:8848\n\n5.1.3 启动类@SpringBootApplication\n@EnableDiscoveryClient\npublic class HystrixApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(HystrixApplication.class, args);\n    &#125;\n&#125;\n\n5.1.4 HystrixServicepublic interface HystrixService &#123;\n\n    String normal();\n\n    String timeout();\n&#125;\n\n@Service\npublic class HystrixServiceImpl implements HystrixService &#123;\n\n    @Override\n    public String normal() &#123;\n        return &quot;normal&quot;;\n    &#125;\n\n    @Override\n    public String timeout() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(5);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        return &quot;timeout&quot;;\n    &#125;\n&#125;\n\n5.1.5 HystrixController@RestController\npublic class HystrixController &#123;\n\n    @Resource\n    private HystrixService hystrixService;\n\n    @GetMapping(&quot;&#x2F;normal&quot;)\n    public String normal() &#123;\n        return hystrixService.normal();\n    &#125;\n\n    @GetMapping(&quot;&#x2F;timeout&quot;)\n    public String timeout() &#123;\n        return hystrixService.timeout();\n    &#125;\n&#125;\n\n5.1.6 访问访问 localhost:8002/normal，正常显示\n\n访问 localhost:8002/timeout，等待 5 秒后显示\n\n5.2 服务降级5.2.1 服务提供方1、HystrixService 添加 @HystrixCommand 注解，参数 fallbackMethod 为定义的回调方法，参数 @HystrixProperty 为超时时间\n@Service\npublic class HystrixServiceImpl implements HystrixService &#123;\n\n    @Override\n    public String normal() &#123;\n        return &quot;normal&quot;;\n    &#125;\n\n    @HystrixCommand(fallbackMethod &#x3D; &quot;globalFallback&quot;,commandProperties &#x3D; &#123;\n            @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value&#x3D;&quot;3000&quot;)\n    &#125;)\n    @Override\n    public String timeout() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(5);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        &#125;\n\n        return &quot;timeout&quot;;\n    &#125;\n\n\n    public String globalFallback()&#123;\n        return &quot;&#x2F;(ㄒoㄒ)&#x2F;调用接口超时或异常：\\t&quot;+ &quot;\\t当前线程池名字&quot; + Thread.currentThread().getName();\n    &#125;\n&#125;\n\n2、启动类添加 @EnableHystrix 注解\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix\npublic class HystrixApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(HystrixApplication.class, args);\n    &#125;\n&#125;\n\n3、再次访问 timeout，触发服务降级\n4、统一配置，通过 @DefaultProperties 来进行默认配置，不用每个方法都进行配置\n@Service\n@DefaultProperties(defaultFallback &#x3D; &quot;globalFallback&quot;, commandProperties &#x3D; &#123;\n        @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value&#x3D;&quot;3000&quot;)\n&#125;)\npublic class HystrixServiceImpl implements HystrixService &#123;\n\n    @Override\n    public String normal() &#123;\n        return &quot;normal&quot;;\n    &#125;\n\n    @HystrixCommand\n    @Override\n    public String timeout() &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(5);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        &#125;\n\n        return &quot;timeout&quot;;\n    &#125;\n\n\n    public String globalFallback()&#123;\n        return &quot;&#x2F;(ㄒoㄒ)&#x2F;调用接口超时或异常：\\t&quot;+ &quot;\\t当前线程池名字&quot; + Thread.currentThread().getName();\n    &#125;\n&#125;\n\n这里是在服务提供方进行了服务降级的处理，假如有其他服务调用该服务，但是服务提供方宕机了，无法触发服务降级（这里首先需要 OpenFeign 的超时时间大于服务提供方返回响应的时间，否则会直接报超时异常），因此调用方也需要进行服务降级的处理，可以配合 OpenFeign 进行处理\n5.2.2 服务调用方1、在 OpenFeign 的配置里开启断路器，开启了断路器之后，会先判断 Hystrix 的超时时间然后再判断 OpenFeign 的超时时间，Hystrix 默认的超时时间是 1 秒，所以需要重新设置 Hystrix 的超时时间\nfeign:\n  client:\n    config:\n      default:\n        # 日志等级\n        logger-level: full\n        # 超时时间\n        connect-timeout: 1500\n        read-timeout: 1500\n  # 断路器\n  circuitbreaker:\n    enabled: true\nhystrix:\n  command:\n    default:\n      execution:\n        isolation:\n          thread:\n            timeoutInMilliseconds: 1500\n\n2、添加依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n3、@FeignClient 注解添加 fallback 参数，FallbackServiceImpl 为处理类\n@FeignClient(value &#x3D; &quot;provider-hystrix&quot;, fallback &#x3D; FallbackServiceImpl.class)\npublic interface FeignService &#123;\n\n    @GetMapping(&quot;&#x2F;timeout&quot;)\n    String get();\n&#125;\n\n4、FallbackServiceImpl 实现 FeignService，统一为调用接口里的方法进行异常处理\n@Service\npublic class FallbackServiceImpl implements FeignService &#123;\n\n    @Override\n    public String get() &#123;\n        return &quot;服务调用失败，提示来自：Consumer-OpenFeign&quot;;\n    &#125;\n&#125;\n\n5、关闭服务提供方，调用接口，触发服务调用方的服务降级\n\n假如没有设置断路器，则会显示白页错误\n\n5.3 服务熔断修改 @HystrixCommand 注解的参数\n@Service\npublic class HystrixServiceImpl implements HystrixService &#123;\n\n    @HystrixCommand(fallbackMethod &#x3D; &quot;circuitBreakerFallback&quot;, commandProperties &#x3D; &#123;\n            @HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;, value &#x3D; &quot;true&quot;), &#x2F;&#x2F; 是否开启断路器\n            @HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;, value &#x3D; &quot;10&quot;), &#x2F;&#x2F; 设置请求次数\n            @HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value &#x3D; &quot;10000&quot;), &#x2F;&#x2F; 时间窗口期\n            @HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;, value &#x3D; &quot;60&quot;), &#x2F;&#x2F; 失败率达到多少后跳闸\n    &#125;)\n    public String circuitBreaker(Integer id) &#123;\n        if (id &lt; 0) &#123;\n            throw new RuntimeException(&quot;******id 不能负数&quot;);\n        &#125;\n        String serialNumber &#x3D; UUID.randomUUID().toString();\n\n        return Thread.currentThread().getName() + &quot;\\t&quot; + &quot;调用成功，流水号: &quot; + serialNumber;\n    &#125;\n\n    public String circuitBreakerFallback(Integer id) &#123;\n        return &quot;id 不能负数，请稍后再试，&#x2F;(ㄒoㄒ)&#x2F;~~   id: &quot; + id;\n    &#125;\n&#125;\n\n涉及到断路器的三个重要参数：快照时间窗、请求总数阀值、错误百分比阀值\n\n快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的 10 秒\n请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为 20，意味着在 10 秒内，如果该 Hystrix 命令的调用次数不足 20 次，即使所有的请求都超时或其他原因失败，断路器都不会打开\n错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了 30 次调用，如果在这 30 次调用中，有 15 次发生了超时异常，也就是超过 50% 的错误百分比，在默认设定 50% 阀值情况下，这时候就会将断路器打开\n\n熔断类型：\n\n打开：请求不再进行调用当前服务，内部设置时钟一般为 MTTR（平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态\n关闭：熔断关闭不会对服务进行熔断\n半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断\n\n5.4 服务监控 HystrixDashboard1、引入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n2、配置\n这里需要配置允许 hostname，否则会报 Unable to connect to Command Metric Stream\nserver:\n  port: 7001\nhystrix:\n  dashboard:\n    proxy-stream-allow-list: &quot;localhost&quot;\n\n3、启动类\n添加 @EnableHystrixDashboard 注解\n@SpringBootApplication\n@EnableHystrixDashboard\npublic class HystrixDashboardApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(HystrixDashboardApplication.class, args);\n    &#125;\n&#125;\n\n4、访问 http://localhost:7001/hystrix，已经可以看到仪表盘\n\n5、在需要监控的服务，引入 spring-boot-starter-actuator 依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n6、配置监控路径\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix\npublic class HystrixApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(HystrixApplication.class, args);\n    &#125;\n\n    &#x2F;&#x2F; 配置监控路径\n    @Bean\n    public ServletRegistrationBean getServlet() &#123;\n        HystrixMetricsStreamServlet streamServlet &#x3D; new HystrixMetricsStreamServlet();\n        ServletRegistrationBean registrationBean &#x3D; new ServletRegistrationBean(streamServlet);\n        registrationBean.setLoadOnStartup(1);\n        registrationBean.addUrlMappings(&quot;&#x2F;hystrix.stream&quot;);\n        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);\n        return registrationBean;\n    &#125;\n&#125;\n\n7、在仪表盘输入需要监控的服务路径\n\n8、调用几次接口请求后，即可看到监控图\n\n其他组件的使用待完善","slug":"BlogRepository/Spring/Spring Cloud 以及 Spring Cloud Alibaba 使用总结","date":"2023-01-13T03:54:15.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"凡"},{"id":"860180e4219f9ce98400fc5559b6d34d","title":"设计模式之美总结（开源实战篇）","content":"设计模式相关的详细知识见如下三篇：\n\n设计模式之美总结（创建型篇）_凡 223 的博客\n设计模式之美总结（结构型篇）_凡 223 的博客\n设计模式之美总结（行为型篇）_凡 223 的博客\n\n1. Java JDK 应用到的设计模式1.1 工厂模式在 Calendar 类中的应用在前面讲到工厂模式的时候，大部分工厂类都是以 Factory 作为后缀来命名，并且工厂类主要负责创建对象这样一件事情。但在实际的项目开发中，工厂类的设计更加灵活。比如工厂模式在 Java JDK 中的一个应用：java.util.Calendar。从命名上，我们无法看出它是一个工厂类\nCalendar 类提供了大量跟日期相关的功能代码，同时，又提供了一个 getInstance() 工厂方法，用来根据不同的 TimeZone 和 Locale 创建不同的 Calendar 子类对象。也就是说，功能代码和工厂方法代码耦合在了一个类中。所以，即便去查看它的源码，如果不细心的话，也很难发现它用到了工厂模式。同时，因为它不单单是一个工厂类，所以，它并没有以 Factory 作为后缀来命名\nCalendar 类的相关代码如下所示，大部分代码都已经省略，只给出了 getInstance() 工厂方法的代码实现。从代码中可以看出，getInstance() 方法可以根据不同 TimeZone 和 Locale，创建不同的 Calendar 子类对象，比如 BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar，这些细节完全封装在工厂方法中，使用者只需要传递当前的时区和地址，就能够获得一个 Calendar 类对象来使用，而获得的对象具体是哪个 Calendar 子类的对象，使用者在使用的时候并不关心\npublic abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123;\n\t&#x2F;&#x2F;...\n\tpublic static Calendar getInstance(TimeZone zone, Locale aLocale) &#123;\n\t\treturn createCalendar(zone, aLocale);\n\t&#125;\n\tprivate static Calendar createCalendar(TimeZone zone,Locale aLocale) &#123;\n\t\tCalendarProvider provider &#x3D; LocaleProviderAdapter.getAdapter(\n\t\t                                CalendarProvider.class, aLocale).getCalendarProvider();\n\t\tif (provider !&#x3D; null) &#123;\n\t\t\ttry &#123;\n\t\t\t\treturn provider.getInstance(zone, aLocale);\n\t\t\t&#125; catch (IllegalArgumentException iae) &#123;\n                                &#x2F;&#x2F; fall back to the default instantiation\n\t\t\t&#125;\n\t\t&#125;\n\t\tCalendar cal &#x3D; null;\n\t\tif (aLocale.hasExtensions()) &#123;\n\t\t\tString caltype &#x3D; aLocale.getUnicodeLocaleType(&quot;ca&quot;);\n\t\t\tif (caltype !&#x3D; null) &#123;\n\t\t\t\tswitch (caltype) &#123;\n\t\t\t\tcase &quot;buddhist&quot;:\n\t\t\t\t\tcal &#x3D; new BuddhistCalendar(zone, aLocale);\n\t\t\t\t\tbreak;\n\t\t\t\tcase &quot;japanese&quot;:\n\t\t\t\t\tcal &#x3D; new JapaneseImperialCalendar(zone, aLocale);\n\t\t\t\t\tbreak;\n\t\t\t\tcase &quot;gregory&quot;:\n\t\t\t\t\tcal &#x3D; new GregorianCalendar(zone, aLocale);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (cal &#x3D;&#x3D; null) &#123;\n\t\t\tif (aLocale.getLanguage() &#x3D;&#x3D; &quot;th&quot; &amp;&amp; aLocale.getCountry() &#x3D;&#x3D; &quot;TH&quot;) &#123;\n\t\t\t\tcal &#x3D; new BuddhistCalendar(zone, aLocale);\n\t\t\t&#125; else if (aLocale.getVariant() &#x3D;&#x3D; &quot;JP&quot; &amp;&amp; aLocale.getLanguage() &#x3D;&#x3D; &quot;ja&quot;) &#123;\n\t\t\t\tcal &#x3D; new JapaneseImperialCalendar(zone, aLocale);\n\t\t\t&#125; else &#123;\n\t\t\t\tcal &#x3D; new GregorianCalendar(zone, aLocale);\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn cal;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n\n1.2 建造者模式在 Calendar 类中的应用还是刚刚的 Calendar 类，它不仅仅用到了工厂模式，还用到了建造者模式。建造者模式有两种实现方法，一种是单独定义一个 Builder 类，另一种是将 Builder 实现为原始类的内部类。Calendar 就采用了第二种实现思路\npublic abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123;\n\t&#x2F;&#x2F;...\n\tpublic static class Builder &#123;\n\t\tprivate static final int NFIELDS &#x3D; FIELD_COUNT + 1;\n\t\tprivate static final int WEEK_YEAR &#x3D; FIELD_COUNT;\n\t\tprivate long instant;\n\t\tprivate int[] fields;\n\t\tprivate int nextStamp;\n\t\tprivate int maxFieldIndex;\n\t\tprivate String type;\n\t\tprivate TimeZone zone;\n\t\tprivate boolean lenient &#x3D; true;\n\t\tprivate Locale locale;\n\t\tprivate int firstDayOfWeek, minimalDaysInFirstWeek;\n\t\tpublic Builder() &#123;&#125;\n\t\tpublic Builder setInstant(long instant) &#123;\n\t\t\tif (fields !&#x3D; null) &#123;\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t&#125;\n\t\t\tthis.instant &#x3D; instant;\n\t\t\tnextStamp &#x3D; COMPUTED;\n\t\t\treturn this;\n\t\t&#125;\n                &#x2F;&#x2F;...省略n多set()方法\n\t\tpublic Calendar build() &#123;\n\t\t\tif (locale &#x3D;&#x3D; null) &#123;\n\t\t\t\tlocale &#x3D; Locale.getDefault();\n\t\t\t&#125;\n\t\t\tif (zone &#x3D;&#x3D; null) &#123;\n\t\t\t\tzone &#x3D; TimeZone.getDefault();\n\t\t\t&#125;\n\t\t\tCalendar cal;\n\t\t\tif (type &#x3D;&#x3D; null) &#123;\n\t\t\t\ttype &#x3D; locale.getUnicodeLocaleType(&quot;ca&quot;);\n\t\t\t&#125;\n\t\t\tif (type &#x3D;&#x3D; null) &#123;\n\t\t\t\tif (locale.getCountry() &#x3D;&#x3D; &quot;TH&quot; &amp;&amp; locale.getLanguage() &#x3D;&#x3D; &quot;th&quot;) &#123;\n\t\t\t\t\ttype &#x3D; &quot;buddhist&quot;;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\ttype &#x3D; &quot;gregory&quot;;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tswitch (type) &#123;\n\t\t\tcase &quot;gregory&quot;:\n\t\t\t\tcal &#x3D; new GregorianCalendar(zone, locale, true);\n\t\t\t\tbreak;\n\t\t\tcase &quot;iso8601&quot;:\n\t\t\t\tGregorianCalendar gcal &#x3D; new GregorianCalendar(zone, locale, true);\n                                &#x2F;&#x2F; make gcal a proleptic Gregorian\n\t\t\t\tgcal.setGregorianChange(new Date(Long.MIN_VALUE));\n                                &#x2F;&#x2F; and week definition to be compatible with ISO 8601\n\t\t\t\tsetWeekDefinition(MONDAY, 4);\n\t\t\t\tcal &#x3D; gcal;\n\t\t\t\tbreak;\n\t\t\tcase &quot;buddhist&quot;:\n\t\t\t\tcal &#x3D; new BuddhistCalendar(zone, locale);\n\t\t\t\tcal.clear();\n\t\t\t\tbreak;\n\t\t\tcase &quot;japanese&quot;:\n\t\t\t\tcal &#x3D; new JapaneseImperialCalendar(zone, locale, true);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(&quot;unknown calendar type: &quot; + type)\n\t\t\t&#125;\n\t\t\tcal.setLenient(lenient);\n\t\t\tif (firstDayOfWeek !&#x3D; 0) &#123;\n\t\t\t\tcal.setFirstDayOfWeek(firstDayOfWeek);\n\t\t\t\tcal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);\n\t\t\t&#125;\n\t\t\tif (isInstantSet()) &#123;\n\t\t\t\tcal.setTimeInMillis(instant);\n\t\t\t\tcal.complete();\n\t\t\t\treturn cal;\n\t\t\t&#125;\n\t\t\tif (fields !&#x3D; null) &#123;\n\t\t\t\tboolean weekDate &#x3D; isSet(WEEK_YEAR) &amp;&amp; fields[WEEK_YEAR] &gt; fields[YEAR]\n\t\t\t\tif (weekDate &amp;&amp; !cal.isWeekDateSupported()) &#123;\n\t\t\t\t\tthrow new IllegalArgumentException(&quot;week date is unsupported by &quot; + t\n\t\t\t\t&#125;\n\t\t\t\tfor (int stamp &#x3D; MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) &#123;\n\t\t\t\t\tfor (int index &#x3D; 0; index &lt;&#x3D; maxFieldIndex; index++) &#123;\n\t\t\t\t\t\tif (fields[index] &#x3D;&#x3D; stamp) &#123;\n\t\t\t\t\t\t\tcal.set(index, fields[NFIELDS + index]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tif (weekDate) &#123;\n\t\t\t\t\tint weekOfYear &#x3D; isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;\n\t\t\t\t\tint dayOfWeek &#x3D; isSet(DAY_OF_WEEK)\n\t\t\t\t\t                ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();\n\t\t\t\t\tcal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);\n\t\t\t\t&#125;\n\t\t\t\tcal.complete();\n\t\t\t&#125;\n\t\t\treturn cal;\n\t\t&#125;\n\t&#125;\n&#125;\n\n看了上面的代码，有一个问题思考一下：既然已经有了 getInstance() 工厂方法来创建 Calendar 类对象，为什么还要用 Builder 来创建 Calendar 类对象呢？这两者之间的区别在哪里呢？\n实际上，在前面讲到这两种模式的时候，对它们之间的区别做了详细的对比。工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象\n粗看 Calendar 的 Builder 类的 build() 方法，可能会觉得它有点像工厂模式。前面一半代码确实跟 getInstance() 工厂方法类似，根据不同的 type 创建了不同的 Calendar 子类。实际上，后面一半代码才属于标准的建造者模式，根据 setXXX() 方法设置的参数，来定制化刚刚创建的 Calendar 子类对象\n这时可能会说，这还能算是建造者模式吗？引用前面提到过的一段话\n\n\n\n\n\n\n\n\n\n我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式，创造出新的模式来解决特定场景的问题\n实际上，从 Calendar 这个例子也能学到，不要过于死板地套用各种模式的原理和实现，不要不敢做丝毫的改动。模式是死的，用的人是活的。在实际上的项目开发中，不仅各种模式可以混合在一起使用，而且具体的代码实现，也可以根据具体的功能需求做灵活的调整\n1.3 装饰器模式在 Collections 类中的应用前面讲到，Java IO 类库是装饰器模式的非常经典的应用。实际上，Java 的 Collections 类也用到了装饰器模式\nCollections 类是一个集合容器的工具类，提供了很多静态方法，用来创建各种集合容器，比如通过 unmodifiableColletion() 静态方法，来创建 UnmodifiableCollection 类对象。而这些容器类中的 UnmodifiableCollection 类、CheckedCollection 和 SynchronizedCollection 类，就是针对 Collection 类的装饰器类\n因为刚刚提到的这三个装饰器类，在代码结构上几乎一样，所以这里只拿其中的 UnmodifiableCollection 类来举例讲解一下。UnmodifiableCollection 类是 Collections 类的一个内部类\npublic class Collections &#123;\n\tprivate Collections() &#123;&#125;\n\tpublic static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123;\n\t\treturn new UnmodifiableCollection&lt;&gt;(c);\n\t&#125;\n\n\t&#x2F;**\n\t * @serial include\n\t *&#x2F;\n\tstatic class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable &#123;\n\t\tprivate static final long serialVersionUID &#x3D; 1820017752578914078L;\n\n\t\tfinal Collection&lt;? extends E&gt; c;\n\n\t\tUnmodifiableCollection(Collection&lt;? extends E&gt; c) &#123;\n\t\t\tif (c&#x3D;&#x3D;null)\n\t\t\t\tthrow new NullPointerException();\n\t\t\tthis.c &#x3D; c;\n\t\t&#125;\n\n\t\tpublic int size()                   &#123;\n\t\t\treturn c.size();\n\t\t&#125;\n\t\tpublic boolean isEmpty()            &#123;\n\t\t\treturn c.isEmpty();\n\t\t&#125;\n\t\tpublic boolean contains(Object o)   &#123;\n\t\t\treturn c.contains(o);\n\t\t&#125;\n\t\tpublic Object[] toArray()           &#123;\n\t\t\treturn c.toArray();\n\t\t&#125;\n\t\tpublic &lt;T&gt; T[] toArray(T[] a)       &#123;\n\t\t\treturn c.toArray(a);\n\t\t&#125;\n\t\tpublic String toString()            &#123;\n\t\t\treturn c.toString();\n\t\t&#125;\n\n\t\tpublic Iterator&lt;E&gt; iterator() &#123;\n\t\t\treturn new Iterator&lt;E&gt;() &#123;\n\t\t\t\tprivate final Iterator&lt;? extends E&gt; i &#x3D; c.iterator();\n\n\t\t\t\tpublic boolean hasNext() &#123;\n\t\t\t\t\treturn i.hasNext();\n\t\t\t\t&#125;\n\t\t\t\tpublic E next()          &#123;\n\t\t\t\t\treturn i.next();\n\t\t\t\t&#125;\n\t\t\t\tpublic void remove() &#123;\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t&#125;\n\t\t\t\t@Override\n\t\t\t\tpublic void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n\t\t\t\t\t&#x2F;&#x2F; Use backing collection version\n\t\t\t\t\ti.forEachRemaining(action);\n\t\t\t\t&#125;\n\t\t\t&#125;;\n\t\t&#125;\n\t\tpublic boolean add(E e) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean remove(Object o) &#123;\n\t\t\throw new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean containsAll(Collection&lt;?&gt; coll) &#123;\n\t\t\treturn c.containsAll(coll);\n\t\t&#125;\n\t\tpublic boolean addAll(Collection&lt;? extends E&gt; coll) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean removeAll(Collection&lt;?&gt; coll) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic boolean retainAll(Collection&lt;?&gt; coll) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\tpublic void clear() &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\t&#x2F;&#x2F; Override default methods in Collection\n\t\t@Override\n\t\tpublic void forEach(Consumer&lt;? super E&gt; action) &#123;\n\t\t\tc.forEach(action);\n\t\t&#125;\n\t\t@Override\n\t\tpublic boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;\n\t\t\tthrow new UnsupportedOperationException();\n\t\t&#125;\n\t\t@SuppressWarnings(&quot;unchecked&quot;)\n\t\t@Override\n\t\tpublic Spliterator&lt;E&gt; spliterator() &#123;\n\t\t\treturn (Spliterator&lt;E&gt;)c.spliterator();\n\t\t&#125;\n\t\t@SuppressWarnings(&quot;unchecked&quot;)\n\t\t@Override\n\t\tpublic Stream&lt;E&gt; stream() &#123;\n\t\t\treturn (Stream&lt;E&gt;)c.stream();\n\t\t&#125;\n\t\t@SuppressWarnings(&quot;unchecked&quot;)\n\t\t@Override\n\t\tpublic Stream&lt;E&gt; parallelStream() &#123;\n\t\t\treturn (Stream&lt;E&gt;)c.parallelStream();\n\t\t&#125;\n\t&#125;\n&#125;\n\n看了上面的代码思考一下，为什么说 UnmodifiableCollection 类是 Collection 类的装饰器类呢？这两者之间可以看作简单的接口实现关系或者类继承关系吗？\n前面讲过，装饰器模式中的装饰器类是对原始类功能的增强。尽管 UnmodifiableCollection 类可以算是对 Collection 类的一种功能增强，但这点还不具备足够的说服力来断定 UnmodifiableCollection 就是 Collection 类的装饰器类\n实际上，最关键的一点是，UnmodifiableCollection 的构造函数接收一个 Collection 类对象，然后对其所有的函数进行了包裹（Wrap）：重新实现（比如 add() 函数）或者简单封装（比如 stream() 函数）。而简单的接口实现或者继承，并不会如此来实现 UnmodifiableCollection 类。所以，从代码实现的角度来说， UnmodifiableCollection类是典型的装饰器类\n1.4 适配器模式在 Collections 类中的应用前面讲到适配器模式的时候说到，适配器模式可以用来兼容老的版本接口。当时举了一个 JDK 的例子，这里再重新仔细看一下\n老版本的 JDK 提供了 Enumeration 类来遍历容器。新版本的 JDK 用 Iterator 类替代 Enumeration 类来遍历容器。为了兼容老的客户端代码（使用老版本 JDK 的代码），保留了 Enumeration 类，并且在 Collections 类中，仍然保留了 enumaration() 静态方法（因为一般都是通过这个静态函数来创建一个容器的 Enumeration 类对象）\n不过，保留 Enumeration 类和 enumeration() 函数，都只是为了兼容，实际上，跟适配器没有一点关系。那到底哪一部分才是适配器呢？\n在新版本的 JDK 中，Enumeration 类是适配器类。它适配的是客户端代码（使用 Enumeration 类）和新版本 JDK 中新的迭代器 Iterator 类。不过，从代码实现的角度来说，这个适配器模式的代码实现，跟经典的适配器模式的代码实现，差别稍微有点大。enumeration() 静态函数的逻辑和 Enumeration 适配器类的代码耦合在一起，enumeration() 静态函数直接通过 new 的方式创建了匿名类对象。具体的代码如下所示：\n&#x2F;**\n* Returns an enumeration over the specified collection. This provides\n* interoperability with legacy APIs that require an enumeration\n* as input.\n*\n* @param &lt;T&gt; the class of the objects in the collection\n* @param c the collection for which an enumeration is to be returned.\n* @return an enumeration over the specified collection.\n* @see Enumeration\n*&#x2F;\npublic static &lt;T&gt; Enumeration&lt;T&gt; enumeration(final Collection&lt;T&gt; c) &#123;\n\treturn new Enumeration&lt;T&gt;() &#123;\n\t\tprivate final Iterator&lt;T&gt; i &#x3D; c.iterator();\n\t\tpublic boolean hasMoreElements() &#123;\n\t\t\treturn i.hasNext();\n\t\t&#125;\n\t\tpublic T nextElement() &#123;\n\t\t\treturn i.next();\n\t\t&#125;\n\t&#125;;\n&#125;\n\n1.5 模板模式在 Collections 类中的应用前面提到，策略、模板、职责链三个模式常用在框架的设计中，提供框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。Java 中的 Collections 类的 sort() 函数就是利用了模板模式的这个扩展特性\n首先，看下 Collections.sort() 函数是如何使用的。示例代码如下所示。这个代码实现了按照不同的排序方式（按照年龄从小到大、按照名字字母序从小到大、按照成绩从大到小）对 students 数组进行排序\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;();\n\t\tstudents.add(new Student(&quot;Alice&quot;, 19, 89.0f));\n\t\tstudents.add(new Student(&quot;Peter&quot;, 20, 78.0f));\n\t\tstudents.add(new Student(&quot;Leo&quot;, 18, 99.0f));\n\t\tCollections.sort(students, new AgeAscComparator());\n\t\tprint(students);\n\t\tCollections.sort(students, new NameAscComparator());\n\t\tprint(students);\n\t\tCollections.sort(students, new ScoreDescComparator());\n\t\tprint(students);\n\t&#125;\n\tpublic static void print(List&lt;Student&gt; students) &#123;\n\t\tfor (Student s : students) &#123;\n\t\t\tSystem.out.println(s.getName() + &quot; &quot; + s.getAge() + &quot; &quot; + s.getScore());\n\t\t&#125;\n\t&#125;\n\tpublic static class AgeAscComparator implements Comparator&lt;Student&gt; &#123;\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) &#123;\n\t\t\treturn o1.getAge() - o2.getAge();\n\t\t&#125;\n\t&#125;\n\tpublic static class NameAscComparator implements Comparator&lt;Student&gt; &#123;\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) &#123;\n\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t&#125;\n\t&#125;\n\tpublic static class ScoreDescComparator implements Comparator&lt;Student&gt; &#123;\n\t\t@Override\n\t\tpublic int compare(Student o1, Student o2) &#123;\n\t\t\tif (Math.abs(o1.getScore() - o2.getScore()) &lt; 0.001) &#123;\n\t\t\t\treturn 0;\n\t\t\t&#125; else if (o1.getScore() &lt; o2.getScore()) &#123;\n\t\t\t\treturn 1;\n\t\t\t&#125; else &#123;\n\t\t\t\treturn -1;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n结合刚刚这个例子，再来看下，为什么说 Collections.sort() 函数用到了模板模式？Collections.sort() 实现了对集合的排序。为了扩展性，它将其中“比较大小”这部分逻辑，委派给用户来实现。如果把比较大小这部分逻辑看作整个排序逻辑的其中一个步骤，那就可以把它看作模板模式。不过，从代码实现的角度来看，它看起来有点类似之前讲过的 JdbcTemplate，并不是模板模式的经典代码实现，而是基于 Callback 回调机制来实现的\n不过，在其他资料中，还看到有人说，Collections.sort() 使用的是策略模式。这样的说法也不是没有道理的。如果并不把“比较大小”看作排序逻辑中的一个步骤，而是看作一种算法或者策略，那就可以把它看作一种策略模式的应用。不过，这也不是典型的策略模式，前面讲到在典型的策略模式中，策略模式分为策略的定义、创建、使用这三部分。策略通过工厂模式来创建，并且在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。而在 Collections.sort() 函数中，策略的创建并非通过工厂模式，策略的使用也非动态确定\n1.6 观察者模式在 JDK 中的应用在前面讲到观察者模式的时候，重点讲解了 Google Guava 的 EventBus 框架，它提供了观察者模式的骨架代码。使用 EventBus，我们不需要从零开始开发观察者模式。实际上，Java JDK 也提供了观察者模式的简单框架实现。在平时的开发中，如果不希望引入 Google Guava 开发库，可以直接使用 Java 语言本身提供的这个框架类\n不过，它比 EventBus 要简单多了，只包含两个类：java.util.Observable 和 java.util.Observer。前者是被观察者，后者是观察者。它们的代码实现也非常简单\npublic interface Observer &#123;\n\tvoid update(Observable o, Object arg);\n&#125;\npublic class Observable &#123;\n\tprivate boolean changed &#x3D; false;\n\tprivate Vector&lt;Observer&gt; obs;\n\tpublic Observable() &#123;\n\t\tobs &#x3D; new Vector&lt;&gt;();\n\t&#125;\n\tpublic synchronized void addObserver(Observer o) &#123;\n\t\tif (o &#x3D;&#x3D; null)\n\t\t\tthrow new NullPointerException();\n\t\tif (!obs.contains(o)) &#123;\n\t\t\tobs.addElement(o);\n\t\t&#125;\n\t&#125;\n\tpublic synchronized void deleteObserver(Observer o) &#123;\n\t\tobs.removeElement(o);\n\t&#125;\n\tpublic void notifyObservers() &#123;\n\t\tnotifyObservers(null);\n\t&#125;\n\tpublic void notifyObservers(Object arg) &#123;\n\t\tObject[] arrLocal;\n\t\tsynchronized (this) &#123;\n\t\t\tif (!changed)\n\t\t\t\treturn;\n\t\t\tarrLocal &#x3D; obs.toArray();\n\t\t\tclearChanged();\n\t\t&#125;\n\t\tfor (int i &#x3D; arrLocal.length-1; i&gt;&#x3D;0; i--)\n\t\t\t((Observer)arrLocal[i]).update(this, arg);\n\t&#125;\n\tpublic synchronized void deleteObservers() &#123;\n\t\tobs.removeAllElements();\n\t&#125;\n\tprotected synchronized void setChanged() &#123;\n\t\tchanged &#x3D; true;\n\t&#125;\n\tprotected synchronized void clearChanged() &#123;\n\t\tchanged &#x3D; false;\n\t&#125;\n&#125;\n\n对于 Observable、Observer 的代码实现，大部分都很好理解，重点来看其中的两个地方。一个是 changed 成员变量，另一个是 notifyObservers() 函数\n先来看 changed 成员变量\n它用来表明被观察者（Observable）有没有状态更新。当有状态更新时，需要手动调用 setChanged() 函数，将 changed 变量设置为 true，这样才能在调用 notifyObservers() 函数的时候，真正触发观察者（Observer）执行 update() 函数。否则，即便调用了 notifyObservers() 函数，观察者的 update() 函数也不会被执行。也就是说，当通知观察者被观察者状态更新的时候，需要依次调用 setChanged() 和notifyObservers() 两个函数，单独调用 notifyObservers() 函数是不起作用的\n再来看 notifyObservers() 函数\n为了保证在多线程环境下，添加、移除、通知观察者三个操作之间不发生冲突，Observable 类中的大部分函数都通过 synchronized 加了锁，不过，也有特例，notifyObservers() 这函数就没有加 synchronized 锁。这是为什么呢？在 JDK 的代码实现中，notifyObservers() 函数是如何保证跟其他函数操作不冲突的呢？这种加锁方法是否存在问题？又存在什么问题呢？\nnotifyObservers() 函数之所以没有像其他函数那样，一把大锁加在整个函数上，主要还是出于性能的考虑\nnotifyObservers() 函数依次执行每个观察者的 update() 函数，每个 update() 函数执行的逻辑提前未知，有可能会很耗时。如果在 notifyObservers() 函数上加 synchronized 锁，notifyObservers() 函数持有锁的时间就有可能会很长，这就会导致其他线程迟迟获取不到锁，影响整个 Observable 类的并发性能\nVector 类不是线程安全的，在多线程环境下，同时添加、删除、遍历 Vector 类对象中的元素，会出现不可预期的结果。所以，在 JDK 的代码实现中，为了避免直接给 notifyObservers() 函数加锁而出现性能问题，JDK 采用了一种折中的方案。这个方案有点类似于之前讲过的让迭代器支持”快照“的解决方案\n在 notifyObservers() 函数中，先拷贝一份观察者列表，赋值给函数的局部变量，局部变量是线程私有的，并不在线程间共享。这个拷贝出来的线程私有的观察者列表就相当于一个快照。遍历快照，逐一执行每个观察者的 update() 函数。而这个遍历执行的过程是在快照这个局部变量上操作的，不存在线程安全问题，不需要加锁。所以，只需要对拷贝创建快照的过程加锁，加锁的范围减少了很多，并发性能提高了\n为什么说这是一种折中的方案呢？这是因为，这种加锁方法实际上是存在一些问题的。在创建好快照之后，添加、删除观察者都不会更新快照，新加入的观察者就不会被通知到，新删除的观察者仍然会被通知到。这种权衡是否能接受完全看你的业务场景。实际上，这种处理方式也是多线程编程中减小锁粒度、提高并发性能的常用方法\n1.7 单例模式在 Runtime 类中的应用每个 Java 应用在运行时会启动一个 JVM 进程，每个 JVM 进程都只对应一个 Runtime 实例，用于查看 JVM 状态以及控制 JVM 行为。进程内唯一，所以比较适合设计为单例。在编程的时候，我们不能自己去实例化一个 Runtime 对象，只能通过 getRuntime() 静态方法来获得\nRuntime 类的的代码实现如下所示。这里面只包含部分相关代码，其他代码做了省略。从代码中也可以看出，它使用了最简单的饿汉式的单例实现方式\n&#x2F;**\n* Every Java application has a single instance of class\n* &lt;code&gt;Runtime&lt;&#x2F;code&gt; that allows the application to interface with\n* the environment in which the application is running. The current\n* runtime can be obtained from the &lt;code&gt;getRuntime&lt;&#x2F;code&gt; method.\n* &lt;p&gt;\n* An application cannot create its own instance of this class.\n*\n* @author unascribed\n* @see java.lang.Runtime#getRuntime()\n* @since JDK1.0\n*&#x2F;\npublic class Runtime &#123;\n\tprivate static Runtime currentRuntime &#x3D; new Runtime();\n\tpublic static Runtime getRuntime() &#123;\n\t\treturn currentRuntime;\n\t&#125;\n\t&#x2F;** Don&#39;t let anyone else instantiate this class *&#x2F;\n\tprivate Runtime() &#123;&#125;\n\t&#x2F;&#x2F;....\n\tpublic void addShutdownHook(Thread hook) &#123;\n\t\tSecurityManager sm &#x3D; System.getSecurityManager();\n\t\tif (sm !&#x3D; null) &#123;\n\t\t\tsm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n\t\t&#125;\n\t\tApplicationShutdownHooks.add(hook);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n\n1.8 其他模式在 JDK 中的应用汇总实际上，在讲解理论部分的时候（见文章开头的前三篇内容），已经讲过很多模式在 Java JDK 中的应用了。这里再回顾一下：\n\n在讲到模板模式的时候，结合 Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList 四个例子，来具体讲解了它的两个作用：扩展性和复用性\n在讲到享元模式的时候，讲到 Integer 类中的 -128~127 之间的整型对象是可以复用的，还讲到 String 类型中的常量字符串也是可以复用的。这些都是享元模式的经典应用\n在讲到职责链模式的时候，讲到Java Servlet 中的 Filter 就是通过职责链来实现的，同时还对比了 Spring 中的 interceptor。实际上，拦截器、过滤器这些功能绝大部分都是采用职责链模式来实现的\n在讲到的迭代器模式的时候，重点剖析了 Java 中 Iterator 迭代器的实现\n\n2. 从 Unix 学习应对大型复杂项目开发软件开发的难度无外乎两点，一是技术难，意思是说，代码量不一定多，但要解决的问题比较难，需要用到一些比较深的技术解决方案或者算法，不是靠“堆人”就能搞定的，比如自动驾驶、图像识别、高性能消息队列等；二是复杂度，意思是说，技术不难，但项目很庞大，业务复杂，代码量多，参与开发的人多，比如物流系统、财务系统等。第一点涉及细分专业的领域知识，这里重点来讲第二点，如何应对软件开发的复杂度\n简单的“hello world”程序，谁都能写得出来。几千行的代码谁都能维护得了。但是，当代码超过几万行、十几万，甚至几十万行、上百万行的时候，软件的复杂度就会呈指数级增长。这种情况下，不仅仅要求程序运行得了，运行得正确，还要求代码看得懂、维护得了。实际上，复杂度不仅仅体现在代码本身，还体现在协作研发上，如何管理庞大的团队，来进行有条不紊地协作开发，也是一个很复杂的难题\n如何应对复杂软件开发？Unix 开源项目就是一个值得学习的例子\nUnix 从 1969 年诞生，一直演进至今，代码量有几百万行，如此庞大的项目开发，能够如此完美的协作开发，并且长期维护，保持足够的代码质量，这里面有很多成功的经验可以借鉴。所以，接下来就以 Unix 开源项目的开发为引子，通过下面三个话题，详细地讲讲应对复杂软件开发的方法论\n\n从设计原则和思想的角度来看，如何应对庞大而复杂的项目开发？\n从研发管理和开发技巧的角度来看，如何应对庞大而复杂的项目开发？\n聚焦在 Code Review 上来看，如何通过 Code Reviwe 保持项目的代码质量？\n\n2.1 设计原则和思想2.1.1 封装与抽象在 Unix、Linux 系统中，有一句经典的话，“Everything is a file”，翻译成中文就是“一切皆文件”。这句话的意思就是，在 Unix、Linux 系统中，很多东西都被抽象成“文件”这样一个概念，比如 Socket、驱动、硬盘、系统信息等。它们使用文件系统的路径作为统一的命名空间（namespace），使用统一的 read、write 标准函数来访问\n比如要查看 CPU 的信息，在 Linux 系统中，只需要使用 Vim、Gedit 等编辑器或者 cat 命令，像打开其他文件一样，打开 /proc/cpuinfo，就能查看到相应的信息。除此之外，还可以通过查看 /proc/uptime 文件，了解系统运行了多久，查看 /proc/version 了解系统的内核版本等\n实际上，“一切皆文件”就体现了封装和抽象的设计思想\n封装了不同类型设备的访问细节，抽象为统一的文件访问方式，更高层的代码就能基于统一的访问方式，来访问底层不同类型的设备。这样做的好处是，隔离底层设备访问的复杂性\n统一的访问方式能够简化上层代码的编写，并且代码更容易复用。除此之外，抽象和封装还能有效控制代码复杂性的蔓延，将复杂性封装在局部代码中，隔离实现的易变性，提供简单、统一的访问接口，让其他模块来使用，其他模块基于抽象的接口而非具体的实现编程，代码会更加稳定\n2.1.2 分层与模块化模块化是构建复杂系统的常用手段\n对于像 Unix 这样的复杂系统，没有人能掌控所有的细节。之所以能开发出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，比如进程调度、进程通信、内存管理、虚拟文件系统、网络接口等模块。不同的模块之间通过接口来进行通信，模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样，将各个模块组装起来，构建成一个超级复杂的系统\n除此之外，Unix、Linux 等大型系统之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好。不同的团队负责不同的模块开发，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转\n实际上，除了模块化之外，分层也是常用来架构复杂系统的方法\n我们常说，计算机领域的任何问题都可以通过增加一个间接的中间层来解决，这本身就体现了分层的重要性。比如，Unix 系统也是基于分层开发的，它可以大致上分为三层，分别是内核、系统调用、应用层。每一层都对上层封装实现细节，暴露抽象的接口来调用。而且，任意一层都可以被重新实现，不会影响到其他层的代码\n面对复杂系统的开发，要善于应用分层技术，把容易复用、跟具体业务关系不大的代码，尽量下沉到下层，把容易变动、跟具体业务强相关的代码，尽量上移到上层\n2.1.3 基于接口通信前面讲了分层、模块化，那不同的层之间、不同的模块之间，是如何通信的呢？一般来讲都是通过接口调用。在设计模块（module）或者层（layer）要暴露的接口的时候，要学会隐藏实现，接口从命名到定义都要抽象一些，尽量少涉及具体的实现细节\n比如，Unix 系统提供的 open() 文件操作函数，底层实现非常复杂，涉及权限控制、并发控制、物理存储，但用起来却非常简单。除此之外，因为 open() 函数基于抽象而非具体的实现来定义，所以在改动 open() 函数的底层实现的时候，并不需要改动依赖它的上层代码\n2.1.4 高内聚、松耦合高内聚、松耦合是一个比较通用的设计思想，内聚性好、耦合少的代码，能让我们在修改或者阅读代码的时候，聚集到在一个小范围的模块或者类中，不需要了解太多其他模块或类的代码，让焦点不至于太发散，也就降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不会牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多\n实际上，前面讲到的很多方法，比如封装、抽象、分层、模块化、基于接口通信，都能有效地实现代码的高内聚、松耦合。反过来，代码的高内聚、松耦合，也就意味着，抽象、封装做到比较到位、代码结构清晰、分层和模块化合理、依赖关系简单，那代码整体的质量就不会太差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围也是非常有限的。可以聚焦于这个模块或者类做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就小多了\n2.1.5 为扩展而设计越是复杂项目，越要在前期设计上多花点时间。提前思考项目中未来可能会有哪些功能需要扩展，提前预留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构的情况下，轻松地添加新功能\n做到代码可扩展，需要代码满足开闭原则。特别是像 Unix 这样的开源项目，有 N 多人参与开发，任何人都可以提交代码到代码库中。代码满足开闭原则，基于扩展而非修改来添加新功能，最小化、集中化代码改动，避免新代码影响到老代码，降低引入 bug 的风险\n除了满足开闭原则，做到代码可扩展，前面也提到很多方法，比如封装和抽象，基于接口编程等。识别出代码可变部分和不可变部分，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，供上层系统使用。当具体的实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改\n2.1.6 KISS 首要原则简单清晰、可读性好，是任何大型软件开发要遵循的首要原则。只要可读性好，即便扩展性不好，顶多就是多花点时间、多改动几行代码的事情。但是，如果可读性不好，连看都看不懂，那就不是多花时间可以解决得了的了。如果对现有代码的逻辑似懂非懂，抱着尝试的心态去修改代码，引入 bug 的可能性就会很大\n不管是自己还是团队，在参与大型项目开发的时候，要尽量避免过度设计、过早优化，在扩展性和可读性有冲突的时候，或者在两者之间权衡，模棱两可的时候，应该选择遵循 KISS原则，首选可读性\n2.1.7 最小惊奇原则《Unix 编程艺术》一书中提到一个 Unix 的经典设计原则，叫“最小惊奇原则”，英文是“The Least Surprise Priciple”。实际上，这个原则等同于“遵守开发规范”，意思是，在做设计或者编码的时候要遵守统一的开发规范，避免反直觉的设计\n遵从统一的编码规范，所有的代码都像一个人写出来的，能有效地减少阅读干扰。在大型软件开发中，参与开发的人员很多，如果每个人都按照自己的编码习惯来写代码，那整个项目的代码风格就会千奇百怪，这个类是这种编码风格，另一个类又是另外一种风格。在阅读的时候，要不停地切换去适应不同的编码风格，可读性就变差了。所以，对于大型项目的开发来说，要特别重视遵守统一的开发规范\n2.2 研发管理和开发技巧项目越复杂、代码量越多、参与开发人员越多、开发维护时间越长，就越是要重视代码质量。代码质量下降会导致项目研发困难重重，比如：开发效率低，招了很多人，天天加班，出活却不多；线上 bug 频发，查找 bug 困难，领导发飙，中层束手无策，工程师抱怨不断\n导致代码质量不高的原因有很多，比如：代码无注释，无文档，命名差，层次结构不清晰，调用关系混乱，到处 hardcode，充斥着各种临时解决方案等等。那怎么才能时刻保证代码质量呢？当然，首要的是团队技术素质要过硬，能够适当地利用设计原则、思想、模式编写高质量的代码。除此之外，还有一些外在的方法可循\n2.2.1 吹毛求疵般地执行编码规范严格执行代码规范，可以使一个项目乃至整个公司的代码具有完全统一的风格，就像同一个人编写的。而且，命名良好的变量、函数、类和注释，也可以提高代码的可读性。编码规范不难掌握，关键是要严格执行。在 Code Review 时，一定要严格要求，看到不符合规范的代码，一定要指出并要求修改\n但是，实际情况往往事与愿违。虽然大家都知道优秀的代码规范是怎样的，但在具体写代码的过程中，执行得却不好。这种情况产生的主要原因还是不够重视。很多人会觉得，一个变量或者函数命名成啥样，关系并不大。所以命名时不推敲，注释也不写，Code Review 的时候也都一副事不关己的心态，觉得没必要太抠细节。日积月累，项目代码就会变得越来越差。所以这里还是要强调一下，细节决定成败，代码规范的严格执行极为关键\n2.2.2 编写高质量的单元测试单元测试是最容易执行且对提高代码质量见效最快的方法之一。高质量的单元测试不仅仅要求测试覆盖率要高，还要求测试的全面性，除了测试正常逻辑的执行之外，还要重点、全面地测试异常下的执行情况。毕竟代码出问题的地方大部分都发生在异常、边界条件下\n对于大型复杂项目，集成测试、黑盒测试都很难测试全面，因为组合爆炸，穷举所有测试用例的成本很高，几乎是不可能的。单元测试就是很好的补充。它可以在类、函数这些细粒度的代码层面，保证代码运行无误。底层细粒度的代码 bug 少了，组合起来构建而成的整个系统的 bug 也就相应的减少了\n2.2.3 不流于形式的 Code Review如果说很多工程师对单元测试不怎么重视，那对 Code Review 就是不怎么接受。我之前跟一些同行聊起 Code Review 的时候，很多人的反应是，这玩意儿不可能很好地执行，形式大于效果，纯粹是浪费时间。是的，即便 Code Review 做得再流畅，也是要花时间的。所以，在业务开发任务繁重的时候，Code Review 往往会流于形式、虎头蛇尾，效果确实不怎么好\n但并不能因此就否定 Code Review 本身的价值。在 Google、Facebook 等外企中，Code Review 应用得非常成功，已经成为了开发流程中不可或缺的一部分。所以，要想真正发挥 Code Review 的作用，关键还是要执行到位，不能流于形式\n2.2.4 开发未动、文档先行对大部分工程师来说，编写技术文档是件挺让人“反感”的事情。一般来讲，在开发某个系统或者重要模块或者功能之前，应该先写技术文档，然后，发送给同组或者相关同事审查，在审查没有问题的情况下再开发。这样能够保证事先达成共识，开发出来的东西不至于走样。而且，当开发完成之后，进行 Code Review 的时候，代码审查者通过阅读开发文档，也可以快速理解代码\n除此之外，对于团队和公司来讲，文档是重要的财富。对新人熟悉代码或任务的交接等，技术文档很有帮助。而且，作为一个规范化的技术团队，技术文档是一种摒弃作坊式开发和个人英雄主义的有效方法，是保证团队有效协作的途径\n2.2.5 持续重构、重构、重构我个人比较反对平时不注重代码质量，堆砌烂代码，实在维护不了了就大刀阔斧地重构甚至重写。有的时候，因为项目代码太多，重构很难做到彻底，最后又搞出来一个四不像的怪物，这就更麻烦了！\n优秀的代码或架构不是一开始就能设计好的，就像优秀的公司或产品也都是迭代出来的。我们无法 100% 预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单。所以，随着系统的演进，重构是不可避免的\n虽然刚刚说不支持大刀阔斧、推倒重来式的大重构，但持续的小重构还是比较提倡的。它也是时刻保证代码质量、防止代码腐化的有效手段。换句话说，不要等到问题堆得太多了再去解决，要时刻有人对代码整体质量负责任，平时没事就改改代码\n特别是一些业务开发团队，有时候为了快速完成一个业务需求，只追求速度，到处 hardcode，在完全不考虑非功能性需求、代码质量的情况下，堆砌烂代码。实际上，这种情况还是比较常见的。不过没关系，等有时间了，一定要记着重构，不然烂代码越堆越多，总有一天代码会变得无法维护\n2.2.6 对项目与团队进行拆分团队人比较少，比如十几个人的时候，代码量不多，不超过 10 万行，怎么开发、怎么管理都没问题，大家互相都比较了解彼此做的东西。即便代码质量太差了，我们大不了把它重写一遍。但是，对于一个大型项目来说，参与开发的人员会比较多，代码量很大，有几十万、甚至几百万行代码，有几十、甚至几百号人同时开发维护，那研发管理就变得极其重要\n面对大型复杂项目，不仅仅需要对代码进行拆分，还需要对研发团队进行拆分。前讲到了一些代码拆分的方法，比如模块化、分层等。同理，也可以把大团队拆成几个小团队。每个小团队对应负责一个小的项目（模块、微服务等），这样每个团队负责的项目包含的代码都不至于很多，也不至于出现代码质量太差无法维护的情况\n2.3 Code Review2.3.1 优势1、Code Review 践行“三人行必有我师”\n有时候可能会觉得，团队中的资深员工或者技术 leader 的技术比较牛，写的代码很好，他们的代码就不需要 Review 了，重点 Review 资历浅的员工的代码就可以了。实际上，这种认识是不对的\nGoogle 工程师的平均研发水平都很高，但即便如此，不管谁提交的代码，包括 Jeff Dean 的，只要需要 Review，都会收到很多 comments（修改意见）。“三人行必有我师”，即便自己觉得写得已经很好的代码，只要经过不停地推敲，都有持续改进的空间\n所以，永远不要觉得自己很厉害，写的代码就不需要别人 Review 了；永远不要觉得自己水平很一般，就没有资格给别人 Review 了；更不要觉得技术大牛让你 Review 代码只是缺少你的一个“approve”，随便看看就可以\n2、Code Review 能摒弃“个人英雄主义”\n在一个成熟的公司里，所有的架构设计、实现，都应该是一个团队的产出。尽管这个过程可能会由某个人来主导，但应该是整个团队共同智慧的结晶\n如果一个人默默地写代码提交，不经过团队的 Review，这样的代码蕴含的是一个人的智慧。代码的质量完全依赖于这个人的技术水平。这就会导致代码质量参差不齐。如果经过团队多人 Review、打磨，代码蕴含的是整个团队的智慧，可以保证代码按照团队中的最高水准输出\n3、Code Review 能有效提高代码可读性\n前面反复强调，在大部分情况下，代码的可读性比任何其他方面（比如扩展性等）都重要。可读性好，代表后期维护成本低，线上 bug 容易排查，新人容易熟悉代码，老人离职时代码容易接手。而且，可读性好，也说明代码足够简单，出错可能性小、bug 少\n不过，自己看自己写的代码，总是会觉得很易读，但换另外一个人来读你的代码，可能就不这么认为了。毕竟自己写的代码，其中涉及的业务、技术自己很熟悉，别人不一定会熟悉。既然自己对可读性的判断很容易出现错觉，那 Code Review 就是一种考察代码可读性的很好手段。如果代码审查者很费劲才能看懂你写的代码，那就说明代码的可读性有待提高了\n4、Code Review 是技术传帮带的有效途径\n良好的团队需要技术和业务的“传帮带”，那如何来做“传帮带”呢？当然，业务上面，可能通过文档或口口相传的方式，那技术呢？如何培养初级工程师的技术能力呢？Code Review 就是一种很好的途径。每次 Code Review 都是一次真实案例的讲解。通过 Code Review，在实践中将技术传递给初级工程师，比让他们自己学习、自己摸索来得更高效！\n5、Code Review 保证代码不止一个人熟悉\n如果一段代码只有一个人熟悉，如果这个同事休假了或离职了，代码交接起来就比较费劲。有时候，单纯只看代码还看不大懂，又要跟 PM、业务团队、或者其他技术团队，再重复来一轮沟通，搞的其他团队的人都很烦。而 Code Review 能保证任何代码同时都至少有两个同事熟悉，互为备份，有备无患，除非两个同事同时都离职……\n6、Code Review 能打造良好的技术氛围\n提交代码 Review 的人，希望自己写的代码足够优秀，毕竟被同事 Review 出很多问题，是件很丢人的事情。而做 Code review 的人，也希望自己尽可能地提出有建设性意见，展示自己的能力。所以，Code Review 还能增进技术交流，活跃技术氛围，培养大家的极客精神，以及对代码质量的追求\n一个良好的技术氛围，能让团队有很强的自驱力。不用技术 leader 反复强调代码质量有多重要，团队中的成员就会自己主动去关注代码质量的问题。这比制定各种规章制度、天天督促执行要更加有效。实际上，好的技术氛围也能降低团队的离职率\n7、Code Review 是一种技术沟通方式\nTalk is cheap，show me the code。怎么“show”，通过 Code Review 工具来“show”，这样也方便别人反馈意见。特别是对于跨不同办公室、跨时区的沟通，Code Review 是一种很好的沟通方式。今天白天写的代码，明天来上班的时候，跨时区的同事已经 Review 好了，改改提交，继续写新的代码了。这样的协作效率会很高\n8、Code Review 能提高团队的自律性\n在开发过程中，难免会有人不自律，存在侥幸心理：反正写的代码也没人看，随便写写就提交了。Code Review 相当于一次代码直播，曝光 dirty code，有一定的威慑力。这样大家就不敢随便应付一下就提交代码了\n2.3.2 如何在团队中落地执行 Code Review？1、有人认为，Code Review 流程太长，太浪费时间，特别是工期紧的时候，今天改的代码，明天就要上，如果要等同事 Review，同事有可能没时间，这样就来不及。这个时候该怎么办呢？\n我所经历的项目还没有一个因为工期紧，导致没有时间 Code Review 的。工期都是人排的，稍微排松点就行了。关键还是在于整个公司对 Code Review 的接受程度。而且，Code Review 熟练之后，并不需要花费太长的时间。尽管开始做 Code Review 的时候，可能因为不熟练，需要有一个 checklist 对照着来做。起步阶段可能会比较耗时。但熟练之后，Code Review 就像键盘盲打一样，已经忘记了哪个手指按的是哪个键了，扫一遍代码就能揪出绝大部分问题\n2、有人认为，业务一直在变，今天写的代码明天可能就要再改，代码可能不会长期维护，写得太好也没用。这种情况下是不是就不需要 Code Review 了呢？\n这种现象在游戏开发、一些早期的创业公司或者项目验证阶段比较常见。项目讲求短平快，先验证产品，再优化技术。如果确实面对的还只是生存问题，代码质量确实不是首要的，特殊情况下，不做 Code Review 是支持的！\n3、有人说，团队成员技术水平不高，过往也没有 Code Review 的经验，不知道 Review 什么，也 Review 不出什么。自己代码都没写明白，不知道什么样的代码是好的，什么样的代码是差的，更不要说 Review 别人的代码了。在 Code Review 的时候，团队成员大眼瞪小眼，只能 Review 点语法，形式大于效果。这种情况该怎么办？\n这种情况也挺常见。不过没关系，团队的技术水平都是可以培养的。可以先让资深同事、技术好的同事或技术 leader，来 Review 其他所有人的代码。Review 的过程本身就是一种“传帮带”的过程。慢慢地，整个团队就知道该如何 Review 了。虽然这可能会有一个相当长的过程，但如果真的想在团队中执行 Code Review，这不失为一种“曲线救国”的方法\n4、还有人说，刚开始 Code Review 的时候，大家都还挺认真，但时间长了，大家觉得这事跟 KPI 无关，而且还要看别人的代码，理解别人写的代码的业务，多浪费时间啊。慢慢地，Code Review 就变得流于形式了。有人提交了代码，随便抓个人 Review。Review 的人也不认真，随便扫一眼就点“approve”。这种情况该如何应对？\n首先，要明确的告诉 Code Review 的重要性，要严格执行，让大家不要懈怠，适当的时候可以“杀鸡儆猴”。其次，可以像 Google 一样，将 Code Review 间接地跟 KPI、升职等联系在一块，高级工程师有义务做 Code Review，就像有义务做技术面试一样。再次，想办法活跃团队的技术氛围，把 Code Review 作为一种展示自己技术的机会，带动起大家对 Code Review 的积极性，提高大家对 Code Review 的认同感\n3. Google GuavaGoogle Guava 是 Google 公司内部 Java 开发工具库的开源版本。Google 内部的很多 Java 项目都在使用它。它提供了一些 JDK 没有提供的功能，以及对 JDK 已有功能的增强功能。其中就包括：集合（Collections）、缓存（Caching）、原生类型支持（Primitives Support）、并发库（Concurrency Libraries）、通用注解（Common Annotation）、字符串处理（Strings Processing）、数学计算（Math）、I&#x2F;O、事件总线（EventBus）等等\n\nJDK 的全称是 Java Development Kit。它本身就是 Java 提供的工具类库。那既然有了 JDK，为什么 Google 还要开发一套新的类库 Google Guava？是否是重复造轮子？两者的差异化在哪里？\n3.1 如何发现通用的功能模块？很多人觉得做业务开发没有挑战，实际上，做业务开发也会涉及很多非业务功能的开发，比如前面讲到的 ID 生成器、性能计数器、EventBus、DI 容器，以及后面会讲到的限流框架、幂等框架、灰度组件。关键在于，要有善于发现、善于抽象的能力，并且具有扎实的设计、开发能力，能够发现这些非业务的、可复用的功能点，并且从业务逻辑中将其解耦抽象出来，设计并开发成独立的功能模块\n在我看来，在业务开发中，跟业务无关的通用功能模块，常见的一般有三类：类库（library）、框架（framework）、功能组件（component）等\n其中，Google Guava 属于类库，提供一组 API 接口。EventBus、DI 容器属于框架，提供骨架代码，能让业务开发人员聚焦在业务开发部分，在预留的扩展点里填充业务代码。ID生成器、性能计数器属于功能组件，提供一组具有某一特殊功能的 API 接口，有点类似类库，但更加聚焦和重量级，比如，ID 生成器有可能会依赖 Redis 等外部系统，不像类库那么简单\n前面提到的限流、幂等、灰度，到底是属于框架还是功能组件，要视具体情况而定。如果业务代码嵌套在它们里面开发，那就可以称它们为框架。如果它们只是开放 API 接口，供业务系统调用，那就可以称它们为组件。不过，叫什么没有太大关系，不必太深究概念\n那如何发现项目中的这些通用的功能模块呢？\n实际上，不管是类库、框架还是功能组件，这些通用功能模块有两个最大的特点：复用和业务无关。Google Guava 就是一个典型的例子\n如果没有复用场景，那也就没有了抽离出来，设计成独立模块的必要了。如果与业务有关又可复用，大部分情况下会设计成独立的系统（比如微服务），而不是类库、框架或功能组件。所以，如果负责开发的代码，与业务无关并且可能会被复用，那就可以考虑将它独立出来，开发成类库、框架、功能组件等通用功能模块\n这里讲的是，在业务开发中，如何发现通用的功能模块。除了业务开发团队之外，很多公司还有一些基础架构团队、架构开发团队，他们除了开发类库、框架、功能组件之外，也会开发一些通用的系统、中间件，比如，Google MapReduce、Kafka 消息中间件、监控系统、分布式调用链追踪系统等\n3.2 如何开发通用的功能模块？当发现了通用功能模块的开发需求之后，如何将它设计开发成一个优秀的类库、框架或功能组件呢？这里先不讲具体的开发技巧，先讲一些更普适的开发思想\n作为通用的类库、框架、功能组件，我们希望开发出来之后，不仅仅是自己项目使用，还能用在其他团队的项目中，甚至可以开源出来供更多人所用，这样才能发挥它更大的价值，构建自己的影响力\n所以，对于这些类库、框架、功能组件的开发，不能闭门造车，要把它们当作“产品”来开发。这个产品是一个“技术产品”，目标用户是“程序员”，解决的是他们的“开发痛点”。要多换位思考，站在用户的角度上，来想他们到底想要什么样的功能\n对于一个技术产品来说，尽管 Bug 少、性能好等技术指标至关重要，但是否易用、易集成、易插拔、文档是否全面、是否容易上手等，这些产品素质也非常重要，甚至还能起到决定性作用。往往就是这些很容易忽视、不被重视的东西，会决定一个技术产品是否能在众多的同类中脱颖而出\n具体到 Google Guava，它是一个开发类库，目标用户是 Java 开发工程师，解决用户主要痛点是，相对于 JDK，提供更多的工具类，简化代码编写，比如，它提供了用来判断 null 值的 Preconditions 类；Splitter、Joiner、CharMatcher 字符串处理类；Multisets、Multimaps、Tables 等更丰富的 Collections 类等等\n它的优势有这样几点：第一，由 Google 管理、长期维护，经过充分的单元测试，代码质量有保证；第二，可靠、性能好、高度优化，比如 Google Guava 提供的 Immutable Collections 要比 JDK 的 unmodifiableCollection 性能好；第三，全面、完善的文档，容易上手，学习成本低，可以去看下它的 Github Wiki\n刚刚讲的是“产品意识”，再来讲讲“服务意识”。如果开发的东西是提供给其他团队用的，一定要有“服务意识”。对于程序员来说，这点可能比“产品意识”更加欠缺\n首先，从心态上，别的团队使用我们开发出来的技术产品，要学会感谢。这点很重要。心态不同了，做起事来就会有微妙的不同。其次，除了写代码，还要有抽出大量时间答疑、充当客服角色的心理准备。有了这个心理准备，别的团队的人在问问题的时候，也就不会很烦了\n相对于业务代码来说，开发这种被多处复用的通用代码，对代码质量的要求更高些，因为这些项目的影响面更大，一旦出现 bug，会牵连很多系统或其他项目。特别是如果你要把项目开源，影响就更大了。所以，这类项目的代码质量一般都很好，开发这类项目对代码能力的锻炼更有大\n具体到 Google Guava，它是 Google 员工开发的，单元测试很完善，注释写得很规范，代码写得也很好，可以说是学习 Google 开发经验的一手资料，建议你如果有时间的话，可以认真阅读一下它的代码\n尽管开发这些通用功能模块更加锻炼技术，但也不要重复造轮子，能复用的尽量复用。而且，在项目中，如果想把所有的通用功能都开发为独立的类库、框架、功能组件，这就有点大动干戈了，有可能会得不到领导的支持。毕竟从项目中将这部分通用功能独立出来开发，比起作为项目的一部分来开发，会更加耗时\n所以，权衡一下的话，建议初期先把这些通用的功能作为项目的一部分来开发。不过，在开发的时候，做好模块化工作，将它们尽量跟其他模块划清界限，通过接口、扩展点等松耦合的方式跟其他模式交互。等到时机成熟了，再将它从项目中剥离出来。因为之前模块化做的好，耦合程度低，剥离出来的成本也就不会很高\n3.3 Google Guava 中用到的几种设计模式3.3.1 Builder 模式在项目开发中，经常用到缓存。它可以非常有效地提高访问速度。常用的缓存系统有 Redis、Memcache 等。但是，如果要缓存的数据比较少，完全没必要在项目中独立部署一套缓存系统。毕竟系统都有一定出错的概率，项目中包含的系统越多，那组合起来，项目整体出错的概率就会升高，可用性就会降低。同时，多引入一个系统就要多维护一个系统，项目维护的成本就会变高\n取而代之，可以在系统内部构建一个内存缓存，跟系统集成在一起开发、部署。那如何构建内存缓存呢？可以基于 JDK 提供的类，比如 HashMap，从零开始开发内存缓存。不过，从零开发一个内存缓存，涉及的工作就会比较多，比如缓存淘汰策略等。为了简化开发，就可以使用 Google Guava 提供的现成的缓存工具类com.google.common.cache.*，如下例：\npublic class CacheDemo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tCache&lt;String, String&gt; cache &#x3D; CacheBuilder.newBuilder()\n\t\t                              .initialCapacity(100)\n\t\t                              .maximumSize(1000)\n\t\t                              .expireAfterWrite(10, TimeUnit.MINUTES)\n\t\t                              .build();\n\t\tcache.put(&quot;key1&quot;, &quot;value1&quot;);\n\t\tString value &#x3D; cache.getIfPresent(&quot;key1&quot;);\n\t\tSystem.out.println(value);\n\t&#125;\n&#125;\n\n从上面的代码中，可以发现，Cache 对象是通过 CacheBuilder 这样一个 Builder 类来创建的。为什么要由 Builder 类来创建 Cache 对象呢？\n构建一个缓存，需要配置 n 多参数，比如过期时间、淘汰策略、最大缓存大小等等。相应地，Cache 类就会包含 n 多成员变量。需要在构造函数中，设置这些成员变量的值，但又不是所有的值都必须设置，设置哪些值由用户来决定。为了满足这个需求，就需要定义多个包含不同参数列表的构造函数\n为了避免构造函数的参数列表过长、不同的构造函数过多，一般有两种解决方案。其中，一个解决方案是使用 Builder 模式；另一个方案是先通过无参构造函数创建对象，然后再通过 setXXX() 方法来逐一设置需要的设置的成员变量\n为什么 Guava 选择第一种而不是第二种解决方案呢？使用第二种解决方案是否也可以呢？答案是不行的，先看下源码如下：\npublic &lt;K1 extends K, V1 extends V&gt; Cache&lt;K1, V1&gt; build() &#123;\n\tthis.checkWeightWithWeigher();\n\tthis.checkNonLoadingCache();\n\treturn new LocalManualCache(this);\n&#125;\nprivate void checkNonLoadingCache() &#123;\n\tPreconditions.checkState(this.refreshNanos &#x3D;&#x3D; -1L, &quot;refreshAfterWrite require&quot;);\n&#125;\nprivate void checkWeightWithWeigher() &#123;\n\tif (this.weigher &#x3D;&#x3D; null) &#123;\n\t\tPreconditions.checkState(this.maximumWeight &#x3D;&#x3D; -1L, &quot;maximumWeight requires&quot;);\n\t&#125; else if (this.strictParsing) &#123;\n\t\tPreconditions.checkState(this.maximumWeight !&#x3D; -1L, &quot;weigher requires maximnum&quot;);\n\t&#125; else if (this.maximumWeight &#x3D;&#x3D; -1L) &#123;\n\t\tlogger.log(Level.WARNING, &quot;ignoring weigher specified without maximumWeight&quot;);\n\t&#125;\n&#125;\n\n必须使用 Builder 模式的主要原因是，在真正构造 Cache 对象的时候，必须做一些必要的参数校验，也就是 build() 函数中前两行代码要做的工作。如果采用无参默认构造函数加 setXXX() 方法的方案，这两个校验就无处安放了。而不经过校验，创建的 Cache 对象有可能是不合法、不可用的\n3.3.2 Wrapper 模式在 Google Guava 的 collection 包路径下，有一组以 Forwarding 开头命名的类\n\n这组 Forwarding 类很多，但实现方式都很相似。这里摘抄了其中的 ForwardingCollection 中的部分代码到这里\n@GwtCompatible\npublic abstract class ForwardingCollection&lt;E&gt; extends ForwardingObject implement Collection &#123;\n\tprotected ForwardingCollection() &#123;\n\t&#125;\n\tprotected abstract Collection&lt;E&gt; delegate();\n\tpublic Iterator&lt;E&gt; iterator() &#123;\n\t\treturn this.delegate().iterator();\n\t&#125;\n\tpublic int size() &#123;\n\t\treturn this.delegate().size();\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean removeAll(Collection&lt;?&gt; collection) &#123;\n\t\treturn this.delegate().removeAll(collection);\n\t&#125;\n\tpublic boolean isEmpty() &#123;\n\t\treturn this.delegate().isEmpty();\n\t&#125;\n\tpublic boolean contains(Object object) &#123;\n\t\treturn this.delegate().contains(object);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean add(E element) &#123;\n\t\treturn this.delegate().add(element);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean remove(Object object) &#123;\n\t\treturn this.delegate().remove(object);\n\t&#125;\n\tpublic boolean containsAll(Collection&lt;?&gt; collection) &#123;\n\t\treturn this.delegate().containsAll(collection);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean addAll(Collection&lt;? extends E&gt; collection) &#123;\n\t\treturn this.delegate().addAll(collection);\n\t&#125;\n\t@CanIgnoreReturnValue\n\tpublic boolean retainAll(Collection&lt;?&gt; collection) &#123;\n\t\treturn this.delegate().retainAll(collection);\n\t&#125;\n\tpublic void clear() &#123;\n\t\tthis.delegate().clear();\n\t&#125;\n\tpublic Object[] toArray() &#123;\n\t\treturn this.delegate().toArray();\n\t&#125;\n\t&#x2F;&#x2F;...省略部分代码...\n&#125;\n\n再来看他的用法示例：\npublic class AddLoggingCollection&lt;E&gt; extends ForwardingCollection&lt;E&gt; &#123;\n\tprivate static final Logger logger &#x3D; LoggerFactory.getLogger(AddLoggingCollec\n\t                                     private Collection&lt;E&gt; originalCollection;\n\tpublic AddLoggingCollection(Collection&lt;E&gt; originalCollection) &#123;\n\t\tthis.originalCollection &#x3D; originalCollection;\n\t&#125;\n\t@Override\n\tprotected Collection delegate() &#123;\n\t\treturn this.originalCollection;\n\t&#125;\n\t@Override\n\tpublic boolean add(E element) &#123;\n\t\tlogger.info(&quot;Add element: &quot; + element);\n\t\treturn this.delegate().add(element);\n\t&#125;\n\t@Override\n\tpublic boolean addAll(Collection&lt;? extends E&gt; collection) &#123;\n\t\tlogger.info(&quot;Size of elements to add: &quot; + collection.size());\n\t\treturn this.delegate().addAll(collection);\n\t&#125;\n&#125;\n\n在上面的代码中，AddLoggingCollection 是基于代理模式实现的一个代理类，它在原始 Collection 类的基础之上，针对“add”相关的操作，添加了记录日志的功能\n前面讲到，代理模式、装饰器、适配器模式可以统称为 Wrapper 模式，通过 Wrapper 类二次封装原始类。它们的代码实现也很相似，都可以通过组合的方式，将 Wrapper 类的函数实现委托给原始类的函数来实现\npublic interface Interf &#123;\n\tvoid f1();\n\tvoid f2();\n&#125;\npublic class OriginalClass implements Interf &#123;\n\t@Override\n\tpublic void f1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class WrapperClass implements Interf &#123;\n\tprivate OriginalClass oc;\n\tpublic WrapperClass(OriginalClass oc) &#123;\n\t\tthis.oc &#x3D; oc;\n\t&#125;\n\t@Override\n\tpublic void f1() &#123;\n\t\t&#x2F;&#x2F;...附加功能...\n\t\tthis.oc.f1();\n\t\t&#x2F;&#x2F;...附加功能...\n\t&#125;\n\t@Override\n\tpublic void f2() &#123;\n\t\tthis.oc.f2();\n\t&#125;\n&#125;\n\n实际上，这个 ForwardingCollection 类是一个“默认 Wrapper 类”或者叫“缺省Wrapper 类”。Java IO 的 FilterInputStream 缺省装饰器类\n如果不使用这个 ForwardinCollection 类，而是让 AddLoggingCollection 代理类直接实现 Collection 接口，那 Collection 接口中的所有方法，都要在 AddLoggingCollection 类中实现一遍，而真正需要添加日志功能的只有 add() 和 addAll() 两个函数，其他函数的实现，都只是类似 Wrapper 类中 f2() 函数的实现那样，简单地委托给原始 collection 类对象的对应函数\n为了简化 Wrapper 模式的代码实现，Guava 提供一系列缺省的 Forwarding 类。用户在实现自己的 Wrapper 类的时候，基于缺省的 Forwarding 类来扩展，就可以只实现自己关心的方法，其他不关心的方法使用缺省 Forwarding 类的实现，就像 AddLoggingCollection 类的实现那样\n3.3.3 Immutable 模式Immutable 模式，中文叫作不变模式，它并不属于经典的 23 种设计模式，但作为一种较常用的设计思路，可以总结为一种设计模式来学习\n一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是不变类（Immutable Class），对象就是不变对象（Immutable Object）。在 Java 中，最常用的不变类就是 String 类，String 对象一旦创建之后就无法改变\n不变模式可以分为两类，一类是普通不变模式，另一类是深度不变模式（Deeply Immutable Pattern）。普通的不变模式指的是，对象中包含的引用对象是可以改变的。如果不特别说明，通常所说的不变模式，指的就是普通的不变模式。深度不变模式指的是，对象包含的引用对象也不可变。它们两个之间的关系，有点类似之前讲过的浅拷贝和深拷贝之间的关系。如下例：\n&#x2F;&#x2F; 普通不变模式\npublic class User &#123;\n\tprivate String name;\n\tprivate int age;\n\tprivate Address addr;\n\tpublic User(String name, int age, Address addr) &#123;\n\t\tthis.name &#x3D; name;\n\t\tthis.age &#x3D; age;\n\t\tthis.addr &#x3D; addr;\n\t&#125;\n\t&#x2F;&#x2F; 只有getter方法，无setter方法...\n&#125;\npublic class Address &#123;\n\tprivate String province;\n\tprivate String city;\n\tpublic Address(String province, String city) &#123;\n\t\tthis.province &#x3D; province;\n\t\tthis.city&#x3D; city;\n\t&#125;\n\t&#x2F;&#x2F; 有getter方法，也有setter方法...\n&#125;\n&#x2F;&#x2F; 深度不变模式\npublic class User &#123;\n\tprivate String name;\n\tprivate int age;\n\tprivate Address addr;\n\tpublic User(String name, int age, Address addr) &#123;\n\t\tthis.name &#x3D; name;\n\t\tthis.age &#x3D; age;\n\t\tthis.addr &#x3D; addr;\n\t&#125;\n\t&#x2F;&#x2F; 只有getter方法，无setter方法...\n&#125;\npublic class Address &#123;\n\tprivate String province;\n\tprivate String city;\n\tpublic Address(String province, String city) &#123;\n\t\tthis.province &#x3D; province;\n\t\tthis.city&#x3D; city;\n\t&#125;\n\t&#x2F;&#x2F; 只有getter方法，无setter方法..\n&#125;\n\n在某个业务场景下，如果一个对象符合创建之后就不会被修改这个特性，那就可以把它设计成不变类。显式地强制它不可变，这样能避免意外被修改。那如何将一个不变类呢？方法很简单，只要这个类满足：所有的成员变量都通过构造函数一次性设置好，不暴露任何 set 等修改成员变量的方法。除此之外，因为数据不变，所以不存在并发读写问题，因此不变模式常用在多线程环境下，来避免线程加锁。所以，不变模式也常被归类为多线程设计模式\n接下来，来看一种特殊的不变类，那就是不变集合。Google Guava 针对集合类（Collection、List、Set、Map…）提供了对应的不变集合类（ImmutableCollection、ImmutableList、ImmutableSet、ImmutableMap…）。上面讲过，不变模式分为两种，普通不变模式和深度不变模式。Google Guava 提供的不变集合类属于前者，也就是说，集合中的对象不会增删，但是对象的成员变量（或叫属性值）是可以改变的\n实际上，Java JDK 也提供了不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）。那它跟 Google Guava 提供的不变集合类的区别在哪里呢？如下例：\npublic class ImmutableDemo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String&gt; originalList &#x3D; new ArrayList&lt;&gt;();\n\t\toriginalList.add(&quot;a&quot;);\n\t\toriginalList.add(&quot;b&quot;);\n\t\toriginalList.add(&quot;c&quot;);\n\t\tList&lt;String&gt; jdkUnmodifiableList &#x3D; Collections.unmodifiableList(originalList);\n\t\tList&lt;String&gt; guavaImmutableList &#x3D; ImmutableList.copyOf(originalList);\n\t\t&#x2F;&#x2F;jdkUnmodifiableList.add(&quot;d&quot;); &#x2F;&#x2F; 抛出UnsupportedOperationException\n\t\t&#x2F;&#x2F; guavaImmutableList.add(&quot;d&quot;); &#x2F;&#x2F; 抛出UnsupportedOperationException\n\t\toriginalList.add(&quot;d&quot;);\n\t\tprint(originalList); &#x2F;&#x2F; a b c d\n\t\tprint(jdkUnmodifiableList); &#x2F;&#x2F; a b c d\n\t\tprint(guavaImmutableList); &#x2F;&#x2F; a b c\n\t&#125;\n\tprivate static void print(List&lt;String&gt; list) &#123;\n\t\tfor (String s : list) &#123;\n\t\t\tSystem.out.print(s + &quot; &quot;);\n\t\t&#125;\n\t\tSystem.out.println();\n\t&#125;\n&#125;\n\n3.4 函数式编程现在主流的编程范式主要有三种，面向过程、面向对象和函数式编程。函数式编程并非一个很新的东西，早在 50 多年前就已经出现了。近几年，函数式编程越来越被人关注，出现了很多新的函数式编程语言，比如 Clojure、Scala、Erlang 等。一些非函数式编程语言也加入了很多特性、语法、类库来支持函数式编程，比如 Java、Python、Ruby、JavaScript 等。除此之外，Google Guava 也有对函数式编程的增强功能\n函数式编程因其编程的特殊性，仅在科学计算、数据处理、统计分析等领域，才能更好地发挥它的优势，所以个人觉得，它并不能完全替代更加通用的面向对象编程范式。但是，作为一种补充，它也有很大存在、发展和学习的意义\n3.4.1 概念函数式编程的英文翻译是 Functional Programming。 那到底什么是函数式编程呢？\n前面讲到，面向过程、面向对象编程并没有严格的官方定义，实际上，函数式编程也是如此，也没有一个严格的官方定义。所以，接下来就从特性上来说说什么是函数式编程\n严格上来讲，函数式编程中的“函数”，并不是指编程语言中的“函数”概念，而是指数学“函数”或者“表达式”（比如，y=f(x)）。不过，在编程实现的时候，对于数学“函数”或“表达式”，一般习惯性地将它们设计成函数。所以，如果不深究的话，函数式编程中的“函数”也可以理解为编程语言中的“函数”\n每个编程范式都有自己独特的地方，这就是它们会被抽象出来作为一种范式的原因。面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性。面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离。那函数式编程最独特的地方又在哪里呢？\n实际上，函数式编程最独特的地方在于它的编程思想。函数式编程认为，程序可以用一系列数学函数或表达式的组合来表示。函数式编程是程序面向数学的更底层的抽象，将计算过程描述为表达式。不过，真的可以把任何程序都表示成一组数学表达式吗？\n理论上讲是可以的。但是，并不是所有的程序都适合这么做。函数式编程有它自己适合的应用场景，比如本节开头提到的科学计算、数据处理、统计分析等。在这些领域，程序往往比较容易用数学表达式来表示，比起非函数式编程，实现同样的功能，函数式编程可以用很少的代码就能搞定。但是，对于强业务相关的大型业务系统开发来说，费劲地将它抽象成数学表达式，硬要用函数式编程来实现，显然是自讨苦吃。相反，在这种应用场景下，面向对象编程更加合适，写出来的代码更加可读、可维护\n具体到编程实现，函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。不过，它跟面向过程编程的区别在于，它的函数是无状态的。何为无状态？简单点讲就是，函数内部涉及的变量都是局部变量，不会像面向对象编程那样，共享类成员变量，也不会像面向过程编程那样，共享全局变量。函数的执行结果只与入参有关，跟其他任何外部变量无关。同样的入参，不管怎么执行，得到的结果都是一样的。这实际上就是数学函数或数学表达式的基本要求，如下例：\n&#x2F;&#x2F; 有状态函数: 执行结果依赖b的值是多少，即便入参相同，多次执行函数，函数的返回值有可能不同\nint b;\nint increase(int a) &#123;\n    return a + b;\n&#125;\n&#x2F;&#x2F; 无状态函数：执行结果不依赖任何外部变量值，只要入参相同，不管执行多少次，函数的返回值就相同\nint increase(int a, int b) &#123;\n    return a + b;\n&#125;\n\n不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念，最顶层都要有 main 函数执行入口，来组装编程单元（类、函数等）。只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数\n3.4.2 Java 对函数式编程的支持实现面向对象编程不一定非得使用面向对象编程语言，同理，实现函数式编程也不一定非得使用函数式编程语言。现在，很多面向对象编程语言，也提供了相应的语法、类库来支持函数式编程\nJava 为函数式编程引入了三个新的语法概念：Stream 类、Lambda 表达式和函数接口（Functional Inteface）。Stream 类用来支持通过“.”级联多个函数操作的代码编写方式；引入 Lambda 表达式的作用是简化代码编写；函数接口的作用是可以把函数包裹成函数接口，来实现把函数当做参数一样来使用（Java 不像 C 一样支持函数指针，可以把函数直接当参数来使用）\n详细的相关知识可自行了解\n3.4.3 Guava 对函数式编程的增强如果你是 Google Guava 的设计者，对于 Java 函数式编程，Google Guava 还能做些什么呢？\n颠覆式创新是很难的。不过可以进行一些补充，一方面，可以增加 Stream 类上的操作（类似 map、filter、max 这样的终止操作和中间操作），另一方面，也可以增加更多的函数接口（类似 Function、Predicate 这样的函数接口）。实际上，还可以设计一些类似 Stream 类的新的支持级联操作的类。这样，使用 Java 配合 Guava 进行函数式编程会更加方便\n但是，跟预期的相反，Google Guava 并没有提供太多函数式编程的支持，仅仅封装了几个遍历集合操作的接口，代码如下所示：\nIterables.transform(Iterable, Function);\nIterators.transform(Iterator, Function);\nCollections.transfrom(Collection, Function);\nLists.transform(List, Function);\nMaps.transformValues(Map, Function);\nMultimaps.transformValues(Mltimap, Function);\n...\nIterables.filter(Iterable, Predicate);\nIterators.filter(Iterator, Predicate);\nCollections2.filter(Collection, Predicate);\n...\n\n从 Google Guava 的 GitHub Wiki 中发现，Google 对于函数式编程的使用还是很谨慎的，认为过度地使用函数式编程，会导致代码可读性变差，强调不要滥用。所以，在函数式编程方面，Google Guava 并没有提供太多的支持\n之所以对遍历集合操作做了优化，主要是因为函数式编程一个重要的应用场景就是遍历集合。如果不使用函数式编程，只能 for 循环，一个一个的处理集合中的数据。使用函数式编程，可以大大简化遍历集合操作的代码编写，一行代码就能搞定，而且在可读性方面也没有太大损失\n4. Spring 框架4.1 蕴含的设计思想4.1.1 约定优于配置在使用 Spring 开发的项目中，配置往往会比较复杂、繁琐。比如利用 Spring MVC 来开发 Web 应用，需要配置每个 Controller 类以及 Controller 类中的接口对应的 URL。如何来简化配置呢？一般来讲，有两种方法，一种是基于注解，另一种是基于约定。这两种配置方式在 Spring 中都有用到。Spring 在最小化配置方面做得淋漓尽致，有很多值得借鉴的地方\n\n基于注解的配置方式：在指定类上使用指定的注解，来替代集中的 XML 配置。比如，使用 @RequestMapping 注解，在 Controller 类或者接口上，标注对应的 URL；使用 @Transaction 注解表明支持事务等\n基于约定的配置方式：也常叫作“约定优于配置”或者“规约优于配置”（Convention over Configuration）。通过约定的代码结构或者命名来减少配置。说直白点，就是提供配置的默认值，优先使用默认值。程序员只需要设置那些偏离约定的配置就可以了\n\n比如，在 Spring JPA（基于 ORM 框架、JPA 规范的基础上，封装的一套 JPA 应用框架）中，约定类名默认跟表名相同，属性名默认跟表字段名相同，String 类型对应数据库中的 varchar 类型，long 类型对应数据库中的 bigint 类型等等\n基于刚刚的约定，代码中定义的 Order 类就对应数据库中的“order”表。只有在偏离这一约定的时候，例如数据库中表命名为“order_info”而非“order”，才需要显示地去配置类与表的映射关系（Order 类 -&gt; order_info 表）\n实际上，约定优于配置，很好地体现了“二八法则”。在平时的项目开发中，80% 的配置使用默认配置就可以了，只有 20% 的配置必须用户显式地去设置。所以，基于约定来配置，在没有牺牲配置灵活性的前提下，节省了大量编写配置的时间，省掉了很多不动脑子的纯体力劳动，提高了开发效率。除此之外，基于相同的约定来做开发，也减少了项目的学习成本和维护成本。\n4.1.2 低侵入、松耦合框架的侵入性是衡量框架好坏的重要指标。所谓低侵入指的是，框架代码很少耦合在业务代码中。低侵入意味着，当要替换一个框架的时候，对原有的业务代码改动会很少。相反，如果一个框架是高度侵入的，代码高度侵入到业务代码中，那替换成另一个框架的成本将非常高，甚至几乎不可能。这也是一些长期维护的老项目，使用的框架、技术比较老旧，又无法更新的一个很重要的原因\n实际上，低侵入是 Spring 框架遵循的一个非常重要的设计思想\nSpring 提供的 IOC 容器，在不需要 Bean 继承任何父类或者实现任何接口的情况下，仅仅通过配置，就能将它们纳入进 Spring 的管理中。如果换一个 IOC 容器，也只是重新配置一下就可以了，原有的 Bean 都不需要任何修改\n除此之外，Spring 提供的 AOP 功能，也体现了低侵入的特性。在项目中，对于非业务功能，比如请求日志、数据采点、安全校验、事务等等，没必要将它们侵入进业务代码中。因为一旦侵入，这些代码将分散在各个业务代码中，删除、修改的成本就变得很高。而基于 AOP 这种开发模式，将非业务代码集中放到切面中，删除、修改的成本就变得很低了\n4.1.3 模块化、轻量级十几年前，EJB 是 Java 企业级应用的主流开发框架。但是，它非常臃肿、复杂，侵入性、耦合性高，开发、维护和学习成本都不低。所以，为了替代笨重的 EJB，Rod Johnson 开发了一套开源的 Interface21 框架，提供了最基本的 IOC 功能。实际上，Interface21 框架就是 Spring 框架的前身\n但是，随着不断的发展，Spring 现在也不单单只是一个只包含 IOC 功能的小框架了，它显然已经壮大成了一个“平台”或者叫“生态”，包含了各种五花八门的功能。尽管如此，但它也并没有重蹈覆辙，变成一个像 EJB 那样的庞大难用的框架。那 Spring 是怎么做到的呢？\n这就要归功于 Spring 的模块化设计思想，下图是 Spring Framework 的模块和分层介绍图\n\n从图中可以看出，Spring 在分层、模块化方面做得非常好。每个模块都只负责一个相对独立的功能。模块之间关系，仅有上层对下层的依赖关系，而同层之间以及下层对上层，几乎没有依赖和耦合。除此之外，在依赖 Spring 的项目中，开发者可以有选择地引入某几个模块，而不会因为需要一个小的功能，就被强迫引入整个 Spring 框架。所以，尽管 Spring Framework 包含的模块很多，已经有二十几个，但每个模块都非常轻量级，都可以单独拿来使用。正因如此，到现在，Spring 框架仍然可以被称为是一个轻量级的开发框架\n4.1.4 再封装、再抽象Spring 不仅仅提供了各种 Java 项目开发的常用功能模块，而且还对市面上主流的中间件、系统的访问类库，做了进一步的封装和抽象，提供了更高层次、更统一的访问接口\n比如，Spring 提供了 spring-data-redis 模块，对 Redis Java 开发类库（比如 Jedis、Lettuce）做了进一步的封装，适配 Spring 的访问方式，让编程访问 Redis 更加简单。还有 Spring Cache，实际上也是一种再封装、再抽象。它定义了统一、抽象的 Cache 访问接口，这些接口不依赖具体的 Cache 实现（Redis、Guava Cache、Caffeine 等）。在项目中，基于 Spring 提供的抽象统一的接口来访问 Cache。这样，就能在不修改代码的情况下，实现不同 Cache 之间的切换\n除此之外，Spring 对 JDBC 异常也做了进一步的封装。封装的数据库异常继承自 DataAccessException 运行时异常。这类异常在开发中无需强制捕获，从而减少了不必要的异常捕获和处理。除此之外，Spring 封装的数据库异常，还屏蔽了不同数据库异常的细节（比如，不同的数据库对同一报错定义了不同的错误码），让异常的处理更加简单\n4.2 用来支持扩展的两种设计模式4.2.1 观察者模式在 Spring 中的应用Spring 中实现的观察者模式包含三部分：Event 事件（相当于消息）、Listener 监听者（相当于观察者）、Publisher 发送者（相当于被观察者）。示例如下所示：\n&#x2F;&#x2F; Event事件\npublic class DemoEvent extends ApplicationEvent &#123;\n\tprivate String message;\n\tpublic DemoEvent(Object source, String message) &#123;\n\t\tsuper(source);\n\t&#125;\n\tpublic String getMessage() &#123;\n\t\treturn this.message;\n\t&#125;\n&#125;\n&#x2F;&#x2F; Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123;\n\t@Override\n\tpublic void onApplicationEvent(DemoEvent demoEvent) &#123;\n\t\tString message &#x3D; demoEvent.getMessage();\n\t\tSystem.out.println(message);\n\t&#125;\n&#125;\n&#x2F;&#x2F; Publisher发送者\n@Component\npublic class DemoPublisher &#123;\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\tpublic void publishEvent(DemoEvent demoEvent) &#123;\n\t\tthis.applicationContext.publishEvent(demoEvent);\n\t&#125;\n&#125;\n\n从代码中可以看出，框架使用起来并不复杂，主要包含三部分工作：定义一个继承 ApplicationEvent 的事件（DemoEvent）；定义一个实现了 ApplicationListener 的监听器（DemoListener）；定义一个发送者（DemoPublisher），发送者调用 ApplicationContext 来发送事件消息\npublic abstract class ApplicationEvent extends EventObject &#123;\n\tprivate static final long serialVersionUID &#x3D; 7099057708183571937L;\n\tprivate final long timestamp &#x3D; System.currentTimeMillis();\n\tpublic ApplicationEvent(Object source) &#123;\n\t\tsuper(source);\n\t&#125;\n\tpublic final long getTimestamp() &#123;\n\t\treturn this.timestamp;\n\t&#125;\n&#125;\npublic class EventObject implements java.io.Serializable &#123;\n\tprivate static final long serialVersionUID &#x3D; 5516075349620653480L;\n\tprotected transient Object source;\n\tpublic EventObject(Object source) &#123;\n\t\tif (source &#x3D;&#x3D; null)\n\t\t\tthrow new IllegalArgumentException(&quot;null source&quot;);\n\t\tthis.source &#x3D; source;\n\t&#125;\n\tpublic Object getSource() &#123;\n\t\treturn source;\n\t&#125;\n\tpublic String toString() &#123;\n\t\treturn getClass().getName() + &quot;[source&#x3D;&quot; + source + &quot;]&quot;;\n\t&#125;\n&#125;\npublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventObject &#123;\n\tvoid onApplicationEvent(E var1);\n&#125;\n\n在之前讲到观察者模式的时候提到，观察者需要事先注册到被观察者（JDK 的实现方式）或者事件总线（EventBus 的实现方式）中。那在 Spring 的实现中，观察者注册到了哪里呢？又是如何注册的呢？\nSpring 把观察者注册到了 ApplicationContext 对象中。这里的 ApplicationContext 就相当于 Google EventBus 框架中的“事件总线”。不过，ApplicationContext 这个类并不只是为观察者模式服务的。它底层依赖 BeanFactory（IOC 的主要实现类），提供应用启动、运行时的上下文信息，是访问这些信息的最顶层接口\n实际上，具体到源码来说，ApplicationContext 只是一个接口，具体的代码实现包含在它的实现类 AbstractApplicationContext 中。其中跟观察者模式相关的代码如下，只需要关注它是如何发送事件和注册监听者就好\npublic abstract class AbstractApplicationContext extends ...&#123;\n    private final Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;\n\n    public AbstractApplicationContext() &#123;\n        this.applicationListeners &#x3D; new LinkedHashSet();\n        &#x2F;&#x2F;...\n    &#125;\n\n    public void publishEvent(ApplicationEvent event) &#123;\n        this.publishEvent(event, (ResolvableType) null);\n    &#125;\n\n    public void publishEvent(Object event) &#123;\n        this.publishEvent(event, (ResolvableType) null);\n    &#125;\n\n    protected void publishEvent(Object event, ResolvableType eventType) &#123;\n        &#x2F;&#x2F;...\n        Object applicationEvent;\n        if (event instanceof ApplicationEvent) &#123;\n            applicationEvent &#x3D; (ApplicationEvent) event;\n        &#125; else &#123;\n            applicationEvent &#x3D; new PayloadApplicationEvent(this, event);\n            if (eventType &#x3D;&#x3D; null) &#123;\n                eventType &#x3D; ((PayloadApplicationEvent) applicationEvent).getResolvableTy\n            &#125;\n        &#125;\n        if (this.earlyApplicationEvents !&#x3D; null) &#123;\n            this.earlyApplicationEvents.add(applicationEvent);\n        &#125; else &#123;\n            this.getApplicationEventMulticaster().multicastEvent(\n                    (ApplicationEvent) applicationEvent, eventType);\n        &#125;\n        if (this.parent !&#x3D; null) &#123;\n            if (this.parent instanceof AbstractApplicationContext) &#123;\n                ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);\n            &#125; else &#123;\n                this.parent.publishEvent(event);\n            &#125;\n        &#125;\n    &#125;\n\n    public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;\n        Assert.notNull(listener, &quot;ApplicationListener must not be null&quot;);\n        if (this.applicationEventMulticaster !&#x3D; null) &#123;\n            this.applicationEventMulticaster.addApplicationListener(listener);\n        &#125; else &#123;\n            this.applicationListeners.add(listener);\n        &#125;\n    &#125;\n\n    public Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;\n        return this.applicationListeners;\n    &#125;\n\n    protected void registerListeners() &#123;\n        Iterator var1 &#x3D; this.getApplicationListeners().iterator();\n        while (var1.hasNext()) &#123;\n            ApplicationListener&lt;?&gt; listener &#x3D; (ApplicationListener) var1.next();\n        &#125;\n        String[] listenerBeanNames &#x3D; this.getBeanNamesForType(ApplicationListener.c\n        String[]var7 &#x3D; listenerBeanNames;\n        int var3 &#x3D; listenerBeanNames.length;\n        for (int var4 &#x3D; 0; var4 &lt; var3; ++var4) &#123;\n            String listenerBeanName &#x3D; var7[var4];\n            this.getApplicationEventMulticaster().addApplicationListenerBean(listene\n        &#125;\n        Set&lt;ApplicationEvent&gt; earlyEventsToProcess &#x3D; this.earlyApplicationEvents;\n        this.earlyApplicationEvents &#x3D; null;\n        if (earlyEventsToProcess !&#x3D; null) &#123;\n            Iterator var9 &#x3D; earlyEventsToProcess.iterator();\n            while (var9.hasNext()) &#123;\n                ApplicationEvent earlyEvent &#x3D; (ApplicationEvent) var9.next();\n                this.getApplicationEventMulticaster().multicastEvent(earlyEvent);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n从上面的代码中可以发现，真正的消息发送，实际上是通过 ApplicationEventMulticaster 这个类来完成的。这个类的源码这里只摘抄了最关键的一部分，也就是 multicastEvent() 这个消息发送函数。不过，它的代码也并不复杂，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式\npublic void multicastEvent(ApplicationEvent event) &#123;\n    this.multicastEvent(event,this.resolveDefaultEventType(event));\n&#125;\n\npublic void multicastEvent(final ApplicationEvent event,ResolvableType eventType) &#123;\n    ResolvableType type &#x3D; eventType !&#x3D;null ? eventType : this.resolveDefaultEvent;\n    Iterator var4&#x3D;this.getApplicationListeners(event,type).iterator();\n    while(var4.hasNext()) &#123;\n        final ApplicationListener&lt;?&gt; listener&#x3D;(ApplicationListener)var4.next();\n        Executor executor&#x3D;this.getTaskExecutor();\n        if(executor!&#x3D;null)&#123;\n            executor.execute(new Runnable()&#123;\n                public void run()&#123;\n                    SimpleApplicationEventMulticaster.this.invokeListener(listener,event\n                &#125;\n            &#125;);\n        &#125;else&#123;\n            this.invokeListener(listener,event);\n        &#125;\n    &#125;\n&#125;\n\n借助 Spring 提供的观察者模式的骨架代码，如果要在 Spring 下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往 ApplicationContext 中发送事件就可以了，剩下的工作都由 Spring 框架来完成。实际上，这也体现了 Spring 框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听\n4.2.2 模板模式在 Spring 中的应用一个经常在面试中被问到的一个问题：请你说下 Spring Bean 的创建过程包含哪些主要的步骤。这其中就涉及模板模式。它也体现了 Spring 的扩展性。利用模板模式，Spring 能让用户定制 Bean 的创建过程\nSpring Bean 的创建过程，可以大致分为两大步：对象的创建和对象的初始化\n对象的创建是通过反射来动态生成对象，而不是 new 方法。不管是哪种方式，说白了，总归还是调用构造函数来生成对象，没有什么特殊的。对象的初始化有两种实现方式。一种是在类中自定义一个初始化函数，并且通过配置文件，显式地告知 Spring，哪个函数是初始化函数。如下所示，在配置文件中，通过 init-method 属性来指定初始化函数\npublic class DemoClass &#123;\n    &#x2F;&#x2F;...\n    public void initDemo() &#123;\n        &#x2F;&#x2F;...初始化..\n    &#125;\n&#125;\n&#x2F;&#x2F; 配置：需要通过init-method显式地指定初始化方法\n&lt;bean id&#x3D;&quot;demoBean&quot; class&#x3D;&quot;com.xzg.cd.DemoClass&quot; init-method&#x3D;&quot;initDemo&quot;&gt;&lt;&#x2F;bean&gt;\n\n这种初始化方式有一个缺点，初始化函数并不固定，由用户随意定义，这就需要 Spring 通过反射，在运行时动态地调用这个初始化函数。而反射又会影响代码执行的性能，那有没有替代方案呢？\nSpring 提供了另外一个定义初始化函数的方法，那就是让类实现 Initializingbean 接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet() 函数）。Spring 在初始化 Bean 的时候，可以直接通过 bean.afterPropertiesSet() 的方式，调用 Bean 对象上的这个函数，而不需要使用反射来调用了。如下所示\npublic class DemoClass implements InitializingBean&#123;\n    @Override\n    public void afterPropertiesSet() throws Exception &#123;\n        &#x2F;&#x2F;...初始化...\n    &#125;\n&#125;\n&#x2F;&#x2F; 配置：不需要显式地指定初始化方法\n&lt;bean id&#x3D;&quot;demoBean&quot; class&#x3D;&quot;com.xzg.cd.DemoClass&quot;&gt;&lt;&#x2F;bean&gt;\n\n尽管这种实现方式不会用到反射，执行效率提高了，但业务代码（DemoClass）跟框架代码（InitializingBean）耦合在了一起。框架代码侵入到了业务代码中，替换框架的成本就变高了。所以，并不是太推荐这种写法\n实际上，在 Spring 对 Bean 整个生命周期的管理中，还有一个跟初始化相对应的过程，那就是 Bean 的销毁过程。在 Java 中，对象的回收是通过 JVM 来自动完成的。但是可以在将 Bean 正式交给 JVM 垃圾回收前，执行一些销毁操作（比如关闭文件句柄等等）\n销毁过程跟初始化过程非常相似，也有两种实现方式。一种是通过配置 destroy-method 指定类中的销毁函数，另一种是让类实现 DisposableBean 接口\n实际上，Spring 针对对象的初始化过程，还做了进一步的细化，将它拆分成了三个小步骤：初始化前置操作、初始化、初始化后置操作。其中，中间的初始化操作就是刚刚讲的那部分，初始化的前置和后置操作，定义在接口 BeanPostProcessor 中。BeanPostProcessor 的接口定义如下所示：\npublic interface BeanPostProcessor &#123;\n    Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException;\n    Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;\n&#125;\n\n再来看下，如何通过 BeanPostProcessor 来定义初始化前置和后置操作？\n只需要定义一个实现了 BeanPostProcessor 接口的处理器类，并在配置文件中像配置普通 Bean 一样去配置就可以了。Spring 中的 ApplicationContext 会自动检测在配置文件中实现了 BeanPostProcessor 接口的所有 Bean，并把它们注册到 BeanPostProcessor 处理器列表中。在 Spring 容器创建 Bean 的过程中，Spring 会逐一去调用这些处理器\n\n到这里可能会说，这里哪里用到了模板模式啊？模板模式不是需要定义一个包含模板方法的抽象模板类，以及定义子类实现模板方法吗？\n实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似前面讲到的 Callback 回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成 InitializingBean 对象），传递给模板（BeanFactory）来执行\n4.3 Spring 框架用到的 11 种设计模式4.3.1 适配器模式在 Spring 中的应用在 Spring MVC 中，定义一个 Controller 最常用的方式是，通过 @Controller 注解来标记某个类是 Controller 类，通过 @RequesMapping 注解来标记函数对应的 URL。不过，定义一个 Controller 远不止这一种方法。还可以通过让类实现 Controller 接口或者 Servlet 接口，来定义一个 Controller。针对这三种定义方式，示例代码如下所示：\n&#x2F;&#x2F; 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController &#123;\n\t@RequestMapping(&quot;&#x2F;employname&quot;)\n\tpublic ModelAndView getEmployeeName() &#123;\n\t\tModelAndView model &#x3D; new ModelAndView(&quot;Greeting&quot;);\n\t\tmodel.addObject(&quot;message&quot;, &quot;Dinesh&quot;);\n\t\treturn model;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller &#123;\n\t@Override\n\tpublic ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse rep) &#123;\n\t\tModelAndView model &#x3D; new ModelAndView(&quot;Greeting&quot;);\n\t\tmodel.addObject(&quot;message&quot;, &quot;Dinesh Madhwal&quot;);\n\t\treturn model;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet &#123;\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tthis.doPost(req, resp);\n\t&#125;\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throw Exception &#123;\n\t\tresp.getWriter().write(&quot;Hello World.&quot;);\n\t&#125;\n&#125;\n\n\n在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端\n但是，不同方式定义的 Controller，其函数的定义（函数名、入参、返回值等）是不统一的。如上示例代码所示，方法一中的函数的定义很随意、不固定，方法二中的函数定义是 handleRequest()、方法三中的函数定义是 service()（看似是定义了 doGet()、doPost()，实际上，这里用到了模板模式，Servlet 中的 service() 调用了 doGet() 或 doPost() 方法，DispatcherServlet 调用的是 service() 方法）。DispatcherServlet 需要根据不同类型的 Controller，调用不同的函数。下面是具体的伪代码：\nHandler handler &#x3D; handlerMapping.get(URL);\nif (handler instanceof Controller) &#123;\n\t((Controller)handler).handleRequest(...);\n&#125; else if (handler instanceof Servlet) &#123;\n\t((Servlet)handler).service(...);\n&#125; else if (hanlder 对应通过注解来定义的Controller) &#123;\n\t反射调用方法...\n&#125;\n\n从代码中可以看出，这种实现方式会有很多 if-else 分支判断，而且，如果要增加一个新的 Controller 的定义方法，就要在 DispatcherServlet 类代码中，对应地增加一段如上伪代码所示的 if 逻辑。这显然不符合开闭原则\n实际上，可以利用适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩赞。在前面讲到适配器其中一个作用是“统一多个类的接口设计”。利用适配器模式，将不同方式定义的 Controller 类中的函数，适配为统一的函数定义。这样，就能在 DispatcherServlet 类代码中，移除掉 if-else 分支判断逻辑，调用统一的函数\n具体看下 Spring 的代码实现，Spring 定义了统一的接口 HandlerAdapter，并且对每种 Controller 定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter 等，源码如下：\npublic interface HandlerAdapter &#123;\n\tboolean supports(Object var1);\n\tModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object\n\t\tlong getLastModified(HttpServletRequest var1, Object var2);\n\t&#125;\n&#x2F;&#x2F; 对应实现Controller接口的Controller\npublic class SimpleControllerHandlerAdapter implements HandlerAdapter &#123;\n\tpublic SimpleControllerHandlerAdapter() &#123;\n\t&#125;\n\tpublic boolean supports(Object handler) &#123;\n\t\treturn handler instanceof Controller;\n\t&#125;\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse re\n\t\treturn ((Controller)handler).handleRequest(request, response);\n\t&#125;\n\tpublic long getLastModified(HttpServletRequest request, Object handler) &#123;\n\t\treturn handler instanceof LastModified ? ((LastModified)handler).getLastMod\n\t&#125;\n&#125;\n&#x2F;&#x2F; 对应实现Servlet接口的Controller\npublic class SimpleServletHandlerAdapter implements HandlerAdapter &#123;\n\tpublic SimpleServletHandlerAdapter() &#123;\n\t&#125;\n\tpublic boolean supports(Object handler) &#123;\n\t\treturn handler instanceof Servlet;\n\t&#125;\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response) &#123;\n\t\t((Servlet)handler).service(request, response);\n\t\treturn null;\n\t&#125;\n\tpublic long getLastModified(HttpServletRequest request, Object handler) &#123;\n\t\treturn -1L;\n\t&#125;\n&#125;\n&#x2F;&#x2F;AnnotationMethodHandlerAdapter对应通过注解实现的Controller，\n&#x2F;&#x2F;...\n\n在 DispatcherServlet 类中，就不需要区分对待不同的 Controller 对象了，统一调用 HandlerAdapter 的 handle() 函数就可以了。按照这个思路实现的伪代码如下所示：\n&#x2F;&#x2F; 之前的实现方式\nHandler handler &#x3D; handlerMapping.get(URL);\nif (handler instanceof Controller) &#123;\n\t((Controller)handler).handleRequest(...);\n&#125; else if (handler instanceof Servlet) &#123;\n\t((Servlet)handler).service(...);\n&#125; else if (hanlder 对应通过注解来定义的Controller) &#123;\n\t反射调用方法...\n&#125;\n&#x2F;&#x2F; 现在实现方式\nHandlerAdapter handlerAdapter &#x3D; handlerMapping.get(URL);\nhandlerAdapter.handle(...);\n\n4.3.2 策略模式在 Spring 中的应用Spring AOP 是通过动态代理来实现的，具体到代码实现，Spring 支持两种动态代理实现方式，一种是 JDK 提供的动态代理实现方式，另一种是 Cglib 提供的动态代理实现方式\n前者需要被代理的类有抽象的接口定义，后者不需要。针对不同的被代理类，Spring 会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景\n前面讲过，策略模式包含三部分，策略的定义、创建和使用。接下来具体看下，这三个部分是如何体现在 Spring 源码中的\n在策略模式中，策略的定义这一部分很简单。只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到 Spring 源码，AopProxy 是策略接口，JdkDynamicAopProxy、CglibAopProxy 是两个实现了 AopProxy 接口的策略类。其中，AopProxy 接口的定义如下所示：\npublic interface AopProxy &#123;\n    Object getProxy();\n    Object getProxy(ClassLoader var1);\n&#125;\n\n在策略模式中，策略的创建一般通过工厂方法来实现。对应到 Spring 源码，AopProxyFactory 是一个工厂类接口，DefaultAopProxyFactory 是一个默认的工厂类，用来创建 AopProxy 对象。两者的源码如下所示：\npublic interface AopProxyFactory &#123;\n\tAopProxy createAopProxy(AdvisedSupport var1) throws AopConfigException;\n&#125;\n\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;\n\tpublic DefaultAopProxyFactory() &#123;\n\t&#125;\n\tpublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException) &#123;\n\t\tif (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUse) &#123;\n\t\t\treturn new JdkDynamicAopProxy(config);\n\t\t&#125; else &#123;\n\t\t\tClass&lt;?&gt; targetClass &#x3D; config.getTargetClass();\n\t\t\tif (targetClass &#x3D;&#x3D; null) &#123;\n\t\t\t\tthrow new AopConfigException(&quot;TargetSource cannot determine target class&quot;);\n\t\t\t&#125; else &#123;\n\t\t\t\treturn (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;用来判断用哪个动态代理实现方式\n\tprivate boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) &#123;\n\t\tClass&lt;?&gt;[] ifcs &#x3D; config.getProxiedInterfaces();\n\t\treturn ifcs.length &#x3D;&#x3D; 0 || ifcs.length &#x3D;&#x3D; 1 &amp;&amp; SpringProxy.class.isAssignab\n\t&#125;\n&#125;\n\n策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。对应到 Spring 源码中，可以参看刚刚给出的 DefaultAopProxyFactory 类中的 createAopProxy() 函数的代码实现。其中，第 10 行代码是动态选择哪种策略的判断条件\n4.3.3 组合模式在 Spring 中的应用前面讲到 Spring“再封装、再抽象”设计思想的时候，提到了 Spring Cache。Spring Cache 提供了一套抽象的 Cache 接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring 中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。Cache 接口的源码如下所示：\npublic interface Cache &#123;\n    String getName();\n    Object getNativeCache();\n    Cache.ValueWrapper get(Object var1);\n    &lt;T&gt; T get(Object var1, Class&lt;T&gt; var2);\n    &lt;T&gt; T get(Object var1, Callable&lt;T&gt; var2);\n    void put(Object var1, Object var2);\n    Cache.ValueWrapper putIfAbsent(Object var1, Object var2);\n    void evict(Object var1);\n    void clear();\n    public static class ValueRetrievalException extends RuntimeException &#123;\n        private final Object key;\n        public ValueRetrievalException(Object key, Callable&lt;?&gt; loader, Throwable exception) &#123;\n            super(String.format(&quot;Value for key &#39;%s&#39; could not be loaded using &#39;%s&#39;&quot;,\n                                this.key &#x3D; key;\n        &#125;\n        public Object getKey() &#123;\n            return this.key;\n        &#125;\n    &#125;\n    public interface ValueWrapper &#123;\n        Object get();\n    &#125;\n&#125;\n\n在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到 Google Guava 缓存，也用到 Redis 缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）\n为了管理多个缓存，Spring 还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建 Cache 对象的时候要设置 name 属性）获取 Cache 对象；另一个是获取管理器管理的所有缓存的名字列表。对应的 Spring 源码如下所示：\npublic interface CacheManager &#123;\n    Cache getCache(String var1);\n    Collection&lt;String&gt; getCacheNames();\n&#125;\n\n刚刚给出的是 CacheManager 接口的定义，那如何来实现这两个接口呢？这就要用到了之前讲过的组合模式，组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点\n叶子节点包含的是它所管理的 Cache 对象，中间节点包含的是其他 CacheManager 管理器，既可以是 CompositeCacheManager，也可以是具体的管理器，比如 EhCacheManager、RedisManager 等\nCompositeCacheManger 的代码如下，其中，getCache()、getCacheNames() 两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方\npublic class CompositeCacheManager implements CacheManager, InitializingBean &#123;\n    private final List&lt;CacheManager&gt; cacheManagers &#x3D; new ArrayList();\n    private boolean fallbackToNoOpCache &#x3D; false;\n    public CompositeCacheManager() &#123;\n    &#125;\n    public CompositeCacheManager(CacheManager... cacheManagers) &#123;\n        this.setCacheManagers(Arrays.asList(cacheManagers));\n    &#125;\n    public void setCacheManagers(Collection&lt;CacheManager&gt; cacheManagers) &#123;\n        this.cacheManagers.addAll(cacheManagers);\n    &#125;\n    public void setFallbackToNoOpCache(boolean fallbackToNoOpCache) &#123;\n        this.fallbackToNoOpCache &#x3D; fallbackToNoOpCache;\n    &#125;\n    public void afterPropertiesSet() &#123;\n        if (this.fallbackToNoOpCache) &#123;\n            this.cacheManagers.add(new NoOpCacheManager());\n        &#125;\n    &#125;\n    public Cache getCache(String name) &#123;\n        Iterator var2 &#x3D; this.cacheManagers.iterator();\n        Cache cache;\n        do &#123;\n            if (!var2.hasNext()) &#123;\n                return null;\n            &#125;\n            CacheManager cacheManager &#x3D; (CacheManager)var2.next();\n            cache &#x3D; cacheManager.getCache(name);\n        &#125; while(cache &#x3D;&#x3D; null);\n        return cache;\n    &#125;\n    public Collection&lt;String&gt; getCacheNames() &#123;\n        Set&lt;String&gt; names &#x3D; new LinkedHashSet();\n        Iterator var2 &#x3D; this.cacheManagers.iterator();\n        while(var2.hasNext()) &#123;\n            CacheManager manager &#x3D; (CacheManager)var2.next();\n            names.addAll(manager.getCacheNames());\n        &#125;\n        return Collections.unmodifiableSet(names);\n    &#125;\n&#125;\n\n4.3.4 装饰器模式在 Spring 中的应用缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。为了解决这个问题，需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败\n实现这样一个功能，Spring 使用到了装饰器模式。TransactionAwareCacheDecorator 增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理\nTransactionAwareCacheDecorator 实现 Cache 接口，并且将所有的操作都委托给 targetCache 来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现\npublic class TransactionAwareCacheDecorator implements Cache &#123;\n    private final Cache targetCache;\n    public TransactionAwareCacheDecorator(Cache targetCache) &#123;\n        Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);\n        this.targetCache &#x3D; targetCache;\n    &#125;\n    public Cache getTargetCache() &#123;\n        return this.targetCache;\n    &#125;\n    public String getName() &#123;\n        return this.targetCache.getName();\n    &#125;\n    public Object getNativeCache() &#123;\n        return this.targetCache.getNativeCache();\n    &#125;\n    public ValueWrapper get(Object key) &#123;\n        return this.targetCache.get(key);\n    &#125;\n    public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) &#123;\n        return this.targetCache.get(key, type);\n    &#125;\n    public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) &#123;\n        return this.targetCache.get(key, valueLoader);\n    &#125;\n    public void put(final Object key, final Object value) &#123;\n        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;\n            TransactionSynchronizationManager.registerSynchronization(new Transaction() &#123;\n                public void afterCommit() &#123;\n                    TransactionAwareCacheDecorator.this.targetCache.put(key, value);\n                &#125;\n            &#125;);\n        &#125; else &#123;\n            this.targetCache.put(key, value);\n        &#125;\n    &#125;\n    public ValueWrapper putIfAbsent(Object key, Object value) &#123;\n        return this.targetCache.putIfAbsent(key, value);\n    &#125;\n    public void evict(final Object key) &#123;\n        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;\n            TransactionSynchronizationManager.registerSynchronization(new Transaction() &#123;\n                public void afterCommit() &#123;\n                    TransactionAwareCacheDecorator.this.targetCache.evict(key);\n                &#125;\n            &#125;);\n        &#125; else &#123;\n            this.targetCache.evict(key);\n        &#125;\n    &#125;\n    public void clear() &#123;\n        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;\n            TransactionSynchronizationManager.registerSynchronization(new Transaction() &#123;\n                public void afterCommit() &#123;\n                    TransactionAwareCacheDecorator.this.targetCache.clear();\n                &#125;\n            &#125;);\n        &#125; else &#123;\n            this.targetCache.clear();\n        &#125;\n    &#125;\n&#125;\n\n4.3.5 工厂模式在 Spring 中的应用在 Spring 中，工厂模式最经典的应用莫过于实现 IOC 容器，对应的 Spring 源码主要是 BeanFactory 类和 ApplicationContext 相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）\n在 Spring 中，创建 Bean 的方式有很多种，比如前面提到的纯构造函数、无参构造函数加 setter 方法，如下例：\npublic class Student &#123;\n    private long id;\n    private String name;\n    public Student(long id, String name) &#123;\n        this.id &#x3D; id;\n        this.name &#x3D; name;\n    &#125;\n    public void setId(long id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.xzg.cd.Student&quot;&gt;\n  &lt; constructor arg&#x3D;&quot;&quot; name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;\n    &lt; constructor arg&#x3D;&quot;&quot; name&#x3D;&quot;name&quot; value&#x3D;&quot;wangzheng&quot;&gt;\n      &lt;  bean&#x3D;&quot;&quot;&gt;&#x2F;&#x2F; 使用无参构造函数+setter方法来创建Bean \n      &lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.xzg.cd.Student&quot;&gt;\n        &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;\n          &lt;  property&#x3D;&quot;&quot;&gt;\n            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;wangzheng&quot;&gt;\n              &lt;  property&#x3D;&quot;&quot;&gt;&lt;&#x2F; &gt;\n            &lt;&#x2F;property&gt;\n          &lt;&#x2F; &gt;\n        &lt;&#x2F;property&gt;\n      &lt;&#x2F;bean&gt;&lt;&#x2F; &gt;\n    &lt;&#x2F; constructor&gt;\n  &lt;&#x2F; constructor&gt;\n&lt;&#x2F;bean&gt;\n\n实际上，除了这两种创建 Bean 的方式之外，还可以通过工厂方法来创建 Bean。还是刚刚这个例子，用这种方式来创建 Bean 的话就是下面这个样子：\npublic class StudentFactory &#123;\n    private static Map&lt;Long, Student&gt; students &#x3D; new HashMap&lt;&gt;();\n    static &#123;\n        map.put(1, new Student(1, &quot;wang&quot;));\n        map.put(2, new Student(2, &quot;zheng&quot;));\n        map.put(3, new Student(3, &quot;xzg&quot;));\n    &#125;\n    public static Student getStudent(long id) &#123;\n        return students.get(id);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 通过工厂方法getStudent(2)来创建BeanId&#x3D;&quot;zheng&quot;&quot;的Bean\n&lt;bean id&#x3D;&quot;zheng&quot; class&#x3D;&quot;com.xzg.cd.StudentFactory&quot; factory-method&#x3D;&quot;getStudent&quot;&gt;\n  &lt;constructor-arg value&#x3D;&quot;2&quot;&gt;&lt;&#x2F;constructor-arg&gt;\n&lt;&#x2F;bean&gt;\n\n4.3.6 其他模式在 Spring 中的应用SpEL，全称叫 Spring Expression Language，是 Spring 中常用来编写配置的表达式语言。它定义了一系列的语法规则。只要按照这些语法规则来编写表达式，Spring 就能解析出表达式的含义。实际上，这就是前面讲到的解释器模式的典型应用场景\n因为解释器模式没有一个非常固定的代码实现结构，而且 Spring 中 SpEL 相关的代码也比较多，所以这里就不进行过多讲述了。如果感兴趣或者项目中正好要实现类似的功能的时候，可以再去阅读、借鉴它的代码实现。代码主要集中在 spring-expresssion 这个模块下面\n前面讲到单例模式的时候提到过，单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过 IOC 容器来管理对象，通过 IOC 容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个 IOC 容器内\n除此之外，Spring 还用到了观察者模式、模板模式、职责链模式、代理模式\n实际上，在 Spring 中，只要后缀带有 Template 的类，基本上都是模板类，而且大部分都是用 Callback 回调来实现的，比如 JdbcTemplate、RedisTemplate 等。剩下的两个模式在 Spring 中的应用应该人尽皆知了。职责链模式在 Spring 中的应用是拦截器（Interceptor），代理模式经典应用是 AOP\n5. MyBatis5.1 Mybatis 和 ORM 框架介绍MyBatis 是一个 ORM（Object Relational Mapping，对象 · 关系映射）框架。ORM 框架主要是根据类和数据库表之间的映射关系，帮助程序员自动实现对象与数据库中数据之间的互相转化。说得更具体点就是，ORM 负责将程序中的对象存储到数据库中、将数据库中的数据转化为程序中的对象。实际上，Java 中的 ORM 框架有很多，除了刚刚提到的 MyBatis 之外，还有 Hibernate、TopLink 等\n在剖析 Spring 框架的时候讲到，如果用一句话来总结框架作用的话，那就是简化开发。MyBatis 框架也不例外。它简化的是数据库方面的开发。那 MyBatis 是如何简化数据库开发的呢？\n前面讲到 Java 提供了 JDBC 类库来封装不同类型的数据库操作。不过，直接使用 JDBC 来进行数据库编程，还是有点麻烦的。于是，Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来进一步简化数据库编程\n使用 JdbcTemplate 进行数据库编程，只需要编写跟业务相关的代码（比如，SQL 语句、数据库中数据与对象之间的互相转化的代码），其他流程性质的代码（比如，加载驱动、创建数据库连接、创建 statement、关闭连接、关闭 statement 等）都封装在了 JdbcTemplate 类中，不需要重复编写\n还是同样这个例子，再来看下，使用 MyBatis 该如何实现，是不是比使用 JdbcTemplate 更加简单\n因为 MyBatis 依赖 JDBC 驱动，所以，在项目中使用 MyBatis，除了需要引入 MyBatis 框架本身（mybatis.jar）之外，还需要引入 JDBC 驱动（比如，访问 MySQL 的 JDBC 驱动实现类库 mysql-connector-java.jar）。将两个 jar 包引入项目之后，就可以开始编程了。使用 MyBatis 来访问数据库中用户信息的代码如下所示：\n&#x2F;&#x2F; 1. 定义UserDO\npublic class UserDo &#123;\n    private long id;\n    private String name;\n    private String telephone;\n    &#x2F;&#x2F; 省略setter&#x2F;getter方法\n&#125;\n&#x2F;&#x2F; 2. 定义访问接口\npublic interface UserMapper &#123;\n    public UserDo selectById(long id);\n&#125;\n\n&#x2F;&#x2F; 3. 定义映射关系：UserMapper.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;cn.xzg.cd.a87.repo.mapper.UserMapper&quot;&gt;\n  &lt;select id&#x3D;&quot;selectById&quot; resultType&#x3D;&quot;cn.xzg.cd.a87.repo.UserDo&quot;&gt;select * from user where id&#x3D;#&#123;id&#125;&lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n&#x2F;&#x2F; 4. 全局配置文件: mybatis.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n&quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n  &lt;environments default&#x3D;&quot;dev&quot;&gt;\n    &lt;environment id&#x3D;&quot;dev&quot;&gt;\n      &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;\n      &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n        &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;...&quot; &#x2F;&gt;\n      &lt;&#x2F;dataSource&gt;\n    &lt;&#x2F;environment&gt;\n  &lt;&#x2F;environments&gt;\n  &lt;mappers&gt;\n    &lt;mapper resource&#x3D;&quot;mapper&#x2F;UserMapper.xml&quot; &#x2F;&gt;\n  &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n需要注意的是，在 UserMapper.xml 配置文件中，只定义了接口和 SQL 语句之间的映射关系，并没有显式地定义类（UserDo）字段与数据库表（user）字段之间的映射关系。实际上，这就体现了“约定优于配置”的设计原则。类字段与数据库表字段之间使用了默认映射关系：类字段跟数据库表中拼写相同的字段一一映射。当然，如果没办法做到一一映射，也可以自定义它们之间的映射关系\n有了上面的代码和配置，就可以像下面这样来访问数据库中的用户信息了\npublic class MyBatisDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Reader reader &#x3D; Resources.getResourceAsReader(&quot;mybatis.xml&quot;);\n        SqlSessionFactory sessionFactory &#x3D; new SqlSessionFactoryBuilder().build(reader);\n        SqlSession session &#x3D; sessionFactory.openSession();\n        UserMapper userMapper &#x3D; session.getMapper(UserMapper.class);\n        UserDo userDo &#x3D; userMapper.selectById(8);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n从代码中可以看出，相对于使用 JdbcTemplate 的实现方式，使用 MyBatis 的实现方式更加灵活。在使用 JdbcTemplate 的实现方式中，对象与数据库中数据之间的转化代码、SQL 语句，是硬编码在业务代码中的。而在使用 MyBatis 的实现方式中，类字段与数据库字段之间的映射关系、接口与 SQL 之间的映射关系，是写在 XML 配置文件中的，是跟代码相分离的，这样会更加灵活、清晰，维护起来更加方便\n5.2 如何平衡易用性、性能和灵活性？刚刚对 MyBatis 框架做了简单介绍，接下来，再对比一下另外两个框架：JdbcTemplate 和 Hibernate。通过对比来看，MyBatis 是如何权衡代码的易用性、性能和灵活性的\n先来看 JdbcTemplate。相对于 MyBatis 来说，JdbcTemplate 更加轻量级。因为它对 JDBC 只做了很简单的封装，所以性能损耗比较少。相对于其他两个框架来说，它的性能最好。但是，它的缺点也比较明显，那就是 SQL 与代码耦合在一起，而且不具备 ORM 的功能，需要自己编写代码，解析对象跟数据库中的数据之间的映射关系。所以，在易用性上它不及其他两个框架\n再来看 Hibernate。相对于 MyBatis 来说，Hibernate 更加重量级。Hibernate 提供了更加高级的映射功能，能够根据业务需求自动生成 SQL 语句。不需要像使用 MyBatis 那样自己编写 SQL。因此，有的时候，也把 MyBatis 称作半自动化的 ORM框架，把 Hibernate 称作全自动化的 ORM 框架。不过，虽然自动生成 SQL 简化了开发，但是毕竟是自动生成的，没有针对性的优化。在性能方面，这样得到的 SQL 可能没有程序员编写得好。同时，这样也丧失了程序员自己编写 SQL 的灵活性\n实际上，不管用哪种实现方式，从数据库中取出数据并且转化成对象，这个过程涉及的代码逻辑基本是一致的。不同实现方式的区别，只不过是哪部分代码逻辑放到了哪里。有的框架提供的功能比较强大，大部分代码逻辑都由框架来完成，程序员只需要实现很小的一部分代码就可以了。这样框架的易用性就更好些。但是，框架集成的功能越多，为了处理逻辑的通用性，就会引入更多额外的处理代码。比起针对具体问题具体编程，这样性能损耗就相对大一些\n所以，粗略地讲，有的时候，框架的易用性和性能成对立关系。追求易用性，那性能就差一些。相反，追求性能，易用性就差一些。除此之外，使用起来越简单，那灵活性就越差，实际上，JdbcTemplate、MyBatis、Hibernate 这几个框架也体现了刚刚说的这个规律\nJdbcTemplate 提供的功能最简单，易用性最差，性能损耗最少，用它编程性能最好。Hibernate 提供的功能最完善，易用性最好，但相对来说性能损耗就最高了。MyBatis 介于两者中间，在易用性、性能、灵活性三个方面做到了权衡。它支撑程序员自己编写 SQL，能够延续程序员对 SQL 知识的积累。相对于完全黑盒子的 Hibernate，很多程序员反倒是更加喜欢 MyBatis 这种半透明的框架。这也提醒我们，过度封装，提供过于简化的开发方式，也会丧失开发的灵活性\n5.3 如何利用职责链与代理模式实现 MyBatis Plugin？MyBatis Plugin，尽管名字叫 Plugin（插件），但它实际上跟之前讲到的 Servlet Filter（过滤器）、Spring Interceptor（拦截器）类似，设计的初衷都是为了框架的扩展性，用到的主要设计模式都是职责链模式\n不过，相对于 Servlet Filter 和 Spring Interceptor，MyBatis Plugin 中职责链模式的代码实现稍微有点复杂。它是借助动态代理模式来实现的职责链\n5.3.1 MyBatis Plugin 功能介绍实际上，MyBatis Plugin 跟 Servlet Filter、Spring Interceptor 的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。它们的唯一区别在于拦截的位置是不同的。Servlet Filter 主要拦截 Servlet 请求，Spring Interceptor 主要拦截 Spring 管理的 Bean 方法（比如 Controller 类的方法等），而 MyBatis Plugin 主要拦截的是 MyBatis 在执行 SQL 的过程中涉及的一些方法，MyBatis Plugin 使用起来比较简单，如下例：\n假设需要统计应用中每个 SQL 的执行耗时，如果使用 MyBatis Plugin 来实现的话，只需要定义一个 SqlCostTimeInterceptor 类，让它实现 MyBatis 的 Interceptor 接口，并且，在 MyBatis 的全局配置文件中，简单声明一下这个插件就可以了。具体的代码和配置如下所示：\n@Intercepts(&#123;\n    @Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;query&quot;, args &#x3D; &#123; StatementHandler &#125;\n    @Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;update&quot;, args &#x3D; &#123; StatementHandler&#125;\n    @Signature(type &#x3D; StatementHandler.class, method &#x3D; &quot;batch&quot;, args &#x3D; &#123; StatementHandler&#125;\n&#125;\npublic class SqlCostTimeInterceptor implements Interceptor &#123;\n    private static Logger logger &#x3D; LoggerFactory.getLogger(SqlCostTimeInterceptor);\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable &#123;\n        Object target &#x3D; invocation.getTarget();\n        long startTime &#x3D; System.currentTimeMillis();\n        StatementHandler statementHandler &#x3D; (StatementHandler) target;\n        try &#123;\n            return invocation.proceed();\n        &#125; finally &#123;\n            long costTime &#x3D; System.currentTimeMillis() - startTime;\n            BoundSql boundSql &#x3D; statementHandler.getBoundSql();\n            String sql &#x3D; boundSql.getSql();\n            logger.info(&quot;执行 SQL：[ &#123;&#125; ]执行耗时[ &#123;&#125; ms]&quot;, sql, costTime);\n        &#125;\n    &#125;\n    @Override\n    public Object plugin(Object target) &#123;\n        return Plugin.wrap(target, this);\n    &#125;\n    @Override\n    public void setProperties(Properties properties) &#123;\n        System.out.println(&quot;插件配置的信息：&quot; + properties);\n    &#125;\n&#125;\n\n&lt;!-- MyBatis全局配置文件：mybatis-config.xml --&gt;\n&lt;plugins&gt;\n  &lt;plugin interceptor&#x3D;&quot;com.xzg.cd.a88.SqlCostTimeInterceptor&quot;&gt;\n    &lt;property name&#x3D;&quot;someProperty&quot; value&#x3D;&quot;100&quot; &#x2F;&gt;\n  &lt;&#x2F;plugin&gt;\n&lt;&#x2F;plugins&gt;\n\n先重点看下 @Intercepts 注解这一部分，不管是拦截器、过滤器还是插件，都需要明确地标明拦截的目标方法。@Intercepts 注解实际上就是起了这个作用。其中，@Intercepts 注解又可以嵌套 @Signature 注解。一个 @Signature 注解标明一个要拦截的目标方法。如果要拦截多个方法，可以像例子中那样，编写多条 @Signature 注解\n@Signature 注解包含三个元素：type、method、args。其中，type 指明要拦截的类、method 指明方法名、args 指明方法的参数列表。通过指定这三个元素，就能完全确定一个要拦截的方法\n默认情况下，MyBatis Plugin 允许拦截的方法有下面这样几个：\n\n为什么默认允许拦截的是这样几个类的方法呢？\nMyBatis 底层是通过 Executor 类来执行 SQL 的。Executor 类会创建 StatementHandler、ParameterHandler、ResultSetHandler 三个对象，并且，首先使用 ParameterHandler 设置 SQL 中的占位符参数，然后使用 StatementHandler 执行SQL 语句，最后使用 ResultSetHandler 封装执行结果。所以，只需要拦截 Executor、ParameterHandler、ResultSetHandler、StatementHandler 这几个类的方法，基本上就能满足对整个 SQL 执行流程的拦截了\n实际上，除了统计 SQL 的执行耗时，利用 MyBatis Plugin，还可以做很多事情，比如分库分表、自动分页、数据脱敏、加密解密等等\n5.3.2 MyBatis Plugin 的设计与实现职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。这两个部分对应到 Servlet Filter 的源码就是 Filter 和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和 HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和 InterceptorChain。除此之外，MyBatis Plugin 还包含另外一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理\n集成了 MyBatis 的应用在启动的时候，MyBatis 框架会读取全局配置文件（前面例子中的 mybatis-config.xml 文件），解析出 Interceptor（也就是例子中的 SqlCostTimeInterceptor），并且将它注入到 Configuration 类的 InterceptorChain 对象中。这部分逻辑对应到源码如下所示：\npublic class XMLConfigBuilder extends BaseBuilder &#123;\n    &#x2F;&#x2F;解析配置\n    private void parseConfiguration(XNode root) &#123;\n        try &#123;\n            &#x2F;&#x2F;省略部分代码...\n            pluginElement(root.evalNode(&quot;plugins&quot;)); &#x2F;&#x2F;解析插件\n        &#125; catch (Exception e) &#123;\n            throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause&quot;);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;解析插件\n    private void pluginElement(XNode parent) throws Exception &#123;\n        if (parent !&#x3D; null) &#123;\n            for (XNode child : parent.getChildren()) &#123;\n                String interceptor &#x3D; child.getStringAttribute(&quot;interceptor&quot;);\n                Properties properties &#x3D; child.getChildrenAsProperties();\n                &#x2F;&#x2F;创建Interceptor类对象\n                Interceptor interceptorInstance &#x3D; (Interceptor) resolveClass(interceptor);\n                &#x2F;&#x2F;调用Interceptor上的setProperties()方法设置properties\n                interceptorInstance.setProperties(properties);\n                &#x2F;&#x2F;下面这行代码会调用InterceptorChain.addInterceptor()方法\n                configuration.addInterceptor(interceptorInstance);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F; Configuration类的addInterceptor()方法的代码如下所示\npublic void addInterceptor(Interceptor interceptor) &#123;\n    interceptorChain.addInterceptor(interceptor);\n&#125;\n\n再来看 Interceptor 和 InterceptorChain 这两个类的代码，如下所示。Interceptor 的 setProperties() 方法就是一个单纯的 setter 方法，主要是为了方便通过配置文件配置 Interceptor 的一些属性值，没有其他作用。Interceptor 类中 intecept() 和 plugin() 函数，以及 InterceptorChain 类中的 pluginAll() 函数，是最核心的三个函数\npublic class Invocation &#123;\n    private final Object target;\n    private final Method method;\n    private final Object[] args;\n    &#x2F;&#x2F; 省略构造函数和getter方法...\n    public Object proceed() throws InvocationTargetException, IllegalAccessExcept\n        return method.invoke(target, args);\n&#125;\n&#125;\npublic interface Interceptor &#123;\n    Object intercept(Invocation invocation) throws Throwable;\n    Object plugin(Object target);\n    void setProperties(Properties properties);\n&#125;\npublic class InterceptorChain &#123;\n    private final List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;Interceptor&gt;();\n    public Object pluginAll(Object target) &#123;\n        for (Interceptor interceptor : interceptors) &#123;\n            target &#x3D; interceptor.plugin(target);\n        &#125;\n        return target;\n    &#125;\n    public void addInterceptor(Interceptor interceptor) &#123;\n        interceptors.add(interceptor);\n    &#125;\n    public List&lt;Interceptor&gt; getInterceptors() &#123;\n        return Collections.unmodifiableList(interceptors);\n    &#125;\n&#125;\n\n解析完配置文件之后，所有的 Interceptor 都加载到了 InterceptorChain 中。接下来，再来看下，这些拦截器是在什么时候被触发执行的？又是如何被触发执行的呢？\n前面提到，在执行 SQL 的过程中，MyBatis 会创建 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这几个类的对象，对应的创建代码在 Configuration 类中，如下所示：\npublic Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;\n    executorType &#x3D; executorType &#x3D;&#x3D; null ? defaultExecutorType : executorType;\n    executorType &#x3D; executorType &#x3D;&#x3D; null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;\n        executor &#x3D; new BatchExecutor(this, transaction);\n    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;\n        executor &#x3D; new ReuseExecutor(this, transaction);\n    &#125; else &#123;\n        executor &#x3D; new SimpleExecutor(this, transaction);\n    &#125;\n    if (cacheEnabled) &#123;\n        executor &#x3D; new CachingExecutor(executor);\n    &#125;\n    executor &#x3D; (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n&#125;\npublic ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object object) &#123;\n    ParameterHandler parameterHandler &#x3D; mappedStatement.getLang().createParameter);\n    parameterHandler &#x3D; (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n    return parameterHandler;\n&#125;\npublic ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement)\nResultHandler resultHandler, BoundSql boundSql) &#123;\n    ResultSetHandler resultSetHandler &#x3D; new DefaultResultSetHandler(executor, map);\n    resultSetHandler &#x3D; (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n    return resultSetHandler;\n&#125;\npublic StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement) &#123;\n    StatementHandler statementHandler &#x3D; new RoutingStatementHandler(executor, map);\n    statementHandler &#x3D; (StatementHandler) interceptorChain.pluginAll(statementHandler);\n    return statementHandler;\n&#125;\n\n从上面的代码中，可以发现，这几个类对象的创建过程都调用了 InteceptorChain 的 pluginAll() 方法。这个方法的代码前面已经给出了。它的代码实现很简单，嵌套调用 InterceptorChain 上每个 Interceptor 的 plugin() 方法。plugin()是一个接口方法（不包含实现代码），需要由用户给出具体的实现代码。在之前的例子中，SQLTimeCostInterceptor 的 plugin() 方法通过直接调用 Plugin 的 wrap() 方法来实现。wrap() 方法的代码实现如下所示：\n&#x2F;&#x2F; 借助Java InvocationHandler实现的动态代理模式\npublic class Plugin implements InvocationHandler &#123;\n    private final Object target;\n    private final Interceptor interceptor;\n    private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;\n    private Plugin(Object target, Interceptor interceptor, Map &lt; Class&lt;?&gt;, Set &lt; Method&gt;&gt; signatureMap) &#123;\n        this.target &#x3D; target;\n        this.interceptor &#x3D; interceptor;\n        this.signatureMap &#x3D; signatureMap;\n    &#125;\n    &#x2F;&#x2F; wrap()静态方法，用来生成target的动态代理，\n    &#x2F;&#x2F; 动态代理对象&#x3D;target对象+interceptor对象。\n    public static Object wrap(Object target, Interceptor interceptor) &#123;\n        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap &#x3D; getSignatureMap(interceptor);\n        Class&lt;?&gt; type &#x3D; target.getClass();\n        Class&lt;?&gt;[] interfaces &#x3D; getAllInterfaces(type, signatureMap);\n        if (interfaces.length &gt; 0) &#123;\n            return Proxy.newProxyInstance(\n                       type.getClassLoader(),\n                       interfaces,\n                       new Plugin(target, interceptor, signatureMap));\n        &#125;\n        return target;\n    &#125;\n    &#x2F;&#x2F; 调用target上的f()方法，会触发执行下面这个方法。\n    &#x2F;&#x2F; 这个方法包含：执行interceptor的intecept()方法 + 执行target上f()方法。\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        try &#123;\n            Set&lt;Method&gt; methods &#x3D; signatureMap.get(method.getDeclaringClass());\n            if (methods !&#x3D; null &amp;&amp; methods.contains(method)) &#123;\n                return interceptor.intercept(new Invocation(target, method, args));\n            &#125;\n            return method.invoke(target, args);\n        &#125; catch (Exception e) &#123;\n            throw ExceptionUtil.unwrapThrowable(e);\n        &#125;\n    &#125;\n    private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;\n        Intercepts interceptsAnnotation &#x3D; interceptor.getClass().getAnnotation(interceptor);\n        &#x2F;&#x2F; issue #251\n        if (interceptsAnnotation &#x3D;&#x3D; null) &#123;\n            throw new PluginException(&quot;No @Intercepts annotation was found in interce\n        &#125;\n        Signature[] sigs &#x3D; interceptsAnnotation.value();\n        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap &#x3D; new HashMap &lt; Class&lt;?&gt;, Set &lt; Method&gt;&gt; signatureMap);\n        for (Signature sig : sigs) &#123;\n        Set&lt;Method&gt; methods &#x3D; signatureMap.get(sig.type());\n            if (methods &#x3D;&#x3D; null) &#123;\n                methods &#x3D; new HashSet&lt;Method&gt;();\n                signatureMap.put(sig.type(), methods);\n            &#125;\n            try &#123;\n                Method method &#x3D; sig.type().getMethod(sig.method(), sig.args());\n                methods.add(method);\n            &#125; catch (NoSuchMethodException e) &#123;\n                throw new PluginException(&quot;Could not find method on &quot; + sig.type() + &quot;\n            &#125;\n        &#125;\n        return signatureMap;\n    &#125;\n    private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map &lt; Class&lt;?&gt;, Set &lt; Method&gt;&gt; signatureMap) &#123;\n        Set&lt;Class&lt;?&gt;&gt; interfaces &#x3D; new HashSet&lt;Class&lt;?&gt;&gt;();\n        while (type !&#x3D; null) &#123;\n            for (Class&lt;?&gt; c : type.getInterfaces()) &#123;\n                if (signatureMap.containsKey(c)) &#123;\n                    interfaces.add(c);\n                &#125;\n            &#125;\n            type &#x3D; type.getSuperclass();\n        &#125;\n        return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]);\n    &#125;\n&#125;\n\n实际上，Plugin 是借助 Java InvocationHandler 实现的动态代理类。用来代理给 target 对象添加 Interceptor 功能。其中，要代理的 target 对象就是 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类的对象。wrap() 静态方法是一个工具函数，用来生成 target 对象的动态代理对象\n当然，只有 interceptor 与 target 互相匹配的时候，wrap() 方法才会返回代理对象，否则就返回 target 对象本身。怎么才算是匹配呢？那就是 interceptor 通过 @Signature 注解要拦截的类包含 target 对象\nMyBatis 中的职责链模式的实现方式比较特殊。它对同一个目标对象嵌套多次代理（也就是 InteceptorChain 中的 pluginAll() 函数要执行的任务）。每个代理对象（Plugin 对象）代理一个拦截器（Interceptor 对象）功能。pluginAll() 函数的代码如下：\npublic Object pluginAll(Object target) &#123;\n    &#x2F;&#x2F; 嵌套代理\n    for (Interceptor interceptor : interceptors) &#123;\n        target &#x3D; interceptor.plugin(target);\n        &#x2F;&#x2F; 上面这行代码等于下面这行代码，target(代理对象)&#x3D;target(目标对象)+interceptor(拦截器)\n        &#x2F;&#x2F; target &#x3D; Plugin.wrap(target, interceptor);\n    &#125;\n    return target;\n&#125;\n&#x2F;&#x2F; MyBatis像下面这样创建target(Executor、StatementHandler、ParameterHandler、Resul\nObject target &#x3D; interceptorChain.pluginAll(target);\n\n当执行 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类上的某个方法的时候，MyBatis 会嵌套执行每层代理对象（Plugin 对象）上的 invoke() 方法。而 invoke() 方法会先执行代理对象中的 interceptor 的 intecept() 函数，然后再执行被代理对象上的方法。就这样，一层一层地把代理对象上的 intercept() 函数执行完之后，MyBatis 才最终执行那 4 个原始类对象上的方法\n5.4 总结 MyBatis 框架中用到的 10 种设计模式5.4.1 SqlSessionFactoryBuilder：为什么要用建造者模式来创建SqlSessionFactory？前面的用户查询例子如下：\npublic class MyBatisDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Reader reader &#x3D; Resources.getResourceAsReader(&quot;mybatis.xml&quot;);\n        SqlSessionFactory sessionFactory &#x3D; new SqlSessionFactoryBuilder().build(reader);\n        SqlSession session &#x3D; sessionFactory.openSession();\n        UserMapper userMapper &#x3D; session.getMapper(UserMapper.class);\n        UserDo userDo &#x3D; userMapper.selectById(8);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n之前讲到建造者模式的时候，使用 Builder 类来创建对象，一般都是先级联一组 setXXX() 方法来设置属性，然后再调用 build() 方法最终创建对象。但是，在上面这段代码中，通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 并不符合这个套路。它既没有 setter 方法，而且 build() 方法也并非无参，需要传递参数。除此之外，从上面的代码来看，SqlSessionFactory 对象的创建过程也并不复杂。那直接通过构造函数来创建 SqlSessionFactory 不就行了吗？为什么还要借助建造者模式创建 SqlSessionFactory呢？\n要回答这个问题，我们就要先看下 SqlSessionFactoryBuilder 类的源码。源码如下所示：\npublic class SqlSessionFactoryBuilder &#123;\n    public SqlSessionFactory build(Reader reader) &#123;\n        return build(reader, null, null);\n    &#125;\n\n    public SqlSessionFactory build(Reader reader, String environment) &#123;\n        return build(reader, environment, null);\n\n    &#125;\n    public SqlSessionFactory build(Reader reader, Properties properties) &#123;\n        return build(reader, null, properties);\n    &#125;\n\n\n    public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;\n        try &#123;\n            XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(reader, environment, properties);\n            return build(parser.parse());\n        &#125; catch (Exception e) &#123;\n            throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);\n        &#125; finally &#123;\n            ErrorContext.instance().reset();\n            try &#123;\n                reader.close();\n            &#125; catch (IOException e) &#123;\n                &#x2F;&#x2F; Intentionally ignore. Prefer previous error.\n            &#125;\n        &#125;\n    &#125;\n    public SqlSessionFactory build(InputStream inputStream) &#123;\n        return build(inputStream, null, null);\n    &#125;\n\n\n    public SqlSessionFactory build(InputStream inputStream, String environment) &#123;\n        return build(inputStream, environment, null);\n    &#125;\n\n    public SqlSessionFactory build(InputStream inputStream, Properties properties) &#123;\n        return build(inputStream, null, properties);\n    &#125;\n\n    public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;\n        try &#123;\n\n            XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);\n            return build(parser.parse());\n        &#125; catch (Exception e) &#123;\n            throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);\n        &#125; finally &#123;\n            ErrorContext.instance().reset();\n            try &#123;\n                inputStream.close();\n            &#125; catch (IOException e) &#123;\n                &#x2F;&#x2F; Intentionally ignore. Prefer previous error.\n            &#125;\n        &#125;\n    &#125;\n    public SqlSessionFactory build(Configuration config) &#123;\n        return new DefaultSqlSessionFactory(config);\n    &#125;\n&#125;\n\nSqlSessionFactoryBuilder 类中有大量的 build() 重载函数。为了方便查看，以及跟 SqlSessionFactory 类的代码作对比，这里把重载函数定义抽象出来如下：\npublic class SqlSessionFactoryBuilder &#123;\n    public SqlSessionFactory build(Reader reader);\n    public SqlSessionFactory build(Reader reader, String environment);\n    public SqlSessionFactory build(Reader reader, Properties properties);\n    public SqlSessionFactory build(Reader reader, String environment, Properties properties);\n    public SqlSessionFactory build(InputStream inputStream);\n    public SqlSessionFactory build(InputStream inputStream, String environment);\n    public SqlSessionFactory build(InputStream inputStream, Properties properties);\n    public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties);\n    &#x2F;&#x2F; 上面所有的方法最终都调用这个方法\n    public SqlSessionFactory build(Configuration config);\n&#125;\n\n如果一个类包含很多成员变量，而构建对象并不需要设置所有的成员变量，只需要选择性地设置其中几个就可以。为了满足这样的构建需求，就要定义多个包含不同参数列表的构造函数。为了避免构造函数过多、参数列表过长，一般通过无参构造函数加 setter 方法或者通过建造者模式来解决\n从建造者模式的设计初衷上来看，SqlSessionFactoryBuilder 虽然带有 Builder 后缀，但不要被它的名字所迷惑，它并不是标准的建造者模式。一方面，原始类 SqlSessionFactory 的构建只需要一个参数，并不复杂。另一方面，Builder 类 SqlSessionFactoryBuilder 仍然定义了 n 多包含不同参数列表的构造函数\n实际上，SqlSessionFactoryBuilder 设计的初衷只不过是为了简化开发。因为构建 SqlSessionFactory 需要先构建 Configuration，而构建 Configuration 是非常复杂的，需要做很多工作，比如配置的读取、解析、创建 n 多对象等。为了将构建 SqlSessionFactory 的过程隐藏起来，对程序员透明，MyBatis 就设计了SqlSessionFactoryBuilder 类封装这些构建细节\n5.4.2 SqlSessionFactory：到底属于工厂模式还是建造器模式？在上面那段 MyBatis 示例代码中，通过 SqlSessionFactoryBuilder 创建了 SqlSessionFactory，然后再通过 SqlSessionFactory 创建了 SqlSession。前面讲了SqlSessionFactoryBuilder，现在再来看下 SqlSessionFactory\n从名字上可能已经猜到，SqlSessionFactory 是一个工厂类，用到的设计模式是工厂模式。不过，它跟 SqlSessionFactoryBuilder 类似，名字有很大的迷惑性。实际上，它也并不是标准的工厂模式。为什么这么说呢？先来看下 SqlSessionFactory 类的源码\npublic interface SqlSessionFactory &#123;\n    SqlSession openSession();\n    SqlSession openSession(boolean autoCommit);\n    SqlSession openSession(Connection connection);\n    SqlSession openSession(TransactionIsolationLevel level);\n    SqlSession openSession(ExecutorType execType);\n    SqlSession openSession(ExecutorType execType, boolean autoCommit);\n    SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);\n    SqlSession openSession(ExecutorType execType, Connection connection);\n    Configuration getConfiguration();\n&#125;\n\nSqlSessionFactory 是一个接口，DefaultSqlSessionFactory 是它唯一的实现类。DefaultSqlSessionFactory 源码如下所示：\npublic class DefaultSqlSessionFactory implements SqlSessionFactory &#123;\n    private final Configuration configuration;\n    public DefaultSqlSessionFactory(Configuration configuration) &#123;\n        this.configuration &#x3D; configuration;\n    &#125;\n    @Override\n    public SqlSession openSession() &#123;\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), null);\n    &#125;\n    @Override\n    public SqlSession openSession(boolean autoCommit) &#123;\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), null);\n    &#125;\n    @Override\n    public SqlSession openSession(ExecutorType execType) &#123;\n        return openSessionFromDataSource(execType, null, false);\n    &#125;\n    @Override\n    public SqlSession openSession(TransactionIsolationLevel level) &#123;\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), level);\n    &#125;\n    @Override\n    public SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level) &#123;\n        return openSessionFromDataSource(execType, level, false);\n    &#125;\n    @Override\n    public SqlSession openSession(ExecutorType execType, boolean autoCommit) &#123;\n        return openSessionFromDataSource(execType, null, autoCommit);\n    &#125;\n    @Override\n    public SqlSession openSession(Connection connection) &#123;\n        return openSessionFromConnection(configuration.getDefaultExecutorType(), co\n    &#125;\n           @Override\n    public SqlSession openSession(ExecutorType execType, Connection connection) &#123;\n        return openSessionFromConnection(execType, connection);\n    &#125;\n    @Override\n    public Configuration getConfiguration() &#123;\n        return configuration;\n    &#125;\n    private SqlSession openSessionFromDataSource(ExecutorType execType, Transacti\n            Transaction tx &#x3D; null;\n    try &#123;\n        final Environment environment &#x3D; configuration.getEnvironment();\n        final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEn\n                tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level\n                        final Executor executor &#x3D; configuration.newExecutor(tx, execType);\n                        return new DefaultSqlSession(configuration, executor, autoCommit);\n    &#125; catch (Exception e) &#123;\n        closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close\n        throw ExceptionFactory.wrapException(&quot;Error opening session. Cause: &quot; +\n    &#125; finally &#123;\n        ErrorContext.instance().reset();\n    &#125;\n&#125;\nprivate SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) &#123;\n    try &#123;\n        boolean autoCommit;\n        try &#123;\n            autoCommit &#x3D; connection.getAutoCommit();\n        &#125; catch (SQLException e) &#123;\n            &#x2F;&#x2F; Failover to true, as most poor drivers\n            &#x2F;&#x2F; or databases won&#39;t support transactions\n            autoCommit &#x3D; true;\n        &#125;\n        final Environment environment &#x3D; configuration.getEnvironment();\n        final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEn\n                final Transaction tx &#x3D; transactionFactory.newTransaction(connection);\n        final Executor executor &#x3D; configuration.newExecutor(tx, execType);\n        return new DefaultSqlSession(configuration, executor, autoCommit);\n    &#125; catch (Exception e) &#123;\n        throw ExceptionFactory.wrapException(&quot;Error opening session. Cause: &quot; +\n    &#125; finally &#123;\n        ErrorContext.instance().reset();\n    &#125;\n&#125;\n&#x2F;&#x2F;...省略部分代码...\n\n从 SqlSessionFactory 和 DefaultSqlSessionFactory 的源码来看，它的设计非常类似刚刚讲到的 SqlSessionFactoryBuilder，通过重载多个 openSession() 函数，支持通过组合 autoCommit、Executor、Transaction 等不同参数，来创建 SqlSession 对象。标准的工厂模式通过 type 来创建继承同一个父类的不同子类对象，而这里只不过是通过传递进不同的参数，来创建同一个类的对象。所以，它更像建造者模式\n虽然设计思路基本一致，但一个叫 xxxBuilder（SqlSessionFactoryBuilder），一个叫 xxxFactory（SqlSessionFactory）。而且，叫 xxxBuilder 的也并非标准的建造者模式，叫 xxxFactory 的也并非标准的工厂模式。所以，个人觉得，MyBatis 对这部分代码的设计还是值得优化的\n实际上，这两个类的作用只不过是为了创建 SqlSession 对象，没有其他作用。所以，更建议参照 Spring 的设计思路，把 SqlSessionFactoryBuilder 和 SqlSessionFactory 的逻辑，放到一个叫“ApplicationContext”的类中。让这个类来全权负责读入配置文件，创建 Congfiguration，生成 SqlSession\n5.4.3 BaseExecutor：模板模式跟普通的继承有什么区别？如果去查阅 SqlSession 与 DefaultSqlSession 的源码，会发现，SqlSession 执行 SQL的业务逻辑，都是委托给了 Executor 来实现。Executor 相关的类主要是用来执行 SQL\n其中，Executor 本身是一个接口；BaseExecutor 是一个抽象类，实现了 Executor 接口；而 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类继承 BaseExecutor 抽象类\n那 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类跟 BaseExecutor 是简单的继承关系，还是模板模式关系呢？怎么来判断呢？看一下 BaseExecutor 的源码就清楚了\npublic abstract class BaseExecutor implements Executor &#123;\n    &#x2F;&#x2F;...省略其他无关代码...\n    @Override\n    public int update(MappedStatement ms, Object parameter) throws SQLException &#123;\n        ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;);\n        if (closed) &#123;\n            throw new ExecutorException(&quot;Executor was closed.&quot;);\n        &#125;\n        clearLocalCache();\n        return doUpdate(ms, parameter);\n    &#125;\n    public List&lt;BatchResult&gt; flushStatements(boolean isRollBack) throws SQLException) &#123;\n        if (closed) &#123;\n            throw new ExecutorException(&quot;Executor was closed.&quot;);\n        &#125;\n        return doFlushStatements(isRollBack);\n    &#125;\n\n    private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBouds rowBounds) &#123;\n        List&lt;E&gt; list;\n        localCache.putObject(key, EXECUTION_PLACEHOLDER);\n        try &#123;\n            list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n        &#125; finally &#123;\n            localCache.removeObject(key);\n        &#125;\n        localCache.putObject(key, list);\n        if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;\n            localOutputParameterCache.putObject(key, parameter);\n        &#125;\n        return list;\n    &#125;\n    @Override\n    public &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBouds rowBounds) &#123;\n        BoundSql boundSql &#x3D; ms.getBoundSql(parameter);\n        return doQueryCursor(ms, parameter, rowBounds, boundSql);\n    &#125;\n    protected abstract int doUpdate(MappedStatement ms, Object parameter);\n    protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback);\n    protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter);\n    protected abstract &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter);\n&#125;\n\n模板模式基于继承来实现代码复用。如果抽象类中包含模板方法，模板方法调用有待子类实现的抽象方法，那这一般就是模板模式的代码实现。而且，在命名上，模板方法与抽象方法一般是一一对应的，抽象方法在模板方法前面多一个“do”，比如，在 BaseExecutor 类中，其中一个模板方法叫 update()，那对应的抽象方法就叫 doUpdate()\n5.4.4 SqlNode：如何利用解释器模式来解析动态 SQL？持配置文件中编写动态 SQL，是 MyBatis 一个非常强大的功能。所谓动态 SQL，就是在 SQL 中可以包含在 trim、if、#{}等语法标签，在运行时根据条件来生成不同的 SQL，如下例：\n&lt;update id&#x3D;&quot;update&quot; parameterType&#x3D;&quot;com.xzg.cd.a89.User&quot; UPDATE&#x3D;&quot;&quot; user&#x3D;&quot;&quot;&gt;\n&lt;trim prefix&#x3D;&quot;SET&quot; prefixOverrides&#x3D;&quot;,&quot;&gt;\n  &lt;if test&#x3D;&quot;name !&#x3D; null and name !&#x3D; &#39;&#39;&quot;&gt;name &#x3D; #&#123;name&#125;&lt;&#x2F;if&gt;\n  &lt;if test&#x3D;&quot;age !&#x3D; null and age !&#x3D; &#39;&#39;&quot;&gt;, age &#x3D; #&#123;age&#125;&lt;&#x2F;if&gt;\n  &lt;if test&#x3D;&quot;birthday !&#x3D; null and birthday !&#x3D; &#39;&#39;&quot;&gt;, birthday &#x3D; #&#123;birthday&#125;&lt;&#x2F;if&gt;\n&lt;&#x2F;trim&gt;where id &#x3D; $&#123;id&#125;&lt;&#x2F;update&gt;\n\n显然，动态 SQL 的语法规则是 MyBatis 自定义的。如果想要根据语法规则，替换掉动态 SQL 中的动态元素，生成真正可以执行的 SQL 语句，MyBatis 还需要实现对应的解释器\n这一部分功能就可以看做是解释器模式的应用。解释器模式在解释语法规则的时候，一般会把规则分割成小的单元，特别是可以嵌套的小单元，针对每个小单元来解析，最终再把解析结果合并在一起。这里也不例外。MyBatis 把每个语法小单元叫 SqlNode。SqlNode 的定义如下所示：\npublic interface SqlNode &#123;\n    boolean apply(DynamicContext context);\n&#125;\n\n对于不同的语法小单元，MyBatis 定义不同的 SqlNode 实现类\n\n整个解释器的调用入口在 DynamicSqlSource.getBoundSql 方法中，它调用了 rootSqlNode.apply(context) 方法\n5.4.5 ErrorContext：如何实现一个线程唯一的单例模式？在单例模式那一部分讲到，单例模式是进程唯一的。同时还讲到单例模式的几种变形，比如线程唯一的单例、集群唯一的单例等。在 MyBatis 中，ErrorContext 这个类就是标准单例的变形：线程唯一的单例\n代码实现如下，它基于 Java 中的 ThreadLocal 来实现，实际上，这里的 ThreadLocal 就相当于那里的 ConcurrentHashMap\npublic class ErrorContext &#123;\n    private static final String LINE_SEPARATOR &#x3D; System.getProperty(&quot;line.separate&quot;);\n    private static final ThreadLocal&lt;ErrorContext&gt; LOCAL &#x3D; new ThreadLocal &lt; ErrorContext&gt; ();\n    private ErrorContext stored;\n    private String resource;\n    private String activity;\n    private String object;\n    private String message;\n    private String sql;\n    private Throwable cause;\n    private ErrorContext() &#123;\n    &#125;\n    public static ErrorContext instance() &#123;\n        ErrorContext context &#x3D; LOCAL.get();\n        if (context &#x3D;&#x3D; null) &#123;\n            context &#x3D; new ErrorContext();\n            LOCAL.set(context);\n        &#125;\n        return context;\n    &#125;\n&#125;\n\n5.4.6 Cache：为什么要用装饰器模式而不设计成继承子类？MyBatis 是一个 ORM 框架。实际上，它不只是简单地完成了对象和数据库数据之间的互相转化，还提供了很多其他功能，比如缓存、事务等。接下来，再讲讲它的缓存实现\n在 MyBatis 中，缓存功能由接口 Cache 定义。PerpetualCache 类是最基础的缓存类，是一个大小无限的缓存。除此之外，MyBatis 还设计了 9 个包裹 PerpetualCache 类的装饰器类，用来实现功能增强。它们分别是：FifoCache、LoggingCache、LruCache、ScheduledCache、SerializedCache、SoftCache、SynchronizedCache、WeakCache、TransactionalCache\npublic interface Cache &#123;\n    String getId();\n    void putObject(Object key, Object value);\n    Object getObject(Object key);\n    Object removeObject(Object key);\n    void clear();\n    int getSize();\n    ReadWriteLock getReadWriteLock();\n&#125;\npublic class PerpetualCache implements Cache &#123;\n    private final String id;\n    private Map&lt;Object, Object&gt; cache &#x3D; new HashMap&lt;Object, Object&gt;();\n    public PerpetualCache(String id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    @Override\n    public String getId() &#123;\n        return id;\n    &#125;\n    @Override\n    public int getSize() &#123;\n        return cache.size();\n    &#125;\n    @Override\n    public void putObject(Object key, Object value) &#123;\n        cache.put(key, value);\n    &#125;\n    @Override\n    public Object getObject(Object key) &#123;\n        return cache.get(key);\n    &#125;\n    @Override\n    public Object removeObject(Object key) &#123;\n        return cache.remove(key);\n    &#125;\n    @Override\n    public void clear() &#123;\n        cache.clear();\n    &#125;\n    @Override\n    public ReadWriteLock getReadWriteLock() &#123;\n        return null;\n    &#125;\n    &#x2F;&#x2F;省略部分代码...\n&#125;\n\n这 9 个装饰器类的代码结构都类似，这里只将其中的 LruCache 的源码贴到这里。从代码中可以看出，它是标准的装饰器模式的代码实现\npublic class LruCache implements Cache &#123;\n    private final Cache delegate;\n    private Map&lt;Object, Object&gt; keyMap;\n    private Object eldestKey;\n    public LruCache(Cache delegate) &#123;\n        this.delegate &#x3D; delegate;\n        setSize(1024);\n    &#125;\n    @Override\n    public String getId() &#123;\n        return delegate.getId();\n    &#125;\n    @Override\n    public int getSize() &#123;\n        return delegate.getSize();\n    &#125;\n    public void setSize(final int size) &#123;\n        keyMap &#x3D; new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123;\n            private static final long serialVersionUID &#x3D; 4267176411845948333L;\n            @Override\n            protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123;\n                boolean tooBig &#x3D; size() &gt; size;\n                if (tooBig) &#123;\n                    eldestKey &#x3D; eldest.getKey();\n                &#125;\n                return tooBig;\n            &#125;\n        &#125;;\n    &#125;\n    @Override\n    public void putObject(Object key, Object value) &#123;\n        delegate.putObject(key, value);\n        cycleKeyList(key);\n    &#125;\n    @Override\n    public Object getObject(Object key) &#123;\n        keyMap.get(key); &#x2F;&#x2F;touch\n        return delegate.getObject(key);\n    &#125;\n    @Override\n    public Object removeObject(Object key) &#123;\n        return delegate.removeObject(key);\n    &#125;\n    @Override\n    public void clear() &#123;\n        delegate.clear();\n        keyMap.clear();\n    &#125;\n    @Override\n    public ReadWriteLock getReadWriteLock() &#123;\n        return null;\n    &#125;\n    private void cycleKeyList(Object key) &#123;\n        keyMap.put(key, key);\n        if (eldestKey !&#x3D; null) &#123;\n            delegate.removeObject(eldestKey);\n            eldestKey &#x3D; null;\n        &#125;\n    &#125;\n&#125;\n\n之所以 MyBatis 采用装饰器模式来实现缓存功能，是因为装饰器模式采用了组合，而非继承，更加灵活，能够有效地避免继承关系的组合爆炸\n5.4.7 PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？迭代器模式常用来替代 for 循环遍历集合元素。Mybatis 的 PropertyTokenizer 类实现了 Java Iterator 接口，是一个迭代器，用来对配置属性进行解析。具体的代码如下所示：\n&#x2F;&#x2F; person[0].birthdate.year 会被分解为3个PropertyTokenizer对象。其中，第一个Property\npublic class PropertyTokenizer implements Iterator&lt;PropertyTokenizer&gt; &#123;\n    private String name; &#x2F;&#x2F; person\n    private final String indexedName; &#x2F;&#x2F; person[0]\n    private String index; &#x2F;&#x2F; 0\n    private final String children; &#x2F;&#x2F; birthdate.year\n    public PropertyTokenizer(String fullname) &#123;\n        int delim &#x3D; fullname.indexOf(&#39;.&#39;);\n        if (delim &gt; -1) &#123;\n            name &#x3D; fullname.substring(0, delim);\n            children &#x3D; fullname.substring(delim + 1);\n        &#125; else &#123;\n            name &#x3D; fullname;\n            children &#x3D; null;\n        &#125;\n        indexedName &#x3D; name;\n        delim &#x3D; name.indexOf(&#39;[&#39;);\n        if (delim &gt; -1) &#123;\n            index &#x3D; name.substring(delim + 1, name.length() - 1);\n            name &#x3D; name.substring(0, delim);\n        &#125;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public String getIndex() &#123;\n        return index;\n    &#125;\n    public String getIndexedName() &#123;\n        return indexedName;\n    &#125;\n    public String getChildren() &#123;\n        return children;\n    &#125;\n    @Override\n    public boolean hasNext() &#123;\n        return children !&#x3D; null;\n    &#125;\n    @Override\n    public PropertyTokenizer next() &#123;\n        return new PropertyTokenizer(children);\n    &#125;\n    @Override\n    public void remove() &#123;\n        throw new UnsupportedOperationException(&quot;Remove is not supported, as it has&quot;);\n    &#125;\n&#125;\n\n实际上，PropertyTokenizer 类也并非标准的迭代器类。它将配置的解析、解析之后的元素、迭代器，这三部分本该放到三个类中的代码，都耦合在一个类中，所以看起来稍微有点难懂。不过，这样做的好处是能够做到惰性解析。不需要事先将整个配置，解析成多个 PropertyTokenizer 对象。只有当在调用 next() 函数的时候，才会解析其中部分配置\n5.4.8 Log：如何使用适配器模式来适配不同的日志框架？在讲适配器模式的时候讲过，Slf4j 框架为了统一各个不同的日志框架（Log4j、JCL、Logback 等），提供了一套统一的日志接口。不过，MyBatis 并没有直接使用 Slf4j 提供的统一日志规范，而是自己又重复造轮子，定义了一套自己的日志访问接口\npublic interface Log &#123;\n    boolean isDebugEnabled();\n    boolean isTraceEnabled();\n    void error(String s, Throwable e);\n    void error(String s);\n    void debug(String s);\n    void trace(String s);\n    void warn(String s);\n&#125;\n\n针对 Log 接口，MyBatis 还提供了各种不同的实现类，分别使用不同的日志框架来实现 Log 接口\n\n这几个实现类的代码结构基本上一致。其中的 Log4jImpl 的源码如下。在适配器模式中，传递给适配器构造函数的是被适配的类对象，而这里是 clazz（相当于日志名称 name），所以，从代码实现上来讲，它并非标准的适配器模式。但是，从应用场景上来看，这里确实又起到了适配的作用，是典型的适配器模式的应用场景\nimport org.apache.ibatis.logging.Log;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\npublic class Log4jImpl implements Log &#123;\n    private static final String FQCN &#x3D; Log4jImpl.class.getName();\n    private final Logger log;\n    public Log4jImpl(String clazz) &#123;\n        log &#x3D; Logger.getLogger(clazz);\n    &#125;\n    @Override\n    public boolean isDebugEnabled() &#123;\n        return log.isDebugEnabled();\n    &#125;\n    @Override\n    public boolean isTraceEnabled() &#123;\n        return log.isTraceEnabled();\n    &#125;\n    @Override\n    public void error(String s, Throwable e) &#123;\n        log.log(FQCN, Level.ERROR, s, e);\n    &#125;\n    @Override\n    public void error(String s) &#123;\n        log.log(FQCN, Level.ERROR, s, null);\n    &#125;\n    @Override\n    public void debug(String s) &#123;\n        log.log(FQCN, Level.DEBUG, s, null);\n    &#125;\n    @Override\n    public void trace(String s) &#123;\n        log.log(FQCN, Level.TRACE, s, null);\n    &#125;\n    @Override\n    public void warn(String s) &#123;\n        log.log(FQCN, Level.WARN, s, null);\n    &#125;\n&#125;\n","slug":"BlogRepository/设计模式/设计模式之美总结（开源实战篇）","date":"2023-01-10T09:13:05.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"2236ff817b0fd532c388d0cf8bb4c954","title":"23 种设计模式总结","content":"设计模式相关的详细知识见如下三篇：\n\n设计模式之美总结（创建型篇）_凡 223 的博客\n设计模式之美总结（结构型篇）_凡 223 的博客\n设计模式之美总结（行为型篇）_凡 223 的博客\n\n这里主要是对上面三篇内容的总结，用于清晰 23 种设计模式的原理概念和应用场景，以及它们之间的异同点，区分 23 种设计模式，对其有一个整体的认知，具体详细实现见上面三篇文章。建议先看完上面三篇文章或者对设计模式有一定了解再来阅读本章内容，对知识做一个归纳汇总，或者也可在本章任一一节末尾点击链接直达对应的详细知识部分\n1. 创建型创建型设计模式主要解决“对象的创建”问题\n1.1 单例模式（Singleton Design Pattern）1.1.1 概述与实现一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式\n应用场景：\n\n解决资源访问冲突\n表示全局唯一类\n\n实现方式：\n1、饿汉式：不支持延迟加载\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n2、懒汉式：支持延迟加载，但可以看到给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低，有性能问题，不支持高并发\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static synchronized IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new IdGenerator();\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n3、双重检测：既支持延迟加载、又支持高并发\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new IdGenerator();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n4、静态内部类：比双重检测更加简单的实现方法\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private IdGenerator() &#123;&#125;\n    private static class SingletonHolder&#123;\n        private static final IdGenerator instance &#x3D; new IdGenerator();\n    &#125;\n    public static IdGenerator getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n5、枚举：利用 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private IdGenerator() &#123;&#125;\n    private static class SingletonHolder&#123;\n        private static final IdGenerator instance &#x3D; new IdGenerator();\n    &#125;\n    public static IdGenerator getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n1.1.2 多例单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象\npublic class BackendServer &#123;\n\tprivate long serverNo;\n\tprivate String serverAddress;\n\tprivate static final int SERVER_COUNT &#x3D; 3;\n\tprivate static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\n\n\tstatic &#123;\n\t\tserverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n\t\tserverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n\t\tserverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n\t&#125;\n\tprivate BackendServer(long serverNo, String serverAddress) &#123;\n\t\tthis.serverNo &#x3D; serverNo;\n\t\tthis.serverAddress &#x3D; serverAddress;\n\t&#125;\n\tpublic BackendServer getInstance(long serverNo) &#123;\n\t\treturn serverInstances.get(serverNo);\n\t&#125;\n\tpublic BackendServer getRandomInstance() &#123;\n\t\tRandom r &#x3D; new Random();\n\t\tint no &#x3D; r.nextInt(SERVER_COUNT)+1;\n\t\treturn serverInstances.get(no);\n\t&#125;\n&#125;\n\n对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？\n如下例，在代码中，loggerName 就是上面说的“类型”，同一个 loggerName 获取到的对象实例是相同的，不同的 loggerName 获取到的对象实例是不同的\npublic class Logger &#123;\n\tprivate static final ConcurrentHashMap&lt;String, Logger&gt; instances\n\t    &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate Logger() &#123;&#125;\n\tpublic static Logger getInstance(String loggerName) &#123;\n\t\tinstances.putIfAbsent(loggerName, new Logger());\n\t\treturn instances.get(loggerName);\n\t&#125;\n\tpublic void log() &#123;\n            &#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);\n\n这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处在于：\n\n多例模式创建的对象都是同一个类的对象\n而工厂模式创建的是不同子类的对象\n\n实际上，它还有点类似享元模式。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象\n详细可见：**设计模式之美总结（创建型篇）_凡 223 的博客** 单例模式部分\n1.2 工厂模式（Factory Design Pattern）一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见\n1.2.1 简单工厂（Simple Factory）如下，根据不同的后缀名，创建不同的解析器类。这里每次调用 createParser() 方法的时候，都要创建一个新的 parser，把这一种实现方法叫作简单工厂模式的第一种实现方法\npublic class RuleConfigParserFactory &#123;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125;\n\t\treturn parser;\n\t&#125;\n&#125;\n\n如果 parser 可以复用，为了节省内存和对象创建的时间，可以将 parser 事先创建好缓存起来，如下。这种实现方法叫作简单工厂模式的第二种实现方法\npublic class RuleConfigParserFactory &#123;\n\tprivate static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n\t\tcachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n\t\tcachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n\t\tcachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n\t&#125;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tif (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;\n                        &#x2F;&#x2F; 或抛出 IllegalArgumentException\n\t\t\treturn null;\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());\n\t\treturn parser;\n\t&#125;\n&#125;\n\n1.2.2 工厂方法（Factory Method）在简单工厂模式的第一种实现方法中，有一组 if 分支逻辑，实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的\n也可以应用多态或设计模式来替代 if 分支判断逻辑，但也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。这里按照多态的实现思路，对上面的代码进行重构\npublic interface IRuleConfigParserFactory &#123;\n\tIRuleConfigParser createParser();\n&#125;\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n&#125;\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n&#125;\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new YamlRuleConfigParser();\n\t&#125;\n&#125;\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new PropertiesRuleConfigParser();\n\t&#125;\n&#125;\n\n这就是工厂方法模式的典型代码实现。这样当新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则\n但这些工厂类的使用上存在挺大的问题，如下：\npublic class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; null;\n\n\t\tif (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new JsonRuleConfigParserFactory();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new XmlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new YamlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new PropertiesRuleConfigParserFactory();\n\t\t&#125; else &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file fo support&quot;)rmat is not\n\n从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟简单工厂模式的第一种实现方法非常相似。怎么来解决这个问题呢？可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象\npublic class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n\t\tif (parserFactory &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file format is not support&quot;);\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; parserFactory.createParser();\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F; 从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F; ...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 因为工厂类只包含方法，不包含成员变量，完全可以复用，不需要每次都创建新的工厂类对象，\n&#x2F;&#x2F; 所以，简单工厂模式的第二种实现思路更加合适\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n\tprivate static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory())\n\t&#125;\n\tpublic static IRuleConfigParserFactory getParserFactory(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\tIRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n\t\treturn parserFactory;\n\t&#125;\n&#125;\n\n1.2.3 工厂方法模式 VS 简单工厂模式当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂\n除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果还想避免烦人的 if-else 分支逻辑，这个时候，就推荐使用工厂方法模式\n1.2.4 抽象工厂（Abstract Factory）在上面简单工厂和工厂方法中，类只有一种分类方式。但是，如果类有两种分类方式，比如上面的解析器例子，假如既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类\n针对规则配置的解析器: 基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n针对系统配置的解析器: 基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n\n如果还是继续用工厂方法来实现的话，要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。过多的类也会让系统难维护。这个问题该怎么解决呢？\n抽象工厂就是针对这种非常特殊的场景而诞生的。可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数\npublic interface IConfigParserFactory &#123;\n\tIRuleConfigParser createRuleParser();\n\tISystemConfigParser createSystemParser();\n        &#x2F;&#x2F; 此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new JsonSystemConfigParser();\n\t&#125;\n&#125;\npublic class XmlConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new XmlSystemConfigParser();\n\t&#125;\n&#125;\n&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n\n详细可见：**设计模式之美总结（创建型篇）_凡 223 的博客** 工厂模式部分\n1.3 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。但什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？\n先来看什么是对象的无效状态，如下，定义了一个长方形类，采用先创建后 set 的方式，那就会导致在第一个 set 之前，对象处于无效状态\nRectangle r &#x3D; new Rectange(); &#x2F;&#x2F; r is invalid\nr.setWidth(2); &#x2F;&#x2F; r is invalid\nr.setHeight(3); &#x2F;&#x2F; r is valid\n\n为了避免这种无效状态的存在，就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，代码在可读性和易用性上都会变差。在使用构造函数的时候，就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug，这时就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态\npublic class ResourcePoolConfig &#123;\n\tprivate String name;\n\tprivate int maxTotal;\n\tprivate int maxIdle;\n\tprivate int minIdle;\n\tprivate ResourcePoolConfig(Builder builder) &#123;\n\t\tthis.name &#x3D; builder.name;\n\t\tthis.maxTotal &#x3D; builder.maxTotal;\n\t\tthis.maxIdle &#x3D; builder.maxIdle;\n\t\tthis.minIdle &#x3D; builder.minIdle;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n\t&#x2F;&#x2F; 将Builder类设计成了ResourcePoolConfig的内部类。\n\t&#x2F;&#x2F; 也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n\tpublic static class Builder &#123;\n\t\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\t\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\t\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\t\tprivate String name;\n\t\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\t\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\t\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\t\tpublic ResourcePoolConfig build() &#123;\n\t\t\t&#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (maxIdle &gt; maxTotal) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\treturn new ResourcePoolConfig(this);\n\t\t&#125;\n\t\tpublic Builder setName(String name) &#123;\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.name &#x3D; name;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxTotal(int maxTotal) &#123;\n\t\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxTotal &#x3D; maxTotal;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxIdle(int maxIdle) &#123;\n\t\t\tif (maxIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxIdle &#x3D; maxIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMinIdle(int minIdle) &#123;\n\t\t\tif (minIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.minIdle &#x3D; minIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()\n\t.setName(&quot;dbconnectionpool&quot;)\n\t.setMaxTotal(16)\n\t.setMaxIdle(10)\n\t.setMinIdle(12)\n\t.build();\n\n详细可见：**设计模式之美总结（创建型篇）_凡 223 的博客** 建造者模式部分，这里只简要描述\n1.3.1 与工厂模式有何区别？工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象\n比如，顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨\n1.4 原型模式（Prototype Design Pattern）如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式\n概念应该不难理解，通过概念应该就大致知道该设计模式的原理和用法，详细可见：**设计模式之美总结（创建型篇）_凡 223 的博客** 原型模式部分\n2. 结构型结构型设计模式主要解决“类或对象的组合或组装”问题\n2.1 代理模式（Proxy Design Pattern）在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。如下例，在 UserController 中实现了接口 IUserController 的 login() 方法，用来处理登录逻辑\npublic interface IUserController &#123;\n\tUserVo login(String telephone, String password);\n&#125;\n\npublic class UserController implements IUserController &#123;\n\t&#x2F;&#x2F;...省略其他属性和方法...\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F; ... 省略login逻辑...\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n&#125;\n\n假设要在不改变该方法的情况下，扩展附加功能，比如收集接口请求的原始数据，比如访问时间、处理时长等，这时代理模式就派上用场了\n如下，代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码\npublic class UserControllerProxy implements IUserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tprivate UserController userController;\n\n\tpublic UserControllerProxy(UserController userController) &#123;\n\t\tthis.userController &#x3D; userController;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\t@Override\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; 委托\n\t\tUserVo userVo &#x3D; userController.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n&#x2F;&#x2F; 将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController &#x3D; new UserControllerProxy(new UserController())\n\n假如原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。对于这种外部类的扩展，一般都是采用继承的方式。让代理类继承原始类，然后扩展附加功能，如下：\npublic class UserControllerProxy extends UserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tpublic UserControllerProxy() &#123;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; super.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n&#x2F;&#x2F; UserControllerProxy使用举例\nUserController userController &#x3D; new UserControllerProxy();\n\n应用场景：\n\n业务系统的非功能性需求开发\n在 RPC 中应用\n在缓存中应用\n\n详细可见：**设计模式之美总结（结构型篇）_凡 223 的博客** 代理模式部分\n2.2 桥接&#x2F;桥梁模式（Bridge Design Pattern）在 GoF 的《设计模式》一书中，桥接模式是这么定义的：\n\n\n\n\n\n\n\n\n\nDecouple an abstraction from its implementation so that the two can vary independently.将抽象和实现解耦，让它们可以独立变化\n弄懂定义中“抽象”、“实现”和“解耦”三个概念，就是理解桥接模式的关键\n\n抽象，可以理解为存在于多个实体中的共同的概念性联系，就是忽略一些信息，从而把不同的实体当做同样的实体对待\n实现，即抽象给出的具体实现，可能有多种不同的实现方式\n解耦，所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称解耦。在这里，解耦是指将抽象和实现之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联，即抽象和实现之间使用组合&#x2F;聚合关系而不是继承关系\n\n建议对照示例来进行理解，具体可见：**设计模式之美总结（结构型篇）_凡 223 的博客** 桥接模式部分\n2.3 装饰器模式（Decorator Design Pattern）装饰器模式和代理模式比较相似，不过在代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能\n&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class AProxy impements IA &#123;\n\tprivate IA a;\n\tpublic AProxy(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t\ta.f();\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ADecorator impements IA &#123;\n\tprivate IA a;\n\tpublic ADecorator(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 功能增强代码\n\t\ta.f();\n\t\t&#x2F;&#x2F; 功能增强代码\n\t&#125;\n&#125;\n\n还可以进行多重装饰：\nclass Father &#123;\n    public void run() &#123;\n        System.out.println(&quot;Father run&quot;);\n    &#125;\n&#125;\n\nclass Son extends Father&#123;\n    public void run() &#123;\n        System.out.println(&quot;Son run&quot;);\n    &#125;\n&#125;\n\nclass ChildDecorator extends Father &#123;\n    protected Father father;\n\n    public ChildDecorator(Father father) &#123;\n        this.father &#x3D; father;\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;ChildDecorator run&quot;);\n    &#125;\n&#125;\n\nclass Child1 extends ChildDecorator&#123;\n\n    public Child1(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child1 run&quot;);\n    &#125;\n&#125;\n\nclass Child2 extends ChildDecorator &#123;\n\n    public Child2(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child2 run&quot;);\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n        Father son &#x3D; new Son();\n        Father child1 &#x3D; new Child1(son);\n        Child2 child2 &#x3D; new Child2(child1);\n        child2.run();\n&#125;\n\n\n详细可见：**设计模式之美总结（结构型篇）_凡 223 的博客** 装饰器模式部分\n2.4 适配器模式（Adapter Design Pattern）顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作\n适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现\n1、类适配器\n&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor extends Adaptee implements ITarget &#123;\n\tpublic void f1() &#123;\n\t\tsuper.fa();\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\t&#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;\n\n2、对象适配器\n&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor implements ITarget &#123;\n\tprivate Adaptee adaptee;\n\tpublic Adaptor(Adaptee adaptee) &#123;\n\t\tthis.adaptee &#x3D; adaptee;\n\t&#125;\n\tpublic void f1() &#123;\n\t\tadaptee.fa(); &#x2F;&#x2F;委托给Adaptee\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\tpublic void fc() &#123;\n\t\tadaptee.fc();\n\t&#125;\n&#125;\n\n针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度\n如果 Adaptee 接口并不多，那两种实现方式都可以。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那推荐使用对象适配器，因为组合结构相对于继承更加灵活\n应用场景：\n\n封装有缺陷的接口设计\n统一多个类的接口设计\n替换依赖的外部系统\n兼容老版本接口\n适配不同格式的数据\n\n详细可见：**设计模式之美总结（结构型篇）_凡 223 的博客** 适配器模式部分\n2.5 代理、桥接、装饰器、适配器 4 种设计模式的区别代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类\n尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别\n\n代理模式： 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同\n桥接模式： 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变\n装饰器模式： 装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用\n适配器模式： 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口\n\n2.6 门面&#x2F;外观模式（Facade Design Pattern）在 GoF 的《设计模式》一书中，门面模式是这样定义的：\n\n\n\n\n\n\n\n\n\nProvide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用\n概念很简单，假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用\n应用场景：\n\n解决易用性问题：门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口\n解决性能问题，通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度\n解决分布式事务问题\n\n详细可见：**设计模式之美总结（结构型篇）_凡 223 的博客** 门面模式部分\n2.7 组合模式（Composite Design Pattern）组合模式跟面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，可以简单理解为一组对象集合\n在 GoF 的《设计模式》一书中，组合模式是这样定义的：\n\n\n\n\n\n\n\n\n\nCompose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者）可以统一单个对象和组合对象的处理逻辑\n比如公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构，这个时候就可以使用组合模式来设计和实现\n再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”\n详细可见：**设计模式之美总结（结构型篇）_凡 223 的博客** 组合模式部分\n2.8 享元模式（Flyweight Design Pattern）所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象\n具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元\n定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码\n概念其实很简单，就是将重复对象或相似对象的重复部分进行复用\n详细可见：**设计模式之美总结（结构型篇）_凡 223 的博客** 享元模式部分\n2.8.1 享元模式 vs 单例、缓存、对象池1、享元模式跟单例的区别\n在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例\n但区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数\n2、享元模式跟缓存的区别\n在享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。平时所讲的缓存，主要是为了提高访问效率，而非复用\n3、享元模式跟对象池的区别\n对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？\n很多人可能对连接池、线程池比较熟悉，对对象池比较陌生，这里简单解释一下对象池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉\n虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念\n池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间\n3. 行为型行为型设计模式主要解决的就是“类或对象之间的交互”问题\n3.1 观察者&#x2F;发布订阅模式（Observer Design Pattern&#x2F;Publish-Subscribe Design Pattern）在 GoF 的《设计模式》一书中，它的定义是这样的：\n\n\n\n\n\n\n\n\n\nDefine a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知\n一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式\n实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，这里来看最经典的一种实现方式，这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：\npublic interface Subject &#123;\n\tvoid registerObserver(Observer observer);\n\tvoid removeObserver(Observer observer);\n\tvoid notifyObservers(Message message);\n&#125;\npublic interface Observer &#123;\n\tvoid update(Message message);\n&#125;\npublic class ConcreteSubject implements Subject &#123;\n\tprivate List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n\t@Override\n\tpublic void registerObserver(Observer observer) &#123;\n\t\tobservers.add(observer);\n\t&#125;\n\t@Override\n\tpublic void removeObserver(Observer observer) &#123;\n\t\tobservers.remove(observer);\n\t&#125;\n\t@Override\n\tpublic void notifyObservers(Message message) &#123;\n\t\tfor (Observer observer : observers) &#123;\n\t\t\tobserver.update(message);\n\t\t&#125;\n\t&#125;\n&#125;\npublic class ConcreteObserverOne implements Observer &#123;\n\t@Override\n\tpublic void update(Message message) &#123;\n\t\t&#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n\t\tSystem.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n\t&#125;\n&#125;\npublic class ConcreteObserverTwo implements Observer &#123;\n\t@Override\n\tpublic void update(Message message) &#123;\n\t\t&#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n\t\tSystem.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n\t&#125;\n&#125;\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tConcreteSubject subject &#x3D; new ConcreteSubject();\n\t\tsubject.registerObserver(new ConcreteObserverOne());\n\t\tsubject.registerObserver(new ConcreteObserverTwo());\n\t\tsubject.notifyObservers(new Message());\n\t&#125;\n&#125;\n\n上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。不过，万变不离其宗，设计思路都是差不多的\n观察者模式的核心概念其实就在它的定义中。详细可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 观察者模式部分\n3.2 模板模式（Template Method Design Pattern）在 GoF 的《设计模式》一书中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nDefine the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤\n这里的“算法”，可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。代码示例如下：\npublic abstract class AbstractClass &#123;\n\tpublic final void templateMethod() &#123;\n\t\t&#x2F;&#x2F;...\n\t\tmethod1();\n\t\t&#x2F;&#x2F;...\n\t\tmethod2();\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tprotected abstract void method1();\n\tprotected abstract void method2();\n&#125;\npublic class ConcreteClass1 extends AbstractClass &#123;\n\t@Override\n\tprotected void method1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tprotected void method2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ConcreteClass2 extends AbstractClass &#123;\n\t@Override\n\tprotected void method1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tprotected void method2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\nAbstractClass demo &#x3D; ConcreteClass1();\ndemo.templateMethod();\n\n\n作用一：复用模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码\n作用二：扩展这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能\n\n假如用过 Java Servlet，继承 HttpServlet 类然后重写 doGet() 和 doPost() 就是典型的模板模式，这里是框架的扩展作用。它将 Servlet 的执行流程进行了封装，然后将可变的 doGet() 和 doPost() 部分留给继承的子类来具体实现\npublic class HelloServlet extends HttpServlet &#123;\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tthis.doPost(req, resp);\n\t&#125;\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tresp.getWriter().write(&quot;Hello World.&quot;);\n\t&#125;\n&#125;\n\n3.2.1 模板模式 VS 回调从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式\n从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系\n前面也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点：\n\n像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力\n回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类\n如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，只需要往用到的模板方法中注入回调对象即可\n\n回调等详细知识，可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 模板模式部分\n3.3 策略模式（Strategy Design Pattern）在 GoF 的《设计模式》一书中，它是这样定义的：\n\n\n\n\n\n\n\n\n\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）\n工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分\n3.3.1 策略的定义策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：\npublic interface Strategy &#123;\n\tvoid algorithmInterface();\n&#125;\npublic class ConcreteStrategyA implements Strategy &#123;\n\t@Override\n\tpublic void algorithmInterface() &#123;\n\t\t&#x2F;&#x2F;具体的算法...\n\t&#125;\n&#125;\npublic class ConcreteStrategyB implements Strategy &#123;\n\t@Override\n\tpublic void algorithmInterface() &#123;\n\t\t&#x2F;&#x2F;具体的算法...\n\t&#125;\n&#125;\n\n一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。针对这种情况，可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回\n相反，如果策略类是有状态的，根据业务场景的需要，希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那就需要按照如下方式来实现策略工厂类\npublic class StrategyFactory &#123;\n\tpublic static Strategy getStrategy(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;type should not be empty.&quot;);\n\t\t&#125;\n\t\tif (type.equals(&quot;A&quot;)) &#123;\n\t\t\treturn new ConcreteStrategyA();\n\t\t&#125; else if (type.equals(&quot;B&quot;)) &#123;\n\t\t\treturn new ConcreteStrategyB();\n\t\t&#125;\n\t\treturn null;\n\t&#125;\n&#125;\n\n3.3.2 策略的创建因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，需要对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。示例代码如下所示：\npublic class StrategyFactory &#123;\n\tprivate static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tstrategies.put(&quot;A&quot;, new ConcreteStrategyA());\n\t\tstrategies.put(&quot;B&quot;, new ConcreteStrategyB());\n\t&#125;\n\tpublic static Strategy getStrategy(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;type should not be empty.&quot;);\n\t\t&#125;\n\t\treturn strategies.get(type);\n\t&#125;\n&#125;\n\n3.3.3 策略的使用策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。这里的“运行时动态”指的是，事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略\n&#x2F;&#x2F; 策略接口：EvictionStrategy\n&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory\npublic class UserCache &#123;\n\tprivate Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();\n\tprivate EvictionStrategy eviction;\n\tpublic UserCache(EvictionStrategy eviction) &#123;\n\t\tthis.eviction &#x3D; eviction;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tEvictionStrategy evictionStrategy &#x3D; null;\n\t\tProperties props &#x3D; new Properties();\n\t\tprops.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));\n\t\tString type &#x3D; props.getProperty(&quot;eviction_type&quot;);\n\t\tevictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);\n\t\tUserCache userCache &#x3D; new UserCache(evictionStrategy);\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tEvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();\n\t\tUserCache userCache &#x3D; new UserCache(evictionStrategy);\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\n从上面的代码中，也可以看出，“非运行时动态确定”，也就是第二个 Application 中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”\n详细可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 策略模式部分\n3.4 职责链模式（Chain Of Responsibility Design Pattern在 GoF 的《设计模式》中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nAvoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止\n在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式\n职责链模式有多种实现方式，这里介绍两种比较常用的\n1、链表\npublic abstract class Handler &#123;\n\tprotected Handler successor &#x3D; null;\n\tpublic void setSuccessor(Handler successor) &#123;\n\t\tthis.successor &#x3D; successor;\n\t&#125;\n\tpublic final void handle() &#123;\n\t\tboolean handled &#x3D; doHandle();\n\t\tif (successor !&#x3D; null &amp;&amp; !handled) &#123;\n\t\t\tsuccessor.handle();\n\t\t&#125;\n\t&#125;\n\tprotected abstract boolean doHandle();\n&#125;\npublic class HandlerA extends Handler &#123;\n\t@Override\n\tprotected boolean doHandle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerB extends Handler &#123;\n\t@Override\n\tprotected boolean doHandle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\n\npublic class HandlerChain &#123;\n\tprivate Handler head &#x3D; null;\n\tprivate Handler tail &#x3D; null;\n\tpublic void addHandler(Handler handler) &#123;\n\t\thandler.setSuccessor(null);\n\t\tif (head &#x3D;&#x3D; null) &#123;\n\t\t\thead &#x3D; handler;\n\t\t\ttail &#x3D; handler;\n\t\t\treturn;\n\t\t&#125;\n\t\ttail.setSuccessor(handler);\n\t\ttail &#x3D; handler;\n\t&#125;\n\tpublic void handle() &#123;\n\t\tif (head !&#x3D; null) &#123;\n\t\t\thead.handle();\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tHandlerChain chain &#x3D; new HandlerChain();\n\t\tchain.addHandler(new HandlerA());\n\t\tchain.addHandler(new HandlerB());\n\t\tchain.handle();\n\t&#125;\n&#125;\n\n2、HandlerChain 类用数组而非链表来保存所有的处理器，并且需要在 HandlerChain 的 handle() 函数中，依次调用每个处理器的 handle() 函数\npublic interface IHandler &#123;\n\tboolean handle();\n&#125;\npublic class HandlerA implements IHandler &#123;\n\t@Override\n\tpublic boolean handle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerB implements IHandler &#123;\n\t@Override\n\tpublic boolean handle() &#123;\n\t\tboolean handled &#x3D; false;\n                &#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerChain &#123;\n\tprivate List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();\n\tpublic void addHandler(IHandler handler) &#123;\n\t\tthis.handlers.add(handler);\n\t&#125;\n\tpublic void handle() &#123;\n\t\tfor (IHandler handler : handlers) &#123;\n\t\t\tboolean handled &#x3D; handler.handle();\n\t\t\tif (handled) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tHandlerChain chain &#x3D; new HandlerChain();\n\t\tchain.addHandler(new HandlerA());\n\t\tchain.addHandler(new HandlerB());\n\t\tchain.handle();\n\t&#125;\n&#125;\n\n在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可\n其实可以对照拦截器和过滤器链来理解，详细可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 责任链模式部分\n3.5 状态模式（State Design Pattern）在实际的软件开发中，状态模式并不是很常用，但是在能够用到的场景里，它可以发挥很大的作用。从这一点上来看，它有点像之前讲到的组合模式。状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法\n有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作\n比如“超级马里奥”，在游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分\n实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）\n概念不难理解，具体可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 状态模式部分\n3.6 迭代器&#x2F;游标模式（Iterator Design Pattern&#x2F;Cursor Design Pattern）迭代器模式用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一\n迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。简单的类图如下：\n\n概念也很简单，可以对照 Java 的 Iterator 迭代器来理解，其他编程语言也大部分都提供了遍历容器的迭代器类，在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器\n详细可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 迭代器模式部分\n3.7 访问者模式（Visitor Design Pattern）在 GoF 的《设计模式》一书中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nAllows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.允许一个或者多个操作应用到一组对象上，解耦操作和对象本身\n访问者模式这里不太好理解，建议直接去看详细的说明：**设计模式之美总结（行为型篇）_凡 223 的博客** 访问者模式部分\n这里涉及到一个双分派的问题，Double Dispatch。既然有 Double Dispatch，对应的就有 Single Dispatch\n\n所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定\n所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定\n\n支持双分派的语言是不需要访问者模式的，访问者模式主要是为了解决 Single Dispatch 下多态的时候，重载方法参数存在的多态问题\n3.8 备忘录&#x2F;快照（Snapshot）模式（Memento Design Pattern）在 GoF 的《设计模式》一书中，备忘录模式是这么定义的：\n\n\n\n\n\n\n\n\n\nCaptures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态\n这个模式的定义主要表达了两部分内容，一部分是，存储副本以便后期恢复，另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复\n概念理解起来也很简单，可以对照平时所说的备份进行理解。这两者的应用场景很类似，都应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计\n详细可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 备忘录模式部分\n3.9 命令模式（Command Design Pattern）在 GoF 的《设计模式》一书中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nThe command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能\n落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。C 语言支持函数指针，可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法作为参数传递给其他函数，也没法赋值给变量。借助命令模式，可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似前面提到的回调\n当把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方\n详细可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 命令模式部分\n3.9.1 命令模式 VS 策略模式看到上面的定义可能会觉得，命令模式跟策略模式、工厂模式非常相似，那它们的区别在哪里呢？不仅如此，感觉前面的很多模式都很相似，不知道你有没有类似的感觉呢？\n实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉\n实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式\n前面讲策略模式的时候有讲到，策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿\n再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别\n在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换\n3.10 解释器模式（Interpreter Design Pattern）在 GoF 的《设计模式》一书中，它是这样定义的：\n\n\n\n\n\n\n\n\n\nInterpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法\n这里面有很多平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等\n要想了解“语言”表达的信息，就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器\n假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：\n\n运算符只包含加、减、乘、除，并且没有优先级的概念\n表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开\n按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果\n\n比如“ 8 3 2 4 - + * ”这样一个表达式，按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。处理出这个结果的，就是解释器\n概念应该不难理解，具体可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 解释器模式部分\n3.11 中介模式（Mediator Design Pattern）在 GoF 中的《设计模式》一书中，它是这样定义的：\n\n\n\n\n\n\n\n\n\nMediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互\n在讲到“如何给代码解耦”时，其中一个方法就是引入中间层。实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性\n如下画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关系优化之后的结果，从图中可以很直观地看出，右边的交互关系更加清晰、简洁\n\n提到中介模式，有一个比较经典的例子不得不说，那就是航空管制\n为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络\n详细可见：**设计模式之美总结（行为型篇）_凡 223 的博客** 中介模式部分\n3.11.1 中介模式 VS 观察者模式前面讲观察者模式的时候讲到，观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的 update() 方法。但是，在跨进程的实现方式中，可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在\n而中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？\n在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理\n而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的\n","slug":"BlogRepository/设计模式/23 种设计模式总结","date":"2022-12-30T08:53:46.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"f836b7c416a11f5069436de43f7aa730","title":"Java Integer.toBinaryString() 方法源码及原理解析（进制转换、位运算）","content":"1. 使用及源码概览Integer.toBinaryString() 方法用于将十进制整数转为二进制，如下例：\n\n完整源码调用如下：\npublic static String toBinaryString(int i) &#123;\n        return toUnsignedString0(i, 1);\n&#125;\n\nprivate static String toUnsignedString0(int val, int shift) &#123;\n        &#x2F;&#x2F; assert shift &gt; 0 &amp;&amp; shift &lt;&#x3D;5 : &quot;Illegal shift value&quot;;\n        int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1);\n        char[] buf &#x3D; new char[chars];\n\n        formatUnsignedInt(val, shift, buf, 0, chars);\n\n        &#x2F;&#x2F; Use special constructor which takes over &quot;buf&quot;.\n        return new String(buf, true);\n&#125;\n\npublic static int numberOfLeadingZeros(int i) &#123;\n        &#x2F;&#x2F; HD, Figure 5-6\n        if (i &#x3D;&#x3D; 0)\n            return 32;\n        int n &#x3D; 1;\n        if (i &gt;&gt;&gt; 16 &#x3D;&#x3D; 0) &#123; n +&#x3D; 16; i &lt;&lt;&#x3D; 16; &#125;\n        if (i &gt;&gt;&gt; 24 &#x3D;&#x3D; 0) &#123; n +&#x3D;  8; i &lt;&lt;&#x3D;  8; &#125;\n        if (i &gt;&gt;&gt; 28 &#x3D;&#x3D; 0) &#123; n +&#x3D;  4; i &lt;&lt;&#x3D;  4; &#125;\n        if (i &gt;&gt;&gt; 30 &#x3D;&#x3D; 0) &#123; n +&#x3D;  2; i &lt;&lt;&#x3D;  2; &#125;\n        n -&#x3D; i &gt;&gt;&gt; 31;\n        return n;\n&#125;\n\nstatic int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len) &#123;\n        int charPos &#x3D; len;\n        int radix &#x3D; 1 &lt;&lt; shift;\n        int mask &#x3D; radix - 1;\n        do &#123;\n            buf[offset + --charPos] &#x3D; Integer.digits[val &amp; mask];\n            val &gt;&gt;&gt;&#x3D; shift;\n        &#125; while (val !&#x3D; 0 &amp;&amp; charPos &gt; 0);\n\n        return charPos;\n&#125;\n\nfinal static char[] digits &#x3D; &#123;\n        &#39;0&#39; , &#39;1&#39; , &#39;2&#39; , &#39;3&#39; , &#39;4&#39; , &#39;5&#39; ,\n        &#39;6&#39; , &#39;7&#39; , &#39;8&#39; , &#39;9&#39; , &#39;a&#39; , &#39;b&#39; ,\n        &#39;c&#39; , &#39;d&#39; , &#39;e&#39; , &#39;f&#39; , &#39;g&#39; , &#39;h&#39; ,\n        &#39;i&#39; , &#39;j&#39; , &#39;k&#39; , &#39;l&#39; , &#39;m&#39; , &#39;n&#39; ,\n        &#39;o&#39; , &#39;p&#39; , &#39;q&#39; , &#39;r&#39; , &#39;s&#39; , &#39;t&#39; ,\n        &#39;u&#39; , &#39;v&#39; , &#39;w&#39; , &#39;x&#39; , &#39;y&#39; , &#39;z&#39;\n&#125;;\n\n2. 解析2.1 二进制转换首先，从运算逻辑上了解一下怎么从十进制转换为二进制，一般来说有两种方法，这里只用 8 位来做示范\n1、短除法\n本质上就是不断除 2，直到商为 0 为止，然后将余数倒序输出。例：15，16\n2| 15                      2| 16  \n  ————                       ————\n  2| 7           1  ^        2| 8             0  ^\n    ————            |          ————              |\n    2| 3         1  |          2| 4           0  |\n      ————          |            ————            |\n      2| 1       1  |            2| 2         0  |\n        ————        |              ————          |\n           0     1  |              2| 1       0  |\n                                     ————        |\n                                        0     1  |\n\n由上，15 的二进制表示为 0000 1111，16 的二进制表示为 0001 0000\n2、按权相加法\n即将二进制数首先写成加权系数展开式，依次与二进制位对应，然后按十进制加法规则求和\n\n\n\n\n\n\n\n\n\n2 的 0 次方是 1     ————– 对应第 1 位2 的 1 次方是 2     ————– 对应第 2 位2 的 2 次方是 4     ————– 对应第 3 位2 的 3 次方是 8     ————– 对应第 4 位2 的 4 次方是 16   ————– 对应第 5 位2 的 5 次方是 32   ————– 对应第 6 位2 的 6 次方是 64   ————– 对应第 7 位……\n例：15 &#x3D; 2^3 + 2^2 + 2^1 + 2^0，16 &#x3D; 2^4，即：\n15            16\n0000 0000     0000 0000\n0000 1000     0001 0000\n0000 1100\n0000 1110\n0000 1111\n\n2.2 原码、反码、补码然后再了解一下原码、反码和补码的相关知识，同样只用 8 位做示范\n1、原码\n原码，即 2.1 所示的转换为二进制，例：15，原码即为 0000 1111。在 2.1 中只用了正数来举例，这里开始需要区分正数和负数，同时引入符号位的概念。二进制的第一位为符号位，正数为 0，负数为 1，符号位不参与位的转换和运算\n例：-15，原码即为 1000 1111\n\n\n\n\n\n\n\n\n\n15原码：  0000 1111-15原码：1000 1111\n2、反码\n反码，即原码按位取反。这里注意，正数的反码与原码相同。例：-15，原码为 1000 1111，符号位不参与转换，按位取反为 1111 0000\n\n\n\n\n\n\n\n\n\n15反码： 0000 1111，与原码同\n-15原码：1000 1111\n-15反码：1111 0000\n3、补码\n补码，即反码加 1，完整说法应为原码取反加1。同样注意，正数的补码与原码相同。例：-15，反码为 1111 0000，加 1 为 1111 0001\n\n\n\n\n\n\n\n\n\n15补码： 0000 1111，与原码同\n-15原码：1000 1111-15反码：1111 0000-15补码：1111 0001\n正数的原码、反码、补码相同，正数的二进制表示为二进制原码即可（其实也是补码，相同不需要计算）。而负数的二进制表示为二进制补码，也就是文章的第一张图片所示示例，如下。由于 int 为 32 位，所以负数显示了一堆 1，正数则是把前面的 0 去掉了\n\n2.3 位运算符再来了解一下位运算的相关知识，同样只用 8 位来示范\n1、&lt;&lt;：按位左移运算符\n将转换后的二进制左移指定的位数，例：15 &lt;&lt; 2，即 0000 1111 &lt;&lt; 2，为 0011 1100，十进制表示为 60。这里后面补的都是 0\n\n\n\n\n\n\n\n\n\n0000 11110011 1100\n\n注意：这里可以用 1 &lt;&lt; n 来表示 2 的 n 次方，因为其实每左移 1 位，就相当于乘以了一个 2\n\n2、&gt;&gt;：按位右移运算符\n将转换后的二进制右移指定的位数，例：15 &gt;&gt; 2，即 0000 1111 &gt;&gt; 2，为 0000 0011，十进制表示为 3。这里前面的补位数是带符号的，正数，符号位为 0，则补 0；负数，符号位为 1，则补 1\n\n\n\n\n\n\n\n\n\n0000 11110000 0011\n\n右移可以变相看成是除 2，这时就存在偶数和奇数的情况。偶数，正数和负数的值是相同的，这里说的值指本身的数值，不带符号；奇数时，负数的值比正数大 1\n3、&gt;&gt;&gt;：按位右移补零操作符\n将转换后的二进制右移指定的位数，移动后的空位以零填充。这里就不区分符号位，因此也叫无符号右移，正数没有影响，因为前面本来就是 0，负数则会改变原本的值大小，例：-15 &gt;&gt;&gt; 2，即 1111 0001 &gt;&gt;&gt; 2，为 0011 1100，这里只用了 8 位来演示，完整 32 位见下图所示，这里前面的 0 被省略了，也可以看到比原来少了两位：\n\n\n\n\n\n\n\n\n\n1111 00010011 1100\n\n4、&amp;：如果相对应位都是 1，则结果为 1，否则为 0，例：15 &amp; 16、3 &amp; 7\n15: 0000 1111     3: 0000 0011\n16: 0001 0000     7: 0000 0111\n    0000 0000        0000 0011\n\n则 15 &amp; 16 结果为 0，3 &amp; 7 结果为 3\n2.4 源码解析1、首先来看调用的顶层方法，这里可以看到就是调用了一个 toUnsignedString0() 的方法，参数 i 即我们传进来需要转换的值，这里的 1，表示的是进制位数，1 即二进制，3 则是 8 进制，4 是 16 进制\npublic static String toBinaryString(int i) &#123;\n        return toUnsignedString0(i, 1);\n&#125;\n\npublic static String toOctalString(int i) &#123;\n        return toUnsignedString0(i, 3);\n&#125;\n\npublic static String toHexString(int i) &#123;\n        return toUnsignedString0(i, 4);\n&#125;\n\n2、再来看 toUnsignedString0() 方法，这里先调用了一个 Integer.numberOfLeadingZeros() 方法，这个方法主要用来计算二进制表示的高位连续 0 位的数量，然后用 Integer.SIZE（32） 减去这个数量，计算需要表示的字符数组的长度，可以理解为省略了前面的 0。如下例：\n\n\n\n\n\n\n\n\n\n15：0000 0000 0000 0000 0000 0000 0000 1111，原本的表示15：1111，实际的表示\n这一步就可以理解为把前面的 0 省略掉了，只保留需要表示的位数\nprivate static String toUnsignedString0(int val, int shift) &#123;\n        &#x2F;&#x2F; assert shift &gt; 0 &amp;&amp; shift &lt;&#x3D;5 : &quot;Illegal shift value&quot;;\n        int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1);\n        char[] buf &#x3D; new char[chars];\n\n        formatUnsignedInt(val, shift, buf, 0, chars);\n\n        &#x2F;&#x2F; Use special constructor which takes over &quot;buf&quot;.\n        return new String(buf, true);\n&#125;\n\n@Native public static final int SIZE &#x3D; 32;\n\n3、接下来来看 Integer.numberOfLeadingZeros() 的具体实现，这里用了一个简易的二分法，分为多个区间 [16, 24, 28, 30] 来进行判断。这里还剩下 [30, 32] 这个区间，为什么没有算呢？见下面的第 6 步。这里的 n 表示高位连续 0 的数量\n\n首先判断 i 是否为 0，0 的话则是 32 位的高位连续 0，直接返回 32\n然后判断 i &gt;&gt;&gt; 16 是否为 0，可以理解为先二分判断一半的区间，假如为 0，则表示至少包含 16 个高位连续 0，n 加上 16，然后 i &lt;&lt;&#x3D; 16，将 i 去除 16 位 0 再进行后续判断\n判断 i &gt;&gt;&gt; 24 是否为 0，即判断是否至少包含 8 个高位连续 0，假如为 0，则 n 加上 8，然后 i &lt;&lt;&#x3D; 8，将 i 去除 8 位 0 再进行后续判断\n同上，判断是否至少包含 4 个高位连续 0\n同上，判断是否至少包含 2 个高位连续 0，这里已经为 i &gt;&gt;&gt; 30\n最后，这里还剩下了 [30, 32] 这个长度为 2 的区间，存在四种情况，[00, 01, 10, 11]，在最前面我们已经判断了等于 0 的情况，所以 00 是排除掉的，剩下 [01, 10, 11]，假如是 x1，那么就不需要判断 x 是多少了，因为只需要判断最高连续 0 位；假如是 x0，由于 00 已经排除，则 x 为 1。所以，其实只需要判断一位就足够了，这也是为什么没有算 [30, 32] 这个区间，只到了 31 为止这里先给 n 赋了初始值为 1，先假设默认这一位是 0，然后再通过 n -=  i &gt;&gt;&gt; 31，判断这一位到底是什么，是 0 则 n &#x3D; n - 0，不变；是 1 则 n &#x3D; n - 1，减掉原先赋的默认初始值 1。这里其实就是用这个技巧代替了 if (i &gt;&gt;&gt; 31 == 0) &#123; n += 1; &#125; 的判断，如下第二种写法\n\npublic static int numberOfLeadingZeros(int i) &#123;\n        &#x2F;&#x2F; HD, Figure 5-6\n        if (i &#x3D;&#x3D; 0)\n            return 32;\n        int n &#x3D; 1;\n        if (i &gt;&gt;&gt; 16 &#x3D;&#x3D; 0) &#123; n +&#x3D; 16; i &lt;&lt;&#x3D; 16; &#125;\n        if (i &gt;&gt;&gt; 24 &#x3D;&#x3D; 0) &#123; n +&#x3D;  8; i &lt;&lt;&#x3D;  8; &#125;\n        if (i &gt;&gt;&gt; 28 &#x3D;&#x3D; 0) &#123; n +&#x3D;  4; i &lt;&lt;&#x3D;  4; &#125;\n        if (i &gt;&gt;&gt; 30 &#x3D;&#x3D; 0) &#123; n +&#x3D;  2; i &lt;&lt;&#x3D;  2; &#125;\n        n -&#x3D; i &gt;&gt;&gt; 31;\n        return n;\n&#125;\n\npublic static int numberOfLeadingZeros(int i) &#123;\n        &#x2F;&#x2F; HD, Figure 5-6\n        if (i &#x3D;&#x3D; 0)\n            return 32;\n        int n &#x3D; 0;\n        if (i &gt;&gt;&gt; 16 &#x3D;&#x3D; 0) &#123; n +&#x3D; 16; i &lt;&lt;&#x3D; 16; &#125;\n        if (i &gt;&gt;&gt; 24 &#x3D;&#x3D; 0) &#123; n +&#x3D;  8; i &lt;&lt;&#x3D;  8; &#125;\n        if (i &gt;&gt;&gt; 28 &#x3D;&#x3D; 0) &#123; n +&#x3D;  4; i &lt;&lt;&#x3D;  4; &#125;\n        if (i &gt;&gt;&gt; 30 &#x3D;&#x3D; 0) &#123; n +&#x3D;  2; i &lt;&lt;&#x3D;  2; &#125;\n        if (i &gt;&gt;&gt; 31 &#x3D;&#x3D; 0) &#123; n +&#x3D; 1; &#125;\n        return n;\n&#125;\n\n4、再回到 toUnsignedString0() 这个方法，通过调用 numberOfLeadingZeros() 得到高位连续 0 的数量，然后通过 Integer.SIZE 减去这个数量得到需要表示的位数\n然后再通过 Math.max(((mag + (shift - 1)) / shift), 1); 来计算 2&#x2F;8&#x2F;16 进制对应的字符数组的长度，这里的参数 shift 前面提到是用来表示进制位数，1 即二进制，3 则是 8 进制，4 是 16 进制\n得到字符数组长度后创建对应的字符数组，调用 formatUnsignedInt() 来填充数组\nprivate static String toUnsignedString0(int val, int shift) &#123;\n        &#x2F;&#x2F; assert shift &gt; 0 &amp;&amp; shift &lt;&#x3D;5 : &quot;Illegal shift value&quot;;\n        int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1);\n        char[] buf &#x3D; new char[chars];\n\n        formatUnsignedInt(val, shift, buf, 0, chars);\n\n        &#x2F;&#x2F; Use special constructor which takes over &quot;buf&quot;.\n        return new String(buf, true);\n&#125;\n\n5、formatUnsignedInt() 方法如下，参数 val 是需要转换的值；shift 表示进制位数，这里为 1；buf 为创建的字符数组；offset 为偏移量，这里为 0；len 为数组长度。其中第 6 行用到的 Integer.digits 是定义好的包含全部数字和字母的字符数组\n这里其实就是按照对应的位数进行对应填充\n\n将数组长度赋值给 charPos，后续用 charPos 来进行计算\n\nradix = 1 &lt;&lt; shift，前面说过，1 &lt;&lt; n 其实就是 2 的 n 次方，这里是用来表示进制，二进制则是 2 的 1 次方，八进制是 2 的 3 次方，十六进制是 2 的 4 次方\n\nmask 为进制减一，用来后续和 val 做 &amp; 运算，实际就是逐批匹配进制对应的位数。例：shift 为 3，即 8 进制，mask 则为 7\n\n\n\n\n\n\n\n\n\n8 &#x3D;&#x3D; radix &#x3D; 1 &lt;&lt; 3;7 &#x3D;&#x3D; mask &#x3D; radix - 1;\nmask 做 &amp; 运算时，表示为 111，即 3 位二进制表示一位 8 进制\n\nval &amp; mask 得到值后，在 digits 数组里去找到对应的索引的字符赋给 buf，即创建的字符数组，注意，这里是倒序存放，对应进制位数的变化，从右往左\n\n然后将 val 右移相应的进制位数，循环匹配\n\n最后返回填充好的字符数组\n\n\nstatic int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len) &#123;\n        int charPos &#x3D; len;\n        int radix &#x3D; 1 &lt;&lt; shift;\n        int mask &#x3D; radix - 1;\n        do &#123;\n            buf[offset + --charPos] &#x3D; Integer.digits[val &amp; mask];\n            val &gt;&gt;&gt;&#x3D; shift;\n        &#125; while (val !&#x3D; 0 &amp;&amp; charPos &gt; 0);\n\n        return charPos;\n&#125;\n\nfinal static char[] digits &#x3D; &#123;\n        &#39;0&#39; , &#39;1&#39; , &#39;2&#39; , &#39;3&#39; , &#39;4&#39; , &#39;5&#39; ,\n        &#39;6&#39; , &#39;7&#39; , &#39;8&#39; , &#39;9&#39; , &#39;a&#39; , &#39;b&#39; ,\n        &#39;c&#39; , &#39;d&#39; , &#39;e&#39; , &#39;f&#39; , &#39;g&#39; , &#39;h&#39; ,\n        &#39;i&#39; , &#39;j&#39; , &#39;k&#39; , &#39;l&#39; , &#39;m&#39; , &#39;n&#39; ,\n        &#39;o&#39; , &#39;p&#39; , &#39;q&#39; , &#39;r&#39; , &#39;s&#39; , &#39;t&#39; ,\n        &#39;u&#39; , &#39;v&#39; , &#39;w&#39; , &#39;x&#39; , &#39;y&#39; , &#39;z&#39;\n&#125;;\n\n6、再回到 toUnsignedString0() 方法，最后一步则是将字符数组转换为 String 返回，到这里整个流程结束\nprivate static String toUnsignedString0(int val, int shift) &#123;\n        &#x2F;&#x2F; assert shift &gt; 0 &amp;&amp; shift &lt;&#x3D;5 : &quot;Illegal shift value&quot;;\n        int mag &#x3D; Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars &#x3D; Math.max(((mag + (shift - 1)) &#x2F; shift), 1);\n        char[] buf &#x3D; new char[chars];\n\n        formatUnsignedInt(val, shift, buf, 0, chars);\n\n        &#x2F;&#x2F; Use special constructor which takes over &quot;buf&quot;.\n        return new String(buf, true);\n&#125;\n","slug":"BlogRepository/Java/Java Integer.toBinaryString() 方法源码及原理解析（进制转换、位运算）","date":"2022-12-27T09:31:38.000Z","categories_index":"Java","tags_index":"Java","author_index":"凡"},{"id":"27f6062000233c0b6c7b071a046007f7","title":"设计模式之美总结（行为型篇）","content":"前五篇见：\n\n设计模式之美总结（面向对象篇）_凡 223 的博客\n设计模式之美总结（设计原则篇）_凡 223 的博客\n设计模式之美总结（重构篇）_凡 223 的博客\n设计模式之美总结（创建型篇）_凡 223 的博客\n设计模式之美总结（结构型篇）_凡 223 的博客\n\n创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题\n行为型设计模式比较多，有 11 个，几乎占了 23 种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式\n1. 观察者&#x2F;发布订阅模式（Observer Design Pattern&#x2F;Publish-Subscribe Design Pattern）根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式\n1.1 原理及应用场景剖析观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：\n\n\n\n\n\n\n\n\n\nDefine a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知\n一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式\n实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，首先先来看其中最经典的一种实现方式，这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：\npublic interface Subject &#123;\n\tvoid registerObserver(Observer observer);\n\tvoid removeObserver(Observer observer);\n\tvoid notifyObservers(Message message);\n&#125;\npublic interface Observer &#123;\n\tvoid update(Message message);\n&#125;\npublic class ConcreteSubject implements Subject &#123;\n\tprivate List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n\t@Override\n\tpublic void registerObserver(Observer observer) &#123;\n\t\tobservers.add(observer);\n\t&#125;\n\t@Override\n\tpublic void removeObserver(Observer observer) &#123;\n\t\tobservers.remove(observer);\n\t&#125;\n\t@Override\n\tpublic void notifyObservers(Message message) &#123;\n\t\tfor (Observer observer : observers) &#123;\n\t\t\tobserver.update(message);\n\t\t&#125;\n\t&#125;\n&#125;\npublic class ConcreteObserverOne implements Observer &#123;\n\t@Override\n\tpublic void update(Message message) &#123;\n\t\t&#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n\t\tSystem.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n\t&#125;\n&#125;\npublic class ConcreteObserverTwo implements Observer &#123;\n\t@Override\n\tpublic void update(Message message) &#123;\n\t\t&#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n\t\tSystem.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n\t&#125;\n&#125;\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tConcreteSubject subject &#x3D; new ConcreteSubject();\n\t\tsubject.registerObserver(new ConcreteObserverOne());\n\t\tsubject.registerObserver(new ConcreteObserverTwo());\n\t\tsubject.notifyObservers(new Message());\n\t&#125;\n&#125;\n\n\n上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。不过，万变不离其宗，设计思路都是差不多的\n假设开发一个 P2P 投资理财系统，用户注册成功之后，会给用户发放投资体验金。代码实现大致如下：\npublic class UserController &#123;\n\tprivate UserService userService; &#x2F;&#x2F; 依赖注入\n\tprivate PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\tpublic Long register(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;省略输入参数的校验代码\n\t\t&#x2F;&#x2F;省略userService.register()异常的try-catch代码\n\t\tlong userId &#x3D; userService.register(telephone, password);\n\t\tpromotionService.issueNewUserExperienceCash(userId);\n\t\treturn userId;\n\t&#125;\n&#125;\n\n虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计\n相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，就需要频繁地修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。这个时候，观察者模式就能派上用场了。利用观察者模式，对上面的代码进行了重构。重构之后的代码如下所示：\npublic interface RegObserver &#123;\n\tvoid handleRegSuccess(long userId);\n&#125;\npublic class RegPromotionObserver implements RegObserver &#123;\n\tprivate PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\t@Override\n\tpublic void handleRegSuccess(long userId) &#123;\n\t\tpromotionService.issueNewUserExperienceCash(userId);\n\t&#125;\n&#125;\npublic class RegNotificationObserver implements RegObserver &#123;\n\tprivate NotificationService notificationService;\n\t@Override\n\tpublic void handleRegSuccess(long userId) &#123;\n\t\tnotificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);\n\t&#125;\n&#125;\npublic class UserController &#123;\n\tprivate UserService userService; &#x2F;&#x2F; 依赖注入\n\tprivate List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();\n\t&#x2F;&#x2F; 一次性设置好，之后也不可能动态的修改\n\tpublic void setRegObservers(List&lt;RegObserver&gt; observers) &#123;\n\t\tregObservers.addAll(observers);\n\t&#125;\n\tpublic Long register(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;省略输入参数的校验代码\n\t\t&#x2F;&#x2F;省略userService.register()异常的try-catch代码\n\t\tlong userId &#x3D; userService.register(telephone, password);\n\t\tfor (RegObserver observer : regObservers) &#123;\n\t\t\tobserver.handleRegSuccess(userId);\n\t\t&#125;\n\t\treturn userId;\n\t&#125;\n&#125;\n\n当需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可\n不过这时可能会说，当把发送体验金替换为发送优惠券的时候，需要修改 RegPromotionObserver 类中 handleRegSuccess() 函数的代码，这还是违反开闭原则呀？没错，不过，相对于 register() 函数来说，handleRegSuccess() 函数的逻辑要简单很多，修改更不容易出错，引入 bug 的风险更低\n实际上，设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。 借助设计模式，利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性\n1.2 不同应用场景的不同实现方式观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式\n不同的应用场景和需求下，这个模式也有截然不同的实现方式，前面也提到，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式\n上面讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register() 函数依次调用执行每个观察者的 handleRegSuccess() 函数，等到都执行完成之后，才会返回结果给客户端\n如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当 userService.register() 函数执行完成之后，启动一个新的线程来执行观察者的 handleRegSuccess() 函数，这样 userController.register()函数就不需要等到所有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。userController.register() 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句就返回，响应时间粗略来讲减少为原来的 1&#x2F;3\n那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个 handleRegSuccess() 函数中，创建一个新的线程执行代码。不过，还有更加优雅的实现方式，那就是基于 EventBus 来实现\n上面讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？\n如果大数据征信系统提供了发送用户注册信息的 RPC 接口，仍然可以沿用之前的实现思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，还有更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现\n当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑\n1.3 如何实现一个异步非阻塞的 EventBus 框架？对于异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用性、复用性，实际上是非常容易的\n有两种实现方式。其中一种是：在每个 handleRegSuccess() 函数中创建一个新的线程执行代码逻辑；另一种是：在 UserController 的 register() 函数中使用线程池来执行每个观察者的 handleRegSuccess() 函数。两种实现方式的具体代码如下所示：\n&#x2F;&#x2F; 第一种实现方式，其他类代码不变，就没有再重复罗列\npublic class RegPromotionObserver implements RegObserver &#123;\n\tprivate PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\t@Override\n\tpublic void handleRegSuccess(long userId) &#123;\n\t\tThread thread &#x3D; new Thread(new Runnable() &#123;\n\t\t\t@Override\n\t\t\tpublic void run() &#123;\n\t\t\t\tpromotionService.issueNewUserExperienceCash(userId);\n\t\t\t&#125;\n\t\t&#125;);\n\t\tthread.start();\n\t&#125;\n&#125;\n&#x2F;&#x2F; 第二种实现方式，其他类代码不变，就没有再重复罗列\npublic class UserController &#123;\n\tprivate UserService userService; &#x2F;&#x2F; 依赖注入\n\tprivate List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();\n\tprivate Executor executor;\n\tpublic UserController(Executor executor) &#123;\n\t\tthis.executor &#x3D; executor;\n\t&#125;\n\tpublic void setRegObservers(List&lt;RegObserver&gt; observers) &#123;\n\t\tregObservers.addAll(observers);\n\t&#125;\n\tpublic Long register(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;省略输入参数的校验代码\n\t\t&#x2F;&#x2F;省略userService.register()异常的try-catch代码\n\t\tlong userId &#x3D; userService.register(telephone, password);\n\t\tfor (RegObserver observer : regObservers) &#123;\n\t\t\texecutor.execute(new Runnable() &#123;\n\t\t\t\t@Override\n\t\t\t\tpublic void run() &#123;\n\t\t\t\t\tobserver.handleRegSuccess(userId);\n\t\t\t\t&#125;\n\t\t\t&#125;);\n\t\t&#125;\n\t\treturn userId;\n\t&#125;\n&#125;\n\n对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 register() 函数中，增加了这部分业务代码的维护成本\n如果需求更加极端一点，需要在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改 UserController 的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用\n框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，也可以将它抽象成框架来达到这样的效果\n1.3.1 功能需求介绍EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式\n将之前用户注册的例子用 Guava EventBus 重新实现一下，代码如下所示：\npublic class UserController &#123;\n\tprivate UserService userService; &#x2F;&#x2F; 依赖注入\n\tprivate EventBus eventBus;\n\tprivate static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;\n\tpublic UserController() &#123;\n\t\t&#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式\n\t\teventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE);\n\t&#125;\n\tpublic void setRegObservers(List&lt;Object&gt; observers) &#123;\n\t\tfor (Object observer : observers) &#123;\n\t\t\teventBus.register(observer);\n\t\t&#125;\n\t&#125;\n\tpublic Long register(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;省略输入参数的校验代码\n\t\t&#x2F;&#x2F;省略userService.register()异常的try-catch代码\n\t\tlong userId &#x3D; userService.register(telephone, password);\n\t\teventBus.post(userId);\n\t\treturn userId;\n\t&#125;\n&#125;\npublic class RegPromotionObserver &#123;\n\tprivate PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\t@Subscribe\n\tpublic void handleRegSuccess(long userId) &#123;\n\t\tpromotionService.issueNewUserExperienceCash(userId);\n\t&#125;\n&#125;\npublic class RegNotificationObserver &#123;\n\tprivate NotificationService notificationService;\n\t@Subscribe\n\tpublic void handleRegSuccess(long userId) &#123;\n\t\tnotificationService.sendInboxMessage(userId, &quot;...&quot;);\n\t&#125;\n&#125;\n\n利用 EventBus 框架实现的观察者模式，跟从零开始编写的观察者模式相比，从大的流程上来说，实现思路大致一样，都需要定义 Observer，并且通过 register() 函数注册 Observer，也都需要通过调用某个函数（比如，EventBus 中的 post() 函数）来给 Observer 发送消息（在 EventBus 中消息被称作事件 event）\n但在实现细节方面，它们又有些区别。基于 EventBus，不需要定义 Observer 接口，任意类型的对象都可以注册到 EventBus 中，通过 @Subscribe 注解来标明类中哪个函数可以接收被观察者发送的消息\n接下来详细地讲一下，Guava EventBus 的几个主要的类和函数\n1、EventBus、AsyncEventBus\nGuava EventBus 对外暴露的所有可调用接口，都封装在 EventBus 类中。其中，EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步非阻塞的观察者模式。具体使用方式如下所示：\nEventBus eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式\nEventBus eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool(8))；&#x2F;&#x2F; 异步非阻塞\n\n2、register() 函数\nEventBus 类提供了 register() 函数用来注册观察者。具体的函数定义如下所示。它可以接受任何类型（Object）的观察者。而在经典的观察者模式的实现中，register() 函数必须接受实现了同一 Observer 接口的类对象\npublic void register(Object object);\n\n3、unregister() 函数\n相对于 register() 函数，unregister() 函数用来从 EventBus 中删除某个观察者。具体的函数定义如下所示：\npublic void unregister(Object object);\n\n4、post() 函数\nEventBus 类提供了 post() 函数，用来给观察者发送消息。具体的函数定义如下所示：\npublic void post(Object event);\n\n跟经典的观察者模式的不同之处在于，当调用 post() 函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类型是发送消息（post 函数定义中的 event）类型的父类\n比如，AObserver 能接收的消息类型是 XMsg，BObserver 能接收的消息类型是 YMsg，CObserver 能接收的消息类型是 ZMsg。其中，XMsg 是 YMsg 的父类。当如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：\nXMsg xMsg &#x3D; new XMsg();\nYMsg yMsg &#x3D; new YMsg();\nZMsg zMsg &#x3D; new ZMsg();\npost(xMsg); &#x3D;&gt; AObserver接收到消息\npost(yMsg); &#x3D;&gt; AObserver、BObserver接收到消息\npost(zMsg); &#x3D;&gt; CObserver接收到消息\n\n那么，每个 Observer 能接收的消息类型是在哪里定义的呢？这就是 Guava EventBus 最特别的一个地方，那就是 @Subscribe 注解\n5、@Subscribe 注解\nEventBus 通过 @Subscribe 注解来标明，某个函数能接收哪种类型的消息。具体的使用代码如下所示。在 DObserver 类中，通过 @Subscribe 注解了两个函数 f1()、f2()\npublic DObserver &#123;\n    &#x2F;&#x2F;...省略其他属性和方法...\n    @Subscribe\n    public void f1(PMsg event) &#123; &#x2F;&#x2F;... &#125;\n    @Subscribe\n    public void f2(QMsg event) &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\n当通过 register() 函数将 DObserver 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe 注解找到 f1() 和 f2()，并且将两个函数能接收的消息类型记录下来（PMsg -&gt; f1，QMsg -&gt; f2）。当通过 post() 函数发送消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg -&gt; f2），调用相应的函数（f2）\n1.3.2 实现Guava EventBus 的功能已经讲清楚了，总体上来说，还是比较简单的。接下来，就重复造轮子，“山寨”一个 EventBus 出来\n重点来看 EventBus 中两个核心函数 register() 和 post() 的实现原理。弄懂了它们，基本上就弄懂了整个 EventBus 框架。下面两张图是这两个函数的实现原理图\n\n\n从图中可以看出，最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数\n弄懂了原理，实现起来就简单多了。整个小框架的代码实现包括 5 个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。接下来依次来看下这 5 个类\n1、Subscribe\nSubscribe 是一个注解，用于标明观察者中的哪个函数可以接收消息\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Beta\npublic @interface Subscribe &#123;&#125;\n\n2、ObserverAction\nObserverAction 类用来表示 @Subscribe 注解的方法，其中，target 表示观察者类，method 表示方法。它主要用在 ObserverRegistry 观察者注册表中\npublic class ObserverAction &#123;\n\tprivate Object target;\n\tprivate Method method;\n\tpublic ObserverAction(Object target, Method method) &#123;\n\t\tthis.target &#x3D; Preconditions.checkNotNull(target);\n\t\tthis.method &#x3D; method;\n\t\tthis.method.setAccessible(true);\n\t&#125;\n\tpublic void execute(Object event) &#123; &#x2F;&#x2F; event是method方法的参数\n\t\ttry &#123;\n\t\t\tmethod.invoke(target, event);\n\t\t&#125; catch (InvocationTargetException | IllegalAccessException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;\n\n3、ObserverRegistry\nObserverRegistry 类就是前面讲到的 Observer 注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类大量使用了 Java 的反射语法，不过代码整体来说都不难理解，其中，一个比较有技巧的地方是 CopyOnWriteArraySet 的使用\nCopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的 set，并且将原始数据 clone 到新的 set 中，在新的 set 中写入数据完成之后，再用新的 set 替换老的 set。这样就能保证在写入数据的时候，不影响数据的读取操作，以此来解决读写并发问题。除此之外，CopyOnWriteSet 还通过加锁的方式，避免了并发写冲突\npublic class ObserverRegistry &#123;\n\tprivate ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry;\n\tpublic void register(Object observer) &#123;\n\t\tMap&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions &#x3D; findAllObserverActions(registry);\n\t\tfor (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions) &#123;\n\t\t\tClass&lt;?&gt; eventType &#x3D; entry.getKey();\n\t\t\tCollection&lt;ObserverAction&gt; eventActions &#x3D; entry.getValue();\n\t\t\tCopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions &#x3D; registry.get\n\t\t\tif (registeredEventActions &#x3D;&#x3D; null) &#123;\n\t\t\t\tregistry.putIfAbsent(eventType, new CopyOnWriteArraySet&lt;&gt;());\n\t\t\t\tregisteredEventActions &#x3D; registry.get(eventType);\n\t\t\t&#125;\n\t\t\tregisteredEventActions.addAll(eventActions);\n\t\t&#125;\n\t&#125;\n\tpublic List&lt;ObserverAction&gt; getMatchedObserverActions(Object event) &#123;\n\t\tList&lt;ObserverAction&gt; matchedObservers &#x3D; new ArrayList&lt;&gt;();\n\t\tClass&lt;?&gt; postedEventType &#x3D; event.getClass();\n\t\tfor (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry) &#123;\n\t\t\tClass&lt;?&gt; eventType &#x3D; entry.getKey();\n\t\t\tCollection&lt;ObserverAction&gt; eventActions &#x3D; entry.getValue();\n\t\t\tif (postedEventType.isAssignableFrom(eventType)) &#123;\n\t\t\t\tmatchedObservers.addAll(eventActions);\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn matchedObservers;\n\t&#125;\n\tprivate Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) &#123;\n\t\tMap&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions &#x3D; new HashMap&lt;&gt;()\n\t\tClass&lt;?&gt; clazz &#x3D; observer.getClass();\n\t\tfor (Method method : getAnnotatedMethods(clazz)) &#123;\n\t\t\tClass&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();\n\t\t\tClass&lt;?&gt; eventType &#x3D; parameterTypes[0];\n\t\t\tif (!observerActions.containsKey(eventType)) &#123;\n\t\t\t\tobserverActions.put(eventType, new ArrayList&lt;&gt;());\n\t\t\t&#125;\n\t\t\tobserverActions.get(eventType).add(new ObserverAction(observer, method))\n\t\t&#125;\n\t\treturn observerActions;\n\t&#125;\n\tprivate List&lt;Method&gt; getAnnotatedMethods(Class&lt;?&gt; clazz) &#123;\n\t\tList&lt;Method&gt; annotatedMethods &#x3D; new ArrayList&lt;&gt;();\n\t\tfor (Method method : clazz.getDeclaredMethods()) &#123;\n\t\t\tif (method.isAnnotationPresent(Subscribe.class)) &#123;\n\t\t\t\tClass&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();\n\t\t\t\tPreconditions.checkArgument(parameterTypes.length &#x3D;&#x3D; 1,\n\t\t\t\t                            &quot;Method %s has @Subscribe annotation but has %s parameters.&quot;\n\t\t\t\t                            + &quot;Subscriber methods must have exactly 1 parameter.&quot;,\n\t\t\t\t                            method, parameterTypes.length);\n\t\t\t\tannotatedMethods.add(method);\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn annotatedMethods;\n\t&#125;\n&#125;\n\n4、EventBus\nEventBus 实现的是阻塞同步的观察者模式。看代码可能会有些疑问，这明明就用到了线程池 Executor 啊。实际上，MoreExecutors.directExecutor() 是 Google Guava 提供的工具类，看似是多线程，实际上是单线程。之所以要这么实现，主要还是为了跟 AsyncEventBus 统一代码逻辑，做到代码复用\npublic class EventBus &#123;\n\tprivate Executor executor;\n\tprivate ObserverRegistry registry &#x3D; new ObserverRegistry();\n\tpublic EventBus() &#123;\n\t\tthis(MoreExecutors.directExecutor());\n\t&#125;\n\tprotected EventBus(Executor executor) &#123;\n\t\tthis.executor &#x3D; executor;\n\t&#125;\n\tpublic void register(Object object) &#123;\n\t\tregistry.register(object);\n\t&#125;\n\tpublic void post(Object event) &#123;\n\t\tList&lt;ObserverAction&gt; observerActions &#x3D; registry.getMatchedObserverActions(e\n\t\tfor (ObserverAction observerAction : observerActions) &#123;\n\t\texecutor.execute(new Runnable() &#123;\n\t\t\t@Override\n\t\t\tpublic void run() &#123;\n\t\t\t\t\tobserverAction.execute(event);\n\t\t\t\t&#125;\n\t\t\t&#125;);\n\t\t&#125;\n\t&#125;\n&#125;\n\n5、AsyncEventBus\n有了 EventBus，AsyncEventBus 的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用 MoreExecutors.directExecutor() 了，而是需要在构造函数中，由调用者注入线程池\npublic class AsyncEventBus extends EventBus &#123;\n\tpublic AsyncEventBus(Executor executor) &#123;\n\t\tsuper(executor);\n\t&#125;\n&#125;\n\n至此，就实现了一个还算凑活能用的 EventBus，从功能上来讲，它跟 Google Guava EventBus 几乎一样。不过，如果去查看 Google Guava EventBus 的源码，就会发现，在实现细节方面，相比我们现在的实现，它其实做了很多优化，比如优化了在注册表中查找消息可匹配函数的算法\n2. 模板模式（Template Method Design Pattern）模板模式，全称是模板方法设计模式，英文是 Template Method Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nDefine the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤\n这里的“算法”，可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。代码示例如下：\npublic abstract class AbstractClass &#123;\n\tpublic final void templateMethod() &#123;\n\t\t&#x2F;&#x2F;...\n\t\tmethod1();\n\t\t&#x2F;&#x2F;...\n\t\tmethod2();\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tprotected abstract void method1();\n\tprotected abstract void method2();\n&#125;\npublic class ConcreteClass1 extends AbstractClass &#123;\n\t@Override\n\tprotected void method1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tprotected void method2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ConcreteClass2 extends AbstractClass &#123;\n\t@Override\n\tprotected void method1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tprotected void method2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\nAbstractClass demo &#x3D; ConcreteClass1();\ndemo.templateMethod();\n\n2.1 作用一：复用模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。所有的子类都可以复用父类中模板方法定义的流程代码\n2.1.1 Java InputStreamJava IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、Reader、Writer。这里以 InputStream 为例\n在代码中，read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同\npublic abstract class InputStream implements Closeable &#123;\n\t&#x2F;&#x2F;...省略其他代码...\n\tpublic int read(byte b[], int off, int len) throws IOException &#123;\n\t\tif (b &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new NullPointerException();\n\t\t&#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123;\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t&#125; else if (len &#x3D;&#x3D; 0) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\tint c &#x3D; read();\n\t\tif (c &#x3D;&#x3D; -1) &#123;\n\t\t\treturn -1;\n\t\t&#125;\n\t\tb[off] &#x3D; (byte)c;\n\t\tint i &#x3D; 1;\n\t\ttry &#123;\n\t\t\tfor (; i &lt; len ; i++) &#123;\n\t\t\t\tc &#x3D; read();\n\t\t\t\tif (c &#x3D;&#x3D; -1) &#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tb[off + i] &#x3D; (byte)c;\n\t\t\t&#125;\n\t\t&#125; catch (IOException ee) &#123;\n\t\t&#125;\n\t\treturn i;\n\t&#125;\n\tpublic abstract int read() throws IOException;\n&#125;\npublic class ByteArrayInputStream extends InputStream &#123;\n\t&#x2F;&#x2F;...省略其他代码...\n\t@Override\n\tpublic synchronized int read() &#123;\n\t\treturn (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;\n\t&#125;\n&#125;\n\n2.1.2 Java AbstractList在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的\npublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;\n\trangeCheckForAdd(index);\n\tboolean modified &#x3D; false;\n\tfor (E e : c) &#123;\n\t\tadd(index++, e);\n\t\tmodified &#x3D; true;\n\t&#125;\n\treturn modified;\n&#125;\npublic void add(int index, E element) &#123;\n\tthrow new UnsupportedOperationException();\n&#125;\n\n2.2 作用二：扩展这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能\n2.2.1 Java Servlet对于 Java Web 项目开发来说，常用的开发框架是 SpringMVC。利用它，只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。具体的代码示例如下所示：\npublic class HelloServlet extends HttpServlet &#123;\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tthis.doPost(req, resp);\n\t&#125;\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n\t\tresp.getWriter().write(&quot;Hello World.&quot;);\n\t&#125;\n&#125;\n\n除此之外，还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系\n&lt;servlet&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n当在浏览器中输入网址（比如，http://127.0.0.1:8080/hello ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello World”）到网页\nHttpServlet 的 service() 函数如下：\npublic void service(ServletRequest req, ServletResponse res)\nthrows ServletException, IOException &#123;\n\tHttpServletRequest request;\n\tHttpServletResponse response;\n\tif (!(req instanceof HttpServletRequest &amp;&amp;\n\t        res instanceof HttpServletResponse)) &#123;\n\t\tthrow new ServletException(&quot;non-HTTP request or response&quot;);\n\t&#125;\n\trequest &#x3D; (HttpServletRequest) req;\n\tresponse &#x3D; (HttpServletResponse) res;\n\tservice(request, response);\n&#125;\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\nthrows ServletException, IOException &#123;\n\tString method &#x3D; req.getMethod();\n\tif (method.equals(METHOD_GET)) &#123;\n\t\tlong lastModified &#x3D; getLastModified(req);\n\t\tif (lastModified &#x3D;&#x3D; -1) &#123;\n\t\t\t&#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason\n\t\t\t&#x2F;&#x2F; to go through further expensive logic\n\t\t\tdoGet(req, resp);\n\t\t&#125; else &#123;\n\t\t\tlong ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);\n\t\t\tif (ifModifiedSince &lt; lastModified) &#123;\n\t\t\t\t&#x2F;&#x2F; If the servlet mod time is later, call doGet()\n\t\t\t\t&#x2F;&#x2F; Round down to the nearest second for a proper compare\n\t\t\t\t&#x2F;&#x2F; A ifModifiedSince of -1 will always be less\n\t\t\t\tmaybeSetLastModified(resp, lastModified);\n\t\t\t\tdoGet(req, resp);\n\t\t\t&#125; else &#123;\n\t\t\t\tresp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125; else if (method.equals(METHOD_HEAD)) &#123;\n\t\tlong lastModified &#x3D; getLastModified(req);\n\t\tmaybeSetLastModified(resp, lastModified);\n\t\tdoHead(req, resp);\n\t&#125; else if (method.equals(METHOD_POST)) &#123;\n\t\tdoPost(req, resp);\n\t&#125; else if (method.equals(METHOD_PUT)) &#123;\n\t\tdoPut(req, resp);\n\t&#125; else if (method.equals(METHOD_DELETE)) &#123;\n\t\tdoDelete(req, resp);\n\t&#125; else if (method.equals(METHOD_OPTIONS)) &#123;\n\t\tdoOptions(req,resp);\n\t&#125; else if (method.equals(METHOD_TRACE)) &#123;\n\t\tdoTrace(req,resp);\n\t&#125; else &#123;\n\t\tString errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);\n\t\tObject[] errArgs &#x3D; new Object[1];\n\t\terrArgs[0] &#x3D; method;\n\t\terrMsg &#x3D; MessageFormat.format(errMsg, errArgs);\n\t\tresp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n\t&#125;\n&#125;\n\n从上面的代码中可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行\n2.2.2 JUnit TestCase跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能\n在使用 JUnit 测试框架来编写单元测试的时候，编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作\nTestCase 类的具体代码如下所示。尽管 setUp()、tearDown() 并不是抽象函数，还提供了默认的实现，不强制子类去重新实现，但这部分也是可以在子类中定制的，所以也符合模板模式的定义\npublic abstract class TestCase extends Assert implements Test &#123;\n\tpublic void runBare() throws Throwable &#123;\n\t\tThrowable exception &#x3D; null;\n\t\tsetUp();\n\t\ttry &#123;\n\t\t\trunTest();\n\t\t&#125; catch (Throwable running) &#123;\n\t\t\texception &#x3D; running;\n\t\t&#125; finally &#123;\n\t\t\ttry &#123;\n\t\t\t\ttearDown();\n\t\t\t&#125; catch (Throwable tearingDown) &#123;\n\t\t\t\tif (exception &#x3D;&#x3D; null) exception &#x3D; tearingDown;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (exception !&#x3D; null) throw exception;\n\t&#125;\n\t&#x2F;**\n\t* Sets up the fixture, for example, open a network connection.\n\t* This method is called before a test is executed.\n\t*&#x2F;\n\tprotected void setUp() throws Exception &#123;\n\t&#125;\n\t&#x2F;**\n\t* Tears down the fixture, for example, close a network connection.\n\t* This method is called after a test is executed.\n\t*&#x2F;\n\tprotected void tearDown() throws Exception &#123;\n\t&#125;\n&#125;\n\n2.3 回调（Callback）2.3.1 原理解析相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”\nA 类如何将回调函数传递给 B 类呢？不同的编程语言，有不同的实现方法。C 语言可以使用函数指针，Java 则需要使用包裹了回调函数的类对象，简称为回调对象，代码如下所示：\npublic interface ICallback &#123;\n\tvoid methodToCallback();\n&#125;\npublic class BClass &#123;\n\tpublic void process(ICallback callback) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tcallback.methodToCallback();\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class AClass &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tBClass b &#x3D; new BClass();\n\t\tb.process(new ICallback() &#123; &#x2F;&#x2F;回调对象\n\t\t\t@Override\n\t\t\tpublic void methodToCallback() &#123;\n\t\t\t\tSystem.out.println(&quot;Call back me.&quot;);\n\t\t\t&#125;\n\t\t&#125;);\n\t&#125;\n&#125;\n\n上面就是 Java 语言中回调的典型代码实现。从代码实现中，可以看出，回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的逻辑都可以复用。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力\n实际上，回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户\n回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码实际上是同步回调的实现方式，在 process() 函数返回之前，执行完回调函数 methodToCallback()。而上面支付的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式\n2.3.2 应用一：JdbcTemplateSpring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template（模板）这个单词作为后缀\n这些 Template 类的设计思路都很相近，这里拿其中的 JdbcTemplate 来举例分析一下：\npublic class JdbcDemo &#123;\n\tpublic User queryUser(long id) &#123;\n\t\tConnection conn &#x3D; null;\n\t\tStatement stmt &#x3D; null;\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F;1.加载驱动\n\t\t\tClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\t\t\tconn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;demo&quot;, &quot;x&quot;);\n\t\t\t&#x2F;&#x2F;2.创建statement类对象，用来执行SQL语句\n\t\t\tstmt &#x3D; conn.createStatement();\n\t\t\t&#x2F;&#x2F;3.ResultSet类，用来存放获取的结果集\n\t\t\tString sql &#x3D; &quot;select * from user where id&#x3D;&quot; + id;\n\t\t\tResultSet resultSet &#x3D; stmt.executeQuery(sql);\n\t\t\tString eid &#x3D; null, ename &#x3D; null, price &#x3D; null;\n\t\t\twhile (resultSet.next()) &#123;\n\t\t\t\tUser user &#x3D; new User();\n\t\t\t\tuser.setId(resultSet.getLong(&quot;id&quot;));\n\t\t\t\tuser.setName(resultSet.getString(&quot;name&quot;));\n\t\t\t\tuser.setTelephone(resultSet.getString(&quot;telephone&quot;));\n\t\t\t\treturn user;\n\t\t\t&#125;\n\t\t&#125; catch (ClassNotFoundException e) &#123;\n\t\t\t&#x2F;&#x2F; TODO: log...\n\t\t&#125; catch (SQLException e) &#123;\n\t\t\t&#x2F;&#x2F; TODO: log...\n\t\t&#125; finally &#123;\n\t\t\tif (conn !&#x3D; null)\n\t\t\t\ttry &#123;\n\t\t\t\t\tconn.close();\n\t\t\t\t&#125; catch (SQLException e) &#123;\n\t\t\t\t\t&#x2F;&#x2F; TODO: log...\n\t\t\t\t&#125;\n\t\t\tif (stmt !&#x3D; null)\n\t\t\t\ttry &#123;\n\t\t\t\t\tstmt.close();\n\t\t\t\t&#125; catch (SQLException e) &#123;\n\t\t\t\t\t&#x2F;&#x2F; TODO: log...\n\t\t\t\t&#125;\n\t\t&#125;\n\t\treturn null;\n\t&#125;\n&#125;\n\n很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连接、创建 statement、关闭连接、关闭 statement、处理异常。针对不同的 SQL 执行请求，这些流程性质的代码是相同的、可以复用的，不需要每次都重新敲一遍\n针对这个问题，Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来简化数据库编程。使用 JdbcTemplate 查询用户信息，我们只需要编写跟这个业务有关的代码，其中包括，查询用户的 SQL 语句、查询结果与 User 对象之间的映射关系。其他流程性质的代码都封装在了 JdbcTemplate 类中，不需要每次都重新编写，如下所示：\npublic class JdbcTemplateDemo &#123;\n\tprivate JdbcTemplate jdbcTemplate;\n\tpublic User queryUser(long id) &#123;\n\t\tString sql &#x3D; &quot;select * from user where id&#x3D;&quot;+id;\n\t\treturn jdbcTemplate.query(sql, new UserRowMapper()).get(0);\n\t&#125;\n\tclass UserRowMapper implements RowMapper&lt;User&gt; &#123;\n\t\tpublic User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;\n\t\t\tUser user &#x3D; new User();\n\t\t\tuser.setId(rs.getLong(&quot;id&quot;));\n\t\t\tuser.setName(rs.getString(&quot;name&quot;));\n\t\t\tuser.setTelephone(rs.getString(&quot;telephone&quot;));\n\t\t\treturn user;\n\t\t&#125;\n\t&#125;\n&#125;\n\n那 JdbcTemplate 底层具体是如何实现的呢？这里只摘抄了部分相关代码，贴到了下面。其中，JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便\n@Override\npublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;\n\treturn query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));\n&#125;\n\n@Override\npublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;\n\tAssert.notNull(sql, &quot;SQL must not be null&quot;);\n\tAssert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);\n\tif (logger.isDebugEnabled()) &#123;\n\t\tlogger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);\n\t&#125;\n\tclass QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;\n\t\t@Override\n\t\tpublic T doInStatement(Statement stmt) throws SQLException &#123;\n\t\t\tResultSet rs &#x3D; null;\n\t\t\ttry &#123;\n\t\t\t\trs &#x3D; stmt.executeQuery(sql);\n\t\t\t\tResultSet rsToUse &#x3D; rs;\n\t\t\t\tif (nativeJdbcExtractor !&#x3D; null) &#123;\n\t\t\t\t\trsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);\n\t\t\t\t&#125;\n\t\t\t\treturn rse.extractData(rsToUse);\n\t\t\t&#125; finally &#123;\n\t\t\t\tJdbcUtils.closeResultSet(rs);\n\t\t\t&#125;\n\t\t&#125;\n\t\t@Override\n\t\tpublic String getSql() &#123;\n\t\t\treturn sql;\n\t\t&#125;\n\t&#125;\n\treturn execute(new QueryStatementCallback());\n&#125;\n\n@Override\npublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;\n\tAssert.notNull(action, &quot;Callback object must not be null&quot;);\n\tConnection con &#x3D; DataSourceUtils.getConnection(getDataSource());\n\tStatement stmt &#x3D; null;\n\ttry &#123;\n\t\tConnection conToUse &#x3D; con;\n\t\tif (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;\n\t\t        this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;\n\t\t\tconToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);\n\t\t&#125;\n\t\tstmt &#x3D; conToUse.createStatement();\n\t\tapplyStatementSettings(stmt);\n\t\tStatement stmtToUse &#x3D; stmt;\n\t\tif (this.nativeJdbcExtractor !&#x3D; null) &#123;\n\t\t\tstmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);\n\t\t&#125;\n\t\tT result &#x3D; action.doInStatement(stmtToUse);\n\t\thandleWarnings(stmt);\n\t\treturn result;\n\t&#125; catch (SQLException ex) &#123;\n\t\t&#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock\n\t\t&#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.\n\t\tJdbcUtils.closeStatement(stmt);\n\t\tstmt &#x3D; null;\n\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t\tcon &#x3D; null;\n\t\tthrow getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action)\n\t&#125; finally &#123;\n\t\tJdbcUtils.closeStatement(stmt);\n\t\tDataSourceUtils.releaseConnection(con, getDataSource());\n\t&#125;\n&#125;\n\n2.3.3 应用二：setClickListener(）在客户端开发中，经常给控件注册事件监听器，比如下面这段代码，就是在 Android应用开发中，给 Button 控件的点击事件注册监听器\nButton button &#x3D; (Button)findViewById(R.id.button);\nbutton.setOnClickListener(new OnClickListener() &#123;\n\t@Override\n\tpublic void onClick(View v) &#123;\n\t\tSystem.out.println(&quot;I am clicked.&quot;);\n\t&#125;\n&#125;);\n\n从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数\n回调分为同步回调和异步回调。这里的回调算是异步回调，往 setOnClickListener() 函数中注册好回调函数之后，并不需要等待回调函数执行，这也印证了前面讲的，异步回调比较像观察者模式\n2.3.4 应用三：addShutdownHook()Hook 可以翻译成“钩子”，那它跟 Callback 有什么区别呢？\n网上有人认为 Hook 就是 Callback，两者说的是一回事儿，只是表达不同而已。而有人觉得 Hook 是 Callback 的一种应用。Callback 更侧重语法机制的描述，Hook 更加侧重应用场景的描述。作者个人比较认可后面一种说法，不过，这个也不重要，只需要见了代码能认识，遇到场景会用就可以了\nHook 比较经典的应用场景是 Tomcat 和 JVM 的 shutdown hook。这里拿 JVM 来举例说明一下。JVM 提供了 Runtime.addShutdownHook(Thread hook) 方法，可以注册一个 JVM 关闭的 Hook。当应用程序关闭的时候，JVM 会自动调用 Hook 代码。代码示例如下所示：\npublic class ShutdownHookDemo &#123;\n\tprivate static class ShutdownHook extends Thread &#123;\n\t\tpublic void run() &#123;\n\t\t\tSystem.out.println(&quot;I am called during shutting down.&quot;);\n\t\t&#125;\n\t&#125;\n\tpublic static void main(String[] args) &#123;\n\t\tRuntime.getRuntime().addShutdownHook(new ShutdownHook());\n\t&#125;\n&#125;\n\n再来看 addShutdownHook() 的代码实现，这里只给出了部分相关代码：\npublic class Runtime &#123;\n\tpublic void addShutdownHook(Thread hook) &#123;\n\t\tSecurityManager sm &#x3D; System.getSecurityManager();\n\t\tif (sm !&#x3D; null) &#123;\n\t\t\tsm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n\t\t&#125;\n\t\tApplicationShutdownHooks.add(hook);\n\t&#125;\n&#125;\nclass ApplicationShutdownHooks &#123;\n\t&#x2F;* The set of registered hooks *&#x2F;\n\tprivate static IdentityHashMap&lt;Thread, Thread&gt; hooks;\n\tstatic &#123;\n\t\thooks &#x3D; new IdentityHashMap&lt;&gt;();\n\t&#125; catch (IllegalStateException e) &#123;\n\t\thooks &#x3D; null;\n\t&#125;\n\n\tstatic synchronized void add(Thread hook) &#123;\n\t\tif(hooks &#x3D;&#x3D; null)\n\t\t\tthrow new IllegalStateException(&quot;Shutdown in progress&quot;);\n\t\tif (hook.isAlive())\n\t\t\tthrow new IllegalArgumentException(&quot;Hook already running&quot;);\n\t\tif (hooks.containsKey(hook))\n\t\t\tthrow new IllegalArgumentException(&quot;Hook previously registered&quot;);\n\t\thooks.put(hook, hook);\n\t&#125;\n\tstatic void runHooks() &#123;\n\t\tCollection&lt;Thread&gt; threads;\n\t\tsynchronized(ApplicationShutdownHooks.class) &#123;\n\t\t\tthreads &#x3D; hooks.keySet();\n\t\t\thooks &#x3D; null;\n\t\t&#125;\n\t\tfor (Thread hook : threads) &#123;\n\t\t\thook.start();\n\t\t&#125;\n\t\tfor (Thread hook : threads) &#123;\n\t\t\twhile (true) &#123;\n\t\t\t\ttry &#123;\n\t\t\t\t\thook.join();\n\t\t\t\t\tbreak;\n\t\t\t\t&#125; catch (InterruptedException ignored) &#123;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n从代码中可以发现，有关 Hook 的逻辑都被封装到 ApplicationShutdownHooks 类中了。当应用程序关闭的时候，JVM 会调用这个类的 runHooks() 方法，创建多个线程，并发地执行多个 Hook。我们在注册完 Hook 之后，并不需要等待 Hook 执行完成，所以，这也算是一种异步回调\n2.3.5 模板模式 VS 回调从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式\n从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系\n前面也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点：\n\n像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力\n回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类\n如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，只需要往用到的模板方法中注入回调对象即可\n\n3. 策略模式（Strategy Design Pattern）策略模式，英文全称是 Strategy Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：\n\n\n\n\n\n\n\n\n\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）\n工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分\n3.1 策略的定义策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：\npublic interface Strategy &#123;\n\tvoid algorithmInterface();\n&#125;\npublic class ConcreteStrategyA implements Strategy &#123;\n\t@Override\n\tpublic void algorithmInterface() &#123;\n\t\t&#x2F;&#x2F;具体的算法...\n\t&#125;\n&#125;\npublic class ConcreteStrategyB implements Strategy &#123;\n\t@Override\n\tpublic void algorithmInterface() &#123;\n\t\t&#x2F;&#x2F;具体的算法...\n\t&#125;\n&#125;\n\n3.2 策略的创建因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，需要对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。示例代码如下所示：\npublic class StrategyFactory &#123;\n\tprivate static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tstrategies.put(&quot;A&quot;, new ConcreteStrategyA());\n\t\tstrategies.put(&quot;B&quot;, new ConcreteStrategyB());\n\t&#125;\n\tpublic static Strategy getStrategy(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;type should not be empty.&quot;);\n\t\t&#125;\n\t\treturn strategies.get(type);\n\t&#125;\n&#125;\n\n一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。针对这种情况，可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回\n相反，如果策略类是有状态的，根据业务场景的需要，希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那就需要按照如下方式来实现策略工厂类\npublic class StrategyFactory &#123;\n\tpublic static Strategy getStrategy(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;type should not be empty.&quot;);\n\t\t&#125;\n\t\tif (type.equals(&quot;A&quot;)) &#123;\n\t\t\treturn new ConcreteStrategyA();\n\t\t&#125; else if (type.equals(&quot;B&quot;)) &#123;\n\t\t\treturn new ConcreteStrategyB();\n\t\t&#125;\n\t\treturn null;\n\t&#125;\n&#125;\n\n3.3 策略的使用策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景\n这里的“运行时动态”指的是，事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略\n&#x2F;&#x2F; 策略接口：EvictionStrategy\n&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory\npublic class UserCache &#123;\n\tprivate Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();\n\tprivate EvictionStrategy eviction;\n\tpublic UserCache(EvictionStrategy eviction) &#123;\n\t\tthis.eviction &#x3D; eviction;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application &#123;\n\tpublic static void main(String[] args) throws Exception &#123;\n\t\tEvictionStrategy evictionStrategy &#x3D; null;\n\t\tProperties props &#x3D; new Properties();\n\t\tprops.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));\n\t\tString type &#x3D; props.getProperty(&quot;eviction_type&quot;);\n\t\tevictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);\n\t\tUserCache userCache &#x3D; new UserCache(evictionStrategy);\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tEvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();\n\t\tUserCache userCache &#x3D; new UserCache(evictionStrategy);\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\n从上面的代码中，也可以看出，“非运行时动态确定”，也就是第二个 Application 中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”\n3.4 如何利用策略模式避免分支判断？实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。先看下例：\npublic class OrderService &#123;\n\tpublic double discount(Order order) &#123;\n\t\tdouble discount &#x3D; 0.0;\n\t\tOrderType type &#x3D; order.getType();\n\t\tif (type.equals(OrderType.NORMAL)) &#123; &#x2F;&#x2F; 普通订单\n\t\t\t&#x2F;&#x2F;...省略折扣计算算法代码\n\t\t&#125; else if (type.equals(OrderType.GROUPON)) &#123; &#x2F;&#x2F; 团购订单\n\t\t\t&#x2F;&#x2F;...省略折扣计算算法代码\n\t\t&#125; else if (type.equals(OrderType.PROMOTION)) &#123; &#x2F;&#x2F; 促销订单\n\t\t\t&#x2F;&#x2F;...省略折扣计算算法代码\n\t\t&#125;\n\t\treturn discount;\n\t&#125;\n&#125;\n\n如何来移除掉分支判断逻辑呢？那策略模式就派上用场了。使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的代码如下所示：\n&#x2F;&#x2F; 策略的定义\npublic interface DiscountStrategy &#123;\n\tdouble calDiscount(Order order);\n&#125;\n&#x2F;&#x2F; 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrateg\n&#x2F;&#x2F; 策略的创建\npublic class DiscountStrategyFactory &#123;\n\tprivate static final Map&lt;OrderType, DiscountStrategy&gt; strategies &#x3D; new HashMa\n\tstatic &#123;\n\t\tstrategies.put(OrderType.NORMAL, new NormalDiscountStrategy());\n\t\tstrategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());\n\t\tstrategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());\n\t&#125;\n\tpublic static DiscountStrategy getDiscountStrategy(OrderType type) &#123;\n\t\treturn strategies.get(type);\n\t&#125;\n&#125;\n&#x2F;&#x2F; 策略的使用\npublic class OrderService &#123;\n\tpublic double discount(Order order) &#123;\n\t\tOrderType type &#x3D; order.getType();\n\t\tDiscountStrategy discountStrategy &#x3D; DiscountStrategyFactory.getDiscountStrategy(type);\n\t\treturn discountStrategy.calDiscount(order);\n\t&#125;\n&#125;\n\n\n重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。包括使用状态模式来避免分支判断逻辑，它们使用的是同样的套路。本质上都是借助“查表法”，根据 type 查表（代码中的 strategies 就是表）替代根据 type 分支判断\n但是，如果业务场景需要每次都创建不同的策略对象，就要用另外一种工厂类的实现方式了。具体的代码如下所示：\npublic class DiscountStrategyFactory &#123;\n\tpublic static DiscountStrategy getDiscountStrategy(OrderType type) &#123;\n\t\tif (type &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;Type should not be null.&quot;);\n\t\t&#125;\n\t\tif (type.equals(OrderType.NORMAL)) &#123;\n\t\t\treturn new NormalDiscountStrategy();\n\t\t&#125; else if (type.equals(OrderType.GROUPON)) &#123;\n\t\t\treturn new GrouponDiscountStrategy();\n\t\t&#125; else if (type.equals(OrderType.PROMOTION)) &#123;\n\t\t\treturn new PromotionDiscountStrategy();\n\t\t&#125;\n\t\treturn null;\n\t&#125;\n&#125;\n\n这种实现方式相当于把原来的 if-else 分支逻辑，从 OrderService 类中转移到了工厂类中，实际上并没有真正将它移除，有没有什么办法解决呢？可见 3.5 结尾部分\n3.5 如何实现一个支持给不同大小文件排序的小程序？假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。如何来实现呢？\n这时可能会说，这不是很简单嘛，只需要将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了\n但是，如果文件很大呢？比如有 10GB 大小，因为内存有限（比如只有 8GB 大小），没办法一次性加载文件中的所有数据到内存中，这个时候，就要利用外部排序算法\n如果文件更大，比如有 100GB 大小，为了利用 CPU 多核的优势，可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的 MapReduce\n如果文件非常大，比如有 1TB 大小，即便是单机多线程排序，这也算很慢了。这个时候，可以使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率\n1、代码实现与分析\n先用最简单直接的方式实现如下，这里省略了每种排序算法的具体代码实现：\npublic class Sorter &#123;\n\tprivate static final long GB &#x3D; 1000 * 1000 * 1000;\n\tpublic void sortFile(String filePath) &#123;\n\t\t&#x2F;&#x2F; 省略校验逻辑\n\t\tFile file &#x3D; new File(filePath);\n\t\tlong fileSize &#x3D; file.length();\n\t\tif (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n\t\t\tquickSort(filePath);\n\t\t&#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n\t\t\texternalSort(filePath);\n\t\t&#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n\t\t\tconcurrentExternalSort(filePath);\n\t\t&#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n\t\t\tmapreduceSort(filePath);\n\t\t&#125;\n\t&#125;\n\tprivate void quickSort(String filePath) &#123;\n\t\t&#x2F;&#x2F; 快速排序\n\t&#125;\n\tprivate void externalSort(String filePath) &#123;\n\t\t&#x2F;&#x2F; 外部排序\n\t&#125;\n\tprivate void concurrentExternalSort(String filePath) &#123;\n\t\t&#x2F;&#x2F; 多线程外部排序\n\t&#125;\n\tprivate void mapreduceSort(String filePath) &#123;\n\t\t&#x2F;&#x2F; 利用MapReduce多机排序\n\t&#125;\n&#125;\npublic class SortingTool &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSorter sorter &#x3D; new Sorter();\n\t\tsorter.sortFile(args[0]);\n\t&#125;\n&#125;\n\n如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果是在开发一个大型项目，排序文件只是其中的一个功能模块，那就要在代码设计、代码质量上下点儿功夫了。只有每个小的功能模块都写好，整个项目的代码才能不差\n在上面的代码中，并没有给出每种排序算法的代码实现。实际上，如果自己实现一下的话，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有排序算法的代码实现都堆在 Sorter 一个类中，这就会导致这个类的代码很多。而在“编码规范”那一部分中也讲到（见 (设计模式之美总结（重构篇）_凡 223 的博客 ），一个类的代码太多也会影响到可读性、可维护性。除此之外，所有的排序算法都设计成 Sorter 的私有函数，也会影响代码的可复用性\n2、代码优化与重构\n只要掌握了之前讲过的设计原则和思想（详细可见本文章开头引入的前几篇文章），针对上面的问题，即便想不到该用什么设计模式来重构，也应该能知道该如何解决，那就是将 Sorter 类中的某些代码拆分出来，独立成职责更加单一的小类。实际上，拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。按照这个解决思路，对代码进行重构。重构之后的代码如下所示：\npublic interface ISortAlg &#123;\n\tvoid sort(String filePath);\n&#125;\npublic class QuickSort implements ISortAlg &#123;\n\t@Override\n\tpublic void sort(String filePath) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ExternalSort implements ISortAlg &#123;\n\t@Override\n\tpublic void sort(String filePath) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ConcurrentExternalSort implements ISortAlg &#123;\n\t@Override\n\tpublic void sort(String filePath) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class MapReduceSort implements ISortAlg &#123;\n\t@Override\n\tpublic void sort(String filePath) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\npublic class Sorter &#123;\n\tprivate static final long GB &#x3D; 1000 * 1000 * 1000;\n\tpublic void sortFile(String filePath) &#123;\n\t\t&#x2F;&#x2F; 省略校验逻辑\n\t\tFile file &#x3D; new File(filePath);\n\t\tlong fileSize &#x3D; file.length();\n\t\tISortAlg sortAlg;\n\t\tif (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n\t\t\tsortAlg &#x3D; new QuickSort();\n\t\t&#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n\t\t\tsortAlg &#x3D; new ExternalSort();\n\t\t&#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n\t\t\tsortAlg &#x3D; new ConcurrentExternalSort();\n\t\t&#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n\t\t\tsortAlg &#x3D; new MapReduceSort();\n\t\t&#125;\n\t\tsortAlg.sort(filePath);\n\t&#125;\n&#125;\n\n经过拆分之后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。除此之外，我们将排序算法设计成独立的类，跟具体的业务逻辑（代码中的 if-else 那部分逻辑）解耦，也让排序算法能够复用。这一步实际上就是策略模式的第一步，也就是将策略的定义分离出来\n实际上，上面的代码还可以继续优化。每种排序类都是无状态的，没必要在每次使用的时候，都重新创建一个新的对象。所以，可以使用工厂模式对对象的创建进行封装。按照这个思路，对代码进行重构。重构之后的代码如下所示：\npublic class SortAlgFactory &#123;\n\tprivate static final Map&lt;String, ISortAlg&gt; algs &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\talgs.put(&quot;QuickSort&quot;, new QuickSort());\n\t\talgs.put(&quot;ExternalSort&quot;, new ExternalSort());\n\t\talgs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());\n\t\talgs.put(&quot;MapReduceSort&quot;, new MapReduceSort());\n\t&#125;\n\tpublic static ISortAlg getSortAlg(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;type should not be empty.&quot;);\n\t\t&#125;\n\t\treturn algs.get(type);\n\t&#125;\n&#125;\npublic class Sorter &#123;\n\tprivate static final long GB &#x3D; 1000 * 1000 * 1000;\n\tpublic void sortFile(String filePath) &#123;\n\t\t&#x2F;&#x2F; 省略校验逻辑\n\t\tFile file &#x3D; new File(filePath);\n\t\tlong fileSize &#x3D; file.length();\n\t\tISortAlg sortAlg;\n\t\tif (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n\t\t\tsortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);\n\t\t&#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n\t\t\tsortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);\n\t\t&#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n\t\t\tsortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);\n\t\t&#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n\t\t\tsortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);\n\t\t&#125;\n\t\tsortAlg.sort(filePath);\n\t&#125;\n&#125;\n\n经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter 类中的 sortFile() 函数还是有一堆 if-else 逻辑。这里的 if-else 逻辑分支不多、也不复杂，这样写完全没问题。但如果特别想将 if-else 分支判断移除掉，那也是有办法的，代码如下。实际上，这也是基于查表法来解决的，其中的“algs”就是“表”\npublic class Sorter &#123;\n\tprivate static final long GB &#x3D; 1000 * 1000 * 1000;\n\tprivate static final List&lt;AlgRange&gt; algs &#x3D; new ArrayList&lt;&gt;();\n\tstatic &#123;\n\t\talgs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));\n\t\talgs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));\n\t\talgs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));\n\t\talgs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));\n\t&#125;\n\tpublic void sortFile(String filePath) &#123;\n\t\t&#x2F;&#x2F; 省略校验逻辑\n\t\tFile file &#x3D; new File(filePath);\n\t\tlong fileSize &#x3D; file.length();\n\t\tISortAlg sortAlg &#x3D; null;\n\t\tfor (AlgRange algRange : algs) &#123;\n\t\t\tif (algRange.inRange(fileSize)) &#123;\n\t\t\t\tsortAlg &#x3D; algRange.getAlg();\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tsortAlg.sort(filePath);\n\t&#125;\n\tprivate static class AlgRange &#123;\n\t\tprivate long start;\n\t\tprivate long end;\n\t\tprivate ISortAlg alg;\n\t\tpublic AlgRange(long start, long end, ISortAlg alg) &#123;\n\t\t\tthis.start &#x3D; start;\n\t\t\tthis.end &#x3D; end;\n\t\t\tthis.alg &#x3D; alg;\n\t\t&#125;\n\t\tpublic ISortAlg getAlg() &#123;\n\t\t\treturn alg;\n\t\t&#125;\n\t\tpublic boolean inRange(long size) &#123;\n\t\t\treturn size &gt;&#x3D; start &amp;&amp; size &lt; end;\n\t\t&#125;\n\t&#125;\n&#125;\n\n现在的代码实现就更加优美了。把可变的部分隔离到了策略工厂类和 Sorter 类中的静态代码段中。当要添加一个新的排序算法时，只需要修改策略工厂类和 Sort 类中的静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了\n这时可能会说，即便这样，当添加新的排序算法的时候，还是需要修改代码，并不完全符合开闭原则。有什么办法能完全满足开闭原则呢？\n对于 Java 语言来说，可以通过反射来避免对策略工厂类的修改。具体是这么做的：通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射了动态地加载这些策略类、创建策略对象；当新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。前面 3.4 提到的问题也可以用这种方法来解决\n对于 Sorter 来说，可以通过同样的方法来避免修改。通过将文件大小区间和算法之间的对应关系放到配置文件中。当添加新的排序算法时，只需要改动配置文件即可，不需要改动代码\n一提到 if-else 分支判断，有人就觉得它是烂代码。如果 if-else 分支判断不复杂、代码不多，这并没有任何问题，毕竟 if-else 分支判断几乎是所有编程语言都会提供的语法，存在即有理由。遵循 KISS 原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出 n 多类，反倒是一种过度设计\n一提到策略模式，有人就觉得，它的作用是避免 if-else 分支判断逻辑。实际上，这种认识是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险\n实际上，设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，就能更清楚的了解，为什么要用某种设计模式，就能更恰到好处地应用设计模式\n4. 职责链模式（Chain Of Responsibility Design Pattern）前面讲到了模板模式、策略模式，接下来是职责链模式。这三种模式具有相同的作用：复用和扩展，在实际的项目开发中比较常用，特别是框架开发中，可以利用它们来提供框架的扩展点，能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能\n4.1 原理和实现职责链模式的英文翻译是 Chain Of Responsibility Design Pattern。在 GoF 的《设计模式》中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nAvoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止\n在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式\n职责链模式有多种实现方式，这里介绍两种比较常用的。第一种实现方式如下所示。其中，Handler 是所有处理器类的抽象父类，handle() 是抽象方法。每个具体的处理器类（HandlerA、HandlerB）的 handle() 函数的代码结构类似，如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也就是调用 successor.handle()）。HandlerChain 是处理器链，从数据结构的角度来看，它就是一个记录了链头、链尾的链表。其中，记录链尾是为了方便添加处理器\npublic abstract class Handler &#123;\n\tprotected Handler successor &#x3D; null;\n\tpublic void setSuccessor(Handler successor) &#123;\n\t\tthis.successor &#x3D; successor;\n\t&#125;\n\tpublic abstract void handle();\n&#125;\npublic class HandlerA extends Handler &#123;\n\t@Override\n\tpublic boolean handle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\tif (!handled &amp;&amp; successor !&#x3D; null) &#123;\n\t\t\tsuccessor.handle();\n\t\t&#125;\n\t&#125;\n&#125;\npublic class HandlerB extends Handler &#123;\n\t@Override\n\tpublic void handle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\tif (!handled &amp;&amp; successor !&#x3D; null) &#123;\n\t\t\tsuccessor.handle();\n\t\t&#125;\n\t&#125;\n&#125;\npublic class HandlerChain &#123;\n\tprivate Handler head &#x3D; null;\n\tprivate Handler tail &#x3D; null;\n\tpublic void addHandler(Handler handler) &#123;\n\t\thandler.setSuccessor(null);\n\t\tif (head &#x3D;&#x3D; null) &#123;\n\t\t\thead &#x3D; handler;\n\t\t\ttail &#x3D; handler;\n\t\t\treturn;\n\t\t&#125;\n\t\ttail.setSuccessor(handler);\n\t\ttail &#x3D; handler;\n\t&#125;\n\tpublic void handle() &#123;\n\t\tif (head !&#x3D; null) &#123;\n\t\t\thead.handle();\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tHandlerChain chain &#x3D; new HandlerChain();\n\t\tchain.addHandler(new HandlerA());\n\t\tchain.addHandler(new HandlerB());\n\t\tchain.handle();\n\t&#125;\n&#125;\n\n\n实际上，上面的代码实现不够优雅。处理器类的 handle() 函数，不仅包含自己的业务逻辑，还包含对下一个处理器的调用，也就是代码中的 successor.handle()。一个不熟悉这种代码结构的程序员，在添加新的处理器类的时候，很有可能忘记在 handle() 函数中调用 successor.handle()，这就会导致代码出现 bug\n针对这个问题，对代码进行重构，利用模板模式，将调用 successor.handle() 的逻辑从具体的处理器类中剥离出来，放到抽象父类中。这样具体的处理器类只需要实现自己的业务逻辑就可以了。重构之后的代码如下：\npublic abstract class Handler &#123;\n\tprotected Handler successor &#x3D; null;\n\tpublic void setSuccessor(Handler successor) &#123;\n\t\tthis.successor &#x3D; successor;\n\t&#125;\n\tpublic final void handle() &#123;\n\t\tboolean handled &#x3D; doHandle();\n\t\tif (successor !&#x3D; null &amp;&amp; !handled) &#123;\n\t\t\tsuccessor.handle();\n\t\t&#125;\n\t&#125;\n\tprotected abstract boolean doHandle();\n&#125;\npublic class HandlerA extends Handler &#123;\n\t@Override\n\tprotected boolean doHandle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerB extends Handler &#123;\n\t@Override\n\tprotected boolean doHandle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\n&#x2F;&#x2F; HandlerChain和Application代码不变\n\n再来看第二种实现方式，代码如下所示。这种实现方式更加简单。HandlerChain 类用数组而非链表来保存所有的处理器，并且需要在 HandlerChain 的 handle() 函数中，依次调用每个处理器的 handle() 函数\npublic interface IHandler &#123;\n\tboolean handle();\n&#125;\npublic class HandlerA implements IHandler &#123;\n\t@Override\n\tpublic boolean handle() &#123;\n\t\tboolean handled &#x3D; false;\n\t\t&#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerB implements IHandler &#123;\n\t@Override\n\tpublic boolean handle() &#123;\n\t\tboolean handled &#x3D; false;\n                &#x2F;&#x2F;...\n\t\treturn handled;\n\t&#125;\n&#125;\npublic class HandlerChain &#123;\n\tprivate List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();\n\tpublic void addHandler(IHandler handler) &#123;\n\t\tthis.handlers.add(handler);\n\t&#125;\n\tpublic void handle() &#123;\n\t\tfor (IHandler handler : handlers) &#123;\n\t\t\tboolean handled &#x3D; handler.handle();\n\t\t\tif (handled) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tHandlerChain chain &#x3D; new HandlerChain();\n\t\tchain.addHandler(new HandlerA());\n\t\tchain.addHandler(new HandlerB());\n\t\tchain.handle();\n\t&#125;\n&#125;\n\n在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可\n这里给出其中一种，用链表存储处理器的实现方式，如下所示：\npublic abstract class Handler &#123;\n\tprotected Handler successor &#x3D; null;\n\tpublic void setSuccessor(Handler successor) &#123;\n\t\tthis.successor &#x3D; successor;\n\t&#125;\n\tpublic final void handle() &#123;\n\t\tdoHandle();\n\t\tif (successor !&#x3D; null) &#123;\n\t\t\tsuccessor.handle();\n\t\t&#125;\n\t&#125;\n\tprotected abstract void doHandle();\n&#125;\npublic class HandlerA extends Handler &#123;\n\t@Override\n\tprotected void doHandle() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class HandlerB extends Handler &#123;\n\t@Override\n\tprotected void doHandle() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class HandlerChain &#123;\n\tprivate Handler head &#x3D; null;\n\tprivate Handler tail &#x3D; null;\n\tpublic void addHandler(Handler handler) &#123;\n\t\thandler.setSuccessor(null);\n\t\tif (head &#x3D;&#x3D; null) &#123;\n\t\t\thead &#x3D; handler;\n\t\t\ttail &#x3D; handler;\n\t\t\treturn;\n\t\t&#125;\n\t\ttail.setSuccessor(handler);\n\t\ttail &#x3D; handler;\n\t&#125;\n\tpublic void handle() &#123;\n\t\tif (head !&#x3D; null) &#123;\n\t\t\thead.handle();\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tHandlerChain chain &#x3D; new HandlerChain();\n\t\tchain.addHandler(new HandlerA());\n\t\tchain.addHandler(new HandlerB());\n\t\tchain.handle();\n\t&#125;\n&#125;\n\n4.2 应用场景对于支持 UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，就可以利用职责链模式来过滤这些敏感词\n对于包含敏感词的内容，有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链模式的定义，第二种处理方式是职责链模式的变体\n这里只给出第一种实现方式的代码示例，如下所示，并且只给出了代码实现的骨架，具体的敏感词过滤算法并没有给出：\npublic interface SensitiveWordFilter &#123;\n\tboolean doFilter(Content content);\n&#125;\npublic class SexyWordFilter implements SensitiveWordFilter &#123;\n\t@Override\n\tpublic boolean doFilter(Content content) &#123;\n\t\tboolean legal &#x3D; true;\n\t\t&#x2F;&#x2F;...\n\t\treturn legal;\n\t&#125;\n&#125;\n&#x2F;&#x2F; PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似\npublic class SensitiveWordFilterChain &#123;\n\tprivate List&lt;SensitiveWordFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n\tpublic void addFilter(SensitiveWordFilter filter) &#123;\n\t\tthis.filters.add(filter);\n\t&#125;\n\t&#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.\n\tpublic boolean filter(Content content) &#123;\n\t\tfor (SensitiveWordFilter filter : filters) &#123;\n\t\t\tif (!filter.doFilter(content)) &#123;\n\t\t\t\treturn false;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n&#125;\npublic class ApplicationDemo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSensitiveWordFilterChain filterChain &#x3D; new SensitiveWordFilterChain();\n\t\tfilterChain.addFilter(new AdsWordFilter());\n\t\tfilterChain.addFilter(new SexyWordFilter());\n\t\tfilterChain.addFilter(new PoliticalWordFilter());\n\t\tboolean legal &#x3D; filterChain.filter(new Content());\n\t\tif (!legal) &#123;\n\t\t\t&#x2F;&#x2F; 不发表\n\t\t&#125; else &#123;\n\t\t\t&#x2F;&#x2F; 发表\n\t\t&#125;\n\t&#125;\n&#125;\n\n看了上面的实现可能会说，像下面这样也可以实现敏感词过滤功能，而且代码更加简单，为什么非要使用职责链模式呢？这是不是过度设计呢？\npublic class SensitiveWordFilter &#123;\n\t&#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.\n\tpublic boolean filter(Content content) &#123;\n\t\tif (!filterSexyWord(content)) &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\tif (!filterAdsWord(content)) &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\tif (!filterPoliticalWord(content)) &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\tprivate boolean filterSexyWord(Content content) &#123;\n\t\t&#x2F;&#x2F;....\n\t&#125;\n\tprivate boolean filterAdsWord(Content content) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tprivate boolean filterPoliticalWord(Content content) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\n应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性。这里应用职责链模式也不例外。实际上，在前面讲到策略模式的时候，也讲过类似的问题，比如，为什么要用策略模式？当时的给出的理由，与现在应用职责链模式的理由，几乎是一样的\n首先，来看职责链模式如何应对代码的复杂性\n将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂\n其次，再来看职责链模式如何让代码满足开闭原则，提高代码的扩展性\n当要扩展新的过滤算法的时候，比如，还需要过滤特殊符号，按照非职责链模式的代码实现方式，需要修改 SensitiveWordFilter 的代码，违反开闭原则。不过，这样的修改还算比较集中，也是可以接受的。而职责链模式的实现方式更加优雅，只需要新添加一个 Filter 类，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不需要修改\n不过可能会说，即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改客户端代码（ApplicationDemo），这样做也没有完全符合开闭原则\n实际上，细化一下的话，可以把上面的代码分成两类：框架代码和客户端代码。其中，ApplicationDemo 属于客户端代码，也就是使用框架的代码。除 ApplicationDemo 之外的代码属于敏感词过滤框架代码\n假设敏感词过滤框架并不是我们开发维护的，而是引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，在框架这个代码范围内实现了开闭原则\n除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是配置过滤算法更加灵活，可以只选择使用某几个过滤算法\n4.3 Servlet Filter前面提到，职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器\nServlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支持过滤器功能。工作原理图如下所示：\n\n在实际项目中该如何使用 Servlet Filter 呢？简单的示例代码如下。添加一个过滤器，只需要定义一个实现 javax.servlet.Filter 接口的过滤器类，并且将它配置在 web.xml 配置文件中。Web 容器启动的时候，会读取 web.xml 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理\npublic class LogFilter implements Filter &#123;\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException &#123;\n\t\t&#x2F;&#x2F; 在创建Filter时自动调用，\n\t\t&#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）\n\t&#125;\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response, Filte\n\t                     System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n\t                     chain.doFilter(request, response);\n\t                     System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n\t                     @Override\n\tpublic void destroy() &#123;\n\t\t&#x2F;&#x2F; 在销毁Filter时自动调用\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 在web.xml配置文件中如下配置：\n&lt;filter&gt;\n    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n从刚刚的示例代码中可以发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现 javax.servlet.Filter 的类，再改改配置就搞定了，完全符合开闭原则。那 Servlet Filter 是如何做到如此好的扩展性的呢？它利用的就是职责链模式。现在，通过剖析它的源码，详细地看看它底层是如何实现的\n前面讲到，职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter，javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。接下来，重点来看 FilterChain 是如何实现的\n不过，Servlet 只是一个规范，并不包含具体的实现，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示，这里对代码进行了简化，只保留了跟设计思路相关的代码片段\npublic final class ApplicationFilterChain implements FilterChain &#123;\n\tprivate int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter\n\tprivate int n; &#x2F;&#x2F;filter的个数\n\tprivate ApplicationFilterConfig[] filters;\n\tprivate Servlet servlet;\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response) &#123;\n\t\tif (pos &lt; n) &#123;\n\t\t\tApplicationFilterConfig filterConfig &#x3D; filters[pos++];\n\t\t\tFilter filter &#x3D; filterConfig.getFilter();\n\t\t\tfilter.doFilter(request, response, this);\n\t\t&#125; else &#123;\n\t\t\t&#x2F;&#x2F; filter都处理完毕后，执行servlet\n\t\t\tservlet.service(request, response);\n\t\t&#125;\n\t&#125;\n\tpublic void addFilter(ApplicationFilterConfig filterConfig) &#123;\n\t\tfor (ApplicationFilterConfig filter:filters)\n\t\t\tif (filter&#x3D;&#x3D;filterConfig)\n\t\t\t\treturn;\n\t\tif (n &#x3D;&#x3D; filters.length) &#123;&#x2F;&#x2F;扩容\n\t\t\tApplicationFilterConfig[] newFilters &#x3D; new ApplicationFilterConfig[n + IN\n\t\t\t        System.arraycopy(filters, 0, newFilters, 0, n);\n\t\t\t        filters &#x3D; newFilters;\n\t\t&#125;\n\t\tfilters[n++] &#x3D; filterConfig;\n\t&#125;\n&#125;\n\nApplicationFilterChain 中的 doFilter() 函数的代码实现比较有技巧，实际上是一个递归调用。可以用每个 Filter（比如 LogFilter）的 doFilter() 的代码实现，直接替换ApplicationFilterChain 的第 12 行代码，一眼就能看出是递归调用了\n@Override\npublic void doFilter(ServletRequest request, ServletResponse response) &#123;\n\tif (pos &lt; n) &#123;\n\t\tApplicationFilterConfig filterConfig &#x3D; filters[pos++];\n\t\tFilter filter &#x3D; filterConfig.getFilter();\n\t\t&#x2F;&#x2F;filter.doFilter(request, response, this);\n\t\t&#x2F;&#x2F;把filter.doFilter的代码实现展开替换到这里\n\t\tSystem.out.println(&quot;拦截客户端发送来的请求.&quot;);\n\t\tchain.doFilter(request, response); &#x2F;&#x2F; chain就是this\n\t\tSystem.out.println(&quot;拦截发送给客户端的响应.&quot;)\n\t&#125; else &#123;\n\t\t&#x2F;&#x2F; filter都处理完毕后，执行servlet\n\t\tservlet.service(request, response);\n\t&#125;\n&#125;\n\n这样实现主要是为了在一个 doFilter() 方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应。而前面原理和实现部分给出的责任链两种实现方式，都没法做到在业务逻辑执行的前后，同时添加处理代码\n4.4 Spring InterceptorSpring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上可以看作一个概念，都用来实现对 HTTP 请求进行拦截处理\n它们不同之处在于，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具体的业务代码中。一个请求的处理流程具体如下所示：\n\n在项目中该如何使用 Spring Interceptor 呢？简单的示例代码如下所示。LogInterceptor 实现的功能跟刚才的 LogFilter 完全相同，只是实现方式上稍有区别。LogFilter 对请求和响应的拦截是在 doFilter() 一个函数中实现的，而 LogInterceptor 对请求的拦截在 preHandle() 中实现，对响应的拦截在 postHandle() 中实现\npublic class LogInterceptor implements HandlerInterceptor &#123;\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response) &#123;\n\t\tSystem.out.println(&quot;拦截客户端发送来的请求.&quot;);\n\t\treturn true; &#x2F;&#x2F; 继续后续的处理\n\t&#125;\n\t@Override\n\tpublic void postHandle(HttpServletRequest request, HttpServletResponse response) &#123;\n\t\tSystem.out.println(&quot;拦截发送给客户端的响应.&quot;);\n\t&#125;\n\t@Override\n\tpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response) &#123;\n\t\tSystem.out.println(&quot;这里总是被执行.&quot;);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;在Spring MVC配置文件中配置interceptors\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;*&quot;&#x2F;&gt;\n        &lt;bean class&#x3D;&quot;com.xzg.cd.LogInterceptor&quot; &#x2F;&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n&lt;&#x2F;mvc:interceptors&gt;\n\n同样，还是来剖析一下，Spring Interceptor 底层是如何实现的：\n当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain 类是职责链模式中的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain 的源码如下所示，同样，这里也对代码也进行了一些简化，只保留了关键代码\npublic class HandlerExecutionChain &#123;\n\tprivate final Object handler;\n\tprivate HandlerInterceptor[] interceptors;\n\tpublic void addInterceptor(HandlerInterceptor interceptor) &#123;\n\t\tinitInterceptorList().add(interceptor);\n\t&#125;\n\tboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) &#123;\n\t\tHandlerInterceptor[] interceptors &#x3D; getInterceptors();\n\t\tif (!ObjectUtils.isEmpty(interceptors)) &#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;\n\t\t\t\tHandlerInterceptor interceptor &#x3D; interceptors[i];\n\t\t\t\tif (!interceptor.preHandle(request, response, this.handler)) &#123;\n\t\t\t\t\ttriggerAfterCompletion(request, response, null);\n\t\t\t\t\treturn false;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\tvoid applyPostHandle(HttpServletRequest request, HttpServletResponse response) &#123;\n\t\tHandlerInterceptor[] interceptors &#x3D; getInterceptors();\n\t\tif (!ObjectUtils.isEmpty(interceptors)) &#123;\n\t\t\tfor (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;\n\t\t\t\tHandlerInterceptor interceptor &#x3D; interceptors[i];\n\t\t\t\tinterceptor.postHandle(request, response, this.handler, mv);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tvoid triggerAfterCompletion(HttpServletRequest request, HttpServletResponse re\n\tthrows Exception &#123;\n\t\tHandlerInterceptor[] interceptors &#x3D; getInterceptors();\n\t\tif (!ObjectUtils.isEmpty(interceptors)) &#123;\n\t\t\tfor (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;\n\t\t\t\tHandlerInterceptor interceptor &#x3D; interceptors[i];\n\t\t\t\ttry &#123;\n\t\t\t\t\tinterceptor.afterCompletion(request, response, this.handler, ex);\n\t\t\t\t&#125; catch (Throwable ex2) &#123;\n\t\t\t\t\tlogger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能\n5. 状态模式（State Design Pattern）在实际的软件开发中，状态模式并不是很常用，但是在能够用到的场景里，它可以发挥很大的作用。从这一点上来看，它有点像之前讲到的组合模式（见：**设计模式之美总结（结构型篇）_凡 223 的博客**）\n状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。接下来就详细讲讲这几种实现方式，并且对比一下它们的优劣和应用场景\n5.1 什么是有限状态机？有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作\n比如“超级马里奥”，在游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分\n实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）\n这里对游戏背景做了简化，只保留了部分状态和事件。简化之后的状态转移如下图所示\n\n如何编程来实现上面的状态机呢？换句话说，如何将上面的状态转移图翻译成代码呢？\n骨架代码如下所示。其中，obtainMushRoom()、obtainCape()、obtainFireFlower()、meetMonster() 这几个函数，能够根据当前的状态和事件，更新状态和增减积分。不过，具体的代码实现暂时并没有给出\npublic enum State &#123;\n\tSMALL(0),\n\tSUPER(1),\n\tFIRE(2),\n\tCAPE(3);\n\tprivate int value;\n\tprivate State(int value) &#123;\n\t\tthis.value &#x3D; value;\n\t&#125;\n\tpublic int getValue() &#123;\n\t\treturn this.value;\n\t&#125;\n&#125;\n\npublic class MarioStateMachine &#123;\n\tprivate int score;\n\tprivate State currentState;\n\n\tpublic MarioStateMachine() &#123;\n\t\tthis.score &#x3D; 0;\n\t\tthis.currentState &#x3D; State.SMALL;\n\t&#125;\n\n\tpublic void obtainMushRoom() &#123;\n\t\t&#x2F;&#x2F;TODO\n\t&#125;\n\n\tpublic void obtainCape() &#123;\n\t\t&#x2F;&#x2F;TODO\n\t&#125;\n\n\tpublic void obtainFireFlower() &#123;\n\t\t&#x2F;&#x2F;TODO\n\t&#125;\n\n\tpublic void meetMonster() &#123;\n\t\t&#x2F;&#x2F;TODO\n\t&#125;\n\n\tpublic int getScore() &#123;\n\t\treturn this.score;\n\t&#125;\n\n\tpublic State getCurrentState() &#123;\n\t\treturn this.currentState;\n\t&#125;\n&#125;\n\npublic class ApplicationDemo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tMarioStateMachine mario &#x3D; new MarioStateMachine();\n\t\tmario.obtainMushRoom();\n\t\tint score &#x3D; mario.getScore();\n\t\tState state &#x3D; mario.getCurrentState();\n\t\tSystem.out.println(&quot;mario score: &quot; + score + &quot;; state: &quot; + state)\n\t&#125;\n&#125;\n\n5.2 状态机实现方式一：分支逻辑法对于如何实现状态机，这里总结了三种方式。其中，最简单直接的实现方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，把这种方法暂且命名为分支逻辑法\npublic class MarioStateMachine &#123;\n\tprivate int score;\n\tprivate State currentState;\n\tpublic MarioStateMachine() &#123;\n\t\tthis.score &#x3D; 0;\n\t\tthis.currentState &#x3D; State.SMALL;\n\t&#125;\n\tpublic void obtainMushRoom() &#123;\n\t\tif (currentState.equals(State.SMALL)) &#123;\n\t\t\tthis.currentState &#x3D; State.SUPER;\n\t\t\tthis.score +&#x3D; 100;\n\t\t&#125;\n\t&#125;\n\tpublic void obtainCape() &#123;\n\t\tif (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;\n\t\t\tthis.currentState &#x3D; State.CAPE;\n\t\t\tthis.score +&#x3D; 200;\n\t\t&#125;\n\t&#125;\n\tpublic void obtainFireFlower() &#123;\n\t\tif (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;\n\t\t\tthis.currentState &#x3D; State.FIRE;\n\t\t\tthis.score +&#x3D; 300;\n\t\t&#125;\n\t&#125;\n\tpublic void meetMonster() &#123;\n\t\tif (currentState.equals(State.SUPER)) &#123;\n\t\t\tthis.currentState &#x3D; State.SMALL;\n\t\t\tthis.score -&#x3D; 100;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (currentState.equals(State.CAPE)) &#123;\n\t\t\tthis.currentState &#x3D; State.SMALL;\n\t\t\tthis.score -&#x3D; 200;\n\t\t\treturn;\n\t\t&#125;\n\t\tif (currentState.equals(State.FIRE)) &#123;\n\t\t\tthis.currentState &#x3D; State.SMALL;\n\t\t\tthis.score -&#x3D; 300;\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n\tpublic int getScore() &#123;\n\t\treturn this.score;\n\t&#125;\n\tpublic State getCurrentState() &#123;\n\t\treturn this.currentState;\n\t&#125;\n&#125;\n\n对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 if\u0002else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 bug\n5.3 状态机实现方式二：查表法实际上，上面这种实现方法有点类似 hard code，对于复杂的状态机来说不适用，而状态机的第二种实现方式查表法，就更加合适了\n实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作\n\n相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上，如果把这两个二维数组存储在配置文件中，当需要修改状态机时，甚至可以不修改任何代码，只需要修改配置文件就可以了。具体的代码如下所示：\npublic enum Event &#123;\n\tGOT_MUSHROOM(0),\n\tGOT_CAPE(1),\n\tGOT_FIRE(2),\n\tMET_MONSTER(3);\n\tprivate int value;\n\tprivate Event(int value) &#123;\n\t\tthis.value &#x3D; value;\n\t&#125;\n\tpublic int getValue() &#123;\n\t\treturn this.value;\n\t&#125;\n&#125;\npublic class MarioStateMachine &#123;\n\tprivate int score;\n\tprivate State currentState;\n\tprivate static final State[][] transitionTable &#x3D; &#123;\n\t\t&#123;SUPER, CAPE, FIRE, SMALL&#125;,\n\t\t&#123;SUPER, CAPE, FIRE, SMALL&#125;,\n\t\t&#123;CAPE, CAPE, CAPE, SMALL&#125;,\n\t\t&#123;FIRE, FIRE, FIRE, SMALL&#125;\n\t&#125;;\n\tprivate static final int[][] actionTable &#x3D; &#123;\n\t\t&#123;+100, +200, +300, +0&#125;,\n\t\t&#123;+0, +200, +300, -100&#125;,\n\t\t&#123;+0, +0, +0, -200&#125;,\n\t\t&#123;+0, +0, +0, -300&#125;\n\t&#125;;\n\tpublic MarioStateMachine() &#123;\n\t\tthis.score &#x3D; 0;\n\t\tthis.currentState &#x3D; State.SMALL;\n\t&#125;\n\tpublic void obtainMushRoom() &#123;\n\t\texecuteEvent(Event.GOT_MUSHROOM);\n\t&#125;\n\tpublic void obtainCape() &#123;\n\t\texecuteEvent(Event.GOT_CAPE);\n\t&#125;\n\tpublic void obtainFireFlower() &#123;\n\t\texecuteEvent(Event.GOT_FIRE);\n\t&#125;\n\tpublic void meetMonster() &#123;\n\t\texecuteEvent(Event.MET_MONSTER);\n\t&#125;\n\tprivate void executeEvent(Event event) &#123;\n\t\tint stateValue &#x3D; currentState.getValue();\n\t\tint eventValue &#x3D; event.getValue();\n\t\tthis.currentState &#x3D; transitionTable[stateValue][eventValue];\n\t\tthis.score &#x3D; actionTable[stateValue][eventValue];\n\t&#125;\n\tpublic int getScore() &#123;\n\t\treturn this.score;\n\t&#125;\n\tpublic State getCurrentState() &#123;\n\t\treturn this.currentState;\n\t&#125;\n&#125;\n\n5.4 状态机实现方式三：状态模式在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，用一个 int 类型的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性\n虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，可以使用状态模式来解决\n状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。代码如下所示：\n其中，IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代码逻辑被分散到了这 4 个状态类中\npublic interface IMario &#123; &#x2F;&#x2F;所有状态类的接口\n\tState getName();\n\t&#x2F;&#x2F;以下是定义的事件\n\tvoid obtainMushRoom();\n\tvoid obtainCape();\n\tvoid obtainFireFlower();\n\tvoid meetMonster();\n&#125;\npublic class SmallMario implements IMario &#123;\n\tprivate MarioStateMachine stateMachine;\n\tpublic SmallMario(MarioStateMachine stateMachine) &#123;\n\t\tthis.stateMachine &#x3D; stateMachine;\n\t&#125;\n\t@Override\n\tpublic State getName() &#123;\n\t\treturn State.SMALL;\n\t&#125;\n\t@Override\n\tpublic void obtainMushRoom() &#123;\n\t\tstateMachine.setCurrentState(new SuperMario(stateMachine));\n\t\tstateMachine.setScore(stateMachine.getScore() + 100);\n\t&#125;\n\t@Override\n\tpublic void obtainCape() &#123;\n\t\tstateMachine.setCurrentState(new CapeMario(stateMachine));\n\t\tstateMachine.setScore(stateMachine.getScore() + 200);\n\t&#125;\n\t@Override\n\tpublic void obtainFireFlower() &#123;\n\t\tstateMachine.setCurrentState(new FireMario(stateMachine));\n\t\tstateMachine.setScore(stateMachine.getScore() + 300);\n\t&#125;\n\t@Override\n\tpublic void meetMonster() &#123;\n\t\t&#x2F;&#x2F; do nothing...\n\t&#125;\n&#125;\npublic class SuperMario implements IMario &#123;\n\tprivate MarioStateMachine stateMachine;\n\tpublic SuperMario(MarioStateMachine stateMachine) &#123;\n\t\tthis.stateMachine &#x3D; stateMachine;\n\t&#125;\n\t@Override\n\tpublic State getName() &#123;\n\t\treturn State.SUPER;\n\t&#125;\n\t@Override\n\tpublic void obtainMushRoom() &#123;\n            &#x2F;&#x2F; do nothing...\n\t&#125;\n\t@Override\n\tpublic void obtainCape() &#123;\n\t\tstateMachine.setCurrentState(new CapeMario(stateMachine));\n\t\tstateMachine.setScore(stateMachine.getScore() + 200);\n\t&#125;\n\t@Override\n\tpublic void obtainFireFlower() &#123;\n\t\tstateMachine.setCurrentState(new FireMario(stateMachine));\n\t\tstateMachine.setScore(stateMachine.getScore() + 300);\n\t&#125;\n\t@Override\n\tpublic void meetMonster() &#123;\n\t\tstateMachine.setCurrentState(new SmallMario(stateMachine));\n\t\tstateMachine.setScore(stateMachine.getScore() - 100);\n\t&#125;\n&#125;\n&#x2F;&#x2F; 省略CapeMario、FireMario类...\npublic class MarioStateMachine &#123;\n\tprivate int score;\n\tprivate IMario currentState; &#x2F;&#x2F; 不再使用枚举来表示状态\n\tpublic MarioStateMachine() &#123;\n\t\tthis.score &#x3D; 0;\n\t\tthis.currentState &#x3D; new SmallMario(this);\n\t&#125;\n\tpublic void obtainMushRoom() &#123;\n\t\tthis.currentState.obtainMushRoom();\n\t&#125;\n\tpublic void obtainCape() &#123;\n\t\tthis.currentState.obtainCape();\n\t&#125;\n\tpublic void obtainFireFlower() &#123;\n\t\tthis.currentState.obtainFireFlower();\n\t&#125;\n\tpublic void meetMonster() &#123;\n\t\tthis.currentState.meetMonster();\n\t&#125;\n\tpublic int getScore() &#123;\n\t\treturn this.score;\n\t&#125;\n\tpublic State getCurrentState() &#123;\n\t\treturn this.currentState.getName();\n\t&#125;\n\tpublic void setScore(int score) &#123;\n\t\tthis.score &#x3D; score;\n\t&#125;\n\tpublic void setCurrentState(IMario currentState) &#123;\n\t\tthis.currentState &#x3D; currentState;\n\t&#125;\n&#125;\n\n上面的代码实现不难看懂，只强调其中的一点，即 MarioStateMachine 和各个状态类之间是双向依赖关系。MarioStateMachine 依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖 MarioStateMachine 呢？这是因为，各个状态类需要更新 MarioStateMachine 中的两个变量，score 和 currentState\n实际上，上面的代码还可以继续优化，可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，就无法通过构造函数来传递 MarioStateMachine 了，而状态类又要依赖 MarioStateMachine，那该如何解决这个问题呢？\n在之前讲到单例模式时，提到过几种解决方法（见：**设计模式之美总结（创建型篇）_凡 223 的博客**）。在这里，可以通过函数参数将 MarioStateMachine 传递进状态类。根据这个设计思路，对上面的代码进行重构。重构之后的代码如下所示：\npublic interface IMario &#123;\n\tState getName();\n\tvoid obtainMushRoom(MarioStateMachine stateMachine);\n\tvoid obtainCape(MarioStateMachine stateMachine);\n\tvoid obtainFireFlower(MarioStateMachine stateMachine);\n\tvoid meetMonster(MarioStateMachine stateMachine);\n&#125;\npublic class SmallMario implements IMario &#123;\n\tprivate static final SmallMario instance &#x3D; new SmallMario();\n\tprivate SmallMario() &#123;&#125;\n\tpublic static SmallMario getInstance() &#123;\n\t\treturn instance;\n\t&#125;\n\t@Override\n\tpublic State getName() &#123;\n\t\treturn State.SMALL;\n\t&#125;\n\t@Override\n\tpublic void obtainMushRoom(MarioStateMachine stateMachine) &#123;\n\t\tstateMachine.setCurrentState(SuperMario.getInstance());\n\t\tstateMachine.setScore(stateMachine.getScore() + 100);\n\t&#125;\n\t@Override\n\tpublic void obtainCape(MarioStateMachine stateMachine) &#123;\n\t\tstateMachine.setCurrentState(CapeMario.getInstance());\n\t\tstateMachine.setScore(stateMachine.getScore() + 200);\n\t&#125;\n\t@Override\n\tpublic void obtainFireFlower(MarioStateMachine stateMachine) &#123;\n\t\tstateMachine.setCurrentState(FireMario.getInstance());\n\t\tstateMachine.setScore(stateMachine.getScore() + 300);\n\t&#125;\n\t@Override\n\tpublic void meetMonster(MarioStateMachine stateMachine) &#123;\n\t\t&#x2F;&#x2F; do nothing...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 省略SuperMario、CapeMario、FireMario类...\npublic class MarioStateMachine &#123;\n\tprivate int score;\n\tprivate IMario currentState;\n\tpublic MarioStateMachine() &#123;\n\t\tthis.score &#x3D; 0;\n\t\tthis.currentState &#x3D; SmallMario.getInstance();\n\t&#125;\n\tpublic void obtainMushRoom() &#123;\n\t\tthis.currentState.obtainMushRoom(this);\n\t&#125;\n\tpublic void obtainCape() &#123;\n\t\tthis.currentState.obtainCape(this);\n\t&#125;\n\tpublic void obtainFireFlower() &#123;\n\t\tthis.currentState.obtainFireFlower(this);\n\t&#125;\n\tpublic void meetMonster() &#123;\n\t\tthis.currentState.meetMonster(this);\n\t&#125;\n\tpublic int getScore() &#123;\n\t\treturn this.score;\n\t&#125;\n\tpublic State getCurrentState() &#123;\n\t\treturn this.currentState.getName();\n\t&#125;\n\tpublic void setScore(int score) &#123;\n\t\tthis.score &#x3D; score;\n\t&#125;\n\tpublic void setCurrentState(IMario currentState) &#123;\n\t\tthis.currentState &#x3D; currentState;\n\t&#125;\n&#125;\n\n\n实际上，像游戏这种比较复杂的状态机，包含的状态比较多，优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现\n6. 迭代器&#x2F;游标模式（Iterator Design Pattern&#x2F;Cursor Design Pattern）6.1 原理和实现迭代器模式用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一\n迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。简单的类图如下：\n\n大部分编程语言都提供了遍历容器的迭代器类，在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原理，假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要从零开始开发。现在一块来看具体该如何去做\n线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应 ArrayList 和 LinkedList 两个类。除此之外，从两个类中抽象出公共的接口，定义为 List 接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换\n现在，针对 ArrayList 和 LinkedList 两个线性容器，设计实现对应的迭代器。按照之前给出的迭代器模式的类图，定义一个迭代器接口 Iterator，以及针对两种容器的具体的迭代器实现类 ArrayIterator 和 ListIterator\n先来看下 Iterator 接口的定义。具体的代码如下所示：\n&#x2F;&#x2F; 接口定义方式一\npublic interface Iterator&lt;E&gt; &#123;\n\tboolean hasNext();\n\tvoid next();\n\tE currentItem();\n&#125;\n&#x2F;&#x2F; 接口定义方式二\npublic interface Iterator&lt;E&gt; &#123;\n\tboolean hasNext();\n\tE next();\n&#125;\n\nIterator 接口有两种定义方式。在第一种定义中，next() 函数用来将游标后移一位元素，currentItem() 函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数 next() 中完成\n第一种定义方式更加灵活一些，比如可以多次调用 currentItem() 查询当前元素，而不移动游标。所以，在接下来的实现中，选择第一种接口定义方式\n再来看下 ArrayIterator 的代码实现，具体如下所示：\npublic class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n\tprivate int cursor;\n\tprivate ArrayList&lt;E&gt; arrayList;\n\tpublic ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n\t\tthis.cursor &#x3D; 0;\n\t\tthis.arrayList &#x3D; arrayList;\n\t&#125;\n\t@Override\n\tpublic boolean hasNext() &#123;\n\t\treturn cursor !&#x3D; arrayList.size(); &#x2F;&#x2F;注意这里，cursor在指向最后一个元素的时候，ha\n\t&#125;\n\t@Override\n\tpublic void next() &#123;\n\t\tcursor++;\n\t&#125;\n\t@Override\n\tpublic E currentItem() &#123;\n\t\tif (cursor &gt;&#x3D; arrayList.size()) &#123;\n\t\t\tthrow new NoSuchElementException();\n\t\t&#125;\n\t\treturn arrayList.get(cursor);\n\t&#125;\n&#125;\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tArrayList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n\t\tnames.add(&quot;xzg&quot;);\n\t\tnames.add(&quot;wang&quot;);\n\t\tnames.add(&quot;zheng&quot;);\n\t\tIterator&lt;String&gt; iterator &#x3D; new ArrayIterator(names);\n\t\twhile (iterator.hasNext()) &#123;\n\t\t\tSystem.out.println(iterator.currentItem());\n\t\t\titerator.next();\n\t\t&#125;\n\t&#125;\n&#125;\n\n在上面的代码实现中，需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，可以在容器中定义一个 iterator() 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，还需要将这个方法定义在 List 接口中。具体的代码实现和使用示例如下所示：\npublic interface List&lt;E&gt; &#123;\n\tIterator iterator();\n\t&#x2F;&#x2F;...省略其他接口函数...\n&#125;\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n\t&#x2F;&#x2F;...\n\tpublic Iterator iterator() &#123;\n\t\treturn new ArrayIterator(this);\n\t&#125;\n\t&#x2F;&#x2F;...省略其他代码\n&#125;\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n\t\tnames.add(&quot;xzg&quot;);\n\t\tnames.add(&quot;wang&quot;);\n\t\tnames.add(&quot;zheng&quot;);\n\t\tIterator&lt;String&gt; iterator &#x3D; names.iterator();\n\t\twhile (iterator.hasNext()) &#123;\n\t\t\tSystem.out.println(iterator.currentItem());\n\t\t\titerator.next();\n\t\t&#125;\n\t&#125;\n&#125;\n\n对于 LinkedIterator，它的代码结构跟 ArrayIterator 完全相同，这里就不给出具体的代码实现了\n结合上面的例子，来总结一下迭代器的设计思路。总结下来就三句话：迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过 iterator() 方法来创建迭代器\n\n6.2 优势一般来讲，遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器。对于这三种方式，拿 Java 语言来举例说明一下。具体的代码如下所示：\nList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\nnames.add(&quot;xzg&quot;);\nnames.add(&quot;wang&quot;);\nnames.add(&quot;zheng&quot;);\n\n&#x2F;&#x2F; 第一种遍历方式：for循环\nfor (int i &#x3D; 0; i &lt; names.size(); i++) &#123;\n\tSystem.out.print(names.get(i) + &quot;,&quot;);\n&#125;\n&#x2F;&#x2F; 第二种遍历方式：foreach循环\nfor (String name : names) &#123;\n\tSystem.out.print(name + &quot;,&quot;)\n&#125;\n&#x2F;&#x2F; 第三种遍历方式：迭代器遍历\nIterator&lt;String&gt; iterator &#x3D; names.iterator();\nwhile (iterator.hasNext()) &#123;\n\t&#x2F;&#x2F; Java中的迭代器接口是第二种定义方式，next\n\tSystem.out.print(iterator.next() + &quot;,&quot;);\n&#125;\n\n\n实际上，foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面代码中的第二种遍历方式（foreach 循环代码）的底层实现，就是第三种遍历方式（迭代器遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式\n从上面的代码来看，for 循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个：\n\n对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性\n应对复杂性的方法就是拆分。可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历\n\n将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响\n\n容器和迭代器都提供了抽象的接口，方便在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，只需要扩展新的迭代器类，也更符合开闭原则\n\n\n6.3 遍历集合的同时，为什么不能增删集合元素？6.3.1 在遍历的同时增删集合元素会发生什么？在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定\n比如，使用前面实现的 ArrayList 迭代器，使用代码如下：\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n\t\tnames.add(&quot;a&quot;);\n\t\tnames.add(&quot;b&quot;);\n\t\tnames.add(&quot;c&quot;);\n\t\tnames.add(&quot;d&quot;);\n\t\tIterator&lt;String&gt; iterator &#x3D; names.iterator();\n\t\titerator.next();\n\t\tnames.remove(&quot;a&quot;);\n\t&#125;\n&#125;\n\nArrayList 底层对应的是数组这种数据结构，在执行完第 55 行代码的时候，数组中存储的是 a、b、c、d 四个元素，迭代器的游标 cursor 指向元素 a。当执行完第 56行代码的时候，游标指向元素 b，到这里都没有问题\n为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到第 57 行代码的时候，从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 56 行代码之后，还可以遍历到 b、c、d 三个元素，但在执行完第 57 行代码之后，只能遍历到 c、d 两个元素，b 遍历不到了\n\n不过，如果第 57 行代码删除的不是游标前面的元素（元素 a）以及游标所在位置的元素（元素 b），而是游标后面的元素（元素 c 和 d），这样就不会存在任何问题了，不会存在某个元素遍历不到的情况了\n所以，前面说，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题（删除元素 c 或 d），有时候就有问题（删除元素 a 或 b），这个要视情况而定（到底删除的是哪个位置的元素），就是这个意思\n在遍历的过程中删除集合元素，有可能会导致某个元素遍历不到，那在遍历的过程中添加集合元素，会发生什么情况呢？如下例：\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n\t\tnames.add(&quot;a&quot;);\n\t\tnames.add(&quot;b&quot;);\n\t\tnames.add(&quot;c&quot;);\n\t\tnames.add(&quot;d&quot;);\n\t\tIterator&lt;String&gt; iterator &#x3D; names.iterator();\n\t\titerator.next();\n\t\tnames.add(0, &quot;x&quot;);\n\t&#125;\n&#125;\n\n在执行完第 10 行代码之后，数组中包含 a、b、c、d 四个元素，游标指向 b 这个元素，已经跳过了元素 a。在执行完第 11 行代码之后，我们将 x 插入到下标为 0 的位置，a、b、c、d 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 a。元素 a 被游标重复指向两次，也就是说，元素 a 存在被重复遍历的情况\n\n跟删除情况类似，如果在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为\n6.3.2 如何应对遍历时改变集合导致的未决行为？当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，“不可预期”比直接出错更加可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。那如何才能避免出现这种不可预期的运行结果呢？\n有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错\n实际上，第一种解决方案比较难实现，要确定遍历开始和结束的时间点。遍历开始的时间节点很容易获得，可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？\n这时可能会说，遍历到最后一个元素的时候就算结束。但是，在实际的软件开发中，每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍，有可能找到某一个匹配的元素就提前结束了遍历\n还可能还会说，那可以在迭代器类中定义一个新的接口 finishIteration()，主动告知容器迭代器使用完了，可以增删元素了。但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也增加了开发成本，还很容易漏掉\n实际上，第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后，让遍历报错\n怎么确定在遍历时候，集合有没有增删元素呢？在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1。当通过调用集合上的 iterator() 函数来创建迭代器的时候，把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，都会检查集合上的 modCount 是否等于 expectedModCount，也就是看，在创建完迭代器之后，modCount 是否改变过\n如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 bug\npublic class ArrayIterator implements Iterator &#123;\n\tprivate int cursor;\n\tprivate ArrayList arrayList;\n\tprivate int expectedModCount;\n\tpublic ArrayIterator(ArrayList arrayList) &#123;\n\t\tthis.cursor &#x3D; 0;\n\t\tthis.arrayList &#x3D; arrayList;\n\t\tthis.expectedModCount &#x3D; arrayList.modCount;\n\t&#125;\n\t@Override\n\tpublic boolean hasNext() &#123;\n\t\tcheckForComodification();\n\t\treturn cursor &lt; arrayList.size();\n\t&#125;\n\t@Override\n\tpublic void next() &#123;\n\t\tcheckForComodification();\n\t\tcursor++;\n\t&#125;\n\t@Override\n\tpublic Object currentItem() &#123;\n\t\tcheckForComodification();\n\t\treturn arrayList.get(cursor);\n\t&#125;\n\tprivate void checkForComodification() &#123;\n\t\tif (arrayList.modCount !&#x3D; expectedModCount)\n\t\t\tthrow new ConcurrentModificationException();\n\t&#125;\n&#125;\n&#x2F;&#x2F;代码示例\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n\t\tnames.add(&quot;a&quot;);\n\t\tnames.add(&quot;b&quot;);\n\t\tnames.add(&quot;c&quot;);\n\t\tnames.add(&quot;d&quot;);\n\t\tIterator&lt;String&gt; iterator &#x3D; names.iterator();\n\t\titerator.next();\n\t\tnames.remove(&quot;a&quot;);\n\t\titerator.next();&#x2F;&#x2F;抛出ConcurrentModificationException异常\n\t&#125;\n&#125;\n\n6.3.3 如何在遍历的同时安全地删除集合元素？像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适\n作者个人觉得，Java 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操作，多次调用 remove() 操作会报错。如下例：\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n\t\tnames.add(&quot;a&quot;);\n\t\tnames.add(&quot;b&quot;);\n\t\tnames.add(&quot;c&quot;);\n\t\tnames.add(&quot;d&quot;);\n\t\tIterator&lt;String&gt; iterator &#x3D; names.iterator();\n\t\titerator.next();\n\t\titerator.remove();\n\t\titerator.remove(); &#x2F;&#x2F;报错，抛出IllegalStateException异常\n\t&#125;\n&#125;\n\n为什么通过迭代器就能安全的删除集合中的元素呢？来看下 remove() 函数是如何实现的，代码如下所示。在 Java 实现中，迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前的元素\npublic class ArrayList&lt;E&gt; &#123;\n\ttransient Object[] elementData;\n\tprivate int size;\n\tpublic Iterator&lt;E&gt; iterator() &#123;\n\t\treturn new Itr();\n\t&#125;\n\tprivate class Itr implements Iterator&lt;E&gt; &#123;\n\t\tint cursor; &#x2F;&#x2F; index of next element to return\n\t\tint lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such\n\t\tint expectedModCount &#x3D; modCount;\n\t\tItr() &#123;&#125;\n\t\tpublic boolean hasNext() &#123;\n\t\t\treturn cursor !&#x3D; size;\n\t\t&#125;\n\t\t@SuppressWarnings(&quot;unchecked&quot;)\n\t\tpublic E next() &#123;\n\t\t\tcheckForComodification();\n\t\t\tint i &#x3D; cursor;\n\t\t\tif (i &gt;&#x3D; size)\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tObject[] elementData &#x3D; ArrayList.this.elementData;\n\t\t\tif (i &gt;&#x3D; elementData.length)\n\t\t\t\tthrow new ConcurrentModificationException();\n\t\t\tcursor &#x3D; i + 1;\n\t\t\treturn (E) elementData[lastRet &#x3D; i];\n\t\t&#125;\n\t\tpublic void remove() &#123;\n\t\t\tif (lastRet &lt; 0)\n\t\t\t\tthrow new IllegalStateException();\n\t\t\tcheckForComodification();\n\t\t\ttry &#123;\n\t\t\t\tArrayList.this.remove(lastRet);\n\t\t\t\tcursor &#x3D; lastRet;\n\t\t\t\tlastRet &#x3D; -1;\n\t\t\t\texpectedModCount &#x3D; modCount;\n\t\t\t&#125; catch (IndexOutOfBoundsException ex) &#123;\n\t\t\t\tthrow new ConcurrentModificationException();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n在上面的代码实现中，迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，可以更新迭代器中的游标和 lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了\n6.4 如何设计实现一个支持“快照”功能的 Iterator？理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指的是为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错\n如果来实现上面的功能呢？针对这个功能需求的骨架代码如下，其中包含 ArrayList、SnapshotArrayIterator 两个类。对于这两个类，这里只定义了必须的几个关键接口\npublic ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n\t&#x2F;&#x2F; TODO: 成员变量、私有函数\n\t@Override\n\tpublic void add(E obj) &#123;\n\t\t&#x2F;&#x2F; TODO\n\t&#125;\n\t@Override\n\tpublic void remove(E obj) &#123;\n\t&#x2F;&#x2F; TODO\n\t&#125;\n\t@Override\n\tpublic Iterator&lt;E&gt; iterator() &#123;\n\t\treturn new SnapshotArrayIterator(this);\n\t&#125;\n&#125;\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n\t&#x2F;&#x2F; TODO\n\t@Override\n\tpublic boolean hasNext() &#123;\n\t\t&#x2F;&#x2F; TODO\n\t&#125;\n\t@Override\n\tpublic E next() &#123;&#x2F;&#x2F;返回当前元素，并且游标后移一位\n\t\t&#x2F;&#x2F; TODO\n\t&#125;\n&#125;\n\n6.4.1 解决方案一最简单的一种解决办法。在迭代器类中定义一个成员变量 snapshot 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n\tprivate int cursor;\n\tprivate ArrayList&lt;E&gt; snapshot;\n\n\tpublic SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n\t\tthis.cursor &#x3D; 0;\n\t\tthis.snapshot &#x3D; new ArrayList&lt;&gt;();\n\t\tthis.snapshot.addAll(arrayList);\n\t&#125;\n\t@Override\n\tpublic boolean hasNext() &#123;\n\t\treturn cursor &lt; snapshot.size();\n\t&#125;\n\t@Override\n\tpublic E next() &#123;\n\t\tE currentItem &#x3D; snapshot.get(cursor);\n\t\tcursor++;\n\t\treturn currentItem;\n\t&#125;\n&#125;\n\n这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于浅拷贝，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已\n6.4.2 解决方案二可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，将 delTimestamp 更新为当前时间，表示已经被删除。这里只是标记删除，而非真正将它从容器中删除\n同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp &lt; snapshotTimestamp &lt; delTimestamp 的元素，才是属于这个迭代器的快照\n如果元素的 addTimestamp &gt; snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的 delTimestamp &lt; snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照\n这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示。注意，这里没有考虑 ArrayList 的扩容问题\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n\tprivate static final int DEFAULT_CAPACITY &#x3D; 10;\n\tprivate int actualSize; &#x2F;&#x2F;不包含标记删除元素\n\tprivate int totalSize; &#x2F;&#x2F;包含标记删除元素\n\tprivate Object[] elements;\n\tprivate long[] addTimestamps;\n\tprivate long[] delTimestamps;\n\n\tpublic ArrayList() &#123;\n\t\tthis.elements &#x3D; new Object[DEFAULT_CAPACITY];\n\t\tthis.addTimestamps &#x3D; new long[DEFAULT_CAPACITY];\n\t\tthis.delTimestamps &#x3D; new long[DEFAULT_CAPACITY];\n\t\tthis.totalSize &#x3D; 0;\n\t\tthis.actualSize &#x3D; 0;\n\t&#125;\n\t@Override\n\tpublic void add(E obj) &#123;\n\t\telements[totalSize] &#x3D; obj;\n\t\taddTimestamps[totalSize] &#x3D; System.currentTimeMillis();\n\t\tdelTimestamps[totalSize] &#x3D; Long.MAX_VALUE;\n\t\ttotalSize++;\n\t\tactualSize++;\n\t&#125;\n\t@Override\n\tpublic void remove(E obj) &#123;\n\t\tfor (int i &#x3D; 0; i &lt; totalSize; ++i) &#123;\n\t\t\tif (elements[i].equals(obj)) &#123;\n\t\t\t\tdelTimestamps[i] &#x3D; System.currentTimeMillis();\n\t\t\t\tactualSize--;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tpublic int actualSize() &#123;\n\t\treturn this.actualSize;\n\t&#125;\n\tpublic int totalSize() &#123;\n\t\treturn this.totalSize;\n\t&#125;\n\tpublic E get(int i) &#123;\n\t\tif (i &gt;&#x3D; totalSize) &#123;\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t&#125;\n\t\treturn (E)elements[i];\n\t&#125;\n\tpublic long getAddTimestamp(int i) &#123;\n\t\tif (i &gt;&#x3D; totalSize) &#123;\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t&#125;\n\t\treturn addTimestamps[i];\n\t&#125;\n\tpublic long getDelTimestamp(int i) &#123;\n\t\tif (i &gt;&#x3D; totalSize) &#123;\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t&#125;\n\t\treturn delTimestamps[i];\n\t&#125;\n&#125;\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n\tprivate long snapshotTimestamp;\n\tprivate int cursorInAll; &#x2F;&#x2F; 在整个容器中的下标，而非快照中的下标\n\tprivate int leftCount; &#x2F;&#x2F; 快照中还有几个元素未被遍历\n\tprivate ArrayList&lt;E&gt; arrayList;\n\tpublic SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n\t\tthis.snapshotTimestamp &#x3D; System.currentTimeMillis();\n\t\tthis.cursorInAll &#x3D; 0;\n\t\tthis.leftCount &#x3D; arrayList.actualSize();;\n\t\tthis.arrayList &#x3D; arrayList;\n\t\tjustNext(); &#x2F;&#x2F; 先跳到这个迭代器快照的第一个元素\n\t&#125;\n\t@Override\n\tpublic boolean hasNext() &#123;\n\t\treturn this.leftCount &gt;&#x3D; 0; &#x2F;&#x2F; 注意是&gt;&#x3D;, 而非&gt;\n\t&#125;\n\t@Override\n\tpublic E next() &#123;\n\t\tE currentItem &#x3D; arrayList.get(cursorInAll);\n\t\tjustNext();\n\t\treturn currentItem;\n\t&#125;\n\tprivate void justNext() &#123;\n\t\twhile (cursorInAll &lt; arrayList.totalSize()) &#123;\n\t\t\tlong addTimestamp &#x3D; arrayList.getAddTimestamp(cursorInAll);\n\t\t\tlong delTimestamp &#x3D; arrayList.getDelTimestamp(cursorInAll);\n\t\t\tif (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;\n\t\t\t\tleftCount--;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\tcursorInAll++;\n\t\t&#125;\n\t&#125;\n&#125;\n\n实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList 底层依赖数组这种数据结构，原本可以支持快速的随机访问，在 O(1) 时间复杂度内获取下标为 i 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了\n怎么解决这个问题：让容器既支持快照遍历，又支持随机访问？\n解决的方法也不难，可以在 ArrayList 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问\n7. 访问者模式（Visitor Design Pattern）大部分设计模式的原理和实现都很简单，不过也有例外，访问者模式就可以算是 23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议不要使用访问者模式\n7.1 “发明”访问者模式假设从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。该怎么实现呢？\n实现这个功能并不难，不同的人有不同的写法，这里给出其中一种实现方式，如下。其中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication中，可以利用多态特性，根据对象的实际类型，来决定执行哪个方法\npublic abstract class ResourceFile &#123;\n\tprotected String filePath;\n\tpublic ResourceFile(String filePath) &#123;\n\t\tthis.filePath &#x3D; filePath;\n\t&#125;\n\tpublic abstract void extract2txt();\n&#125;\npublic class PPTFile extends ResourceFile &#123;\n\tpublic PPTFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t@Override\n\tpublic void extract2txt() &#123;\n\t\t&#x2F;&#x2F;...省略一大坨从PPT中抽取文本的代码...\n\t\t&#x2F;&#x2F;...将抽取出来的文本保存在跟filePath同名的.txt文件中...\n\t\tSystem.out.println(&quot;Extract PPT.&quot;);\n\t&#125;\n&#125;\npublic class PdfFile extends ResourceFile &#123;\n\tpublic PdfFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t@Override\n\tpublic void extract2txt() &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract PDF.&quot;);\n\t&#125;\n&#125;\npublic class WordFile extends ResourceFile &#123;\n\tpublic WordFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t@Override\n\tpublic void extract2txt() &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract WORD.&quot;);\n\t&#125;\n&#125;\n&#x2F;&#x2F; 运行结果是：\n&#x2F;&#x2F; Extract PDF.\n&#x2F;&#x2F; Extract WORD.\n&#x2F;&#x2F; Extract PPT.\npublic class ToolApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);\n\t\tfor (ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\tresourceFile.extract2txt();\n\t\t&#125;\n\t&#125;\n\tprivate static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirector) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)\n\t\tresourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n\t\tresourceFiles.add(new WordFile(&quot;b.word&quot;));\n\t\tresourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n\t\treturn resourceFiles;\n\t&#125;\n&#125;\n\n如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果继续按照上面的实现思路，就会存在这样几个问题：\n\n违背开闭原则，添加一个新的功能，所有类的代码都要修改\n虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了\n把所有比较上层的业务逻辑都耦合到 PdfFile、PPTFile、WordFile 类中，导致这些类的职责不够单一，变成了大杂烩\n\n针对上面的问题，常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦，设计成独立的类。这里按照访问者模式的演进思路来对上面的代码进行重构。重构之后的代码如下所示\npublic abstract class ResourceFile &#123;\n\tprotected String filePath;\n\tpublic ResourceFile(String filePath) &#123;\n\t\tthis.filePath &#x3D; filePath;\n\t&#125;\n&#125;\npublic class PdfFile extends ResourceFile &#123;\n\tpublic PdfFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;...PPTFile、WordFile代码省略...\npublic class Extractor &#123;\n\tpublic void extract2txt(PPTFile pptFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract PPT.&quot;);\n\t&#125;\n\tpublic void extract2txt(PdfFile pdfFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract PDF.&quot;);\n\t&#125;\n\tpublic void extract2txt(WordFile wordFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract WORD.&quot;);\n\t&#125;\n&#125;\npublic class ToolApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tExtractor extractor &#x3D; new Extractor();\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);\n\t\tfor (ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\textractor.extract2txt(resourceFile);\n\t\t&#125;\n\t&#125;\n\tprivate static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirector) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)\n\t\tresourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n\t\tresourceFiles.add(new WordFile(&quot;b.word&quot;));\n\t\tresourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n\t\treturn resourceFiles;\n\t&#125;\n&#125;\n\n这其中最关键的一点设计是，把抽取文本内容的操作，设计成了三个重载函数。函数重载是 Java、C++ 这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类中函数名相同、参数不同的一组函数\n不过，上面的代码是编译通过不了的，第 37 行会报错。这是为什么呢？\n多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法\n在上面代码的第 35～38 行中，resourceFiles 包含的对象的声明类型都是 ResourceFile，而我们并没有在 Extractor 类中定义参数类型是 ResourceFile 的 extract2txt() 重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决这个问题呢？\npublic abstract class ResourceFile &#123;\n\tprotected String filePath;\n\tpublic ResourceFile(String filePath) &#123;\n\t\tthis.filePath &#x3D; filePath;\n\t&#125;\n\tabstract public void accept(Extractor extractor);\n&#125;\npublic class PdfFile extends ResourceFile &#123;\n\tpublic PdfFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t@Override\n\tpublic void accept(Extractor extractor) &#123;\n\t\textractor.extract2txt(this);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n&#x2F;&#x2F;...Extractor代码不变...\npublic class ToolApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tExtractor extractor &#x3D; new Extractor();\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);\n\t\tfor (ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\tresourceFile.accept(extractor);\n\t\t&#125;\n\t&#125;\n\tprivate static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirector) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)\n\t\tresourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n\t\tresourceFiles.add(new WordFile(&quot;b.word&quot;));\n\t\tresourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n\t\treturn resourceFiles;\n\t&#125;\n&#125;\n\n在执行第 30 行的时候，根据多态特性，程序会调用实际类型的 accept 函数，比如 PdfFile 的 accept 函数，也就是第 16 行代码。而 16 行代码中的 this 类型是 PdfFile 的，在编译的时候就确定了，所以会调用 extractor 的 extract2txt(PdfFile pdfFile) 这个重载函数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是之前所说的访问者模式不好理解的原因\n现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那该如何实现呢？需要实现一个类似 Extractor 类的新类 Compressor 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，还要在每个资源文件类中定义新的 accept 重载函数。具体的代码如下所示：\npublic abstract class ResourceFile &#123;\n\tprotected String filePath;\n\tpublic ResourceFile(String filePath) &#123;\n\t\tthis.filePath &#x3D; filePath;\n\t&#125;\n\tabstract public void accept(Extractor extractor);\n\tabstract public void accept(Compressor compressor);\n&#125;\npublic class PdfFile extends ResourceFile &#123;\n\tpublic PdfFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t@Override\n\tpublic void accept(Extractor extractor) &#123;\n\t\textractor.extract2txt(this);\n\t&#125;\n\t@Override\n\tpublic void accept(Compressor compressor) &#123;\n\t\tcompressor.compress(this);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#125;\n&#x2F;&#x2F;...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n&#x2F;&#x2F;...Extractor代码不变\npublic class ToolApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tExtractor extractor &#x3D; new Extractor();\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);\n\t\tfor (ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\tresourceFile.accept(extractor);\n\t\t&#125;\n\t\tCompressor compressor &#x3D; new Compressor();\n\t\tfor(ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\tresourceFile.accept(compressor);\n\t\t&#125;\n\t&#125;\n\tprivate static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirector) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)\n\t\tresourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n\t\tresourceFiles.add(new WordFile(&quot;b.word&quot;));\n\t\tresourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n\t\treturn resourceFiles;\n\t&#125;\n&#125;\n\n上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 Visitor接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。当新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改ToolApplication 的代码就可以了\npublic abstract class ResourceFile &#123;\n\tprotected String filePath;\n\tpublic ResourceFile(String filePath) &#123;\n\t\tthis.filePath &#x3D; filePath;\n\t&#125;\n\tabstract public void accept(Visitor vistor);\n&#125;\npublic class PdfFile extends ResourceFile &#123;\n\tpublic PdfFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t@Override\n\tpublic void accept(Visitor visitor) &#123;\n\t\tvisitor.visit(this);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;...PPTFile、WordFile跟PdfFile类似，这里就省略了...\npublic interface Visitor &#123;\n\tvoid visit(PdfFile pdfFile);\n\tvoid visit(PPTFile pdfFile);\n\tvoid visit(WordFile pdfFile);\n&#125;\npublic class Extractor implements Visitor &#123;\n\t@Override\n\tpublic void visit(PPTFile pptFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract PPT.&quot;);\n\t&#125;\n\t@Override\n\tpublic void visit(PdfFile pdfFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract PDF.&quot;);\n\t&#125;\n\t@Override\n\tpublic void visit(WordFile wordFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract WORD.&quot;);\n\t&#125;\n&#125;\npublic class Compressor implements Visitor &#123;\n\t@Override\n\tpublic void visit(PPTFile pptFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Compress PPT.&quot;);\n\t&#125;\n\t@Override\n\tpublic void visit(PdfFile pdfFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Compress PDF.&quot;);\n\t&#125;\n\t@Override\n\tpublic void visit(WordFile wordFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Compress WORD.&quot;);\n\t&#125;\n&#125;\npublic class ToolApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tExtractor extractor &#x3D; new Extractor();\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);\n\t\tfor (ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\tresourceFile.accept(extractor);\n\t\t&#125;\n\t\tCompressor compressor &#x3D; new Compressor();\n\t\tfor(ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\tresourceFile.accept(compressor);\n\t\t&#125;\n\t&#125;\n\tprivate static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirector) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)\n\t\tresourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n\t\tresourceFiles.add(new WordFile(&quot;b.word&quot;));\n\t\tresourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n\t\treturn resourceFiles;\n\t&#125;\n&#125;\n\n7.2 重新来看访问者模式访问者者模式的英文翻译是 Visitor Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nAllows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.允许一个或者多个操作应用到一组对象上，解耦操作和对象本身\n在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。这里总结了一张类图，如下：\n\n一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中\n对于访问者模式，主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差\n7.3 为什么支持双分派的语言不需要访问者模式？实际上，讲到访问者模式，大部分书籍或者资料都会讲到 Double Dispatch，中文翻译为双分派。既然有 Double Dispatch，对应的就有 Single Dispatch\n\n所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定\n所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定\n\n如何理解“Dispatch”这个单词呢？ 在面向对象编程语言中，可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数\n如何理解“Single”“Double”这两个单词呢？“Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关\n具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch\nJava 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch\npublic class ParentClass &#123;\n\tpublic void f() &#123;\n\t\tSystem.out.println(&quot;I am ParentClass&#39;s f().&quot;);\n\t&#125;\n&#125;\npublic class ChildClass extends ParentClass &#123;\n\tpublic void f() &#123;\n\t\tSystem.out.println(&quot;I am ChildClass&#39;s f().&quot;);\n\t&#125;\n&#125;\npublic class SingleDispatchClass &#123;\n\tpublic void polymorphismFunction(ParentClass p) &#123;\n\t\tp.f();\n\t&#125;\n\tpublic void overloadFunction(ParentClass p) &#123;\n\t\tSystem.out.println(&quot;I am overloadFunction(ParentClass p).&quot;);\n\t&#125;\n\tpublic void overloadFunction(ChildClass c) &#123;\n\t\tSystem.out.println(&quot;I am overloadFunction(ChildClass c).&quot;);\n\t&#125;\n&#125;\npublic class DemoMain &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSingleDispatchClass demo &#x3D; new SingleDispatchClass();\n\t\tParentClass p &#x3D; new ChildClass();\n\t\tdemo.polymorphismFunction(p);&#x2F;&#x2F;执行哪个对象的方法，由对象的实际类型决定\n\t\tdemo.overloadFunction(p);&#x2F;&#x2F;执行对象的哪个方法，由参数对象的声明类型决定\n\t&#125;\n&#125;\n&#x2F;&#x2F;代码执行结果:\nI am ChildClass&#39;s f().\nI am overloadFunction(ParentClass p).\n\n在上面的代码中，第 31 行代码的 polymorphismFunction() 函数，执行 p 的实际类型的 f() 函数，也就是 ChildClass 的 f() 函数。第 32 行代码的 overloadFunction() 函数，匹配的是重载函数中的 overloadFunction(ParentClass p)，也就是根据 p 的声明类型来决定匹配哪个重载函数\n假设 Java 语言支持 Double Dispatch，那前面引出访问者模式的代码中的第 37 行就不会报错。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用 extract2txt 的三个重载函数中的哪一个。那下面的代码实现就能正常运行了，也就不需要访问者模式了。这也回答了为什么支持 Double Dispatch 的语言不需要访问者模式\npublic abstract class ResourceFile &#123;\n\tprotected String filePath;\n\tpublic ResourceFile(String filePath) &#123;\n\t\tthis.filePath &#x3D; filePath;\n\t&#125;\n&#125;\npublic class PdfFile extends ResourceFile &#123;\n\tpublic PdfFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;...PPTFile、WordFile代码省略...\npublic class Extractor &#123;\n\tpublic void extract2txt(PPTFile pptFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract PPT.&quot;);\n\t&#125;\n\tpublic void extract2txt(PdfFile pdfFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract PDF.&quot;);\n\t&#125;\n\tpublic void extract2txt(WordFile wordFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t\tSystem.out.println(&quot;Extract WORD.&quot;);\n\t&#125;\n&#125;\n\npublic class ToolApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tExtractor extractor &#x3D; new Extractor();\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);\n\t\tfor (ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\textractor.extract2txt(resourceFile);\n\t\t&#125;\n\t&#125;\n\tprivate static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirector) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)\n\t\tresourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n\t\tresourceFiles.add(new WordFile(&quot;b.word&quot;));\n\t\tresourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n\t\treturn resourceFiles;\n\t&#125;\n&#125;\n\n7.4 除了访问者模式，还有其他实现方案吗？再一块回顾一下前面的例子。从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。要开发一个工具来处理这批资源文件，这其中就包含抽取文本内容、压缩资源文件、提取文件元信息等\n实际上，开发这个工具有很多种代码设计和实现思路。为了引出访问者模式，前面选择了用访问者模式来实现。实际上，还有其他的实现方法，比如，还可以利用工厂模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor\npublic abstract class ResourceFile &#123;\n\tprotected String filePath;\n\tpublic ResourceFile(String filePath) &#123;\n\t\tthis.filePath &#x3D; filePath;\n\t&#125;\n\tpublic abstract ResourceFileType getType();\n&#125;\npublic class PdfFile extends ResourceFile &#123;\n\tpublic PdfFile(String filePath) &#123;\n\t\tsuper(filePath);\n\t&#125;\n\t@Override\n\tpublic ResourceFileType getType() &#123;\n\t\treturn ResourceFileType.PDF;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;...PPTFile&#x2F;WordFile跟PdfFile代码结构类似，此处省略...\npublic interface Extractor &#123;\n\tvoid extract2txt(ResourceFile resourceFile);\n&#125;\npublic class PdfExtractor implements Extractor &#123;\n\t@Override\n\tpublic void extract2txt(ResourceFile resourceFile) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F;...PPTExtractor&#x2F;WordExtractor跟PdfExtractor代码结构类似，此处省略...\npublic class ExtractorFactory &#123;\n\tprivate static final Map&lt;ResourceFileType, Extractor&gt; extractors &#x3D; new HashMa\n\tstatic &#123;\n\t\textractors.put(ResourceFileType.PDF, new PdfExtractor());\n\t\textractors.put(ResourceFileType.PPT, new PPTExtractor());\n\t\textractors.put(ResourceFileType.WORD, new WordExtractor());\n\t&#125;\n\tpublic static Extractor getExtractor(ResourceFileType type) &#123;\n\t\treturn extractors.get(type);\n\t&#125;\n&#125;\npublic class ToolApplication &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; listAllResourceFiles(args[0]);\n\t\tfor (ResourceFile resourceFile : resourceFiles) &#123;\n\t\t\tExtractor extractor &#x3D; ExtractorFactory.getExtractor(resourceFile.getType());\n\t\t\textractor.extract2txt(resourceFile);\n\t\t&#125;\n\t&#125;\n\tprivate static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirector) &#123;\n\t\tList&lt;ResourceFile&gt; resourceFiles &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F;...根据后缀(pdf&#x2F;ppt&#x2F;word)由工厂方法创建不同的类对象(PdfFile&#x2F;PPTFile&#x2F;WordFile)\n\t\tresourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n\t\tresourceFiles.add(new WordFile(&quot;b.word&quot;));\n\t\tresourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n\t\treturn resourceFiles;\n\t&#125;\n&#125;\n\n当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，只需要添加一个 Compressor 接口，PdfCompressor、PPTCompressor、WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一需要修改的只有最上层的 ToolApplication 类。基本上符合“对扩展开放、对修改关闭”的设计原则\n对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，那更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的功能，比如有十几个，那更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性\n8. 备忘录&#x2F;快照（Snapshot）模式（Memento Design Pattern）8.1 原理与实现备忘录模式，也叫快照（Snapshot）模式，英文翻译是 Memento Design Pattern。在 GoF 的《设计模式》一书中，备忘录模式是这么定义的：\n\n\n\n\n\n\n\n\n\nCaptures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态\n这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。这一部分很好理解。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解\n\n为什么存储和恢复副本会违背封装原则？\n备忘录模式是如何做到不违背封装原则的？\n\n假设需要编写一个小程序，可以接收命令行的输入。用户输入文本时，程序将其追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。怎么来编程实现呢？\npublic class InputText &#123;\n\tprivate StringBuilder text &#x3D; new StringBuilder();\n\tpublic String getText() &#123;\n\t\treturn text.toString();\n\t&#125;\n\tpublic void append(String input) &#123;\n\t\ttext.append(input);\n\t&#125;\n\tpublic void setText(String text) &#123;\n\t\tthis.text.replace(0, this.text.length(), text);\n\t&#125;\n&#125;\npublic class SnapshotHolder &#123;\n\tprivate Stack&lt;InputText&gt; snapshots &#x3D; new Stack&lt;&gt;();\n\tpublic InputText popSnapshot() &#123;\n\t\treturn snapshots.pop();\n\t&#125;\n\tpublic void pushSnapshot(InputText inputText) &#123;\n\t\tInputText deepClonedInputText &#x3D; new InputText();\n\t\tdeepClonedInputText.setText(inputText.getText());\n\t\tsnapshots.push(deepClonedInputText);\n\t&#125;\n&#125;\npublic class ApplicationMain &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tInputText inputText &#x3D; new InputText();\n\t\tSnapshotHolder snapshotsHolder &#x3D; new SnapshotHolder();\n\t\tScanner scanner &#x3D; new Scanner(System.in);\n\t\twhile (scanner.hasNext()) &#123;\n\t\t\tString input &#x3D; scanner.next();\n\t\t\tif (input.equals(&quot;:list&quot;)) &#123;\n\t\t\t\tSystem.out.println(inputText.toString());\n\t\t\t&#125; else if (input.equals(&quot;:undo&quot;)) &#123;\n\t\t\t\tInputText snapshot &#x3D; snapshotsHolder.popSnapshot();\n\t\t\t\tinputText.setText(snapshot.getText());\n\t\t\t&#125; else &#123;\n\t\t\t\tsnapshotsHolder.pushSnapshot(inputText);\n\t\t\t\tinputText.append(input);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二点：要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：\n\n为了能用快照恢复 InputText 对象，在 InputText 类中定义了 setText() 函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则\n快照本身是不可变的，理论上讲，不应该包含任何 set() 等修改内部状态的函数，但在上面的代码实现中，“快照“这个业务模型复用了 InputText 类的定义，而 InputText 类本身有一系列修改内部状态的函数，所以，用 InputText 类来表示快照违背了封装原则\n\n针对以上问题，对代码做两点修改。其一，定义一个独立的类（Snapshot 类）来表示快照，而不是复用 InputText 类。这个类只暴露 get() 方法，没有 set() 等任何修改内部状态的方法。其二，在 InputText 类中，把 setText() 方法重命名为 restoreSnapshot() 方法，用意更加明确，只用来恢复对象\npublic class InputText &#123;\n\tprivate StringBuilder text &#x3D; new StringBuilder();\n\tpublic String getText() &#123;\n\t\treturn text.toString();\n\t&#125;\n\tpublic void append(String input) &#123;\n\t\ttext.append(input);\n\t&#125;\n\tpublic Snapshot createSnapshot() &#123;\n\t\treturn new Snapshot(text.toString());\n\t&#125;\n\tpublic void restoreSnapshot(Snapshot snapshot) &#123;\n\t\tthis.text.replace(0, this.text.length(), snapshot.getText());\n\t&#125;\n&#125;\npublic class Snapshot &#123;\n\tprivate String text;\n\tpublic Snapshot(String text) &#123;\n\t\tthis.text &#x3D; text;\n\t&#125;\n\tpublic String getText() &#123;\n\t\treturn this.text;\n\t&#125;\n&#125;\npublic class SnapshotHolder &#123;\n\tprivate Stack&lt;Snapshot&gt; snapshots &#x3D; new Stack&lt;&gt;();\n\tpublic Snapshot popSnapshot() &#123;\n\t\treturn snapshots.pop();\n\t&#125;\n\tpublic void pushSnapshot(Snapshot snapshot) &#123;\n\t\tsnapshots.push(snapshot);\n\t&#125;\n&#125;\npublic class ApplicationMain &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tInputText inputText &#x3D; new InputText();\n\t\tSnapshotHolder snapshotsHolder &#x3D; new SnapshotHolder();\n\t\tScanner scanner &#x3D; new Scanner(System.in);\n\t\twhile (scanner.hasNext()) &#123;\n\t\t\tString input &#x3D; scanner.next();\n\t\t\tif (input.equals(&quot;:list&quot;)) &#123;\n\t\t\t\tSystem.out.println(inputText.toString());\n\t\t\t&#125; else if (input.equals(&quot;:undo&quot;)) &#123;\n\t\t\t\tSnapshot snapshot &#x3D; snapshotsHolder.popSnapshot();\n\t\t\t\tinputText.restoreSnapshot(snapshot);\n\t\t\t&#125; else &#123;\n\t\t\t\tsnapshotsHolder.pushSnapshot(inputText.createSnapshot());\n\t\t\t\tinputText.append(input);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n实际上，上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍（包括 GoF 的《设计模式》）中给出的实现方法\n除了备忘录模式，还有一个跟它很类似的概念，“备份”，它在平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计\n8.2 如何优化内存和时间消耗？如果要备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题该如何解决呢？\n不同的应用场景下有不同的解决方法。比如，前面举的那个例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次输入撤销之前的输入。在具有这样特点的应用场景下，为了节省内存，不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合 InputText 类对象存储的文本来做撤销操作\n假设每当有数据改动，都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频率的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都可能是无法接受的。想要解决这个问题，一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法\n全量备份跟上面的例子类似，就是把所有的数据“拍个快照”保存下来。所谓“增量备份”，指的是记录每次操作或数据变动。当需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗\n9. 命令模式（Command Design Pattern）9.1 原理命令模式的英文翻译是 Command Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：\n\n\n\n\n\n\n\n\n\nThe command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能\n落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。C 语言支持函数指针，可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法作为参数传递给其他函数，也没法赋值给变量。借助命令模式，可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似之前讲过的回调\n当把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方\n9.2 应用假设正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以，后端逻辑相对于客户端来说，要简单很多\n为了提高性能，会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简单了很多\n一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如 Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令也可以叫作事件，数据是执行这个指令所需的数据\n服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路\n\n常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理\n另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了\n\n这里重点讲一下第二种实现方式\n整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示：\npublic interface Command &#123;\n\tvoid execute();\n&#125;\npublic class GotDiamondCommand implements Command &#123;\n\t&#x2F;&#x2F; 省略成员变量\n\tpublic GotDiamondCommand(&#x2F;*数据*&#x2F;) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\t@Override\n\tpublic void execute() &#123;\n\t\t&#x2F;&#x2F; 执行相应的逻辑\n\t&#125;\n&#125;\n&#x2F;&#x2F;GotStartCommand&#x2F;HitObstacleCommand&#x2F;ArchiveCommand类省略\npublic class GameApplication &#123;\n\tprivate static final int MAX_HANDLED_REQ_COUNT_PER_LOOP &#x3D; 100;\n\tprivate Queue&lt;Command&gt; queue &#x3D; new LinkedList&lt;&gt;();\n\tpublic void mainloop() &#123;\n\t\twhile (true) &#123;\n\t\t\tList&lt;Request&gt; requests &#x3D; new ArrayList&lt;&gt;();\n\t\t\t&#x2F;&#x2F;省略从epoll或者select中获取数据，并封装成Request的逻辑，\n\t\t\t&#x2F;&#x2F;注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。\n\t\t\tfor (Request request : requests) &#123;\n\t\t\t\tEvent event &#x3D; request.getEvent();\n\t\t\t\tCommand command &#x3D; null;\n\t\t\t\tif (event.equals(Event.GOT_DIAMOND)) &#123;\n\t\t\t\t\tcommand &#x3D; new GotDiamondCommand(&#x2F;*数据*&#x2F;);\n\t\t\t\t&#125; else if (event.equals(Event.GOT_STAR)) &#123;\n\t\t\t\t\tcommand &#x3D; new GotStartCommand(&#x2F;*数据*&#x2F;);\n\t\t\t\t&#125; else if (event.equals(Event.HIT_OBSTACLE)) &#123;\n\t\t\t\t\tcommand &#x3D; new HitObstacleCommand(&#x2F;*数据*&#x2F;);\n\t\t\t\t&#125; else if (event.equals(Event.ARCHIVE)) &#123;\n\t\t\t\t\tcommand &#x3D; new ArchiveCommand(&#x2F;*数据*&#x2F;);\n\t\t\t\t&#125; &#x2F;&#x2F; ...一堆else if...\n\t\t\t\tqueue.add(command);\n\t\t\t&#125;\n\t\t\tint handledCount &#x3D; 0;\n\t\t\twhile (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;\n\t\t\t\tif (queue.isEmpty()) &#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\tCommand command &#x3D; queue.poll();\n\t\t\t\tcommand.execute();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n9.3 命令模式 VS 策略模式看到这里可能会觉得，命令模式跟策略模式、工厂模式非常相似，那它们的区别在哪里呢？不仅如此，感觉前面的很多模式都很相似，不知道你有没有类似的感觉呢？\n实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉\n实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式\n前面讲策略模式的时候有讲到，策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿\n再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别\n在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换\n10. 解释器模式（Interpreter Design Pattern）10.1 原理与实现解释器模式的英文翻译是 Interpreter Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：\n\n\n\n\n\n\n\n\n\nInterpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法\n这里面有很多平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等\n要想了解“语言”表达的信息，就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器\n实际上，理解这个概念，可以类比中英文翻译。把英文翻译成中文是有一定规则的。这个规则就是定义中的“语法”。开发一个类似 Google Translate 这样的翻译器，这个翻译器能够根据语法规则，将输入的中文翻译成英文。这里的翻译器就是解释器模式定义中的“解释器”\n假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：\n\n运算符只包含加、减、乘、除，并且没有优先级的概念\n表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开\n按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果\n\n比如“ 8 3 2 4 - + * ”这样一个表达式，按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28\npublic class ExpressionInterpreter &#123;\n\tprivate Deque&lt;Long&gt; numbers &#x3D; new LinkedList&lt;&gt;();\n\tpublic long interpret(String expression) &#123;\n\t\tString[] elements &#x3D; expression.split(&quot; &quot;);\n\t\tint length &#x3D; elements.length;\n\t\tfor (int i &#x3D; 0; i &lt; (length+1)&#x2F;2; ++i) &#123;\n\t\t\tnumbers.addLast(Long.parseLong(elements[i]));\n\t\t&#125;\n\t\tfor (int i &#x3D; (length+1)&#x2F;2; i &lt; length; ++i) &#123;\n\t\t\tString operator &#x3D; elements[i];\n\t\t\tboolean isValid &#x3D; &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)\n\t\t\t                  || &quot;*&quot;.equals(operator) || &quot;&#x2F;&quot;.equals(operator);\n\t\t\tif (!isValid) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n\t\t\t&#125;\n\t\t\tlong number1 &#x3D; numbers.pollFirst();\n\t\t\tlong number2 &#x3D; numbers.pollFirst();\n\t\t\tlong result &#x3D; 0;\n\t\t\tif (operator.equals(&quot;+&quot;)) &#123;\n\t\t\t\tresult &#x3D; number1 + number2;\n\t\t\t&#125; else if (operator.equals(&quot;-&quot;)) &#123;\n\t\t\t\tresult &#x3D; number1 - number2;\n\t\t\t&#125; else if (operator.equals(&quot;*&quot;)) &#123;\n\t\t\t\tresult &#x3D; number1 * number2;\n\t\t\t&#125; else if (operator.equals(&quot;&#x2F;&quot;)) &#123;\n\t\t\t\tresult &#x3D; number1 &#x2F; number2;\n\t\t\t&#125;\n\t\t\tnumbers.addFirst(result)\n\t\t&#125;\n\t\tif (numbers.size() !&#x3D; 1) &#123;\n\t\t\tthrow new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n\t\t&#125;\n\t\treturn numbers.pop();\n\t&#125;\n&#125;\n\n在上面的代码实现中，语法规则的解析逻辑（第 23、25、27、29 行）都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是，对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，就要考虑拆分代码，将解析逻辑拆分到独立的小类中\n该怎么拆分呢？可以借助解释器模式\n解释器模式的代码实现比较灵活，没有固定的模板。应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析\n前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。利用解释器模式，把解析的工作拆分到 NumberExpression、AdditionExpression、SubstractionExpression、MultiplicationExpression、DivisionExpression 这样五个解析类中\n按照这个思路，对代码进行重构，重构之后的代码如下所示。当然，因为加减乘除表达式的解析比较简单，利用解释器模式的设计思路，看起来有点过度设计。不过这里主要是为了解释原理\npublic interface Expression &#123;\n\tlong interpret();\n&#125;\npublic class NumberExpression implements Expression &#123;\n\tprivate long number;\n\tpublic NumberExpression(long number) &#123;\n\t\tthis.number &#x3D; number;\n\t&#125;\n\tpublic NumberExpression(String number) &#123;\n\t\tthis.number &#x3D; Long.parseLong(number);\n\t&#125;\n\t@Override\n\tpublic long interpret() &#123;\n\t\treturn this.number;\n\t&#125;\n&#125;\npublic class AdditionExpression implements Expression &#123;\n\tprivate Expression exp1;\n\tprivate Expression exp2;\n\tpublic AdditionExpression(Expression exp1, Expression exp2) &#123;\n\t\tthis.exp1 &#x3D; exp1;\n\t\tthis.exp2 &#x3D; exp2;\n\t&#125;\n\t@Override\n\tpublic long interpret() &#123;\n\t\treturn exp1.interpret() + exp2.interpret();\n\t&#125;\n&#125;\n&#x2F;&#x2F; SubstractionExpression&#x2F;MultiplicationExpression&#x2F;DivisionExpression与Addition\npublic class ExpressionInterpreter &#123;\n\tprivate Deque&lt;Expression&gt; numbers &#x3D; new LinkedList&lt;&gt;();\n\tpublic long interpret(String expression) &#123;\n\t\tString[] elements &#x3D; expression.split(&quot; &quot;);\n\t\tint length &#x3D; elements.length;\n\t\tfor (int i &#x3D; 0; i &lt; (length+1)&#x2F;2; ++i) &#123;\n\t\t\tnumbers.addLast(new NumberExpression(elements[i]));\n\t\t&#125;\n\t\tfor (int i &#x3D; (length+1)&#x2F;2; i &lt; length; ++i) &#123;\n\t\t\tString operator &#x3D; elements[i];\n\t\t\tboolean isValid &#x3D; &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)\n\t\t\t                  || &quot;*&quot;.equals(operator) || &quot;&#x2F;&quot;.equals(operator);\n\t\t\tif (!isValid) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n\t\t\t&#125;\n\t\t\tExpression exp1 &#x3D; numbers.pollFirst();\n\t\t\tExpression exp2 &#x3D; numbers.pollFirst();\n\t\t\tExpression combinedExp &#x3D; null;\n\t\t\tif (operator.equals(&quot;+&quot;)) &#123;\n\t\t\t\tcombinedExp &#x3D; new AdditionExpression(exp1, exp2);\n\t\t\t&#125; else if (operator.equals(&quot;-&quot;)) &#123;\n\t\t\t\tcombinedExp &#x3D; new AdditionExpression(exp1, exp2);\n\t\t\t&#125; else if (operator.equals(&quot;*&quot;)) &#123;\n\t\t\t\tcombinedExp &#x3D; new AdditionExpression(exp1, exp2);\n\t\t\t&#125; else if (operator.equals(&quot;&#x2F;&quot;)) &#123;\n\t\t\t\tcombinedExp &#x3D; new AdditionExpression(exp1, exp2);\n\t\t\t&#125;\n\t\t\tlong result &#x3D; combinedExp.interpret();\n\t\t\tnumbers.addFirst(new NumberExpression(result));\n\t\t&#125;\n\t\tif (numbers.size() !&#x3D; 1) &#123;\n\t\t\tthrow new RuntimeException(&quot;Expression is invalid: &quot; + expression);\n\t\t&#125;\n\t\treturn numbers.pop().interpret();\n\t&#125;\n&#125;\n\n10.2 如何实现一个自定义接口告警规则功能？在平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过 100，监控系统就通过短信、微信、邮件等方式发送告警给开发者\n一般来讲，监控系统支持开发者自定义告警规则，比如可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 100 或者每分钟 API 总调用数超过 10000 就触发告警\n\n\n\n\n\n\n\n\n\napi_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000\n在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟 API 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个 Map 中（数据的格式如下所示），发送给告警模块\nMap&lt;String, Long&gt; apiStat &#x3D; new HashMap&lt;&gt;();\napiStat.put(&quot;api_error_per_minute&quot;, 103);\napiStat.put(&quot;api_count_per_minute&quot;, 987);\n\n为了简化，假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、=&#x3D;”这五个运算符，其中，“&gt;、&lt;、&#x3D;&#x3D;”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute\n那如何实现上面的需求呢？骨架代码如下所示\npublic class AlertRuleInterpreter &#123;\n\t&#x2F;&#x2F; key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 &#x3D;&#x3D; 200\n\tpublic AlertRuleInterpreter(String ruleExpression) &#123;\n\t\t&#x2F;&#x2F;TODO\n\t&#125;\n\t&#x2F;&#x2F;&lt;String, Long&gt; apiStat &#x3D; new HashMap&lt;&gt;();\n\t&#x2F;&#x2F;apiStat.put(&quot;key1&quot;, 103);\n\t&#x2F;&#x2F;apiStat.put(&quot;key2&quot;, 987);\n\tpublic boolean interpret(Map&lt;String, Long&gt; stats) &#123;\n\t\t&#x2F;&#x2F;TODO\n\t&#125;\n&#125;\npublic class DemoTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tString rule &#x3D; &quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 &#x3D;&#x3D; 88&quot;;\n\t\tAlertRuleInterpreter interpreter &#x3D; new AlertRuleInterpreter(rule);\n\t\tMap&lt;String, Long&gt; stats &#x3D; new HashMap&lt;&gt;();\n\t\tstats.put(&quot;key1&quot;, 101l);\n\t\tstats.put(&quot;key3&quot;, 121l);\n\t\tstats.put(&quot;key4&quot;, 88l);\n\t\tboolean alert &#x3D; interpreter.interpret(stats);\n\t\tSystem.out.println(alert);\n\t&#125;\n&#125;\n\n实际上，可以把自定义的告警规则，看作一种特殊“语言”的语法规则。实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路，把刚刚的代码补全\npublic interface Expression &#123;\n\tboolean interpret(Map&lt;String, Long&gt; stats);\n&#125;\npublic class GreaterExpression implements Expression &#123;\n\tprivate String key;\n\tprivate long value;\n\tpublic GreaterExpression(String strExpression) &#123;\n\t\tString[] elements &#x3D; strExpression.trim().split(&quot;\\\\s+&quot;);\n\t\tif (elements.length !&#x3D; 3 || !elements[1].trim().equals(&quot;&gt;&quot;)) &#123;\n\t\t\tthrow new RuntimeException(&quot;Expression is invalid: &quot; + strExpression);\n\t\t&#125;\n\t\tthis.key &#x3D; elements[0].trim();\n\t\tthis.value &#x3D; Long.parseLong(elements[2].trim());\n\t&#125;\n\tpublic GreaterExpression(String key, long value) &#123;\n\t\tthis.key &#x3D; key;\n\t\tthis.value &#x3D; value;\n\t&#125;\n\t@Override\n\tpublic boolean interpret(Map&lt;String, Long&gt; stats) &#123;\n\t\tif (!stats.containsKey(key)) &#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\tlong statValue &#x3D; stats.get(key);\n\t\treturn statValue &gt; value;\n\t&#125;\n&#125;\n&#x2F;&#x2F; LessExpression&#x2F;EqualExpression跟GreaterExpression代码类似，这里就省略了\npublic class AndExpression implements Expression &#123;\n\tprivate List&lt;Expression&gt; expressions &#x3D; new ArrayList&lt;&gt;();\n\tpublic AndExpression(String strAndExpression) &#123;\n\t\tString[] strExpressions &#x3D; strAndExpression.split(&quot;&amp;&amp;&quot;);\n\t\tfor (String strExpr : strExpressions) &#123;\n\t\t\tif (strExpr.contains(&quot;&gt;&quot;)) &#123;\n\t\t\t\texpressions.add(new GreaterExpression(strExpr));\n\t\t\t&#125; else if (strExpr.contains(&quot;&lt;&quot;)) &#123;\n\t\t\t\texpressions.add(new LessExpression(strExpr));\n\t\t\t&#125; else if (strExpr.contains(&quot;&#x3D;&#x3D;&quot;)) &#123;\n\t\t\t\texpressions.add(new EqualExpression(strExpr));\n\t\t\t&#125; else &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Expression is invalid: &quot; + strAndExpression\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tpublic AndExpression(List&lt;Expression&gt; expressions) &#123;\n\t\tthis.expressions.addAll(expressions);\n\t&#125;\n\t@Override\n\tpublic boolean interpret(Map&lt;String, Long&gt; stats) &#123;\n\t\tfor (Expression expr : expressions) &#123;\n\t\t\tif (!expr.interpret(stats)) &#123;\n\t\t\t\treturn false;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n&#125;\npublic class OrExpression implements Expression &#123;\n\tprivate List&lt;Expression&gt; expressions &#x3D; new ArrayList&lt;&gt;();\n\tpublic OrExpression(String strOrExpression) &#123;\n\t\tString[] andExpressions &#x3D; strOrExpression.split(&quot;\\\\|\\\\|&quot;);\n\t\tfor (String andExpr : andExpressions) &#123;\n\t\t\texpressions.add(new AndExpression(andExpr));\n\t\t&#125;\n\t&#125;\n\tpublic OrExpression(List&lt;Expression&gt; expressions) &#123;\n\t\tthis.expressions.addAll(expressions);\n\t&#125;\n\t@Override\n\tpublic boolean interpret(Map&lt;String, Long&gt; stats) &#123;\n\t\tfor (Expression expr : expressions) &#123;\n\t\t\tif (expr.interpret(stats)) &#123;\n\t\t\t\treturn true;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn false;\n\t&#125;\n&#125;\npublic class AlertRuleInterpreter &#123;\n\tprivate Expression expression;\n\tpublic AlertRuleInterpreter(String ruleExpression) &#123;\n\t\tthis.expression &#x3D; new OrExpression(ruleExpression);\n\t&#125;\n\tpublic boolean interpret(Map&lt;String, Long&gt; stats) &#123;\n\t\treturn expression.interpret(stats);\n\t&#125;\n&#125;\n\n11. 中介模式（Mediator Design Pattern）11.1 原理与实现中介模式的英文翻译是 Mediator Design Pattern。在 GoF 中的《设计模式》一书中，它是这样定义的：\n\n\n\n\n\n\n\n\n\nMediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互\n在前面讲到“如何给代码解耦”时，其中一个方法就是引入中间层。实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性\n这里画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关系优化之后的结果，从图中可以很直观地看出，右边的交互关系更加清晰、简洁\n\n提到中介模式，有一个比较经典的例子不得不说，那就是航空管制\n为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络\n再举一个跟编程开发相关的例子。这个例子与 UI 控件有关，算是中介模式比较经典的应用，很多书籍在讲到中介模式的时候，都会拿它来举例\n假设有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当对某个控件进行操作的时候，其他控件会做出相应的反应，比如，在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中\n按照通常习惯的 UI 界面的开发方式，将刚刚的需求用代码实现出来，就是下面这个样子。在这种实现方式中，控件和控件之间互相操作、互相依赖\npublic class UIControl &#123;\n\tprivate static final String LOGIN_BTN_ID &#x3D; &quot;login_btn&quot;;\n\tprivate static final String REG_BTN_ID &#x3D; &quot;reg_btn&quot;;\n\tprivate static final String USERNAME_INPUT_ID &#x3D; &quot;username_input&quot;;\n\tprivate static final String PASSWORD_INPUT_ID &#x3D; &quot;pswd_input&quot;;\n\tprivate static final String REPEATED_PASSWORD_INPUT_ID &#x3D; &quot;repeated_pswd_input&quot;;\n\t        private static final String HINT_TEXT_ID &#x3D; &quot;hint_text&quot;;\n\tprivate static final String SELECTION_ID &#x3D; &quot;selection&quot;;\n\tpublic static void main(String[] args) &#123;\n\t\tButton loginButton &#x3D; (Button)findViewById(LOGIN_BTN_ID);\n\t\tButton regButton &#x3D; (Button)findViewById(REG_BTN_ID);\n\t\tInput usernameInput &#x3D; (Input)findViewById(USERNAME_INPUT_ID);\n\t\tInput passwordInput &#x3D; (Input)findViewById(PASSWORD_INPUT_ID);\n\t\tInput repeatedPswdInput &#x3D; (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n\t\tText hintText &#x3D; (Text)findViewById(HINT_TEXT_ID);\n\t\tSelection selection &#x3D; (Selection)findViewById(SELECTION_ID);\n\t\tloginButton.setOnClickListener(new OnClickListener() &#123;\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) &#123;\n\t\t\t\tString username &#x3D; usernameInput.text();\n\t\t\t\tString password &#x3D; passwordInput.text();\n\t\t\t\t&#x2F;&#x2F;校验数据...\n\t\t\t\t&#x2F;&#x2F;做业务处理...\n\t\t\t&#125;\n\t\t&#125;);\n\t\tregButton.setOnClickListener(new OnClickListener() &#123;\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) &#123;\n\t\t\t\t&#x2F;&#x2F;获取usernameInput、passwordInput、repeatedPswdInput数据...\n\t\t\t\t&#x2F;&#x2F;校验数据...\n\t\t\t\t&#x2F;&#x2F;做业务处理...\n\t\t\t&#125;\n\t\t&#125;);\n\t\t&#x2F;&#x2F;...省略selection下拉选择框相关代码....\n\t&#125;\n&#125;\n\n再按照中介模式，将上面的代码重新实现一下。在新的代码实现中，各个控件只跟中介对象交互，中介对象负责所有业务逻辑的处理\npublic interface Mediator &#123;\n\tvoid handleEvent(Component component, String event);\n&#125;\npublic class LandingPageDialog implements Mediator &#123;\n\tprivate Button loginButton;\n\tprivate Button regButton;\n\tprivate Selection selection;\n\tprivate Input usernameInput;\n\tprivate Input passwordInput;\n\tprivate Input repeatedPswdInput;\n\tprivate Text hintText;\n\t@Override\n\tpublic void handleEvent(Component component, String event) &#123;\n\t\tif (component.equals(loginButton)) &#123;\n\t\t\tString username &#x3D; usernameInput.text();\n\t\t\tString password &#x3D; passwordInput.text();\n\t\t\t&#x2F;&#x2F;校验数据...\n\t\t\t&#x2F;&#x2F;做业务处理...\n\t\t&#125; else if (component.equals(regButton)) &#123;\n\t\t\t&#x2F;&#x2F;获取usernameInput、passwordInput、repeatedPswdInput数据...\n\t\t\t&#x2F;&#x2F;校验数据...\n\t\t\t&#x2F;&#x2F;做业务处理...\n\t\t&#125; else if (component.equals(selection)) &#123;\n\t\t\tString selectedItem &#x3D; selection.select();\n\t\t\tif (selectedItem.equals(&quot;login&quot;)) &#123;\n\t\t\t\tusernameInput.show();\n\t\t\t\tpasswordInput.show();\n\t\t\t\trepeatedPswdInput.hide();\n\t\t\t\thintText.hide();\n\t\t\t\t&#x2F;&#x2F;...省略其他代码\n\t\t\t&#125; else if (selectedItem.equals(&quot;register&quot;)) &#123;\n\t\t\t\t&#x2F;&#x2F;....\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\npublic class UIControl &#123;\n\tprivate static final String LOGIN_BTN_ID &#x3D; &quot;login_btn&quot;;\n\tprivate static final String REG_BTN_ID &#x3D; &quot;reg_btn&quot;;\n\tprivate static final String USERNAME_INPUT_ID &#x3D; &quot;username_input&quot;;\n\tprivate static final String PASSWORD_INPUT_ID &#x3D; &quot;pswd_input&quot;;\n\tprivate static final String REPEATED_PASSWORD_INPUT_ID &#x3D; &quot;repeated_pswd_input&quot;;\n\t        private static final String HINT_TEXT_ID &#x3D; &quot;hint_text&quot;;\n\tprivate static final String SELECTION_ID &#x3D; &quot;selection&quot;;\n\tpublic static void main(String[] args) &#123;\n\t\tButton loginButton &#x3D; (Button)findViewById(LOGIN_BTN_ID);\n\t\tButton regButton &#x3D; (Button)findViewById(REG_BTN_ID);\n\t\tInput usernameInput &#x3D; (Input)findViewById(USERNAME_INPUT_ID);\n\t\tInput passwordInput &#x3D; (Input)findViewById(PASSWORD_INPUT_ID);\n\t\tInput repeatedPswdInput &#x3D; (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n\t\tText hintText &#x3D; (Text)findViewById(HINT_TEXT_ID);\n\t\tSelection selection &#x3D; (Selection)findViewById(SELECTION_ID);\n\t\tMediator dialog &#x3D; new LandingPageDialog();\n\t\tdialog.setLoginButton(loginButton);\n\t\tdialog.setRegButton(regButton);\n\t\tdialog.setUsernameInput(usernameInput);\n\t\tdialog.setPasswordInput(passwordInput);\n\t\tdialog.setRepeatedPswdInput(repeatedPswdInput);\n\t\tdialog.setHintText(hintText);\n\t\tdialog.setSelection(selection);\n\t\tloginButton.setOnClickListener(new OnClickListener() &#123;\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) &#123;\n\t\t\t\tdialog.handleEvent(loginButton, &quot;click&quot;);\n\t\t\t&#125;\n\t\t&#125;);\n\t\tregButton.setOnClickListener(new OnClickListener() &#123;\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) &#123;\n\t\t\t\tdialog.handleEvent(regButton, &quot;click&quot;);\n\t\t\t&#125;\n\t\t&#125;);\n\t\t&#x2F;&#x2F;....\n\t&#125;\n&#125;\n\n从代码中可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实际上，这样做既有好处，也有坏处。好处是简化了控件之间的交互，坏处是中介类有可能会变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度\n11.2 中介模式 VS 观察者模式前面讲观察者模式的时候讲到，观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的 update() 方法。但是，在跨进程的实现方式中，可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在\n而中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？\n在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理\n而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的\n","slug":"BlogRepository/设计模式/设计模式之美总结（行为型篇）","date":"2022-12-26T09:25:29.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"0e3cbfa1ef18be6a0efacfe867734435","title":"SpringBoot 结合 MyBatis-Plus 配置多数据源以及结合 p6spy 打印 SQL 日志","content":"1. 配置多数据源官网：多数据源 | MyBatis-Plus (baomidou.com)\n1.1 引入依赖&lt;dependency&gt;\n  &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.5.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n1.2 配置数据源在 application.yml 文件或其他同等配置文件中进行配置\nspring:\n  datasource:\n    dynamic:\n      primary: master #设置默认的数据源或者数据源组,默认值即为master\n      strict: false #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源\n      datasource:\n        master:\n          url: jdbc:mysql:&#x2F;&#x2F;xx.xx.xx.xx:3306&#x2F;dynamic\n          username: root\n          password: 123456\n          driver-class-name: com.mysql.jdbc.Driver # 3.2.0开始支持SPI可省略此配置\n        slave_1:\n          url: jdbc:mysql:&#x2F;&#x2F;xx.xx.xx.xx:3307&#x2F;dynamic\n          username: root\n          password: 123456\n          driver-class-name: com.mysql.jdbc.Driver\n        slave_2:\n          url: ENC(xxxxx) # 内置加密,使用请查看详细文档\n          username: ENC(xxxxx)\n          password: ENC(xxxxx)\n          driver-class-name: com.mysql.jdbc.Driver\n       #......省略\n       #以上会配置一个默认库master，一个组slave下有两个子库slave_1,slave_2\n\n# 多主多从                      纯粹多库（记得设置primary）                   混合配置\nspring:                               spring:                               spring:\n  datasource:                           datasource:                           datasource:\n    dynamic:                              dynamic:                              dynamic:\n      datasource:                           datasource:                           datasource:\n        master_1:                             mysql:                                master:\n        master_2:                             oracle:                               slave_1:\n        slave_1:                              sqlserver:                            slave_2:\n        slave_2:                              postgresql:                           oracle_1:\n        slave_3:                              h2:                                   oracle_2:\n\n1.3 使用使用 @DS 切换数据源，@DS 可以注解在方法上或类上，同时存在就近原则 方法上注解 优先于 类上注解\n\n\n\n注解\n结果\n\n\n\n没有@DS\n默认数据源\n\n\n@DS(“dsName”)\ndsName可以为组名也可以为具体某个库的名称\n\n\n@Service\n@DS(&quot;slave&quot;)\npublic class UserServiceImpl implements UserService &#123;\n\n  @Autowired\n  private JdbcTemplate jdbcTemplate;\n\n  public List selectAll() &#123;\n    return  jdbcTemplate.queryForList(&quot;select * from user&quot;);\n  &#125;\n  \n  @Override\n  @DS(&quot;slave_1&quot;)\n  public List selectByCondition() &#123;\n    return  jdbcTemplate.queryForList(&quot;select * from user where age &gt; 10&quot;);\n  &#125;\n&#125;\n\n其实直接标注在 DAO 接口上即可\n1.4 示例application-dev.yml 配置，这里用了下面的 p6spy 来打印日志\nspring:\n  datasource:\n    dynamic:\n      primary: common\n      strict: false\n      datasource:\n        common:\n          driver-class-name: com.p6spy.engine.spy.P6SpyDriver\n          url: jdbc:p6spy:mysql:&#x2F;&#x2F;124.xxx.xxx.90:3306&#x2F;common?connectTimeout&#x3D;5000&amp;socketTimeout&#x3D;10000&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;GMT%2B8\n          username: root\n          password: xxx\n        resNav:\n          driver-class-name: com.p6spy.engine.spy.P6SpyDriver\n          url: jdbc:p6spy:mysql:&#x2F;&#x2F;124.xxx.xxx.90:3306&#x2F;resource_nav?connectTimeout&#x3D;5000&amp;socketTimeout&#x3D;10000&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;GMT%2B8\n          username: root\n          password: xxx\n      druid:\n        # 关闭空闲检测\n        # test-while-idle: false\n        # 设置空闲检测语句\n        validation-query: SELECT 1\n\n2. p6spy 打印 SQL 日志p6spy GitHub 地址：p6spy&#x2F;p6spy (github.com)\nMyBatis-Plus 结合 p6spy：MyBatis-Plus (baomidou.com)\n2.1 引入依赖&lt;dependency&gt;\n        &lt;groupId&gt;p6spy&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;p6spy&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;3.9.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.2 配置将 Driver 替换为 p6spy，同时 url 在 jdbc 后加上 p6spy 即可，示例见 1.4\nspring:\n  datasource:\n    driver-class-name: com.p6spy.engine.spy.P6SpyDriver\n    url: jdbc:p6spy:h2:mem:test\n    ...\n\n2.3 spy.properties 配置在 resource 目录下创建 spy.properties，即可对 p6spy 进行自定义配置。其中，结合 MyBatis-Plus 的配置如下：\n#3.2.1以上使用\nmodulelist&#x3D;com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory\n#3.2.1以下使用或者不配置\n#modulelist&#x3D;com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory\n# 自定义日志打印\nlogMessageFormat&#x3D;com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger\n#日志输出到控制台\nappender&#x3D;com.baomidou.mybatisplus.extension.p6spy.StdoutLogger\n# 使用日志系统记录 sql\n#appender&#x3D;com.p6spy.engine.spy.appender.Slf4JLogger\n# 设置 p6spy driver 代理\nderegisterdrivers&#x3D;true\n# 取消JDBC URL前缀\nuseprefix&#x3D;true\n# 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.\nexcludecategories&#x3D;info,debug,result,commit,resultset\n# 日期格式\ndateformat&#x3D;yyyy-MM-dd HH:mm:ss\n# 实际驱动可多个\n#driverlist&#x3D;org.h2.Driver\n# 是否开启慢SQL记录\noutagedetection&#x3D;true\n# 慢SQL记录标准 2 秒\noutagedetectioninterval&#x3D;2\n\np6spy 完整配置如下，详细可见：**Configuration and Usage — p6spy documentation**\n#################################################################\n# P6Spy Options File                                            #\n# See documentation for detailed instructions                   #\n# http:&#x2F;&#x2F;p6spy.github.io&#x2F;p6spy&#x2F;2.0&#x2F;configandusage.html          #\n#################################################################\n\n#################################################################\n# MODULES                                                       #\n#                                                               #\n# Module list adapts the modular functionality of P6Spy.        #\n# Only modules listed are active.                               #\n# (default is com.p6spy.engine.logging.P6LogFactory and         #\n# com.p6spy.engine.spy.P6SpyFactory)                            #\n# Please note that the core module (P6SpyFactory) can&#39;t be      #\n# deactivated.                                                  #\n# Unlike the other properties, activation of the changes on     #\n# this one requires reload.                                     #\n#################################################################\n#modulelist&#x3D;com.p6spy.engine.spy.P6SpyFactory,com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory\n\n################################################################\n# CORE (P6SPY) PROPERTIES                                      #\n################################################################\n\n# A comma separated list of JDBC drivers to load and register.\n# (default is empty)\n#\n# Note: This is normally only needed when using P6Spy in an\n# application server environment with a JNDI data source or when\n# using a JDBC driver that does not implement the JDBC 4.0 API\n# (specifically automatic registration).\n#driverlist&#x3D;\n\n# for flushing per statement\n# (default is false)\n#autoflush&#x3D;false\n\n# sets the date format using Java&#39;s SimpleDateFormat routine.\n# In case property is not set, milliseconds since 1.1.1970 (unix time) is used (default is empty)\n#dateformat&#x3D;\n\n# prints a stack trace for every statement logged\n#stacktrace&#x3D;false\n# if stacktrace&#x3D;true, specifies the stack trace to print\n#stacktraceclass&#x3D;\n\n# determines if property file should be reloaded\n# Please note: reload means forgetting all the previously set\n# settings (even those set during runtime - via JMX)\n# and starting with the clean table\n# (default is false)\n#reloadproperties&#x3D;false\n\n# determines how often should be reloaded in seconds\n# (default is 60)\n#reloadpropertiesinterval&#x3D;60\n\n# specifies the appender to use for logging\n# Please note: reload means forgetting all the previously set\n# settings (even those set during runtime - via JMX)\n# and starting with the clean table\n# (only the properties read from the configuration file)\n# (default is com.p6spy.engine.spy.appender.FileLogger)\n#appender&#x3D;com.p6spy.engine.spy.appender.Slf4JLogger\n#appender&#x3D;com.p6spy.engine.spy.appender.StdoutLogger\n#appender&#x3D;com.p6spy.engine.spy.appender.FileLogger\n\n# name of logfile to use, note Windows users should make sure to use forward slashes in their pathname (e:&#x2F;test&#x2F;spy.log)\n# (used for com.p6spy.engine.spy.appender.FileLogger only)\n# (default is spy.log)\n#logfile&#x3D;spy.log\n\n# append to the p6spy log file. if this is set to false the\n# log file is truncated every time. (file logger only)\n# (default is true)\n#append&#x3D;true\n\n# class to use for formatting log messages (default is: com.p6spy.engine.spy.appender.SingleLineFormat)\n#logMessageFormat&#x3D;com.p6spy.engine.spy.appender.SingleLineFormat\n\n# Custom log message format used ONLY IF logMessageFormat is set to com.p6spy.engine.spy.appender.CustomLineFormat\n# default is %(currentTime)|%(executionTime)|%(category)|connection%(connectionId)|%(sqlSingleLine)\n# Available placeholders are:\n#   %(connectionId)            the id of the connection\n#   %(currentTime)             the current time expressing in milliseconds\n#   %(executionTime)           the time in milliseconds that the operation took to complete\n#   %(category)                the category of the operation\n#   %(effectiveSql)            the SQL statement as submitted to the driver\n#   %(effectiveSqlSingleLine)  the SQL statement as submitted to the driver, with all new lines removed\n#   %(sql)                     the SQL statement with all bind variables replaced with actual values\n#   %(sqlSingleLine)           the SQL statement with all bind variables replaced with actual values, with all new lines removed\n#customLogMessageFormat&#x3D;%(currentTime)|%(executionTime)|%(category)|connection%(connectionId)|%(sqlSingleLine)\n\n# format that is used for logging of the java.util.Date implementations (has to be compatible with java.text.SimpleDateFormat)\n# (default is yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ)\n#databaseDialectDateFormat&#x3D;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ\n\n# format that is used for logging of the java.sql.Timestamp implementations (has to be compatible with java.text.SimpleDateFormat)\n# (default is yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ)\n#databaseDialectTimestampFormat&#x3D;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ\n\n# format that is used for logging booleans, possible values: boolean, numeric\n# (default is boolean)\n#databaseDialectBooleanFormat&#x3D;boolean\n\n# Specifies the format for logging binary data. Not applicable if excludebinary is true.\n# (default is com.p6spy.engine.logging.format.HexEncodedBinaryFormat)\n#databaseDialectBinaryFormat&#x3D;com.p6spy.engine.logging.format.PostgreSQLBinaryFormat\n#databaseDialectBinaryFormat&#x3D;com.p6spy.engine.logging.format.MySQLBinaryFormat\n#databaseDialectBinaryFormat&#x3D;com.p6spy.engine.logging.format.HexEncodedBinaryFormat\n\n# whether to expose options via JMX or not\n# (default is true)\n#jmx&#x3D;true\n\n# if exposing options via jmx (see option: jmx), what should be the prefix used?\n# jmx naming pattern constructed is: com.p6spy(.&lt;jmxPrefix&gt;)?:name&#x3D;&lt;optionsClassName&gt;\n# please note, if there is already such a name in use it would be unregistered first (the last registered wins)\n# (default is none)\n#jmxPrefix&#x3D;\n\n# if set to true, the execution time will be measured in nanoseconds as opposed to milliseconds\n# (default is false)\n#useNanoTime&#x3D;false\n\n#################################################################\n# DataSource replacement                                        #\n#                                                               #\n# Replace the real DataSource class in your application server  #\n# configuration with the name com.p6spy.engine.spy.P6DataSource #\n# (that provides also connection pooling and xa support).       #\n# then add the JNDI name and class name of the real             #\n# DataSource here                                               #\n#                                                               #\n# Values set in this item cannot be reloaded using the          #\n# reloadproperties variable. Once it is loaded, it remains      #\n# in memory until the application is restarted.                 #\n#                                                               #\n#################################################################\n#realdatasource&#x3D;&#x2F;RealMySqlDS\n#realdatasourceclass&#x3D;com.mysql.jdbc.jdbc2.optional.MysqlDataSource\n\n#################################################################\n# DataSource properties                                         #\n#                                                               #\n# If you are using the DataSource support to intercept calls    #\n# to a DataSource that requires properties for proper setup,    #\n# define those properties here. Use name value pairs, separate  #\n# the name and value with a semicolon, and separate the         #\n# pairs with commas.                                            #\n#                                                               #\n# The example shown here is for mysql                           #\n#                                                               #\n#################################################################\n#realdatasourceproperties&#x3D;port;3306,serverName;myhost,databaseName;jbossdb,foo;bar\n\n#################################################################\n# JNDI DataSource lookup                                        #\n#                                                               #\n# If you are using the DataSource support outside of an app     #\n# server, you will probably need to define the JNDI Context     #\n# environment.                                                  #\n#                                                               #\n# If the P6Spy code will be executing inside an app server then #\n# do not use these properties, and the DataSource lookup will   #\n# use the naming context defined by the app server.             #\n#                                                               #\n# The two standard elements of the naming environment are       #\n# jndicontextfactory and jndicontextproviderurl. If you need    #\n# additional elements, use the jndicontextcustom property.      #\n# You can define multiple properties in jndicontextcustom,      #\n# in name value pairs. Separate the name and value with a       #\n# semicolon, and separate the pairs with commas.                #\n#                                                               #\n# The example shown here is for a standalone program running on #\n# a machine that is also running JBoss, so the JNDI context     #\n# is configured for JBoss (3.0.4).                              #\n#                                                               #\n# (by default all these are empty)                              #\n#################################################################\n#jndicontextfactory&#x3D;org.jnp.interfaces.NamingContextFactory\n#jndicontextproviderurl&#x3D;localhost:1099\n#jndicontextcustom&#x3D;java.naming.factory.url.pkgs;org.jboss.naming:org.jnp.interfaces\n\n#jndicontextfactory&#x3D;com.ibm.websphere.naming.WsnInitialContextFactory\n#jndicontextproviderurl&#x3D;iiop:&#x2F;&#x2F;localhost:900\n\n################################################################\n# P6 LOGGING SPECIFIC PROPERTIES                               #\n################################################################\n\n# filter what is logged\n# please note this is a precondition for usage of: include&#x2F;exclude&#x2F;sqlexpression\n# (default is false)\n#filter&#x3D;false\n\n# comma separated list of strings to include\n# please note that special characters escaping (used in java) has to be done for the provided regular expression\n# (default is empty)\n#include&#x3D;\n# comma separated list of strings to exclude\n# (default is empty)\n#exclude&#x3D;\n\n# sql expression to evaluate if using regex\n# please note that special characters escaping (used in java) has to be done for the provided regular expression\n# (default is empty)\n#sqlexpression&#x3D;\n\n#list of categories to exclude: error, info, batch, debug, statement,\n#commit, rollback, result and resultset are valid values\n# (default is info,debug,result,resultset,batch)\n#excludecategories&#x3D;info,debug,result,resultset,batch\n\n#whether the binary values (passed to DB or retrieved ones) should be logged with placeholder: [binary] or not.\n# (default is false)\n#excludebinary&#x3D;false\n\n# Execution threshold applies to the standard logging of P6Spy.\n# While the standard logging logs out every statement\n# regardless of its execution time, this feature puts a time\n# condition on that logging. Only statements that have taken\n# longer than the time specified (in milliseconds) will be\n# logged. This way it is possible to see only statements that\n# have exceeded some high water mark.\n# This time is reloadable.\n#\n# executionThreshold&#x3D;integer time (milliseconds)\n# (default is 0)\n#executionThreshold&#x3D;\n\n################################################################\n# P6 OUTAGE SPECIFIC PROPERTIES                                #\n################################################################\n# Outage Detection\n#\n# This feature detects long-running statements that may be indicative of\n# a database outage problem. If this feature is turned on, it will log any\n# statement that surpasses the configurable time boundary during its execution.\n# When this feature is enabled, no other statements are logged except the long\n# running statements. The interval property is the boundary time set in seconds.\n# For example, if this is set to 2, then any statement requiring at least 2\n# seconds will be logged. Note that the same statement will continue to be logged\n# for as long as it executes. So if the interval is set to 2, and the query takes\n# 11 seconds, it will be logged 5 times (at the 2, 4, 6, 8, 10 second intervals).\n#\n# outagedetection&#x3D;true|false\n# outagedetectioninterval&#x3D;integer time (seconds)\n#\n# (default is false)\n#outagedetection&#x3D;false\n# (default is 60)\n#outagedetectioninterval&#x3D;30\n","slug":"BlogRepository/开发技术及框架/SpringBoot 结合 MyBatis-Plus 配置多数据源以及结合 p6spy 打印 SQL 日志","date":"2022-12-23T03:23:16.000Z","categories_index":"开发技术及框架","tags_index":"MyBatis-Plus,SpringBoot","author_index":"凡"},{"id":"dc36ba1463e60735e3396234d94e7099","title":"设计模式之美总结（结构型篇）","content":"前四篇见：\n\n设计模式之美总结（面向对象篇）_凡 223 的博客\n设计模式之美总结（设计原则篇）_凡 223 的博客\n设计模式之美总结（重构篇）_凡 223 的博客\n设计模式之美总结（创建型篇）_凡 223 的博客\n\n1. 代理模式（Proxy Design Pattern）1.1 原理解析代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握，它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。如下例，这是一个性能计数器，用来收集接口请求的原始数据，比如访问时间、处理时长等\npublic class UserController &#123;\n\t&#x2F;&#x2F;...省略其他属性和方法...\n\tprivate MetricsCollector metricsCollector; &#x2F;&#x2F; 依赖注入\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong  &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; ... 省略login逻辑...\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; ... 省略register逻辑...\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n&#125;\n\n很明显，上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理\n为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。具体的代码实现如下所示：\npublic interface IUserController &#123;\n\tUserVo login(String telephone, String password);\n\tUserVo register(String telephone, String password);\n&#125;\npublic class UserController implements IUserController &#123;\n\t&#x2F;&#x2F;...省略其他属性和方法...\n\t@Override\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;...省略login逻辑...\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n\t@Override\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\t&#x2F;&#x2F;...省略register逻辑...\n\t\t&#x2F;&#x2F;...返回UserVo数据...\n\t&#125;\n&#125;\npublic class UserControllerProxy implements IUserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tprivate UserController userController;\n\tpublic UserControllerProxy(UserController userController) &#123;\n\t\tthis.userController &#x3D; userController;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\t@Override\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t&#x2F;&#x2F; 委托\n\t\tUserVo userVo &#x3D; userController.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n\t@Override\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; userController.register(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;UserControllerProxy使用举例\n&#x2F;&#x2F;因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n&#x2F;&#x2F;将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController &#x3D; new UserControllerProxy(new UserController())\n\n参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，该如何实现代理模式呢？\n对于这种外部类的扩展，一般都是采用继承的方式。让代理类继承原始类，然后扩展附加功能，具体代码如下所示：\npublic class UserControllerProxy extends UserController &#123;\n\tprivate MetricsCollector metricsCollector;\n\tpublic UserControllerProxy() &#123;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\tpublic UserVo login(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; super.login(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n\tpublic UserVo register(String telephone, String password) &#123;\n\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\tUserVo userVo &#x3D; super.register(telephone, password);\n\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\tRequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n\t\tmetricsCollector.recordRequest(requestInfo);\n\t\treturn userVo;\n\t&#125;\n&#125;\n&#x2F;&#x2F;UserControllerProxy使用举例\nUserController userController &#x3D; new UserControllerProxy();\n\n1.2 动态代理不过，刚刚的代码实现还是有点问题。一方面，需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，需要针对每个类都创建一个代理类\n如果有 50 个要添加附加功能的原始类，那就要创建 50 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。那这个问题怎么解决呢？\n可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？\n如果熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法），代码如下所示。其中，MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类\npublic class MetricsCollectorProxy &#123;\n\tprivate MetricsCollector metricsCollector;\n\tpublic MetricsCollectorProxy() &#123;\n\t\tthis.metricsCollector &#x3D; new MetricsCollector();\n\t&#125;\n\tpublic Object createProxy(Object proxiedObject) &#123;\n\t\tClass&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();\n\t\tDynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);\n\t\treturn Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces\n\t&#125;\n\tprivate class DynamicProxyHandler implements InvocationHandler &#123;\n\t\tprivate Object proxiedObject;\n\t\tpublic DynamicProxyHandler(Object proxiedObject) &#123;\n\t\t\tthis.proxiedObject &#x3D; proxiedObject;\n\t\t&#125;\n\t\t@Override\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n\t\t\tlong startTimestamp &#x3D; System.currentTimeMillis();\n\t\t\tObject result &#x3D; method.invoke(proxiedObject, args);\n\t\t\tlong endTimeStamp &#x3D; System.currentTimeMillis();\n\t\t\tlong responseTime &#x3D; endTimeStamp - startTimestamp;\n\t\t\tString apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n\t\t\tRequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);\n\t\t\tmetricsCollector.recordRequest(requestInfo);\n\t\t\treturn result;\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F;MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();\nIUserController userController &#x3D; (IUserController) proxy.createProxy(new userController());\n\n实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的\n1.3 应用场景1、业务系统的非功能性需求开发\n代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发\n如果熟悉 Java 语言和 Spring 开发框架，这部分工作都是可以在 Spring AOP 切面中完成的，Spring AOP 底层的实现原理就是基于动态代理\n2、代理模式在 RPC 中的应用\n实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节\n3、代理模式在缓存中的应用\n假设要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，让其调用实时查询接口，对于不需要实时数据的需求，让其调用支持缓存的接口。那如何来实现接口请求的缓存功能呢？\n最简单的实现方法就是上面讲到的，给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。但是，这样做显然增加了开发成本，而且会让代码看起来非常臃肿（接口个数成倍增加），也不方便缓存接口的集中管理（增加、删除缓存接口）、集中配置（比如配置每个接口缓存过期时间）\n针对这些问题，代理模式就能派上用场了，确切地说，应该是动态代理。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时候，从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http:&#x2F;&#x2F;…?..&amp;cached&#x3D;true），便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回\n2. 桥接&#x2F;桥梁模式（Bridge Design Pattern）2.1 原理解析这个模式有两种不同的理解方式。当然，这其中“最纯正”的理解方式，当属 GoF 的《设计模式》一书中对桥接模式的定义。毕竟，这 23 种经典的设计模式，最初就是由这本书总结出来的。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”\n关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于之前讲过的“组合优于继承”设计原则，所以这里重点看下 GoF 的理解方式\nGoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。JDBC 驱动是桥接模式的经典应用。先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序\nString url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;\nConnection con &#x3D; DriverManager.getConnection(url);\nStatement stmt &#x3D; con.createStatement()；\nString query &#x3D; &quot;select * from test&quot;;\nResultSet rs&#x3D;stmt.executeQuery(query);\nwhile(rs.next()) &#123;\n    rs.getString(1);\n    rs.getInt(2);\n&#125;\n\n如果想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候，自动从配置文件中加载，这样在切换数据库的时候，都不需要修改代码，只需要修改配置文件就可以了\n不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？\n从 com.mysql.jdbc.Driver 这个类的代码看起，摘抄了部分相关源码，如下：\npackage com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;\n\tstatic &#123;\n\t\ttry &#123;\n\t\t\tjava.sql.DriverManager.registerDriver(new Driver());\n\t\t&#125; catch (SQLException E) &#123;\n\t\t\tthrow new RuntimeException(&quot;Can&#39;t register driver!&quot;);\n\t\t&#125;\n\t&#125;\n\t&#x2F;**\n\t* Construct a new driver and register it with DriverManager\n\t* @throws SQLException if a database error occurs.\n\t*&#x2F;\n\tpublic Driver() throws SQLException &#123;\n\t\t&#x2F;&#x2F; Required for Class.forName().newInstance()\n\t&#125;\n&#125;\n\n结合 com.mysql.jdbc.Driver 的代码实现，可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情。第一件事情是要求 JVM 查找并加载指定的 Driver 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中\n再来看一下，DriverManager 类是干什么用的。具体的代码如下所示。当把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因\npublic class DriverManager &#123;\n\tprivate final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;&gt;();\n\t&#x2F;&#x2F;...\n\tstatic &#123;\n\t\tloadInitialDrivers();\n\t\tprintln(&quot;JDBC DriverManager initialized&quot;);\n\t&#125;\n\t&#x2F;&#x2F;...\n\tpublic static synchronized void registerDriver(java.sql.Driver driver) throws NullPointerException &#123;\n\t\tif (driver !&#x3D; null) &#123;\n\t\t\tregisteredDrivers.addIfAbsent(new DriverInfo(driver));\n\t\t&#125; else &#123;\n\t\t\tthrow new NullPointerException();\n\t\t&#125;\n\t&#125;\n\tpublic static Connection getConnection(String url, String user, String password) &#123;\n\t\tjava.util.Properties info &#x3D; new java.util.Properties();\n\t\tif (user !&#x3D; null) &#123;\n\t\t\tinfo.put(&quot;user&quot;, user);\n\t\t&#125;\n\t\tif (password !&#x3D; null) &#123;\n\t\t\tinfo.put(&quot;password&quot;, password);\n\t\t&#125;\n\t\treturn (getConnection(url, info, Reflection.getCallerClass()));\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n\n桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”、“实现”和“解耦”三个概念，就是理解桥接模式的关键\n\n抽象，可以理解为存在于多个实体中的共同的概念性联系，就是忽略一些信息，从而把不同的实体当做同样的实体对待\n实现，即抽象给出的具体实现，可能有多种不同的实现方式\n解耦，所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称解耦。在这里，解耦是指将抽象和实现之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联，即抽象和实现之间使用组合&#x2F;聚合关系而不是继承关系\n\n那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？\n实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行\n\n2.2 应用举例之前讲过一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。先来看最简单、最直接的一种实现方式。代码如下所示：\npublic enum NotificationEmergencyLevel &#123;\n\tSEVERE, URGENCY, NORMAL, TRIVIAL\n&#125;\npublic class Notification &#123;\n\tprivate List&lt;String&gt; emailAddresses;\n\tprivate List&lt;String&gt; telephones;\n\tprivate List&lt;String&gt; wechatIds;\n\tpublic Notification() &#123;&#125;\n\n\tpublic void setEmailAddress(List&lt;String&gt; emailAddress) &#123;\n\t\tthis.emailAddresses &#x3D; emailAddress;\n\t&#125;\n\tpublic void setTelephones(List&lt;String&gt; telephones) &#123;\n\t\tthis.telephones &#x3D; telephones;\n\t&#125;\n\tpublic void setWechatIds(List&lt;String&gt; wechatIds) &#123;\n\t\tthis.wechatIds &#x3D; wechatIds;\n\t&#125;\n\n\tpublic void notify(NotificationEmergencyLevel level, String message) &#123;\n\t\tif (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;\n\t\t\t&#x2F;&#x2F;...自动语音电话\n\t\t&#125; else if (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;\n\t\t\t&#x2F;&#x2F;...发微信\n\t\t&#125; else if (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;\n\t\t\t&#x2F;&#x2F;...发邮件\n\t\t&#125; else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;\n\t\t\t&#x2F;&#x2F;...发邮件\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F;在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler &#123;\n\tpublic ErrorAlertHandler(AlertRule rule, Notification notification) &#123;\n\t\tsuper(rule, notification);\n\t&#125;\n\t@Override\n\tpublic void check(ApiStatInfo apiStatInfo) &#123;\n\t\tif (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi())) &#123;\n\t\t\tnotification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n\t\t&#125;\n\t&#125;\n&#125;\n\nNotification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑\n不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。类的代码越多，就越难读懂，越难修改，维护的成本也就越高。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起\n针对 Notification 的代码，将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，可以动态地去指定（比如，通过读取配置来获取对应关系）\npublic interface MsgSender &#123;\n\tvoid send(String message);\n&#125;\npublic class TelephoneMsgSender implements MsgSender &#123;\n\tprivate List&lt;String&gt; telephones;\n\tpublic TelephoneMsgSender(List&lt;String&gt; telephones) &#123;\n\t\tthis.telephones &#x3D; telephones;\n\t&#125;\n\t@Override\n\tpublic void send(String message) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class EmailMsgSender implements MsgSender &#123;\n\t&#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...\n&#125;\npublic class WechatMsgSender implements MsgSender &#123;\n\t&#x2F;&#x2F; 与TelephoneMsgSender代码结构类似，所以省略...\n&#125;\npublic abstract class Notification &#123;\n\tprotected MsgSender msgSender;\n\tpublic Notification(MsgSender msgSender) &#123;\n\t\tthis.msgSender &#x3D; msgSender;\n\t&#125;\n\tpublic abstract void notify(String message);\n&#125;\n\npublic class SevereNotification extends Notification &#123;\n\tpublic SevereNotification(MsgSender msgSender) &#123;\n\t\tsuper(msgSender);\n\t&#125;\n\t@Override\n\tpublic void notify(String message) &#123;\n\t\tmsgSender.send(message);\n\t&#125;\n&#125;\npublic class UrgencyNotification extends Notification &#123;\n\t&#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...\n&#125;\npublic class NormalNotification extends Notification &#123;\n\t&#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...\n&#125;\npublic class TrivialNotification extends Notification &#123;\n\t&#x2F;&#x2F; 与SevereNotification代码结构类似，所以省略...\n&#125;\n\n3. 装饰器模式（Decorator Design Pattern）3.1 Java IO 类Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，可以从下面两个维度将它划分为四类。具体如下所示：\n\n针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：\n\n假如要打开文件 test.txt，从中读取数据。其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率\nInputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nbyte[] data &#x3D; new byte[128];\nwhile (bin.read(data) !&#x3D; -1) &#123;\n\t&#x2F;&#x2F;...\n&#125;\n\n初看上面的代码，会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream对象，然后再传递给 BufferedInputStream 对象来使用。Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据，用起来岂不是更加简单？\nInputStream bin &#x3D; new BufferedFileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nbyte[] data &#x3D; new byte[128];\nwhile (bin.read(data) !&#x3D; -1) &#123;\n    &#x2F;&#x2F;...\n&#125;\n\n3.2 基于继承的设计方案如果 InputStream 只有一个子类 FileInputStream 的话，那在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。需要给每一个 InputStream的子类，再继续派生支持缓存读取的子类\n除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据\nFileInputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nDataInputStream din &#x3D; new DataInputStream(in);\nint data &#x3D; din.readInt();\n\n在这种情况下，如果继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护\n3.3 基于装饰器模式的设计方案这里展示了 Java IO 的这种设计思路，对代码做了简化：\npublic abstract class InputStream &#123;\n\t&#x2F;&#x2F;...\n\tpublic int read(byte b[]) throws IOException &#123;\n\t\treturn read(b, 0, b.length);\n\t&#125;\n\tpublic int read(byte b[], int off, int len) throws IOException &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic long skip(long n) throws IOException &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic int available() throws IOException &#123;\n\t\treturn 0;\n\t&#125;\n\tpublic void close() throws IOException &#123;&#125;\n\tpublic synchronized void mark(int readlimit) &#123;&#125;\n\tpublic synchronized void reset() throws IOException &#123;\n\t\tthrow new IOException(&quot;mark&#x2F;reset not supported&quot;);\n\t&#125;\n\tpublic boolean markSupported() &#123;\n\t\treturn false;\n\t&#125;\n&#125;\npublic class BufferedInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\tprotected BufferedInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\t&#x2F;&#x2F;...实现基于缓存的读数据接口...\n&#125;\npublic class DataInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\tprotected DataInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\t&#x2F;&#x2F;...实现读取基本类型数据的接口\n&#125;\n\n看了上面的代码可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方\n1、装饰器类和原始类继承同样的父类，这样可以对原始类“嵌套”多个装饰器类\n比如，下面这样一段代码，对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据\nInputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nDataInputStream din &#x3D; new DataInputStream(bin);\nint data &#x3D; din.readInt();\n\n2、装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点\n实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能\n&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class AProxy impements IA &#123;\n\tprivate IA a;\n\tpublic AProxy(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t\ta.f();\n\t\t&#x2F;&#x2F; 新添加的代理逻辑\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n\tvoid f();\n&#125;\npublic class A impelements IA &#123;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class ADecorator impements IA &#123;\n\tprivate IA a;\n\tpublic ADecorator(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\tpublic void f() &#123;\n\t\t&#x2F;&#x2F; 功能增强代码\n\t\ta.f();\n\t\t&#x2F;&#x2F; 功能增强代码\n\t&#125;\n&#125;\n\n实际上，如果去查看 JDK 的源码会发现，BufferedInputStream、DataInputStream并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类。那这又是出于什么样的设计意图，才引入这样一个类呢？\n再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的\n对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示：\npublic class BufferedInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\tprotected BufferedInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\t&#x2F;&#x2F; f()函数不需要增强，只是重新调用一下InputStream in对象的f()\n\tpublic void f() &#123;\n\t\tin.f();\n\t&#125;\n&#125;\n\n如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。因为假设我们没有重写方法 f()，然后在内部调用传递进来的 InputStream 对象的 f()，在使用 f()方法时调用的只会是最顶层的 f()方法，假如存在多个装饰器时就会出现问题，出现链式中断（整体的调用过程其实就是一个链式调用）。同样，假如我们重写了 f()方法，但是在内部忘记调用了传递进来的 InputStream 对象的 f() 方法，即上一个 InputStream 对象，也会出现链式中断\n实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现\npublic class FilterInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\n\tprotected FilterInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\tpublic int read() throws IOException &#123;\n\t\treturn in.read();\n\t&#125;\n\tpublic int read(byte b[]) throws IOException &#123;\n\t\treturn read(b, 0, b.length);\n\t&#125;\n\tpublic int read(byte b[], int off, int len) throws IOException &#123;\n\t\treturn in.read(b, off, len);\n\t&#125;\n\tpublic long skip(long n) throws IOException &#123;\n\t\treturn in.skip(n);\n\t&#125;\n\tpublic int available() throws IOException &#123;\n\t\treturn in.available();\n\t&#125;\n\tpublic void close() throws IOException &#123;\n\t\tin.close();\n\t&#125;\n\tpublic synchronized void mark(int readlimit) &#123;\n\t\tin.mark(readlimit);\n\t&#125;\n\tpublic synchronized void reset() throws IOException &#123;\n\t\tin.reset();\n\t&#125;\n\tpublic boolean markSupported() &#123;\n\t\treturn in.markSupported();\n\t&#125;\n&#125;\n\n这里贴一段 BufferedInputStream 的 read() 方法调用的源码，省略了逻辑部分\npublic synchronized int read() throws IOException &#123;\n        &#x2F;&#x2F; 省略其他\n        fill();\n&#125;\n\nprivate void fill() throws IOException &#123;\n        &#x2F;&#x2F; 省略其他\n        int n &#x3D; getInIfOpen().read(buffer, pos, buffer.length - pos);\n&#125;\n\nprivate InputStream getInIfOpen() throws IOException &#123;\n        &#x2F;&#x2F; in 就是通过构造函数传递进来的 InputStream 对象\n        InputStream input &#x3D; in;\n        if (input &#x3D;&#x3D; null)\n            throw new IOException(&quot;Stream closed&quot;);\n        return input;\n&#125;\n\n可以看到 BufferedInputStream 重写了 read() 方法后，通过 getInIfOpen() 这个方法获取了传进来的 InputStream in，然后通过 in.read() 调用了前面传递进来的 InputStream 对象的 read() 方法。但从这个方法看 FilterInputStream 的 read() 的包裹调用是完全没起作用的\npublic class FilterInputStream extends InputStream &#123;\n\tprotected volatile InputStream in;\n\n\tprotected FilterInputStream(InputStream in) &#123;\n\t\tthis.in &#x3D; in;\n\t&#125;\n\tpublic int read() throws IOException &#123;\n\t\treturn in.read();\n\t&#125;\n\tpublic int read(byte b[]) throws IOException &#123;\n\t\treturn read(b, 0, b.length);\n\t&#125;\n\tpublic int read(byte b[], int off, int len) throws IOException &#123;\n\t\treturn in.read(b, off, len);\n\t&#125;\n        &#x2F;&#x2F; 省略其他\n&#125;\n\n但是就像上面所说，没有重写的方法，就必须包裹调用，不然会出现链式中断。为了代码复用，扩展性，包括避免出现漏调用的情况，所以这里 FilterInputStream 实现了所有 InputStream 方法的包裹调用。假如子类（如 BufferedInputStream）重写了，就用子类的，子类没有重写，则用 FilterInputStream 的（这点其实是继承的知识）\n完整示例如下：\nclass Father &#123;\n    public void run() &#123;\n        System.out.println(&quot;Father run&quot;);\n    &#125;\n&#125;\n\nclass Son extends Father&#123;\n    public void run() &#123;\n        System.out.println(&quot;Son run&quot;);\n    &#125;\n&#125;\n\nclass ChildDecorator extends Father &#123;\n    protected Father father;\n\n    public ChildDecorator(Father father) &#123;\n        this.father &#x3D; father;\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;ChildDecorator run&quot;);\n    &#125;\n&#125;\n\nclass Child1 extends ChildDecorator&#123;\n\n    public Child1(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child1 run&quot;);\n    &#125;\n&#125;\n\nclass Child2 extends ChildDecorator &#123;\n\n    public Child2(Father father) &#123;\n        super(father);\n    &#125;\n\n    public void run() &#123;\n        father.run();\n        System.out.println(&quot;Child2 run&quot;);\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n        Father son &#x3D; new Son();\n        Father child1 &#x3D; new Child1(son);\n        Child2 child2 &#x3D; new Child2(child1);\n        child2.run();\n&#125;\n\n\n4. 适配器模式（Adapter Design Pattern）4.1 原理与实现顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作\n原理很简单，再来看下它的代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口\n&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor extends Adaptee implements ITarget &#123;\n\tpublic void f1() &#123;\n\t\tsuper.fa();\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\t&#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;\n\n&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n\tvoid f1();\n\tvoid f2();\n\tvoid fc();\n&#125;\npublic class Adaptee &#123;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fb() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void fc() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\npublic class Adaptor implements ITarget &#123;\n\tprivate Adaptee adaptee;\n\tpublic Adaptor(Adaptee adaptee) &#123;\n\t\tthis.adaptee &#x3D; adaptee;\n\t&#125;\n\tpublic void f1() &#123;\n\t\tadaptee.fa(); &#x2F;&#x2F;委托给Adaptee\n\t&#125;\n\tpublic void f2() &#123;\n\t\t&#x2F;&#x2F;...重新实现f2()...\n\t&#125;\n\tpublic void fc() &#123;\n\t\tadaptee.fc();\n\t&#125;\n&#125;\n\n针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度\n如果 Adaptee 接口并不多，那两种实现方式都可以。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那推荐使用对象适配器，因为组合结构相对于继承更加灵活\n4.2 应用场景一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了\n1、封装有缺陷的接口设计\n假设依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了\npublic class CD &#123; &#x2F;&#x2F;这个类来自外部sdk，我们无权修改它的代码\n\t&#x2F;&#x2F;...\n\tpublic static void staticFunction1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void uglyNamingFunction2() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void tooManyParamsFunction3(int paramA, int paramB, ...) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tpublic void lowPerformanceFunction4() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 使用适配器模式进行重构\npublic interface ITarget &#123;\n\tvoid function1();\n\tvoid function2();\n\tvoid fucntion3(ParamsWrapperDefinition paramsWrapper);\n\tvoid function4();\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F; 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget &#123;\n\t&#x2F;&#x2F;...\n\tpublic void function1() &#123;\n\t\tsuper.staticFunction1();\n\t&#125;\n\tpublic void function2() &#123;\n\t\tsuper.uglyNamingFucntion2();\n\t&#125;\n\tpublic void function3(ParamsWrapperDefinition paramsWrapper) &#123;\n\t\tsuper.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n\t&#125;\n\tpublic void function4() &#123;\n\t\t&#x2F;&#x2F;...reimplement it...\n\t&#125;\n&#125;\n\n2、统一多个类的接口设计\n某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后就可以使用多态的特性来复用代码逻辑\n假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着没法复用一套逻辑来调用各个系统。这个时候，就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样可以复用调用敏感词过滤的代码\n&#x2F;&#x2F; A敏感词过滤系统提供的接口\npublic class ASensitiveWordsFilter &#123;\n\t&#x2F;&#x2F;text是原始文本，函数输出用***替换敏感词之后的文本\n\tpublic String filterSexyWords(String text) &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n\tpublic String filterPoliticalWords(String text) &#123;\n\t\t&#x2F;&#x2F; ...\n\t&#125;\n&#125;\n&#x2F;&#x2F; B敏感词过滤系统提供的接口\npublic class BSensitiveWordsFilter &#123;\n\tpublic String filter(String text) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; C敏感词过滤系统提供的接口\npublic class CSensitiveWordsFilter &#123;\n\tpublic String filter(String text, String mask) &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement &#123;\n\tprivate ASensitiveWordsFilter aFilter &#x3D; new ASensitiveWordsFilter();\n\tprivate BSensitiveWordsFilter bFilter &#x3D; new BSensitiveWordsFilter();\n\tprivate CSensitiveWordsFilter cFilter &#x3D; new CSensitiveWordsFilter();\n\tpublic String filterSensitiveWords(String text) &#123;\n\t\tString maskedText &#x3D; aFilter.filterSexyWords(text);\n\t\tmaskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n\t\tmaskedText &#x3D; bFilter.filter(maskedText);\n\t\tmaskedText &#x3D; cFilter.filter(maskedText, &quot;***&quot;);\n\t\treturn maskedText;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter &#123; &#x2F;&#x2F; 统一接口定义\n\tString filter(String text);\n&#125;\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123;\n\tprivate ASensitiveWordsFilter aFilter;\n\tpublic String filter(String text) &#123;\n\t\tString maskedText &#x3D; aFilter.filterSexyWords(text);\n\t\tmaskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n\t\treturn maskedText;\n\t&#125;\n&#125;\n&#x2F;&#x2F;...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n&#x2F;&#x2F; 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n&#x2F;&#x2F; 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement &#123;\n\tprivate List&lt;ISensitiveWordsFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n\tpublic void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123;\n\t\tfilters.add(filter);\n\t&#125;\n\tpublic String filterSensitiveWords(String text) &#123;\n\t\tString maskedText &#x3D; text;\n\t\tfor (ISensitiveWordsFilter filter : filters) &#123;\n\t\t\tmaskedText &#x3D; filter.filter(maskedText);\n\t\t&#125;\n\t\treturn maskedText;\n\t&#125;\n&#125;\n\n3、替换依赖的外部系统\n当把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。具体的代码示例如下所示：\n&#x2F;&#x2F; 外部系统A\npublic interface IA &#123;\n\t&#x2F;&#x2F;...\n\tvoid fa();\n&#125;\npublic class A implements IA &#123;\n\t&#x2F;&#x2F;...\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F; 在我们的项目中，外部系统A的使用示例\npublic class Demo &#123;\n\tprivate IA a;\n\tpublic Demo(IA a) &#123;\n\t\tthis.a &#x3D; a;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\nDemo d &#x3D; new Demo(new A());\n\n&#x2F;&#x2F; 将外部系统A替换成外部系统B\npublic class BAdaptor implemnts IA &#123;\n\tprivate B b;\n\tpublic BAdaptor(B b) &#123;\n\t\tthis.b&#x3D; b;\n\t&#125;\n\tpublic void fa() &#123;\n\t\t&#x2F;&#x2F;...\n\t\tb.fb();\n\t&#125;\n&#125;\n&#x2F;&#x2F; 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n&#x2F;&#x2F; 只需要将BAdaptor如下注入到Demo即可。\nDemo d &#x3D; new Demo(new BAdaptor(new B()));\n\n4、兼容老版本接口\n在做版本升级的时候，对于一些要废弃的接口，不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改\nJDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行\n单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：\npublic class Collections &#123;\n\tpublic static Emueration emumeration(final Collection c) &#123;\n\t\treturn new Enumeration() &#123;\n\t\t\tIterator i &#x3D; c.iterator();\n\t\t\tpublic boolean hasMoreElments() &#123;\n\t\t\t\treturn i.hashNext();\n\t\t\t&#125;\n\t\t\tpublic Object nextElement() &#123;\n\t\t\t\treturn i.next():\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n5、适配不同格式的数据\n前面说到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型\n\n\n\n\n\n\n\n\n\nList stooges &#x3D; Arrays.asList(“Larry”, “Moe”, “Curly”);\n4.3 适配器模式在 Java 日志中的应用Java 中有很多日志框架，在项目开发中，常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等\n大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、error……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范\n如果只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了\n比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架\n如果是做 Java 开发的，那 Slf4j 这个日志框架肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用\n不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：\n&#x2F;&#x2F; slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger &#123;\n\tpublic boolean isTraceEnabled();\n\tpublic void trace(String msg);\n\tpublic void trace(String format, Object arg);\n\tpublic void trace(String format, Object arg1, Object arg2);\n\tpublic void trace(String format, Object[] argArray);\n\tpublic void trace(String msg, Throwable t);\n\tpublic boolean isDebugEnabled();\n\tpublic void debug(String msg);\n\tpublic void debug(String format, Object arg);\n\tpublic void debug(String format, Object arg1, Object arg2)\n\tpublic void debug(String format, Object[] argArray)\n\tpublic void debug(String msg, Throwable t);\n\t&#x2F;&#x2F;...省略info、warn、error等一堆接口\n&#125;\n\n&#x2F;&#x2F; log4j日志框架的适配器\n&#x2F;&#x2F; Log4jLoggerAdapter实现了LocationAwareLogger接口，\n&#x2F;&#x2F; 其中LocationAwareLogger继承自Logger接口，\n&#x2F;&#x2F; 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n\timplements LocationAwareLogger, Serializable &#123;\n\tfinal transient org.apache.log4j.Logger logger; &#x2F;&#x2F; log4j\n\tpublic boolean isDebugEnabled() &#123;\n\t\treturn logger.isDebugEnabled();\n\t&#125;\n\tpublic void debug(String msg) &#123;\n\t\tlogger.log(FQCN, Level.DEBUG, msg, null);\n\t&#125;\n\tpublic void debug(String format, Object arg) &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tFormattingTuple ft &#x3D; MessageFormatter.format(format, arg);\n\t\t\tlogger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n\t\t&#125;\n\t&#125;\n\tpublic void debug(String format, Object arg1, Object arg2) &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tFormattingTuple ft &#x3D; MessageFormatter.format(format, arg1, arg2);\n\t\t\tlogger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n\t\t&#125;\n\t&#125;\n\tpublic void debug(String format, Object[] argArray) &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tFormattingTuple ft &#x3D; MessageFormatter.arrayFormat(format, argArray);\n\t\t\tlogger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n\t\t&#125;\n\t&#125;\n\tpublic void debug(String msg, Throwable t) &#123;\n\t\tlogger.log(FQCN, Level.DEBUG, msg, t);\n\t&#125;\n\t&#x2F;&#x2F;...省略一堆接口的实现...\n&#125;\n\n所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术），只需要将相应的 SDK 导入到项目中即可\n如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，就能成功将 log4j 切换为了 logback\n4.4 代理、桥接、装饰器、适配器 4 种设计模式的区别代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类\n尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别\n代理模式： 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同\n桥接模式： 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变\n装饰器模式： 装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用\n适配器模式： 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口\n5. 门面&#x2F;外观模式（Facade Design Pattern）如果平时的工作涉及接口开发，不知道你有没有遇到关于接口粒度的问题呢？\n为了保证接口的可复用性（或者叫通用性），我们需要将接口尽量设计得细粒度一点，责任单一一点，但是，如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用\n相反，如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。那如何来解决接口的可复用性（通用性）和易用性之间的矛盾呢？\n5.1 原理与实现门面模式，也叫外观模式，英文全称是 Facade Design Pattern。在 GoF 的《设计模式》一书中，门面模式是这样定义的：\n\n\n\n\n\n\n\n\n\nProvide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用\n假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用\n这时可能会有这样的疑问，让系统 B 直接调用 a、b、d 感觉没有太大问题呀，为什么还要提供一个包裹 a、b、d 的接口 x 呢？\n假设刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过后端服务器提供的接口来获取数据。App 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之间的网络通信次数\n假设，完成某个业务功能（比如显示某个页面信息）需要“依次”调用 a、b、d 三个接口，因自身业务的特点，不支持并发调用这三个接口\n如果现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度\n这里举的例子只是应用门面模式的其中一个意图，也就是解决性能问题。实际上，不同的应用场景下，使用门面模式的意图也不同\n5.2 应用场景在 GoF 给出的定义中提到，“门面模式让子系统更加易用”，实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。除此之外，还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块\n1、解决易用性问题\n门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互\n设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节\n2、解决性能问题\n关于利用门面模式解决性能问题这一点，前面已经讲过了。通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。现在来讨论一下这样一个问题：从代码实现的角度来看，该如何组织门面接口和非门面接口？\n如果门面接口不多，完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口放到一个新的子系统中\n3、解决分布式事务问题\n在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）\n对于这样一个简单的业务需求，可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败\n要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作\n6. 组合模式（Composite Design Pattern）组合模式跟之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，可以简单理解为一组对象集合\n正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁\n6.1 原理与实现在 GoF 的《设计模式》一书中，组合模式是这样定义的：\n\n\n\n\n\n\n\n\n\nCompose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者）可以统一单个对象和组合对象的处理逻辑\n假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：\n\n动态地添加、删除某个目录下的子目录或文件\n统计指定目录下的文件个数\n统计指定目录下的文件总大小\n\n骨架代码如下所示，其中的核心逻辑并未实现。在下面的代码实现中，把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分\npublic class FileSystemNode &#123;\n\tprivate String path;\n\tprivate boolean isFile;\n\tprivate List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\tpublic FileSystemNode(String path, boolean isFile) &#123;\n\t\tthis.path &#x3D; path;\n\t\tthis.isFile &#x3D; isFile;\n\t&#125;\n\tpublic int countNumOfFiles() &#123;\n\t\t&#x2F;&#x2F; TODO:...\n\t&#125;\n\tpublic long countSizeOfFiles() &#123;\n\t\t&#x2F;&#x2F; TODO:...\n\t&#125;\n\tpublic String getPath() &#123;\n\t\treturn path;\n\t&#125;\n\tpublic void addSubNode(FileSystemNode fileOrDir) &#123;\n\t\tsubNodes.add(fileOrDir);\n\t&#125;\n\tpublic void removeSubNode(FileSystemNode fileOrDir) &#123;\n\t\tint size &#x3D; subNodes.size();\n\t\tint i &#x3D; 0;\n\t\tfor (; i &lt; size; ++i) &#123;\n\t\t\tif (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (i &lt; size) &#123;\n\t\t\tsubNodes.remove(i);\n\t\t&#125;\n\t&#125;\n&#125;\n\ncountNumOfFiles() 和 countSizeOfFiles() 这两个函数，实际上这就是树的递归遍历算法。对于文件，可以直接返回文件的个数（返回 1）或大小。对于目录，遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小\npublic int countNumOfFiles() &#123;\n\tif (isFile) &#123;\n\t\treturn 1;\n\t&#125;\n\tint numOfFiles &#x3D; 0;\n\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\tnumOfFiles +&#x3D; fileOrDir.countNumOfFiles();\n\t&#125;\n\treturn numOfFiles;\n&#125;\npublic long countSizeOfFiles() &#123;\n\tif (isFile) &#123;\n\t\tFile file &#x3D; new File(path);\n\t\tif (!file.exists()) return 0;\n\t\treturn file.length();\n\t&#125;\n\tlong sizeofFiles &#x3D; 0;\n\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\tsizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();\n\t&#125;\n\treturn sizeofFiles;\n&#125;\n\n单纯从功能实现角度来说，上面的代码没有问题，已经实现了想要的功能。但是，如果开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，最好对文件和目录进行区分设计，定义为 File 和 Directory两个类\npublic abstract class FileSystemNode &#123;\n\tprotected String path;\n\tpublic FileSystemNode(String path) &#123;\n\t\tthis.path &#x3D; path;\n\t&#125;\n\tpublic abstract int countNumOfFiles();\n\tpublic abstract long countSizeOfFiles();\n\tpublic String getPath() &#123;\n\t\treturn path;\n\t&#125;\n&#125;\npublic class File extends FileSystemNode &#123;\n\tpublic File(String path) &#123;\n\t\tsuper(path);\n\t&#125;\n\t@Override\n\tpublic int countNumOfFiles() &#123;\n\t\treturn 1;\n\t&#125;\n\t@Override\n\tpublic long countSizeOfFiles() &#123;\n\t\tjava.io.File file &#x3D; new java.io.File(path);\n\t\tif (!file.exists()) return 0;\n\t\treturn file.length();\n\t&#125;\n&#125;\npublic class Directory extends FileSystemNode &#123;\n\tprivate List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\tpublic Directory(String path) &#123;\n\t\tsuper(path);\n\t&#125;\n\t@Override\n\tpublic int countNumOfFiles() &#123;\n\t\tint numOfFiles &#x3D; 0;\n\t\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\t\tnumOfFiles +&#x3D; fileOrDir.countNumOfFiles();\n\t\t&#125;\n\t\treturn numOfFiles;\n\t&#125;\n\t@Override\n\tpublic long countSizeOfFiles() &#123;\n\t\tlong sizeofFiles &#x3D; 0;\n\t\tfor (FileSystemNode fileOrDir : subNodes) &#123;\n\t\t\tsizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();\n\t\t&#125;\n\t\treturn sizeofFiles;\n\t&#125;\n\tpublic void addSubNode(FileSystemNode fileOrDir) &#123;\n\t\tsubNodes.add(fileOrDir);\n\t&#125;\n\tpublic void removeSubNode(FileSystemNode fileOrDir) &#123;\n\t\tint size &#x3D; subNodes.size();\n\t\tint i &#x3D; 0;\n\t\tfor (; i &lt; size; ++i) &#123;\n\t\t\tif (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif (i &lt; size) &#123;\n\t\t\tsubNodes.remove(i);\n\t\t&#125;\n\t&#125;\n&#125;\n\n文件和目录类都设计好了，现在来看如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;**\n\t\t* &#x2F;\n\t\t* &#x2F;wz&#x2F;\n\t\t* &#x2F;wz&#x2F;a.txt\n\t\t* &#x2F;wz&#x2F;b.txt\n\t\t* &#x2F;wz&#x2F;movies&#x2F;\n\t\t* &#x2F;wz&#x2F;movies&#x2F;c.avi\n\t\t* &#x2F;xzg&#x2F;\n\t\t* &#x2F;xzg&#x2F;docs&#x2F;\n\t\t* &#x2F;xzg&#x2F;docs&#x2F;d.txt\n\t\t*&#x2F;\n\t\tDirectory fileSystemTree &#x3D; new Directory(&quot;&#x2F;&quot;);\n\t\tDirectory node_wz &#x3D; new Directory(&quot;&#x2F;wz&#x2F;&quot;);\n\t\tDirectory node_xzg &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;&quot;);\n\t\tfileSystemTree.addSubNode(node_wz);\n\t\tfileSystemTree.addSubNode(node_xzg);\n\t\tFile node_wz_a &#x3D; new File(&quot;&#x2F;wz&#x2F;a.txt&quot;);\n\t\tFile node_wz_b &#x3D; new File(&quot;&#x2F;wz&#x2F;b.txt&quot;);\n\t\tDirectory node_wz_movies &#x3D; new Directory(&quot;&#x2F;wz&#x2F;movies&#x2F;&quot;);\n\t\tnode_wz.addSubNode(node_wz_a);\n\t\tnode_wz.addSubNode(node_wz_b);\n\t\tnode_wz.addSubNode(node_wz_movies);\n\t\tFile node_wz_movies_c &#x3D; new File(&quot;&#x2F;wz&#x2F;movies&#x2F;c.avi&quot;);\n\t\tnode_wz_movies.addSubNode(node_wz_movies_c);\n\t\tDirectory node_xzg_docs &#x3D; new Directory(&quot;&#x2F;xzg&#x2F;docs&#x2F;&quot;);\n\t\tnode_xzg.addSubNode(node_xzg_docs);\n\t\tFile node_xzg_docs_d &#x3D; new File(&quot;&#x2F;xzg&#x2F;docs&#x2F;d.txt&quot;);\n\t\tnode_xzg_docs.addSubNode(node_xzg_docs_d);\n\t\tSystem.out.println(&quot;&#x2F; files num:&quot; + fileSystemTree.countNumOfFiles());\n\t\tSystem.out.println(&quot;&#x2F;wz&#x2F; files num:&quot; + node_wz.countNumOfFiles());\n\t&#125;\n&#125;\n\n对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现\n6.2 应用场景假设在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：\n\n现在希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）\n部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现\n示例代码如下，其中，HumanResource 是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责从数据库中读取数据并在内存中构建组织架构图\npublic abstract class HumanResource &#123;\n\tprotected long id;\n\tprotected double salary;\n\tpublic HumanResource(long id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\tpublic long getId() &#123;\n\t\treturn id;\n\t&#125;\n\tpublic abstract double calculateSalary();\n&#125;\npublic class Employee extends HumanResource &#123;\n\tpublic Employee(long id, double salary) &#123;\n\t\tsuper(id);\n\t\tthis.salary &#x3D; salary;\n\t&#125;\n\t@Override\n\tpublic double calculateSalary() &#123;\n\t\treturn salary;\n\t&#125;\n&#125;\npublic class Department extends HumanResource &#123;\n\tprivate List&lt;HumanResource&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\tpublic Department(long id) &#123;\n\t\tsuper(id);\n\t&#125;\n\t@Override\n\tpublic double calculateSalary() &#123;\n\t\tdouble totalSalary &#x3D; 0;\n\t\tfor (HumanResource hr : subNodes) &#123;\n\t\t\ttotalSalary +&#x3D; hr.calculateSalary();\n\t\t&#125;\n\t\tthis.salary &#x3D; totalSalary;\n\t\treturn totalSalary;\n\t&#125;\n\tpublic void addSubNode(HumanResource hr) &#123;\n\t\tsubNodes.add(hr);\n\t&#125;\n&#125;\n&#x2F;&#x2F; 构建组织架构的代码\npublic class Demo &#123;\n\tprivate static final long ORGANIZATION_ROOT_ID &#x3D; 1001;\n\tprivate DepartmentRepo departmentRepo; &#x2F;&#x2F; 依赖注入\n\tprivate EmployeeRepo employeeRepo; &#x2F;&#x2F; 依赖注入\n\tpublic void buildOrganization() &#123;\n\t\tDepartment rootDepartment &#x3D; new Department(ORGANIZATION_ROOT_ID);\n\t\tbuildOrganization(rootDepartment);\n\t&#125;\n\tprivate void buildOrganization(Department department) &#123;\n\t\tList&lt;Long&gt; subDepartmentIds &#x3D; departmentRepo.getSubDepartmentIds(department);\n\t\tfor (Long subDepartmentId : subDepartmentIds) &#123;\n\t\tDepartment subDepartment &#x3D; new Department(subDepartmentId);\n\t\t\tdepartment.addSubNode(subDepartment);\n\t\t\tbuildOrganization(subDepartment);\n\t\t&#125;\n\t\tList&lt;Long&gt; employeeIds &#x3D; employeeRepo.getDepartmentEmployeeIds(department.getId());\n\t\tfor (Long employeeId : employeeIds) &#123;\n\t\tdouble salary &#x3D; employeeRepo.getEmployeeSalary(employeeId);\n\t\t\tdepartment.addSubNode(new Employee(employeeId, salary));\n\t\t&#125;\n\t&#125;\n&#125;\n\n再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”\n7. 享元模式（Flyweight Design Pattern）7.1 原理与实现所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象\n具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元\n定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码\n假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息\npublic class ChessPiece &#123;&#x2F;&#x2F;棋子\n\tprivate int id;\n\tprivate String text;\n\tprivate Color color;\n\tprivate int positionX;\n\tprivate int positionY;\n\tpublic ChessPiece(int id, String text, Color color, int positionX, int positionY) &#123;\n\t\tthis.id &#x3D; id;\n\t\tthis.text &#x3D; text;\n\t\tthis.color &#x3D; color;\n\t\tthis.positionX &#x3D; positionX;\n\t\tthis.positionY &#x3D; positionX;\n\t&#125;\n\tpublic static enum Color &#123;\n\t\tRED, BLACK\n\t&#125;\n\t&#x2F;&#x2F; ...省略其他属性和getter&#x2F;setter方法...\n&#125;\npublic class ChessBoard &#123;&#x2F;&#x2F;棋局\n\tprivate Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\tpublic ChessBoard() &#123;\n\t\tinit();\n\t&#125;\n\tprivate void init() &#123;\n\t\tchessPieces.put(1, new ChessPiece(1, &quot;車&quot;, ChessPiece.Color.BLACK, 0, 0));\n\t\tchessPieces.put(2, new ChessPiece(2,&quot;馬&quot;, ChessPiece.Color.BLACK, 0, 1));\n\t\t&#x2F;&#x2F;...省略摆放其他棋子的代码...\n\t&#125;\n\tpublic void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n\t\t&#x2F;&#x2F;...省略...\n\t&#125;\n&#125;\n\n为了记录每个房间当前的棋局情况，需要给每个房间都创建一个 ChessBoard 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？\n这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：\n&#x2F;&#x2F; 享元类\npublic class ChessPieceUnit &#123;\n\tprivate int id;\n\tprivate String text;\n\tprivate Color color;\n\tpublic ChessPieceUnit(int id, String text, Color color) &#123;\n\t\tthis.id &#x3D; id;\n\t\tthis.text &#x3D; text;\n\t\tthis.color &#x3D; color;\n\t&#125;\n\tpublic static enum Color &#123;\n\t\tRED, BLACK\n\t&#125;\n\t&#x2F;&#x2F; ...省略其他属性和getter方法...\n&#125;\npublic class ChessPieceUnitFactory &#123;\n\tprivate static final Map&lt;Integer, ChessPieceUnit&gt; pieces &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tpieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));\n\t\tpieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));\n\t\t&#x2F;&#x2F;...省略摆放其他棋子的代码...\n\t&#125;\n\tpublic static ChessPieceUnit getChessPiece(int chessPieceId) &#123;\n\t\treturn pieces.get(chessPieceId);\n\t&#125;\n&#125;\npublic class ChessPiece &#123;\n\tprivate ChessPieceUnit chessPieceUnit;\n\tprivate int positionX;\n\tprivate int positionY;\n\tpublic ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;\n\t\tthis.chessPieceUnit &#x3D; unit;\n\t\tthis.positionX &#x3D; positionX;\n\t\tthis.positionY &#x3D; positionY;\n\t&#125;\n\t&#x2F;&#x2F; 省略getter、setter方法\n&#125;\npublic class ChessBoard &#123;\n\tprivate Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\tpublic ChessBoard() &#123;\n\t\tinit();\n\t&#125;\n\tprivate void init() &#123;\n\t\tchessPieces.put(1, new ChessPiece(\n\t\t                    ChessPieceUnitFactory.getChessPiece(1), 0,0));\n\t\tchessPieces.put(1, new ChessPiece(\n\t\t                    ChessPieceUnitFactory.getChessPiece(2), 1,0));\n\t\t&#x2F;&#x2F;...省略摆放其他棋子的代码...\n\t&#125;\n\tpublic void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n\t\t&#x2F;&#x2F;...省略...\n\t&#125;\n&#125;\n\n在上面的代码实现中，利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存\n总结一下它的代码结构。实际上，代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的\n7.2 在文本编辑器中的应用可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息\n尽管在实际的文档编写中，一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：\npublic class Character &#123;&#x2F;&#x2F;文字\n\tprivate char c;\n\tprivate Font font;\n\tprivate int size;\n\tprivate int colorRGB;\n\tpublic Character(char c, Font font, int size, int colorRGB) &#123;\n\t\tthis.c &#x3D; c;\n\t\tthis.font &#x3D; font;\n\t\tthis.size &#x3D; size;\n\t\tthis.colorRGB &#x3D; colorRGB;\n\t&#125;\n&#125;\npublic class Editor &#123;\n\tprivate List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\tpublic void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n\t\tCharacter character &#x3D; new Character(c, font, size, colorRGB);\n\t\tchars.add(character);\n\t&#125;\n&#125;\n\n在文本编辑器中，每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那就要在内存中存储这么多 Character 对象。那有没有办法可以节省一点内存呢？\n实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，对上面的代码进行重构。重构后的代码如下所示：\npublic class CharacterStyle &#123;\n\tprivate Font font;\n\tprivate int size;\n\tprivate int colorRGB;\n\tpublic CharacterStyle(Font font, int size, int colorRGB) &#123;\n\t\tthis.font &#x3D; font;\n\t\tthis.size &#x3D; size;\n\t\tthis.colorRGB &#x3D; colorRGB;\n\t&#125;\n\t@Override\n\tpublic boolean equals(Object o) &#123;\n\t\tCharacterStyle otherStyle &#x3D; (CharacterStyle) o;\n\t\treturn font.equals(otherStyle.font)\n\t\t       &amp;&amp; size &#x3D;&#x3D; otherStyle.size\n\t\t       &amp;&amp; colorRGB &#x3D;&#x3D; otherStyle.colorRGB;\n\t&#125;\n&#125;\npublic class CharacterStyleFactory &#123;\n\tprivate static final List&lt;CharacterStyle&gt; styles &#x3D; new ArrayList&lt;&gt;();\n\tpublic static CharacterStyle getStyle(Font font, int size, int colorRGB) &#123;\n\t\tCharacterStyle newStyle &#x3D; new CharacterStyle(font, size, colorRGB);\n\t\tfor (CharacterStyle style : styles) &#123;\n\t\t\tif (style.equals(newStyle)) &#123;\n\t\t\t\treturn style;\n\t\t\t&#125;\n\t\t&#125;\n\t\tstyles.add(newStyle);\n\t\treturn newStyle;\n\t&#125;\n&#125;\npublic class Character &#123;\n\tprivate char c;\n\tprivate CharacterStyle style;\n\tpublic Character(char c, CharacterStyle style) &#123;\n\t\tthis.c &#x3D; c;\n\t\tthis.style &#x3D; style;\n\t&#125;\n&#125;\npublic class Editor &#123;\n\tprivate List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\tpublic void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n\t\tCharacter character &#x3D; new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB);\n\t\tchars.add(character);\n\t&#125;\n&#125;\n\n7.3 享元模式 vs 单例、缓存、对象池1、享元模式跟单例的区别\n在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例\n但区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数\n2、享元模式跟缓存的区别\n在享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。平时所讲的缓存，主要是为了提高访问效率，而非复用\n3、享元模式跟对象池的区别\n对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？\n很多人可能对连接池、线程池比较熟悉，对对象池比较陌生，这里简单解释一下对象池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉\n虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念\n池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间\n7.4 在 Java Integer 中的应用先来看下面这样一段代码，思考下这段代码会输出什么样的结果：\nInteger i1 &#x3D; 56;\nInteger i2 &#x3D; 56;\nInteger i3 &#x3D; 129;\nInteger i4 &#x3D; 129;\nSystem.out.println(i1 &#x3D;&#x3D; i2);\nSystem.out.println(i3 &#x3D;&#x3D; i4);\n\n如果不熟悉 Java 语言，可能会觉得，i1 和 i2 值都是 56，i3 和 i4 值都是 129，i1 跟 i2值相等，i3 跟 i4 值相等，所以输出结果应该是两个 true。这样的分析是不对的，要正确地分析上面的代码，需要弄清楚下面两个问题：\n\n如何判定两个 Java 对象是否相等（也就代码中的“&#x3D;&#x3D;”操作符的含义）？\n什么是自动装箱（Autoboxing）和自动拆箱（Unboxing）？\n\nJava 为基本数据类型提供了对应的包装器类型。具体如下所示：\n\n所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型。具体的代码示例如下所示：\nInteger i &#x3D; 56; &#x2F;&#x2F;自动装箱\nint j &#x3D; i; &#x2F;&#x2F;自动拆箱\n\n数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语句：\nInteger i &#x3D; 59; 底层执行了: Integer i &#x3D; Integer.valueOf(59);\n\n反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：\nint j &#x3D; i; 底层执行了: int j &#x3D; i.intValue();\n\n弄清楚了自动装箱和自动拆箱，再来看，如何判定两个对象是否相等？不过，在此之前，先要搞清楚，Java 对象在内存中是如何存储的。如下例：\nUser a &#x3D; new User(123, 23); &#x2F;&#x2F; id&#x3D;123, age&#x3D;23\n\na 存储的值是 User 对象的内存地址，在图中就表现为 a 指向 User 对象。\n\n当通过“&#x3D;&#x3D;”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象\n再来看之前的代码：\nInteger i1 &#x3D; 56;\nInteger i2 &#x3D; 56;\nInteger i3 &#x3D; 129;\nInteger i4 &#x3D; 129;\nSystem.out.println(i1 &#x3D;&#x3D; i2);\nSystem.out.println(i3 &#x3D;&#x3D; i4);\n\n前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、i3、i4 这四个变量。根据刚刚的讲解，i1、i2 尽管存储的数值相同，都是 56，但是指向不同的 Integer 对象，所以通过“&#x3D;&#x3D;”来判定是否相同的时候，会返回 false。同理，i3==i4 判定语句也会返回 false\n不过，上面的分析还是不对，答案并非是两个 false，而是一个 true，一个 false。看到这里可能会比较纳闷了。实际上，这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果。当通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 valueOf() 函数的具体代码如下所示：\npublic static Integer valueOf(int i) &#123;\n    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;\n\n实际上，这里的 IntegerCache 相当于前面讲的生成享元对象的工厂类，只不过名字不叫 xxxFactory 而已。下面来看它的具体代码实现。这个类是 Integer 的内部类，也可以自行查看 JDK 源码：\n&#x2F;**\n* Cache to support the object identity semantics of autoboxing for values betw\n* -128 and 127 (inclusive) as required by JLS.\n*\n* The cache is initialized on first usage. The size of the cache\n* may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125; option.\n* During VM initialization, java.lang.Integer.IntegerCache.high property\n* may be set and saved in the private system properties in the\n* sun.misc.VM class.\n*&#x2F;\nprivate static class IntegerCache &#123;\n\tstatic final int low &#x3D; -128;\n\tstatic final int high;\n\tstatic final Integer cache[];\n\tstatic &#123;\n\t\t&#x2F;&#x2F; high value may be configured by property\n\t\tint h &#x3D; 127;\n\t\tString integerCacheHighPropValue &#x3D;\n\t\t    sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;)\n\t\tif (integerCacheHighPropValue !&#x3D; null) &#123;\n\t\t\ttry &#123;\n\t\t\t\tint i &#x3D; parseInt(integerCacheHighPropValue);\n\t\t\t\ti &#x3D; Math.max(i, 127);\n\t\t\t\t&#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE\n\t\t\t\th &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);\n\t\t\t&#125; catch( NumberFormatException nfe) &#123;\n\t\t\t\t&#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.\n\t\t\t&#125;\n\t\t&#125;\n\t\thigh &#x3D; h;\n\t\tcache &#x3D; new Integer[(high - low) + 1];\n\t\tint j &#x3D; low;\n\t\tfor(int k &#x3D; 0; k &lt; cache.length; k++)\n\t\t\tcache[k] &#x3D; new Integer(j++);\n\t\t&#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)\n\t\tassert IntegerCache.high &gt;&#x3D; 127;\n\t&#125;\n\tprivate IntegerCache() &#123;&#125;\n&#125;\n\n为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢？\n在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，不可能在 IntegerCache 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 IntegerCache 类的时间过长。所以，只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（-128 到 127 之间的数据）\n实际上，JDK 也提供了方法来让我们可以自定义缓存的最大值，有下面两种方式。如果通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，就可以用如下方式，将缓存的最大值从 127 调整到 255。不过，这里注意一下，JDK 并没有提供设置最小值的方法\n&#x2F;&#x2F;方法一：\n-Djava.lang.Integer.IntegerCache.high&#x3D;255\n&#x2F;&#x2F;方法二：\n-XX:AutoBoxCacheMax&#x3D;255\n\n实际上，除了 Integer 类型之外，其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据。比如，Long 类型对应的 LongCache 享元工厂类及 valueOf() 函数代码如下所示：\nprivate static class LongCache &#123;\n\tprivate LongCache() &#123;&#125;\n\tstatic final Long cache[] &#x3D; new Long[-(-128) + 127 + 1];\n\tstatic &#123;\n\t\tfor(int i &#x3D; 0; i &lt; cache.length; i++)\n\t\t\tcache[i] &#x3D; new Long(i - 128);\n\t&#125;\n&#125;\npublic static Long valueOf(long l) &#123;\n\tfinal int offset &#x3D; 128;\n\tif (l &gt;&#x3D; -128 &amp;&amp; l &lt;&#x3D; 127) &#123; &#x2F;&#x2F; will cache\n\t\treturn LongCache.cache[(int)l + offset];\n\t&#125;\n\treturn new Long(l);\n&#125;\n\n在平时的开发中，对于下面这样三种创建整型对象的方式，优先使用后两种：\nInteger a &#x3D; new Integer(123);\nInteger a &#x3D; 123;\nInteger a &#x3D; Integer.valueOf(123);\n\n第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，最多只需要分配 256 个 Integer 对象的内存空间\n7.5 在 Java String 中的应用同样，还是先来看一段代码，这段代码输出的结果是什么呢？\nString s1 &#x3D; &quot;小争哥&quot;;\nString s2 &#x3D; &quot;小争哥&quot;;\nString s3 &#x3D; new String(&quot;小争哥&quot;);\nSystem.out.println(s1 &#x3D;&#x3D; s2);\nSystem.out.println(s1 &#x3D;&#x3D; s3);\n\n上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。上面代码对应的内存存储结构如下所示：\n\n不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了\n实际上，享元模式对 JVM 的垃圾回收并不友好。因为享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反倒可能会浪费更多的内存。所以，除非经过线上验证，利用享元模式真的可以大大节省内存，否则，就不要过度使用这个模式，为了一点点内存的节省而引入一个复杂的设计模式，得不偿失\n","slug":"BlogRepository/设计模式/设计模式之美总结（结构型篇）","date":"2022-12-21T01:59:11.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"6c3cfbb59bb90aa0cd86d47a59e86094","title":"Vue3 总结（开发）","content":"更详细的 API 和使用见：Vue2 总结（开发）_凡 223 的博客\n1. Vue Router官网地址：Home | Vue Router (vuejs.org)\n1.1 安装npm install vue-router@4\n\n1.2 使用1.2.1 new Router 变成 createRouter&#x2F;&#x2F; 以前是\n&#x2F;&#x2F; import Router from &#39;vue-router&#39;\nimport &#123; createRouter &#125; from &#39;vue-router&#39;\n\nconst router &#x3D; createRouter(&#123;\n  &#x2F;&#x2F; ...\n&#125;)\n\n1.2.2 新的 history 配置取代 modemode: &#39;history&#39; 配置已经被一个更灵活的 history 配置所取代。根据使用的模式，必须用适当的函数替换它：\n\n&quot;history&quot;：createWebHistory()\n&quot;hash&quot;：createWebHashHistory()\n&quot;abstract&quot;：createMemoryHistory()\n\nimport &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;\n&#x2F;&#x2F; 还有 createWebHashHistory 和 createMemoryHistory\n\ncreateRouter(&#123;\n  history: createWebHashHistory(),\n  routes: [],\n&#125;)\n\n1.2.3 index.js 示例import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHistory(),\n  routes: [\n    &#123;\n      path: &#39;&#x2F;&#39;,\n      redirect: &#39;&#x2F;home&#39;,\n      name: &#39;Root&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;layout&#x2F;MainMenu.vue&#39;),\n      children: [\n        &#123;\n          path: &#39;&#x2F;home&#39;,\n          name: &#39;Home&#39;,\n          component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home.vue&#39;)\n        &#125;\n      ],\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;index&#39;,\n      name: &#39;Index&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Index.vue&#39;),\n    &#125;,\n  ]\n&#125;)\n\nexport default router\n\n1.2.4 main.js 里引入import &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport router from &#39;.&#x2F;router&#39;\n\nconst app &#x3D; createApp(App)\n\napp.use(router)\n  .mount(&#39;#app&#39;)\n\n1.2.5 组合式 API&lt;script&gt;\nimport &#123; useRouter, useRoute &#125; from &#39;vue-router&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Login&#39;,\n  setup() &#123;\n    const router &#x3D; useRouter()\n    const route &#x3D; useRoute()\n\n    function pushWithQuery(query) &#123;\n      &#x2F;&#x2F; router.push(&#39;&#x2F;home&#39;);\n      router.push(&#123;\n        name: &#39;Hone&#39;,\n        query: &#123;\n          ...route.query,\n        &#125;,\n      &#125;)\n    &#125;\n\n    return &#123;\n      pushWithQuery,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n1.3 导航守卫和动态路由可以在路由前注册一个全局前置守卫来进行动态路由\n&#x2F;&#x2F; 全局前置守卫\nrouter.beforeEach((to, from ,next) &#x3D;&gt; &#123;\n  let hasRoute &#x3D; store.state.menu.hasRoute;\n\n  if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n    next()\n  &#125; else if(!localStorage.getItem(&#39;JWT&#39;)) &#123;\n    ElMessage(&#123;\n      message: &#39;请先登录&#39;,\n      type: &#39;error&#39;\n    &#125;)\n    next(&#39;&#x2F;login&#39;)\n  &#125; else if (!hasRoute)&#123;\n    axios.get(&#39;&#x2F;resNav&#x2F;menu&#x2F;listNavMenus&#39;).then(response &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 拿到 menus 菜单列表\n      store.commit(&#39;SET_MENUS&#39;, response.data.data.menus);\n      &#x2F;&#x2F; 拿到 authorities 权限列表\n      store.commit(&#39;SET_AUTHORITIES&#39;, response.data.data.authorities);\n\n      if(response.data.data.menus) &#123;\n        &#x2F;&#x2F; 动态绑定路由\n        response.data.data.menus.forEach(menu &#x3D;&gt; &#123;\n          if (menu.children &amp;&amp; menu.children.length &gt; 0) &#123;\n            transToRouter(menu)\n          &#125; else &#123;\n            let route &#x3D; menuToRouter(menu);\n            if (route) &#123;\n              router.addRoute(&#39;Root&#39;, route);\n            &#125;\n          &#125;\n        &#125;);\n\n        store.commit(&#39;CHANGE_ROUTE_STATUS&#39;, true);\n      &#125;\n\n      next(to.path)\n    &#125;)\n  &#125; else &#123;\n    next()\n  &#125;\n&#125;)\n\nfunction transToRouter(menu) &#123;\n  if(menu.children &amp;&amp; menu.children.length &gt; 0) &#123;\n    menu.children.forEach(child &#x3D;&gt; &#123;\n      transToRouter(child)\n    &#125;)\n  &#125; else &#123;\n    let route &#x3D; menuToRouter(menu);\n    if (route) &#123;\n      router.addRoute(&#39;Root&#39;, route)\n    &#125;\n  &#125;\n&#125;\n\nfunction menuToRouter(menu) &#123;\n  if(!menu.component)&#123;\n    return null;\n  &#125; else &#123;\n    return &#123;\n      path: menu.path,\n      name: menu.permission,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#39; + menu.component +&#39;.vue&#39;),\n      meta: &#123;\n        title: menu.name,\n        icon: menu.icon\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nexport default router\n\n2. Vuex官网地址：Vuex 是什么？ | Vuex (vuejs.org)\n2.1 安装npm install vuex@next --save\n\n2.2 使用2.2.1 new Vuex.Store 变成 createStoreimport &#123; createStore &#125; from &#39;vuex&#39;\n\nexport const store &#x3D; createStore(&#123;\n  state () &#123;\n    return &#123;\n      count: 1\n    &#125;\n  &#125;\n&#125;)\n\n2.2.2 index.js 示例import &#123; createStore &#125; from &#39;vuex&#39;\n\nconst store &#x3D; createStore(&#123;\n  state: &#123;\n    isCollapsed: false\n  &#125;\n&#125;)\n\nexport default store\n\n2.2.3 main.js 里引入import &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport router from &#39;.&#x2F;router&#39;\nimport store from &#39;.&#x2F;store&#39;\n\nconst app &#x3D; createApp(App)\n\napp.use(router)\n  .use(store)\n  .mount(&#39;#app&#39;)\n\n2.2.4 组合式 API 中使用 store可以通过调用 useStore 函数，来在 setup 钩子函数中访问 store。这与在组件中使用选项式 API 访问 this.$store 是等效的\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  setup () &#123;\n    const store &#x3D; useStore()\n  &#125;\n&#125;\n\n访问 State\n&lt;script&gt;\nimport &#123; useStore &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  name: &#39;HeaderMenu&#39;,\n  setup() &#123;\n    const store &#x3D; useStore()\n\n    function collapsedSider() &#123;\n      store.state.isCollapsed &#x3D; !store.state.isCollapsed\n    &#125;\n\n    return &#123;\n      collapsedSider\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n同上，访问 Getter、Mutation 和 Action 类似\n3. View UI Plus官网地址：View Design (iviewui.com)\n3.1 安装npm install view-ui-plus --save\n\n3.2 main.js 里引入3.2.1 完整引入import &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport ViewUIPlus from &#39;view-ui-plus&#39;\nimport &#39;view-ui-plus&#x2F;dist&#x2F;styles&#x2F;viewuiplus.css&#39;\n\nconst app &#x3D; createApp(App)\n\napp.use(ViewUIPlus)\n  .mount(&#39;#app&#39;)\n\n3.2.2 按需引入助插件 babel-plugin-import 可以实现按需加载组件，减少文件体积\n1、安装\nnpm install babel-plugin-import --save-dev\n\n2、在文件 babel.config.js 里配置\nmodule.exports &#x3D; &#123;\n  presets: [\n    &#39;@vue&#x2F;cli-plugin-babel&#x2F;preset&#39;\n  ],\n  plugins: [\n    [\n      &quot;import&quot;,\n      &#123;\n        &quot;libraryName&quot;: &quot;view-ui-plus&quot;,\n        &quot;libraryDirectory&quot;: &quot;src&#x2F;components&quot;\n      &#125;,\n      &quot;view-ui-plus&quot;\n    ]\n  ]\n&#125;\n\n3、再进行引入\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport &#123; Button, Table &#125; from &#39;view-ui-plus&#39;;\nimport &#39;view-ui-plus&#x2F;dist&#x2F;styles&#x2F;viewuiplus.css&#39;;\n\nconst app &#x3D; createApp(App)\n\napp.component(&#39;Button&#39;, Button);\napp.component(&#39;Table&#39;, Table);\n\napp.mount(&#39;#app&#39;)\n\n3.3 使用按照官方文档使用相关组件即可：View Design (iviewui.com)\n4. Element Plus官网地址：Element Plus (element-plus.org)\n4.1 安装npm install element-plus --save\n\n4.2 main.js 里引入4.2.1 完整引入import &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport ElementPlus from &#39;element-plus&#39;\nimport &#39;element-plus&#x2F;dist&#x2F;index.css&#39;\n\nconst app &#x3D; createApp(App)\n\napp.use(ElementPlus)\napp.mount(&#39;#app&#39;)\n\n4.2.2 按需引入自动导入\n1、安装 unplugin-vue-components 和 unplugin-auto-import 这两款插件\nnpm install -D unplugin-vue-components unplugin-auto-import\n\n2、在 Webpack 的配置文件里配置\nconst AutoImport &#x3D; require(&#39;unplugin-auto-import&#x2F;webpack&#39;)\nconst Components &#x3D; require(&#39;unplugin-vue-components&#x2F;webpack&#39;)\nconst &#123; ElementPlusResolver &#125; &#x3D; require(&#39;unplugin-vue-components&#x2F;resolvers&#39;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...\n  plugins: [\n    AutoImport(&#123;\n      resolvers: [ElementPlusResolver()],\n    &#125;),\n    Components(&#123;\n      resolvers: [ElementPlusResolver()],\n    &#125;),\n  ],\n&#125;\n\n手动导入\n1、安装 unplugin-element-plus 来导入样式，参考 文档 进行配置\n2、使用\n&lt;template&gt;\n  &lt;el-button&gt;I am ElButton&lt;&#x2F;el-button&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  import &#123; ElButton &#125; from &#39;element-plus&#39;\n  export default &#123;\n    components: &#123; ElButton &#125;,\n  &#125;\n&lt;&#x2F;script&gt;\n\n4.3 使用按照官方文档使用相关组件即可：Element Plus\n4.3.1 图标使用1、安装\nnpm install @element-plus&#x2F;icons-vue\n\n2、main.js 里注册所有图标\nimport * as ElementPlusIconsVue from &#39;@element-plus&#x2F;icons-vue&#39;\n\nconst app &#x3D; createApp(App)\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123;\n  app.component(key, component)\n&#125;\n\n3、组件中配合 Button 使用\n&lt;template&gt;\n  &lt;el-button :icon&#x3D;&quot;Fold&quot;&gt; &lt;&#x2F;el-button&gt;\n  &lt;el-button :icon&#x3D;&quot;Expand&quot;&gt; &lt;&#x2F;el-button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; Fold, Expand &#125; from &#39;@element-plus&#x2F;icons-vue&#39;\n\nexport default &#123;\n  name: &#39;HeaderMenu&#39;,\n  setup() &#123;\n    return &#123;\n      Fold,\n      Expand\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n4.3.2 消息提示使用1、全局方法\n&lt;script&gt;\nimport &#123; getCurrentInstance &#125; from &quot;@vue&#x2F;runtime-core&quot;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Login&#39;,\n  setup() &#123;\n    const &#123; proxy &#125; &#x3D; getCurrentInstance()\n\n    proxy.$message(&#123;\n      message: &#39;&#39;,\n      type: &#39;success&#39;,\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n2、单独引用\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\n3、全局注入\nmain.js\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\n\napp.provide(&#39;ElMessage&#39;, ElMessage)\n\n组件使用\n&lt;script&gt;\nimport &#123; inject &#125; from &quot;@vue&#x2F;runtime-core&quot;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Login&#39;,\n  setup() &#123;\n    const ElMessage &#x3D; inject(&#39;ElMessage&#39;)\n\n    ElMessage(&#123;\n      message: &#39;&#39;,\n      type: &#39;success&#39;,\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n5. Vue-Axios官网地址：axios 中文文档 (axios-js.com)\n5.1 安装npm install --save axios vue-axios\n\n5.2 main.js 里引入import &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport axios from &#39;axios&#39;\nimport VueAxios from &#39;vue-axios&#39;\n\nconst app &#x3D; createApp(App)\n\napp.use(VueAxios, axios)\n  .mount(&#39;#app&#39;)\n\n5.3 使用1、使用 app.provide\nmain.js 里添加一条配置\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport axios from &#39;axios&#39;\nimport VueAxios from &#39;vue-axios&#39;\n\nconst app &#x3D; createApp(App)\n\napp.use(VueAxios, axios)\n  .mount(&#39;#app&#39;)\n\napp.provide(&#39;axios&#39;, app.config.globalProperties.axios)\n\n在组件中使用\n&lt;script&gt;\nimport &#123; inject &#125; from &#39;@vue&#x2F;runtime-core&#39;;\n\nexport default &#123;\n  name: &#39;AsideMenu&#39;,\n  setup() &#123;\n    const axios &#x3D; inject(&#39;axios&#39;)\n\n    function listMenu() &#123;\n      axios.get(&#39;&#x2F;resNav&#x2F;menu&#x2F;listMenu&#39;).then(\n        response &#x3D;&gt; &#123;\n          console.log(response.data.data.records);\n        &#125;\n      )\n    &#125;\n\n    listMenu();\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n2、使用 app.config.globalProperties\nmain.js 里添加一条配置\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nimport axios from &#39;axios&#39;\nimport VueAxios from &#39;vue-axios&#39;\n\nconst app &#x3D; createApp(App)\n\napp.use(VueAxios, axios)\n  .mount(&#39;#app&#39;)\n\napp.config.globalProperties.$axios &#x3D; axios;\n\n在组件中使用\n&lt;script&gt;\nimport &#123; getCurrentInstance &#125; from &#39;@vue&#x2F;runtime-core&#39;;\n\nexport default &#123;\n  name: &#39;AsideMenu&#39;,\n  setup() &#123;\n    const &#123; proxy &#125; &#x3D; getCurrentInstance();\n\n    function listMenu() &#123;\n      proxy.axios.get(&#39;&#x2F;resNav&#x2F;menu&#x2F;listMenu&#39;).then(\n        response &#x3D;&gt; &#123;\n          console.log(response.data.data.records);\n        &#125;\n      )\n    &#125;\n\n    listMenu();\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n5.4 全局拦截器创建 axios.js 文件\nimport axios from &#39;axios&#39;;\nimport &#123; ElMessage &#125; from &#39;element-plus&#39;\nimport router from &#39;@&#x2F;router&#39;\nimport ViewUIPlus from &#39;view-ui-plus&#39;;\n\nconst request &#x3D; axios.create(&#123;\n  timeout: 10000,\n  headers: &#123;\n    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,\n  &#125;,\n&#125;);\n\nrequest.interceptors.request.use(config &#x3D;&gt; &#123;\n  if (localStorage.getItem(&quot;JWT&quot;)) &#123;\n    &#x2F;&#x2F; 请求头带上 JWT\n    config.headers.Authorization &#x3D; localStorage.getItem(&quot;JWT&quot;);\n  &#125;\n\n  return config;\n&#125;);\n\nrequest.interceptors.response.use(response &#x3D;&gt; &#123;\n  return response;\n&#125;, error &#x3D;&gt; &#123;\n  ViewUIPlus.LoadingBar.error()\n  \n  if (error.response) &#123;\n    switch (error.response.status) &#123;\n      case 400: \n        ElMessage(&#123;\n          message: &#39;请求错误&#39;,\n          type: &#39;error&#39;\n        &#125;)\n        break;\n      case 401:\n        router.push(&#39;&#x2F;login&#39;);\n        ElMessage(&#123;\n          message: &#39;登录已过期, 请重新登录&#39;,\n          type: &#39;error&#39;\n        &#125;)\n        break;\n      case 403:\n        ElMessage(&#123;\n          message: error.response.data.msg,\n          type: &#39;error&#39;\n        &#125;)\n        break;\n      case 404:\n        ElMessage(&#123;\n          message: &#39;请求错误,未找到该资源&#39;,\n          type: &#39;error&#39;\n        &#125;)\n        break;\n      case 500:\n        ElMessage(&#123;\n          message: &#39;服务器出错&#39;,\n          type: &#39;error&#39;\n        &#125;)\n        break;\n      default:\n        ElMessage(&#123;\n          message: &#39;未知错误&#39;,\n          type: &#39;error&#39;\n        &#125;)\n    &#125;\n  &#125;\n\n  return Promise.reject(error);\n&#125;);\n\nexport default request\n\n\n在 main.js 文件中替换引入\nimport request from &#39;.&#x2F;axios&#39;\nimport VueAxios from &#39;vue-axios&#39;\n\napp.use(VueAxios, request)\n  .mount(&#39;#app&#39;)\n","slug":"BlogRepository/Vue/Vue3 总结（开发）","date":"2022-12-20T16:57:55.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"凡"},{"id":"ac0a19fc42d1d09f368f9cb237bd1e7b","title":"通过 Request 请求获取真实 IP 地址以及对应省份城市和系统浏览器信息","content":"1. 获取真实 IP 地址1.1 代码代码如下，这里的 CommonUtil.isBlank() 为封装的判空方法\npublic static String getIpAddress(HttpServletRequest request) &#123;\n        &#x2F;&#x2F; 首先, 获取 X-Forwarded-For 中的 IP 地址，它在 HTTP 扩展协议中能表示真实的客户端 IP\n        String ipAddress &#x3D; request.getHeader(&quot;X-Forwarded-For&quot;);\n        if (CommonUtil.isNotBlank(ipAddress) &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 多次反向代理后会有多个 ip 值，第一个 ip 才是真实 ip, 例: X-Forwarded-For: client, proxy1, proxy2，proxy…\n            int index &#x3D; ipAddress.indexOf(&quot;,&quot;);\n            if (index !&#x3D; -1) &#123;\n                return ipAddress.substring(0, index);\n            &#125;\n\n            return ipAddress;\n        &#125;\n\n        &#x2F;&#x2F; 如果 X-Forwarded-For 获取不到, 就去获取 X-Real-IP\n        ipAddress &#x3D; request.getHeader(&quot;X-Real-IP&quot;);\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 X-Real-IP 获取不到, 就去获取 Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 Proxy-Client-IP 获取不到, 就去获取 WL-Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 WL-Proxy-Client-IP 获取不到, 就去获取 HTTP_CLIENT_IP\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 HTTP_CLIENT_IP 获取不到, 就去获取 HTTP_X_FORWARDED_FOR\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 都获取不到, 最后才通过 request.getRemoteAddr() 获取IP\n            ipAddress &#x3D; request.getRemoteAddr();\n        &#125;\n\n        return &quot;0:0:0:0:0:0:0:1&quot;.equals(ipAddress) ? &quot;127.0.0.1&quot; : ipAddress;;\n&#125;\n\n1.2 解释1、首先，获取 X-Forwarded-For 中第 0 位的 IP 地址，它在 HTTP 扩展协议中能表示真实的客户端 IP，如下例：\n\n\n\n\n\n\n\n\n\nX-Forwarded-For: client, proxy1, proxy2, proxy…\n2、如果 X-Forwarded-For 获取不到，就去获取 X-Real-IP ，X-Real-IP 获取不到，就依次获取 Proxy-Client-IP 、WL-Proxy-Client-IP 、HTTP_CLIENT_IP 、 HTTP_X_FORWARDED_FOR 。最后获取不到才通过 request.getRemoteAddr() 获取 IP\n\nX-Real-IP ： 记录请求的客户端真实 IP，与 X-Forwarded-For 类似\nProxy-Client-IP ： 代理客户端的 IP，如果客户端真实 IP 获取不到的时候，就只能获取代理客户端的 IP 了\nWL-Proxy-Client-IP ： 在 Weblogic 下获取真实 IP 所用的的参数\nHTTP_CLIENT_IP 、HTTP_X_FORWARDED_FOR ： 可以理解为 X-Forwarded-For ， 它们是 PHP 中的用法\n\n3、在服务器上通过 request.getRemoteAddr() 获取服务器的地址时，获取到的是 IPV6 的 0:0:0:0:0:0:0:1，需要转换为 IPV4 的 127.0.0.1\n1.3 Nginx 配置请求头参数server &#123;\n        listen       8081;\n        server_name  localhost;\n\n        location &#x2F; &#123;\n            root   html&#x2F;resource-nav;\n            index  index.html index.htm;\n        &#125;\n  \n        location ~ &#x2F;resNav &#123;\n            #代理请求头相关\n\t    proxy_set_header Host $host:$server_port; \n\t    proxy_set_header X-Real-Ip $remote_addr;\n\t    proxy_set_header X-Forwarded-For $remote_addr;\n  \n            proxy_pass http:&#x2F;&#x2F;ip:port;\n        &#125;\n&#125;\n\n2. 通过 IP 地址获取省份城市信息分为两种方式，在线和离线：\n1、使用在线第三方提供的 api：\n\nip-api.com\nip.taotao.com\n百度地图 api\n新浪 iplookup\n\n2、使用离线查询方式：\n\n纯真库\nGeoLite2\n埃文科技\n\n具体的数据丰富性、准确性和查询速度可自行搜集相关资料。由于 GeoLite2 免费，且离线查询速度更快和稳定，同时不限制 API 并发数等，这里使用 GeoLite2 来获取省份城市信息，同时数据丰富性也比较高\n2.1 下载 GeoLite2 City 库GeoLite 数据库是 MaxMind 公司旗下的 ，GeoLite 数据库有开源版本和收费版本，这里使用开源版本，GeoLite 目前已经更新到 2 了，所以下载 GeoLite2 City 库。下载地址如下：GeoLite2 Free Geolocation Data | MaxMind Developer Portal\n点击页面中的 Download Files\n\n未登录的话会跳转到登录页面\n\n没有账户的话点击创建\n\n这里会有几种账户形式，选择登录免费的 GeoLite2 数据库和 Web 服务\n\n填写完对应的信息后，会发一封设置密码的邮件，点击链接设置密码\n\n完成后点击进行登录\n\n输入用户名密码进行登录，用户名就是邮箱地址\n\n选择下载数据库\n\n选择 GZIP 下载\n\n下载完成后会得到一个 tar 包文件\n\n解压后里面就是我们需要的数据库文件（Windows 可用 7-Zip 解压）\n\n2.2 使用2.2.1将文件放入项目根路径下\n2.2.2 引入依赖好像 3.0 版本以上最低支持 JDK 11，假如是 JDK 8 的话最高使用 2.16.1 即可\n&lt;!-- GeoIP2 --&gt;\n&lt;dependency&gt;\n        &lt;groupId&gt;com.maxmind.geoip2&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;geoip2&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.16.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.2.3 代码这里的 new DatabaseReader.Builder(database).build() 支持两种类型，一种是 File，一种是 InputStream。本地项目两种皆可，但打包到服务器上运行时获取 File 类型文件可能会存在问题，最好通过流的方式来获取构建\npublic class Test &#123;\n    public static void main(String[] args) throws IOException, GeoIp2Exception &#123;\n        &#x2F;&#x2F; 读取数据库文件\n        ClassPathResource classPathResource &#x3D; new ClassPathResource(&quot;GeoLite2-City.mmdb&quot;);\n        InputStream database &#x3D; database &#x3D; classPathResource.getInputStream();\n        &#x2F;&#x2F; 创建数据库\n        DatabaseReader reader &#x3D; new DatabaseReader.Builder(database).build();\n        &#x2F;&#x2F; 获取 IP 地址信息\n        InetAddress ipAddress &#x3D; InetAddress.getByName(&quot;139.227.47.35&quot;);\n\n        &#x2F;&#x2F; 获取查询信息\n        CityResponse response &#x3D; reader.city(ipAddress);\n\n        &#x2F;&#x2F; 国家信息\n        Country country &#x3D; response.getCountry();\n        System.out.println(country.getIsoCode()); &#x2F;&#x2F; &#39;CN&#39;\n        System.out.println(country.getName()); &#x2F;&#x2F; &#39;China&#39;\n        &#x2F;&#x2F; &#123;de&#x3D;China, ru&#x3D;Китай, pt-BR&#x3D;China, ja&#x3D;中国, en&#x3D;China, fr&#x3D;Chine, zh-CN&#x3D;中国, es&#x3D;China&#125;\n        System.out.println(country.getNames());\n        System.out.println(country.getNames().get(&quot;zh-CN&quot;)); &#x2F;&#x2F; &#39;中国&#39;\n\n        &#x2F;&#x2F; 省级信息\n        Subdivision subdivision &#x3D; response.getMostSpecificSubdivision();\n        System.out.println(subdivision.getIsoCode()); &#x2F;&#x2F; &#39;SH&#39;\n        System.out.println(subdivision.getName()); &#x2F;&#x2F; &#39;Shanghai&#39;\n        &#x2F;&#x2F; &#123;&#123;en&#x3D;Shanghai, fr&#x3D;Municipalité de Shanghai, zh-CN&#x3D;上海, pt-BR&#x3D;Xangai&#125;&#125;\n        System.out.println(subdivision.getNames());\n        System.out.println(subdivision.getNames().get(&quot;zh-CN&quot;)); &#x2F;&#x2F; &#39;上海&#39;\n\n        &#x2F;&#x2F; 城市信息\n        City city &#x3D; response.getCity();\n        System.out.println(city.getName()); &#x2F;&#x2F; &#39;Shanghai&#39;\n        System.out.println(city.getNames().get(&quot;zh-CN&quot;)); &#x2F;&#x2F; &#39;上海&#39;\n\n        &#x2F;&#x2F; 邮政编码(国内的可能获取不到)\n        Postal postal &#x3D; response.getPostal();\n        System.out.println(postal.getCode()); &#x2F;&#x2F; &#39;55423&#39;\n\n        &#x2F;&#x2F; 经纬度\n        Location location &#x3D; response.getLocation();\n        System.out.println(location.getLatitude()); &#x2F;&#x2F; 纬度 31.2222\n        System.out.println(location.getLongitude()); &#x2F;&#x2F; 经度 121.4581\n    &#125;\n&#125;\n\n\n2.3 封装成工具类1、实体类\n@Data\n@TableName(&quot;login_geo&quot;)\npublic class LoginGeoDO &#123;\n\n    &#x2F;&#x2F; 主键ID\n    private String id;\n\n    &#x2F;&#x2F; 国家 ISO 代码\n    private String countryIsoCode;\n\n    &#x2F;&#x2F; 国家名称\n    private String countryName;\n\n    &#x2F;&#x2F; 国家中文名称\n    private String countryZhCnName;\n\n    &#x2F;&#x2F; 省级 ISO 代码, 外国则是同级别地区代码\n    private String subdivisionIsoCode;\n\n    &#x2F;&#x2F; 省级名称\n    private String subdivisionName;\n\n    &#x2F;&#x2F; 省级中文名称\n    private String subdivisionZhCnName;\n\n    &#x2F;&#x2F; 城市名称\n    private String cityName;\n\n    &#x2F;&#x2F; 城市中文名称\n    private String cityZhCnName;\n\n    &#x2F;&#x2F; 邮政编码\n    private String postal;\n\n    &#x2F;&#x2F; 纬度\n    private double latitude;\n\n    &#x2F;&#x2F; 经度\n    private double longitude;\n\n    &#x2F;&#x2F; 创建时间\n    private Timestamp createTime;\n\n    &#x2F;&#x2F; 更新时间\n    private Timestamp updateTime;\n&#125;\n\n2、封装工具类\n这里把前面获取 IP 地址的方法也封装进来了，LogUtil 为封装的日志工具类\npublic class AuthUtil &#123;\n\n    private static InputStream database;\n\n    private static DatabaseReader reader;\n\n    static &#123;\n        &#x2F;&#x2F; 读取数据库文件\n        LogUtil.info(&quot;读取数据库文件&quot;);\n        ClassPathResource classPathResource &#x3D; new ClassPathResource(&quot;GeoLite2-City.mmdb&quot;);\n        &#x2F;&#x2F; 创建数据库\n        try &#123;\n            database &#x3D; classPathResource.getInputStream();\n            reader &#x3D; new DatabaseReader.Builder(database).build();\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e.getMessage());\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 获取 IP 地址\n     *\n     * @param request 请求\n     * @return &#123;@link String&#125;\n     * @author Fan\n     * @since 2022&#x2F;11&#x2F;28 9:08\n     *&#x2F;\n    public static String getIpAddress(HttpServletRequest request) &#123;\n        &#x2F;&#x2F; 首先, 获取 X-Forwarded-For 中的 IP 地址，它在 HTTP 扩展协议中能表示真实的客户端 IP\n        String ipAddress &#x3D; request.getHeader(&quot;X-Forwarded-For&quot;);\n        if (CommonUtil.isNotBlank(ipAddress) &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 多次反向代理后会有多个 ip 值，第一个 ip 才是真实 ip, 例: X-Forwarded-For: client, proxy1, proxy2，proxy…\n            int index &#x3D; ipAddress.indexOf(&quot;,&quot;);\n            if (index !&#x3D; -1) &#123;\n                return ipAddress.substring(0, index);\n            &#125;\n\n            return ipAddress;\n        &#125;\n\n        &#x2F;&#x2F; 如果 X-Forwarded-For 获取不到, 就去获取 X-Real-IP\n        ipAddress &#x3D; request.getHeader(&quot;X-Real-IP&quot;);\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 X-Real-IP 获取不到, 就去获取 Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 Proxy-Client-IP 获取不到, 就去获取 WL-Proxy-Client-IP\n            ipAddress &#x3D; request.getHeader(&quot;WL-Proxy-Client-IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 WL-Proxy-Client-IP 获取不到, 就去获取 HTTP_CLIENT_IP\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_CLIENT_IP&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 如果 HTTP_CLIENT_IP 获取不到, 就去获取 HTTP_X_FORWARDED_FOR\n            ipAddress &#x3D; request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);\n        &#125;\n        if (CommonUtil.isBlank(ipAddress) || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;\n            &#x2F;&#x2F; 都获取不到, 最后才通过 request.getRemoteAddr() 获取IP\n            ipAddress &#x3D; request.getRemoteAddr();\n        &#125;\n\n        return ipAddress;\n    &#125;\n\n    &#x2F;**\n     * 通过 IP 地址获取地理信息\n     *\n     * @param ipAddress IP地址\n     * @return &#123;@link LoginGeoDO&#125;\n     * @author Fan\n     * @since 2022&#x2F;12&#x2F;14 16:35\n     *&#x2F;\n    public static LoginGeoDO getGeoInformation(String ipAddress) &#123;\n        try &#123;\n            &#x2F;&#x2F; 获取 IP 地址信息\n            InetAddress inetAddress &#x3D; InetAddress.getByName(ipAddress);\n            &#x2F;&#x2F; 获取查询信息\n            CityResponse response &#x3D; reader.city(inetAddress);\n            LoginGeoDO loginGeoDO &#x3D; new LoginGeoDO();\n\n            &#x2F;&#x2F; 国家信息\n            Country country &#x3D; response.getCountry();\n            loginGeoDO.setCountryIsoCode(country.getIsoCode());\n            loginGeoDO.setCountryName(country.getName());\n            loginGeoDO.setCountryZhCnName(country.getNames().get(&quot;zh-CN&quot;));\n\n            &#x2F;&#x2F; 省级信息\n            Subdivision subdivision &#x3D; response.getMostSpecificSubdivision();\n            loginGeoDO.setSubdivisionIsoCode(subdivision.getIsoCode());\n            loginGeoDO.setSubdivisionName(subdivision.getName());\n            loginGeoDO.setSubdivisionZhCnName(subdivision.getNames().get(&quot;zh-CN&quot;));\n\n            &#x2F;&#x2F; 城市信息\n            City city &#x3D; response.getCity();\n            loginGeoDO.setCityName(city.getName());\n            loginGeoDO.setCityZhCnName(city.getNames().get(&quot;zh-CN&quot;));\n\n            &#x2F;&#x2F; 邮政编码(国内的可能获取不到)\n            Postal postal &#x3D; response.getPostal();\n            loginGeoDO.setPostal(postal.getCode());\n\n            &#x2F;&#x2F; 经纬度\n            Location location &#x3D; response.getLocation();\n            loginGeoDO.setLatitude(location.getLatitude());\n            loginGeoDO.setLongitude(location.getLongitude());\n\n            return loginGeoDO;\n        &#125; catch (IOException | GeoIp2Exception exception) &#123;\n            LogUtil.error(exception.getMessage());\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n3. 获取系统、浏览器信息该类信息一般通过 UA（User Agent）标识来获取。 User Agent 中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等\n先获取请求头中的 User-Agent\nString ua &#x3D; request.getHeader(&quot;User-Agent&quot;);\n\n引入 UserAgentUtils 依赖\n&lt;!-- UserAgentUtils --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;eu.bitwalker&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;UserAgentUtils&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.21&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n使用提供的 UserAgent 类来解析 ua 字符串\nUserAgent userAgent &#x3D; UserAgent.parseUserAgentString(ua);\n\n&#x2F;&#x2F; 操作系统\nuserAgent.getOperatingSystem().getName()\n&#x2F;&#x2F; 浏览器\nuserAgent.getBrowser().getName()\n","slug":"BlogRepository/开发实践/通过 Request 请求获取真实 IP 地址以及对应省份城市","date":"2022-12-16T08:20:26.000Z","categories_index":"开发实践","tags_index":"GeoIP2,UserAgentUtils","author_index":"凡"},{"id":"1777dd13afd91a7e9bd508c03cf35724","title":"基础微服务项目架构构建总结","content":"1. Maven 依赖版本管理1.1 Maven 依赖的优先级1、最短路径优先\n\n工程中依赖了 B、C 两个 jar 包\n在 B jar 包内引用了 C jar 包版本为 1.0\n在工程内直接引用的 C jar 包版本为 2.0\n\nProject -&gt; B -&gt; C(1.0) ，Project -&gt; C(2.0)。由于 C(2.0) 路径最短，所以项目使用的是 C(2.0)\n2、POM 申明顺序优先\n如果 project -&gt; B -&gt; C(1.0) ，project -&gt; D -&gt; C(2.0) 这样的路径长度一样怎么办呢？\n这样的情况下，Maven 会根据 POM 文件声明的顺序加载，如果先声明了 B，后声明了 D，那就最后的依赖就会是 C(1.0)\n1.2 Maven 包版本控制在项目顶层的父 POM 中可以定义如下的三方 jar 的版本定义（这里的 jar 包只是定义，并没有引用，即不会下载依赖）\n&lt;dependencyManagement&gt;\n  &lt;dependency&gt;\n      &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;1.1.43&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencyManagement&gt;\n\n这样需要引用这个 jar 的子模块可以忽略版本定义直接引用（此时才真正下载依赖）\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n      &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n1.3 多项目全局管理随便打开一个 SpringBoot 的项目，打开 POM 文件，父级依赖都是\n&lt;parent&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;$&#123;springboot-version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n点击这个 parent 的依赖进去看到顶级的父级依赖为\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;springboot-version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n继续点进去，里面已经没有任何 jar 的实际引用了，只有各种各样的 SpringBoot 或者 Spring 生态可能会依赖到的 jar 包的版本定义\nSpring 通过定义一个顶层的父级版本依赖，只要是符合 SpringBoot 大版本下的 Spring 组件内的各个 jar 版本都是统一的，如果出现依赖升级的情况，不需要再去升级一个个组件的版本，直接升级父级的依赖管理 POM 中的版本即可\n参照 Spring Maven 版本管理的思路，我们也可以定义这样一个业务的顶层 Maven 版本管理工程，如 common-dependency\n\n版本管理工程的 POM 的父 POM 依赖 spring-boot\n版本管理工程的 POM 内定义业务通用的一些 Maven 依赖版本\n推送该工程至中央仓库（本地可以直接执行 maven install 打包到本地仓库）\n业务应用将父 POM 从 spring-boot 切换为 common-dependency\n\n即在单个业务项目上抽离出一个版本管理工程作为父工程，所有的项目都使用统一的通用的依赖版本，假如某个项目需要自定义依赖或依赖版本，在项目的顶层 POM 文件中再进行定义即可，根据依赖优先级，会优先使用项目的 POM 文件中自定义的依赖版本\n1.4 common-dependency1、新建一个项目\n\n\n2、删掉多余的其他文件\n\n3、进行版本管理，父依赖为 spring-boot-starter-parent\n注：这里 build 里的 spring-boot-maven-plugin 插件只是为了演示同样有依赖版本继承所以才在此处定义（注释状态），该插件只需定义在项目的主启动类的 POM 文件里即可。单模块项目不影响，假如为多模块项目，打包时会报错 Unable to find main class\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.7.5&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;common-dependency&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;modules&gt;\n        &lt;module&gt;demo&lt;&#x2F;module&gt;\n    &lt;&#x2F;modules&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;\n    &lt;name&gt;common-dependency&lt;&#x2F;name&gt;\n    &lt;description&gt;common-dependency&lt;&#x2F;description&gt;\n\n    &lt;!-- 统一管理jar包版本 --&gt;\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;8&lt;&#x2F;maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;8&lt;&#x2F;maven.compiler.target&gt;\n        &lt;lombok.version&gt;1.18.24&lt;&#x2F;lombok.version&gt;\n        &lt;mybatis.plus.version&gt;3.5.1&lt;&#x2F;mybatis.plus.version&gt;\n        &lt;druid.version&gt;1.2.9&lt;&#x2F;druid.version&gt;\n    &lt;&#x2F;properties&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- MySql --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;8.0.19&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;!-- lombok --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;lombok.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;!-- Mybatis-Plus --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;mybatis.plus.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n            &lt;!-- 动态数据源 --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;mybatis.plus.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;!-- Druid --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n        &lt;&#x2F;dependencies&gt;\n    &lt;&#x2F;dependencyManagement&gt;\n\n&lt;!--\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n--&gt;\n&lt;&#x2F;project&gt;\n\n4、推送到中央仓库，本地的话 maven install 到本地仓库\n\n5、其他项目父依赖改为 common-dependency，即可进行统一的依赖版本管理\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;common-dependency&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;common-project&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;\n    &lt;name&gt;common-project&lt;&#x2F;name&gt;\n    &lt;description&gt;common-project&lt;&#x2F;description&gt;\n\n    &lt;!-- 统一通用的依赖 --&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\n依赖结构如下，不同的颜色的框表示不同的层级，或者说独立工程。如 common-dependency 为通用的顶层版本依赖工程，与 project 是独立的。project 将父依赖设置为 common-dependency，其内部模块的父依赖即相应的项目顶层 POM，module 是包含在 project 里的\n\n单项目的话可以直接在项目顶层 POM 中进行版本控制即可，即从上图的 project 开始，或者说直接将 common-dependency 当成 project，这时 common-dependency 应该改为对应的项目名\n\n\n2. 项目内划分模块2.1 分模块业务模块划分没有一个严格的业界标准，也没有说一定要按照怎么设计，这里根据个人使用总结为以下几个模块，具体使用可根据情况自己进行调整：\n\n\n\nMaven 模块\n模块描述\n特殊说明\n\n\n\napi\n将 rpc 相关的接口、所必须的交互实体、枚举等定义在此处，提供给内部其他系统进行服务调用\n单体服务可去除此模块\n\n\nbase&#x2F;comm\n与业务无关的通用配置定义在此处，如统一结果返回类、统一工具类等。具有业务无关性，与业务相关的工具类、枚举等可定义在具体的业务模块内\n\n\n\nrpc\napi 包的 rpc 接口定义实现，一般来说是调用模块内的具体业务接口进行相关的处理\n单体服务可去除此模块\n\n\nservice\n具体的服务模块，进行业务处理，不特指某一个模块名\n\n\n\nweb\n在此处定义启动类，配置文件（resources 目录），配置类（RedisConfig&#x2F;MyBatisConfig）等项目配置\n\n\n\n依赖结构如下，在之前的基础上添加项目内部划分的模块间的依赖关系\n\n此处同样可以将上述划分好模块的 project 抽离出来成一个 common-project 用于多项目的统一的通用配置\n2.2 common-project1、同样的新建一个项目\n\n2、删除其他多余文件，并按照前面的模块划分创建好对应的模块\n\n3、顶层 POM 如下，父依赖为 common-dependency，并把各个模块依赖进去\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;common-dependency&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;common-api&lt;&#x2F;module&gt;\n        &lt;module&gt;common-base&lt;&#x2F;module&gt;\n        &lt;module&gt;common-rpc&lt;&#x2F;module&gt;\n        &lt;module&gt;common-service&lt;&#x2F;module&gt;\n        &lt;module&gt;common-web&lt;&#x2F;module&gt;\n    &lt;&#x2F;modules&gt;\n\n    &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;common-project&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;\n    &lt;name&gt;common-project&lt;&#x2F;name&gt;\n    &lt;description&gt;common-project&lt;&#x2F;description&gt;\n\n    &lt;!-- 统一通用的依赖 --&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n\n    &lt;!-- 将各模块依赖进来 --&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;common-api&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;common-base&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;common-rpc&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;common-service&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;common-web&lt;&#x2F;artifactId&gt;\n                &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n            &lt;&#x2F;dependency&gt;\n        &lt;&#x2F;dependencies&gt;\n    &lt;&#x2F;dependencyManagement&gt;\n&lt;&#x2F;project&gt;\n\n\n4、同时根据依赖关系依赖对应的模块\n如 common-api 依赖 common-base\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;common-project&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n  \n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;common-api&lt;&#x2F;artifactId&gt;\n    &lt;name&gt;common-api&lt;&#x2F;name&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;common-base&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\ncommon-rpc 又依赖 common-api。由于 common-api 已经依赖了 common-base，所以不需要重复引入 common-base\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;common-project&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;common-rpc&lt;&#x2F;artifactId&gt;\n    &lt;name&gt;common-rpc&lt;&#x2F;name&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;common-api&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\ncommon-service 依赖 common-base\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;common-project&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;common-service&lt;&#x2F;artifactId&gt;\n    &lt;name&gt;common-service&lt;&#x2F;name&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;common-base&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\n同样推送到中央仓库，本地的话 maven install 到本地仓库\n3. 业务模块内分层3.1 分层目前很多业务系统都是基于 MVC 三层架构来开发的，MVC 三层架构中的 M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整\n很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，一般就将后端项目分为 Repository 层、Service 层、Controller 层。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。这里的 Service 层假如业务复杂，可再细分为如下三层：\n\nManager 层： 负责将 Dao 层中的数据库操作组合复用，主要是一些缓存方案，中间件的处理，以及对第三方平台的封装\nService 层： 更加关注业务逻辑，是业务处理层，将 Manager 组合过的操作和业务逻辑组合在一起，再封装成业务操作\nBiz 层： 包含 Service 层，Service 层注重基础业务的处理，Biz 层是复杂应用层的业务层\n\n当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的 Web 项目，基本的分层思路都大差不差\n3.2 数据载体划分3.2.1 PO（Persistant Object）&#x2F;Entity持久化对象，通过 DAO 层向上传输的数据源对象，实体属性与表字段一一对应。简单来说 PO 就是数据库中的记录，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象，通常 PO 里面除了 getter，setter 之外没有别的方法。概念与 Entity 一致\n3.2.2 BO（Business Object）业务对象，由 Service 层输出的封装业务逻辑的对象。BO 即 PO 的组合，如 PO1 是交易记录，PO2 是商品浏览记录，PO3 是添加购物车记录，等等组合起来形成 BO ，就是个人网站行为对象\n一类业务就会对应一个 BO，数量上没有限制，而且 BO 会有很多业务操作，也就是说除了 getter，setter 方法以外，BO 会有很多针对自身数据进行计算的方法\n现在很多持久层框架自身就提供了数据组合的功能，因此 BO 有可能是在业务层由业务来拼装 PO 而成，也有可能是在数据库访问层由框架直接生成\n3.2.3 DODO 主要有两种定义\n\n一种在阿里巴巴开发手册中的定义，DO（ Data Object），等同于上面的 PO\n一种是在 DDD（Domain-Driven Design）领域驱动设计中，DO（Domain Object），等同于上面的 BO\n\n3.2.4 DTO（Data Transfer Object）数据传输对象，这个传输通常指的前后端之间的传输，Service 或 Manager 向外传输的对象\nBO 和 DTO 的区别\n这两个的区别主要是就是字段的删减。BO 对内，为了进行业务计算需要辅助数据，或者是一个业务有多个对外的接口，BO 可能会含有很多接口对外所不需要的数据，而 DTO 在 BO 的基础上，只要自己需要的数据，然后对外提供。在这个关系上，通常不会有数据内容的变化\n现在微服务盛行，服务和服务之间调用的传输对象能叫 DTO 吗？\nDTO 本身的一个隐含的意义是要能够完整的表达一个业务模块的输出，如果服务和服务之间相对独立，那就可以叫 DTO；如果服务和服务之间不独立，每个都不是一个完整的业务模块，拆开可能仅仅是因为计算复杂度或者性能的问题，那这就不能够叫做 DTO，只能是 BO\n3.2.5 VO（Value Object）数据展示对象，通常是 Web 向模板渲染引擎层传输的对象，字段值与前端要求的字段名称保持一致。即 JSON 里的数据对象\nVO 和 DTO 的区别\n对于绝大部分的应用场景来说，DTO 和 VO 的属性值基本是一致的，而且它们通常都是 POJO，因此没必要多此一举，但这是实现层面的思维，对于设计层面来说，概念上还是应该存在 VO 和 DTO，因为两者有着本质的区别，DTO 代表服务层需要接收的数据和返回的数据，而 VO 代表展示层需要显示的数据\n通常可能的区别如下：\n\n字段不一样，假如这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，VO 可能会根据需要删减一些字段\n值不一样，VO 会根据需要对 DTO 中的值进行展示业务的解释\n\n比如服务层有一个 getUser() 的方法返回一个系统用户，其中有一个属性是 gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定\n\nDTO 可能是这样的：&#123;&quot;gender&quot;: &quot;男&quot;, &quot;age&quot;: 35&#125;\n经过业务解释的 VO 是这样的：&#123;&quot;gender&quot;:&quot;帅哥&quot;, &quot;age&quot;: &quot;30~39&quot;&#125;\n\n这时可能说，在服务层直接就返回“帅哥美女”不就行了吗？\n对于大部分应用来说，这不是问题，但如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从单一职责原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的 DTO，不应该出现与表现形式的耦合\n3.2.6 Query数据查询对象，各层接收上层的查询请求，超过 2 个参数的查询封装，禁止使用 Map 类来传输\n3.3 结构图示例结构图如下，个人理解可能不一样，可根据具体情况进行调整\n\n4. 项目实践4.1 结构图这里由于是单体服务，去掉了 api 和 rpc 模块，假如有多个服务需要互相调用的话，加上 api 和 rpc 模块同样依赖对应的 common-api 和 common-rpc 模块即可，同时服务模块都依赖 common-service\n\n4.2 实践1、按照上面的模块划分，创建好项目\n\n2、依赖 common-project 对应的模块\n如 resource_nav_comm 依赖 common-base\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n\txsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;ResourceNavigation&lt;&#x2F;artifactId&gt;\n\t\t&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n\t&lt;&#x2F;parent&gt;\n\n\t&lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;resource_nav_comm&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n\n\t&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\t&lt;name&gt;resource_nav_comm&lt;&#x2F;name&gt;\n\t&lt;description&gt;resource_nav_comm&lt;&#x2F;description&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;common-base&lt;&#x2F;artifactId&gt;\n\t\t&lt;&#x2F;dependency&gt;\n\t&lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nresource_nav_web 依赖 common-web\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;ResourceNavigation&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;artifactId&gt;resource_nav_web&lt;&#x2F;artifactId&gt;\n    &lt;name&gt;resource_nav_web&lt;&#x2F;name&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;common-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\nresource_nav_system 模块依赖 common-service\n3、然后再根据上面的模块内分层，在对应层进行相应的开发\n","slug":"BlogRepository/开发实践/基础微服务项目架构构建总结","date":"2022-11-16T06:08:04.000Z","categories_index":"开发实践","tags_index":"IDEA,微服务","author_index":"凡"},{"id":"253be1f39f8482a0ee0e446a428827b1","title":"Vue3 总结","content":"Vue2 基础见：Vue2 总结（Basic）_凡 223 的博客\nVue2 开发见：Vue2 总结（开发）_凡 223 的博客\n1. 简介\n性能的提升\n\n打包大小减少41%\n初次渲染快55%，更新渲染快133%\n内存减少54%……\n\n\n源码的升级\n\n使用Proxy代替defineProperty实现响应式\n重写虚拟DOM的实现和Tree-Shaking……\n\n\n拥抱 TypeScriptVue3 可以更好的支持 TypeScript\n\n新的特性\n\nComposition API（组合API）\nsetup配置\nref与reactive\nwatch与watchEffect\nprovide与inject……\n\n\n新的内置组件\nFragment\nTeleport\nSuspense\n\n\n其他改变\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除 keyCode 支持作为 v-on 的修饰符……\n\n\n\n\n\n2. 创建使用2.1 使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\n## 查看@vue&#x2F;cli版本，确保@vue&#x2F;cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue&#x2F;cli\nnpm install -g @vue&#x2F;cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve\n\n2.2 使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vitevite官网：https://vitejs.cn\n什么是 vite？—— 新一代前端构建工具。\n\n开发环境中，无需打包操作，可快速的冷启动\n轻量快速的热重载（HMR）\n真正的按需编译，不再等待整个应用编译完成。\n\n传统构建 与 vite 构建对比图\n## 创建工程\nnpm init vite-app &lt;project-name&gt;\n## 进入工程目录\ncd &lt;project-name&gt;\n## 安装依赖\nnpm install\n## 运行\nnpm run dev\n\n2.3 main.js 改动&#x2F;&#x2F; 引入的不再是Vue构造函数，引入的是一个名为 createApp 的工厂函数（不需要 new）\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\n&#x2F;&#x2F; createApp(App).mount(&#39;#app&#39;)\n\n&#x2F;&#x2F; 创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)\nconst app &#x3D; createApp(App)\n&#x2F;&#x2F;挂载\napp.mount(&#39;#app&#39;)\n\n2.4 App.vue 改动Vue3 组件中的模板结构可以没有根标签\n&lt;template&gt;\n\t&lt;!-- Vue3组件中的模板结构可以没有根标签 --&gt;\n\t&lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;\n\t&lt;HelloWorld msg&#x3D;&quot;Welcome to Your Vue.js App&quot;&#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n2.5 Vue3 开发者工具\n3. 常用 Composition API3.1 setup 函数\nVue3.0 中一个新的配置项，值为一个函数\nsetup 是所有 Composition API（组合API）“ 表演的舞台 ”\n组件中所用到的：数据、方法等等，均要配置在 setup 中\nsetup 函数的两种返回值：\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用\n若返回一个渲染函数：则可以自定义渲染内容\n\n\n\n&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;info&quot;&gt;个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; import &#123;h&#125; from &#39;vue&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; &quot;张三&quot;\n    let age &#x3D; 18\n\n    &#x2F;&#x2F; 方法\n    function info() &#123;\n      alert(&#96;我叫$&#123;name&#125;, 年龄$&#123;age&#125;岁&#96;)\n    &#125;\n\n    &#x2F;&#x2F; 返回一个对象（常用）\n    return &#123;\n      name,\n      age,\n      info\n    &#125;\n    &#x2F;&#x2F;返回一个函数（渲染函数），需要导入 h\n    &#x2F;&#x2F; return ()&#x3D;&gt; h(&#39;h1&#39;,&#39;渲染&#39;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n1、尽量不要与 Vue2.x 配置混用\n\nVue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法\n但在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）\n如果有重名，setup 优先\n\n2、setup 不能是一个 async 函数，因为 async 的返回值不再是 return 的对象，而是被 promise 包起来的，模板看不到 return 对象中的属性（也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\n3.2 ref 函数如下，通过函数修改个人信息\n&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; &quot;李四&quot;\n    let age &#x3D; 18\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      name &#x3D; &quot;张三&quot;\n      age &#x3D; 20\n      console.log(name + age);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n发现实际值已经修改了，但页面并没有响应改变\n此时需要使用 ref 函数来定义响应的数据\n\n作用：定义一个响应式的数据\n语法：const xxx = ref(initValue) \n创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）\nJS 中操作数据： xxx.value\n模板中读取数据: 不需要 .value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;，vue3 自动解析了\n\n\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; ref(&#39;李四&#39;)\n    let age &#x3D; ref(18)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      name.value &#x3D; &quot;张三&quot;\n      age.value &#x3D; 20\n      console.log(name, age);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n使用了 ref 函数的对象已经是一个 RefImpl 对象（Reference Implement）假如是对象类型的数据，此时 RefImpl 对象的 value 是一个 Proxy 对象\n&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; ref(&#39;李四&#39;)\n    let age &#x3D; ref(18)\n    let job &#x3D; ref(&#123;\n      type: &#39;开发&#39;,\n      salary: &#39;20k&#39;\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      job.value.type &#x3D; &#39;设计&#39;\n      job.value.salary &#x3D; &#39;25k&#39;\n      console.log(job);\n      console.log(job.value);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      job,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n注意：\n\n接收的数据可以是：基本类型、也可以是对象类型\n基本类型的数据：响应式依然是靠 Object.defineProperty() 的 get 与 set 完成的\n对象类型的数据：内部 “ 求助 ” 了 Vue3.0 中的一个新函数—— reactive 函数\n\n3.3 reactive 函数\n作用：定义一个对象类型的响应式数据（基本类型不要用它，要用 ref 函数）\n语法：const 代理对象 = reactive(源对象)，接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 Proxy 对象）\nreactive 定义的响应式数据是“深层次的”\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作\n\n将 3.2 的对象类型示例修改一下，使用 reactive 来定义对象类型数据，如下：\n&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;姓名：&#123;&#123;age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let name &#x3D; ref(&#39;李四&#39;)\n    let age &#x3D; ref(18)\n    &#x2F;&#x2F; let job &#x3D; ref(&#123;\n    &#x2F;&#x2F;   type: &#39;开发&#39;,\n    &#x2F;&#x2F;   salary: &#39;20k&#39;\n    &#x2F;&#x2F; &#125;)\n    let job &#x3D; reactive(&#123;\n      type: &#39;开发&#39;,\n      salary: &#39;20k&#39;\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      &#x2F;&#x2F; job.value.type &#x3D; &#39;设计&#39;\n      &#x2F;&#x2F; job.value.salary &#x3D; &#39;25k&#39;\n      job.type &#x3D; &#39;设计&#39;\n      job.salary &#x3D; &#39;25k&#39;\n      console.log(job);\n    &#125;\n\n    return &#123;\n      name,\n      age,\n      job,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n同时还可以响应数组类型以及进行深层次的响应\n&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;person.job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;person.job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h1&gt;爱好：&#123;&#123;person.hobby&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;李四&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;20k&#39;\n      &#125;,\n      hobby: [&#39;看剧&#39;, &#39;听歌&#39;]\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      person.name &#x3D; &#39;张三&#39;\n      person.age &#x3D; 20\n      person.job.type &#x3D; &#39;设计&#39;\n      person.job.salary &#x3D; &#39;25k&#39;\n      person.hobby[0] &#x3D; &#39;学习&#39;\n    &#125;\n\n    return &#123;\n      person,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n3.4 Vue3.0 中的响应式原理3.4.1 Vue2.x 的响应式实现原理：\n\n对象类型：通过 Object.defineProperty() 对属性的读取、修改进行拦截（数据劫持），但对新增和删除无法响应式的改变Object.defineProperty(data, &#39;count&#39;, &#123;\n\tconfigurable: true, &#x2F;&#x2F; 可配置，即可删除属性\n    get () &#123; return ... &#125;, \n    set () &#123; 响应... &#125;\n&#125;)\n数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹）\n\n存在问题：\n\n直接新增属性、删除属性，界面不会更新，需要调用对应的函数（set、delete）methods: &#123;\n  addSex()&#123;\n    this.person.sex &#x3D; &#39;女&#39;; &#x2F;&#x2F; 不生效\n    this.$set(this.person, &#39;sex&#39;, &#39;女&#39;)\n    Vue.set(this.person, &#39;sex&#39;, &#39;女&#39;)\n  &#125;,\n  deleteName()&#123;\n    this.$delete(this.person, &#39;name&#39;, &#39;张三&#39;)\n    Vue.delete(this.person, &#39;name&#39;, &#39;张三&#39;)\n  &#125;\n&#125;,\n直接通过下标修改数组，界面不会自动更新，同样可通过上面的方式修改，还可直接变更数组来修改methods: &#123;\n\tupdateHobby()&#123;\n\t\tthis.person.hobby[0] &#x3D; &#39;学习&#39;; &#x2F;&#x2F; 不生效\n\t\tthis.$set(this.person.hobby, 0, &#39;学习&#39;)\n\t\tVue.delete(this.person.hobby, 0, &#39;学习&#39;)\n\t\tthis.person.hobby.splice(0, 1, &#39;学习&#39;)\n\t&#125;\n&#125;,\n\n3.4.2 Vue3.0 的响应式实现原理:\n\n通过Proxy（代理）：拦截对象中任意属性的变化，包括属性值的读写、属性的添加、属性的删除等\n\n通过Reflect（反射）：对源对象的属性进行操作\n&lt;body&gt;\n   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let person &#x3D; &#123;\n      name: &#39;张三&#39;,\n      age: 18\n    &#125;\n\n    &#x2F;&#x2F; 模拟 Vue3中实现响应式\n    const p &#x3D; new Proxy(person, &#123;\n      &#x2F;&#x2F; 读取时调用\n      get(target, prop) &#123;\n        console.log(target, prop);\n        return target[prop]\n      &#125;,\n      &#x2F;&#x2F; 修改或新增时调用\n      set(target, prop, value) &#123;\n        console.log(target, prop, value);\n        target[prop] &#x3D; value;\n      &#125;,\n      &#x2F;&#x2F; 删除时调用\n      deleteProperty(target, prop) &#123;\n        console.log(target, prop);\n        return delete target[prop];\n      &#125;\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n对原对象的代理对象进行操作，而代理对象操作原对象可以把上述操作交给 Reflect 去执行\nnew Proxy(data, &#123;\n\t&#x2F;&#x2F; 拦截读取属性值\n    get (target, prop) &#123;\n    \treturn Reflect.get(target, prop)\n    &#125;,\n    &#x2F;&#x2F; 拦截设置属性值或添加新属性\n    set (target, prop, value) &#123;\n    \treturn Reflect.set(target, prop, value)\n    &#125;,\n    &#x2F;&#x2F; 拦截删除属性\n    deleteProperty (target, prop) &#123;\n    \treturn Reflect.deleteProperty(target, prop)\n    &#125;\n&#125;)\n\nproxy.name &#x3D; &#39;tom&#39;  \nMDN 文档中描述的 Proxy 与 Reflect：\n\nProxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Proxy\nReflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Reflect\n\n\n\n&lt;template&gt;\n  &lt;h1&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h1 v-show&#x3D;&quot;person.sex&quot;&gt;性别：&#123;&#123;person.sex&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;h2&gt;职业：&#123;&#123;person.job.type&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪水：&#123;&#123;person.job.salary&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;changeInfo&quot;&gt;改变个人信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;李四&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;20k&#39;\n      &#125;,\n      hobby: [&#39;看剧&#39;, &#39;听歌&#39;]\n    &#125;)\n\n    &#x2F;&#x2F; 方法\n    function changeInfo() &#123;\n      person.sex &#x3D; &#39;男&#39;\n      delete person.name\n      person.hobby[0] &#x3D; &#39;学习&#39;\n    &#125;\n\n    return &#123;\n      person,\n      changeInfo\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n3.5 reactive 对比 ref1、 从定义数据角度对比\n\nref 用来定义：基本类型数据\nreactive 用来定义：对象（或数组）类型数据\n备注：ref 也可以用来定义对象（或数组）类型数据，它内部会自动通过 reactive 转为代理对象\n\n2、从原理角度对比\n\nref 通过 Object.defineProperty() 的 get 与 set 来实现响应式（数据劫持）\nreactive 通过使用 Proxy 来实现响应式（数据劫持），并通过 Reflect 操作源对象内部的数据\n\n3、从使用角度对比\n\nref 定义的数据：操作数据需要 .value，读取数据时模板中直接读取不需要 .value\nreactive 定义的数据：操作数据与读取数据：均不需要 .value\n\n3.6 setup 的两个注意点3.6.1 setup 执行的时机在 beforeCreate 之前执行一次，this 是 undefined\n3.6.2 setup 的参数\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性App.vue 组件，传值进 Demo.vue\n&lt;template&gt;\n  &lt;Demo\n    msg&#x3D;&quot;你好&quot;\n    school&#x3D;&quot;无&quot;\n  &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Demo from &#39;.&#x2F;components&#x2F;Demo.vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Demo\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\nDemo.vue 组件，接收 App.vue 传进来的值\n&lt;template&gt;\n  &lt;h1&gt;个人信息&lt;&#x2F;h1&gt;\n  &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h2&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  props: [&#39;msg&#39;, &#39;school&#39;],\n  setup(props) &#123;\n    console.log(props);\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18\n    &#125;)\n\n    return &#123;\n      person\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n\ncontext：上下文对象\n\nattrs：值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs\nslots：收到的插槽内容, 相当于 this.$slots\nemit：分发自定义事件的函数, 相当于 this.$emit\n\n\n\nApp.vue，传值进 Demo.vue，同时传入自定义事件以及插槽\n&lt;template&gt;\n  &lt;Demo\n    msg&#x3D;&quot;你好&quot;\n    school&#x3D;&quot;无&quot;\n    @hello&#x3D;&quot;showMsg&quot;\n  &gt;\n    &lt;template v-slot:te&gt;\n      &lt;span&gt;测试&lt;&#x2F;span&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;Demo&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Demo from &#39;.&#x2F;components&#x2F;Demo.vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    function showMsg(value) &#123;\n      alert(&#96;触发，参数是$&#123;value&#125;&#96;)\n    &#125;\n\n    return &#123;\n      showMsg\n    &#125;\n  &#125;,\n  components: &#123;\n    Demo\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\nDemo.vue 组件，props 接收 App.vue 传进来的值，未接收的值在 attrs 里，emits 接收自定义事件，假如未写接收会报警告，但不影响使用，emit 触发 App.vue 里的自定义事件。插槽直接使用\n&lt;template&gt;\n  &lt;h1&gt;个人信息&lt;&#x2F;h1&gt;\n  &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;hello&quot;&gt;测试触发事件&lt;&#x2F;button&gt;\n  &lt;slot name&#x3D;&quot;te&quot;&gt;&lt;&#x2F;slot&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  props: [&#39;msg&#39;],\n  emits: [&#39;hello&#39;],\n  setup(props, context) &#123;\n    console.log(props);\n    console.log(context.attrs);\n    console.log(context.emit);\n    console.log(context.slots);\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18\n    &#125;)\n    &#x2F;&#x2F; 方法\n    function hello() &#123;\n      context.emit(&#39;hello&#39;, 666);\n    &#125;\n\n    return &#123;\n      person,\n      hello\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n3.7 计算属性与监视3.7.1 computed 函数（计算属性）第一种写法：与 Vue2.x 中 computed 配置功能一致\n&lt;script&gt;\nimport &#123; reactive, computed &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  computed: &#123;\n    fullName() &#123;\n      return this.person.firstName + &#39;-&#39; + this.person.lastName;\n    &#125;\n  &#125;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      firstName: &#39;张&#39;,\n      lastName: &#39;三&#39;,\n    &#125;)\n\n    return &#123;\n      person,\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n第二种写法，如下：\n&lt;template&gt;\n  &lt;h1&gt;个人信息&lt;&#x2F;h1&gt;\n  姓：&lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;person.firstName&quot;\n  &#x2F;&gt; &lt;br&gt;\n  名：&lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;person.lastName&quot;\n  &#x2F;&gt; &lt;br&gt;\n  &lt;span&gt;全名： &#123;&#123;person.fullName&#125;&#125; &lt;&#x2F;span&gt; &lt;br&gt;\n  全名：&lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;person.fullName&quot;\n  &gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, computed &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      firstName: &#39;张&#39;,\n      lastName: &#39;三&#39;,\n    &#125;)\n    &#x2F;&#x2F; 计算属性-简写（只读，不考虑计算属性被修改的情况）\n    person.fullName &#x3D; computed(() &#x3D;&gt; &#123;\n      return person.firstName + &#39;-&#39; + person.lastName;\n    &#125;)\n\n    &#x2F;&#x2F; 计算属性-完整写法（考虑读和写）\n    person.fullName &#x3D; computed(&#123;\n      get() &#123;\n        return person.firstName + &#39;-&#39; + person.lastName;\n      &#125;,\n      set(value) &#123;\n        let nameArr &#x3D; value.split(&#39;-&#39;);\n        person.firstName &#x3D; nameArr[0]\n        person.lastName &#x3D; nameArr[1]\n      &#125;\n    &#125;)\n\n    return &#123;\n      person,\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n3.7.2 watch 函数（监视）第一种写法：与 Vue2.x 中 computed 配置功能一致\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  watch: &#123;\n    sum(newValue, oldValue) &#123;\n      console.log(&#39;sum 的值变化了&#39;, newValue, oldValue);\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; watch: &#123;\n  &#x2F;&#x2F;   sum: &#123;\n  &#x2F;&#x2F;     immediate: true, &#x2F;&#x2F; 立即监视，一进来就会监视一下\n  &#x2F;&#x2F;     deep: true,\n  &#x2F;&#x2F;     handler(newValue, oldValue) &#123;\n  &#x2F;&#x2F;       console.log(&#39;sum 的值变化了&#39;, newValue, oldValue);\n  &#x2F;&#x2F;     &#125;\n  &#x2F;&#x2F;   &#125;\n  &#x2F;&#x2F; &#125;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let sum &#x3D; ref(0)\n\n    return &#123;\n      sum,\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n第二种写法，如下：\n1、监视 ref 定义的数据\n&lt;template&gt;\n  &lt;h1&gt;当前求和为：&#123;&#123;sum&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;sum++&quot;&gt;点击 + 1&lt;&#x2F;button&gt;\n  &lt;hr&gt;\n  &lt;h1&gt;当前信息为：&#123;&#123;msg&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;msg +&#x3D; &#39;!&#39;&quot;&gt;修改信息&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref, watch &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let sum &#x3D; ref(0)\n    let msg &#x3D; ref(&#39;你好&#39;)\n\n    &#x2F;&#x2F; 情况一，监视 ref 所定义的一个响应式数据\n    &#x2F;&#x2F; watch(sum, (newValue, oldValue) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(&#39;sum 变了&#39;, newValue, oldValue);\n    &#x2F;&#x2F; &#125;, &#123;immediate: true, deep: true&#125;)\n\n    &#x2F;&#x2F; 情况二，监视 ref 所定义的多个响应式数据\n    watch([sum, msg], (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(newValue, oldValue);\n    &#125;, &#123; immediate: true, deep: true &#125;)\n\n    return &#123;\n      sum,\n      msg\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n2、监视 reactive 定义的数据\n&lt;template&gt;\n  &lt;h1&gt;当前姓名为：&#123;&#123;person.name&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;person.name +&#x3D; &#39;~&#39;&quot;&gt;修改姓名&lt;&#x2F;button&gt;\n  &lt;hr&gt;\n  &lt;h1&gt;当前年龄为：&#123;&#123;person.age&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;button @click&#x3D;&quot;person.age ++&quot;&gt;修改年龄&lt;&#x2F;button&gt;\n  &lt;hr&gt;\n  &lt;h2&gt;职业：&#123;&#123;person.job.type&#125;&#125; &lt;&#x2F;h2&gt;\n  &lt;h2&gt;薪酬：&#123;&#123;person.job.salary&#125;&#125; &lt;&#x2F;h2&gt;\n  &lt;button @click&#x3D;&quot;person.job.type +&#x3D; &#39;!&#39;&quot;&gt;修改职业&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, watch &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;25k&#39;\n      &#125;\n    &#125;)\n\n    &#x2F;&#x2F; 情况一，监视 reactive 所定义的一个响应式数据的全部属性\n    &#x2F;&#x2F;      watch 监视的是 reactive 定义的响应式数据，则无法正确获得 oldValue！！\n    &#x2F;&#x2F;      若watch 监视的是 reactive 定义的响应式数据，则强制开启了深度监视（deep 配置无效）\n    &#x2F;&#x2F; watch(person, (newValue, oldValue) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(&#39;person变化&#39;, newValue, oldValue);\n    &#x2F;&#x2F; &#125;, &#123; deep: false &#125;)\n\n    &#x2F;&#x2F; 情况二：监视 reactive 所定义的一个响应式数据的某个属性\n    &#x2F;&#x2F; watch(() &#x3D;&gt; person.age, (newValue, oldValue) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(&#39;person 的age 变化了&#39;, newValue, oldValue);\n    &#x2F;&#x2F; &#125;)\n\n    &#x2F;&#x2F; 情况三：监视 reactive 所定义的一个响应式数据的某些属性\n    watch([() &#x3D;&gt; person.age, () &#x3D;&gt; person.name], (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(&#39;person 的age 变化了&#39;, newValue, oldValue);\n    &#125;)\n\n    &#x2F;&#x2F; 特殊情况：监视的是 reactive 定义的属性中的某个对象属性，所以 deep 配置有效\n    watch(() &#x3D;&gt; person.job, (newValue, oldValue) &#x3D;&gt; &#123;\n      console.log(&#39;person 的age 变化了&#39;, newValue, oldValue);\n    &#125;, &#123; deep: true &#125;)\n\n\n    return &#123;\n      person\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n&lt;&#x2F;style&gt;\n\n\n3.7.2 watchEffect 函数\nwatch 的套路是：既要指明监视的属性，也要指明监视的回调\nwatchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性\nwatchEffect 有点像 computed：\n但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值\n而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值\n\n\n\n&lt;script&gt;\nimport &#123; reactive, watchEffect &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 数据\n    let sum &#x3D; ref(0)\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18,\n      job: &#123;\n        type: &#39;开发&#39;,\n        salary: &#39;25k&#39;\n      &#125;\n    &#125;)\n\n    &#x2F;&#x2F; watchEffect 所指定的回调中用到的数据只要发生变化，则直接重新执行回调\n    watchEffect(() &#x3D;&gt; &#123;\n      const x1 &#x3D; person.name\n      const x2 &#x3D; person.job.type\n      console.log(&#39;watchEffect 配置的回调执行了&#39;);\n    &#125;)\n\n    return &#123;\n      person\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n3.8 生命周期Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有两个被更名：\n\nbeforeDestroy 改名为 beforeUnmount\ndestroyed 改名为 unmounted\n\nApp.vue\n&lt;template&gt;\n  &lt;button @click&#x3D;&quot;isShowDemo &#x3D; !isShowDemo&quot;&gt;显示&#x2F;隐藏Demo&lt;&#x2F;button&gt;\n  &lt;Demo v-if&#x3D;&quot;isShowDemo&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Demo from &#39;.&#x2F;components&#x2F;Demo.vue&#39;;\nimport &#123; ref &#125; from &#39;vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    let isShowDemo &#x3D; ref(true)\n\n    return &#123;\n      isShowDemo\n    &#125;\n  &#125;,\n  components: &#123;\n    Demo\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\nDemo.vue\n&lt;template&gt;\n  &lt;h1&gt;Demo&lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  beforeCreate() &#123;\n    console.log(&#39;---beforeCreate---&#39;);\n  &#125;,\n  created() &#123;\n    console.log(&#39;---created---&#39;);\n  &#125;,\n  beforeMount() &#123;\n    console.log(&#39;---beforeMount---&#39;);\n  &#125;,\n  mounted() &#123;\n    console.log(&#39;---mounted---&#39;);\n  &#125;,\n  beforeUnmount() &#123;\n    console.log(&#39;---beforeUnmount---&#39;);\n  &#125;,\n  unmounted() &#123;\n    console.log(&#39;---unmounted--&#39;);\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\nVue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：\n\nbeforeCreate &#x3D;&#x3D;&#x3D;&gt; setup()\ncreated &#x3D;&#x3D;&#x3D;&gt; setup()\nbeforeMount &#x3D;&#x3D;&#x3D;&gt; onBeforeMount\nmounted &#x3D;&#x3D;&#x3D;&gt; onMounted\nbeforeUpdate &#x3D;&#x3D;&#x3D;&gt; onBeforeUpdate\nupdated &#x3D;&#x3D;&#x3D;&gt; onUpdated\nbeforeUnmount &#x3D;&#x3D;&gt; onBeforeUnmount\nunmounted &#x3D;&#x3D;&#x3D;&gt; onUnmounted\n\n&lt;template&gt;\n  &lt;h1&gt;Demo&lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    console.log(&#39;---setup()---&#39;);\n\n    onBeforeMount(() &#x3D;&gt; &#123;\n      console.log(&#39;---onBeforeMount---&#39;)\n    &#125;)\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;---onMounted---&#39;);\n    &#125;)\n    onBeforeUpdate(() &#x3D;&gt; &#123;\n      console.log(&#39;---onBeforeUpdate---&#39;);\n    &#125;)\n    onUpdated(() &#x3D;&gt; &#123;\n      console.log(&#39;---onUpdated---&#39;);\n    &#125;)\n    onBeforeUnmount(() &#x3D;&gt; &#123;\n      console.log(&#39;---onBeforeUnmount---&#39;);\n    &#125;)\n    onUnmounted(() &#x3D;&gt; &#123;\n      console.log(&#39;---onUnmounted---&#39;);\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n3.9 自定义 hook 函数hook 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。类似于 Vue2.x中的 mixin。可以复用代码，让 setup 中的逻辑更清楚易懂\n如下，获取当前鼠标的位置\n&lt;template&gt;\n  &lt;h1&gt;当前点击时鼠标的坐标为：X：&#123;&#123;point.x&#125;&#125;，y：&#123;&#123;point.y&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, onMounted &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let point &#x3D; reactive(&#123;\n      x: 0,\n      y: 0\n    &#125;)\n\n    onMounted(() &#x3D;&gt; &#123;\n      window.addEventListener(&#39;click&#39;, (event) &#x3D;&gt; &#123;\n        point.x &#x3D; event.pageX\n        point.y &#x3D; event.pageY\n      &#125;)\n    &#125;)\n\n    return &#123;\n      point\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n此时给 window 加了一个点击事件，只要点击页面就会获取页面的鼠标位置给 point，假如该组件卸载了，也还是会触发可以在组件卸载后，移除该点击事件。移除事件时需要传入移除的是哪个事件，所以将该点击事件单独写成一个函数\n&lt;script&gt;\nimport &#123; reactive, onMounted, onBeforeUnmount &#125; from &#39;vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let point &#x3D; reactive(&#123;\n      x: 0,\n      y: 0\n    &#125;)\n\n    function savePoint(event) &#123;\n      point.x &#x3D; event.pageX\n      point.y &#x3D; event.pageY\n\n      console.log(point.x, point.y);\n    &#125;\n\n    onMounted(() &#x3D;&gt; &#123;\n      window.addEventListener(&#39;click&#39;, savePoint)\n    &#125;)\n    onBeforeUnmount(() &#x3D;&gt; &#123;\n      window.removeEventListener(&#39;click&#39;, savePoint)\n    &#125;)\n\n    return &#123;\n      point\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n假如有另一个组件也想用该功能，复用这块代码，就可以将该功能相关的数据和函数抽离出来，形成一个 hook 函数\nimport &#123; reactive, onMounted, onBeforeUnmount&#125; from &#39;vue&#39;;\n\nexport default function() &#123;\n  let point &#x3D; reactive(&#123;\n    x: 0,\n    y: 0\n  &#125;)\n\n  function savePoint(event) &#123;\n    point.x &#x3D; event.pageX\n    point.y &#x3D; event.pageY\n\n    console.log(point.x, point.y);\n  &#125;\n\n  onMounted(() &#x3D;&gt; &#123;\n    window.addEventListener(&#39;click&#39;, savePoint)\n  &#125;)\n  onBeforeUnmount(() &#x3D;&gt; &#123;\n    window.removeEventListener(&#39;click&#39;, savePoint)\n  &#125;)\n\n  return point\n&#125;\n\n使用时引入即可\n&lt;template&gt;\n  &lt;h1&gt;当前点击时鼠标的坐标为：X：&#123;&#123;point.x&#125;&#125;，y：&#123;&#123;point.y&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport usePoint from &#39;..&#x2F;hooks&#x2F;usePoint&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let point &#x3D; usePoint()\n\n    return &#123;\n      point\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n3.10 toRef创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。\n\n语法：const name = toRef(person, &#39;name&#39;)\n\n用于要将响应式对象中的某个属性单独提供给外部使用时，如下，将 person 对象里的name、age 等属性单独提供给外部使用\n&lt;template&gt;\n  &lt;h1&gt;姓名： &#123;&#123;name&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;h1&gt;年龄： &#123;&#123;age&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;h1&gt;薪资： &#123;&#123;salary&#125;&#125; &lt;&#x2F;h1&gt;\n\n  &lt;button @click&#x3D;&quot;name +&#x3D; &#39;~&#39;&quot;&gt;修改姓名&lt;&#x2F;button&gt;\n  &lt;button @click&#x3D;&quot;age ++&quot;&gt;修改年龄&lt;&#x2F;button&gt;\n  &lt;button @click&#x3D;&quot;salary ++&quot;&gt;修改薪资&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, toRef &#125; from &#39;@vue&#x2F;reactivity&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Demo&#39;,\n  setup() &#123;\n    let person &#x3D; reactive(&#123;\n      name: &#39;张三&#39;,\n      age: 18,\n      job: &#123;\n        j1: &#123;\n          salary: 20\n        &#125;\n      &#125;\n    &#125;)\n\n    return &#123;\n      &#x2F;&#x2F; name: ref(person, &#39;name&#39;)\n      name: toRef(person, &#39;name&#39;),\n      age: toRef(person, &#39;age&#39;),\n      salary: toRef(person.job.j1, &#39;salary&#39;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n具有响应式效果，且此时 toRef 这里操纵的数据，就是原先的 person对象里的数据，修改即同步修改 person 对象里的对应的值假如直接使用 ref 来转换，如：ref(person.name)，操纵的是这个用 person 对象的 name 属性值新建的 ref 对象，而不再与原本的 person 对象的 name 有联系toRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，即把整个对象都抛出去，语法：toRefs(person)，但只能定位到第外层的属性\n&lt;h1&gt;姓名： &#123;&#123;name&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;h1&gt;年龄： &#123;&#123;age&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;h1&gt;薪资： &#123;&#123;job.j1.salary&#125;&#125; &lt;&#x2F;h1&gt;\n  \n...toRefs(person)\n&#x2F;&#x2F; name: toRef(person, &#39;name&#39;),\n&#x2F;&#x2F; age: toRef(person, &#39;age&#39;),\n&#x2F;&#x2F; salary: toRef(person.job.j1, &#39;salary&#39;)\n\n4. 其它 Composition API4.1 shallowReactive 与 shallowRef\nshallowReactive：只处理对象最外层属性的响应式（浅响应式）\nshallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理\n\nlet person &#x3D; shallowReactive (&#123;\n\tname: &#39;张三&#39;,\n\tage: 18,\n\tjob: &#123;\n\t\tj1: &#123;\n\t\t\tsalary: 20\n\t\t&#125;\n\t&#125;\n&#125;)\n\n什么时候使用?\n\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef\n\n4.2 readonly 与 shallowReadonly\nreadonly：让一个响应式数据变为只读的（深只读）\nshallowReadonly：让一个响应式数据变为只读的（浅只读）\n\nlet person &#x3D; reactive (&#123;\n\tname: &#39;张三&#39;,\n\tage: 18,\n\tjob: &#123;\n\t\tj1: &#123;\n\t\t\tsalary: 20\n\t\t&#125;\n\t&#125;\n&#125;)\n\nperson &#x3D; readonly(person)\n\n应用于不希望数据被修改时\n4.3 toRaw 与 markRawtoRaw\n\n作用：将一个由 reactive 生成的响应式对象转为普通对象\n\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新\nconst p &#x3D; toRaw(person)\n\nmarkRaw\n\n作用：标记一个对象，使其永远不会再成为响应式对象\n\n应用场景：\n\n有些值不应被设置为响应式的，例如复杂的第三方类库等\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能\n\nperson.car &#x3D; markRaw(person)\n\n4.4 customRef创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制如下例，实现防抖效果\n&lt;template&gt;\n  &lt;input\n    type&#x3D;&quot;text&quot;\n    v-model&#x3D;&quot;keyWord&quot;\n  &#x2F;&gt;\n  &lt;h1&gt; &#123;&#123;keyWord&#125;&#125; &lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; customRef &#125; from &#39;vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    &#x2F;&#x2F; 自定义一个 ref\n    function myRef(value, delay) &#123;\n      let timer;\n\n      return customRef((track, trigger) &#x3D;&gt; &#123;\n        return &#123;\n          get() &#123;\n            &#x2F;&#x2F; 通知 Vue 追踪数据变化（提前约定）\n            track();\n            return value;\n          &#125;,\n          set(newValue) &#123;\n            value &#x3D; newValue;\n            clearTimeout(timer);\n\n            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n              &#x2F;&#x2F; 通知 Vue 去重新解析模板（调用一下 get() 方法）\n              trigger();\n            &#125;, delay);\n          &#125;\n        &#125;\n      &#125;)\n    &#125;\n\n    &#x2F;&#x2F; let keyWord &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F; 使用 Vue 提供的 ref\n    let keyWord &#x3D; myRef(&#39;hello&#39;, &#39;500&#39;) &#x2F;&#x2F; 使用自定义的 ref\n\n    return &#123;\n      keyWord,\n      myRef\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n4.5 provide 与 inject实现祖与后代组件间通信，父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据如下，祖组件 App.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖），&#123;&#123;name&#125;&#125;---&#123;&#123;price&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;Child &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; reactive, toRefs &#125; from &#39;@vue&#x2F;reactivity&#39;\nimport Child from &#39;.&#x2F;components&#x2F;Child.vue&#39;\nimport &#123; provide &#125; from &#39;@vue&#x2F;runtime-core&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  setup() &#123;\n    let car &#x3D; reactive(&#123;\n      name: &#39;奔驰&#39;,\n      price: &#39;40w&#39;\n    &#125;)\n\n    provide(&#39;car&#39;, car)\n\n    return &#123;\n      ...toRefs(car)\n    &#125;\n  &#125;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n子组件，Child.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;child&quot;&gt;\n    &lt;h1&gt; Child组件（子）&lt;&#x2F;h1&gt;\n    &lt;Son &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Son from &#39;.&#x2F;Son.vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Child&#39;,\n  components: &#123;\n    Son\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n孙组件，Son.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;son&quot;&gt;\n    &lt;h1&gt; Son组件（孙），&#123;&#123;car.name&#125;&#125;---&#123;&#123;car.price&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; inject &#125; from &#39;@vue&#x2F;runtime-core&#39;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Son&#39;,\n  setup() &#123;\n    let car &#x3D; inject(&#39;car&#39;)\n\n    return &#123;\n      car\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n4.6 响应式数据的判断\nisRef：检查一个值是否为一个 ref 对象\nisReactive：检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly：检查一个对象是否是由 readonly 创建的只读代理\nisProxy：检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\nlet car &#x3D; reactive(&#123;name: &#39;奔驰&#39;, price: &#39;40w&#39;&#125;)\nlet sum &#x3D; ref(0)\nlet car2 &#x3D; readonly(car)\n\nconsole.log(isReactive(car))\nconsole.log(isRef(sum))\nconsole.log(isReadonly(car2))\nconsole.log(isReadonly(isProxy))\n\n5. Composition API 的优势5.1 Options API 存在的问题Vue2 使用的传统 Options API 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改\n5.2 Composition API 的优势可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起\n6. 新的组件6.1 Fragment在 Vue2 中：组件必须有一个根标签。在 Vue3 中：组件可以没有根标签，内部会将多个标签包含在一个 Fragment 虚拟元素中，可以减少标签层级, 减小内存占用\n&lt;template&gt;\n  &lt;h1&gt;111&lt;&#x2F;h1&gt;\n  &lt;h1&gt;222&lt;&#x2F;h1&gt;\n&lt;&#x2F;template&gt;\n\n\n6.2 Teleport能够将组件 html 结构移动到指定位置如下，直接打开弹窗会撑开组件及其父组件的高度组件 Son.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;son&quot;&gt;\n    &lt;h1&gt; Son 组件（孙）&lt;&#x2F;h1&gt;\n    &lt;Dialog &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Dialog from &#39;.&#x2F;Dialog.vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Son&#39;,\n  components: &#123;\n    Dialog\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n组件 Dialog.vue\n&lt;template&gt;\n  &lt;button @click&#x3D;&quot;isShow &#x3D; true&quot;&gt; 点击弹窗 &lt;&#x2F;button&gt;\n  &lt;div\n    v-if&#x3D;&quot;isShow&quot;\n    class&#x3D;&quot;dialog&quot;\n  &gt;\n    &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n    &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n    &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n    &lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;@vue&#x2F;reactivity&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Dialog&#39;,\n  setup() &#123;\n    let isShow &#x3D; ref(false);\n\n    return &#123;\n      isShow\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n利用 Teleport 将弹窗移动到 body 上\n&lt;template&gt;\n  &lt;button @click&#x3D;&quot;isShow &#x3D; true&quot;&gt; 点击弹窗 &lt;&#x2F;button&gt;\n  &lt;teleport to&#x3D;&#39;body&#39;&gt;\n    &lt;div\n      v-if&#x3D;&quot;isShow&quot;\n      class&#x3D;&quot;mask&quot;\n    &gt;\n      &lt;div class&#x3D;&quot;dialog&quot;&gt;\n        &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n        &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n        &lt;h1&gt;弹窗内容&lt;&#x2F;h1&gt;\n        &lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;teleport&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;@vue&#x2F;reactivity&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Dialog&#39;,\n  setup() &#123;\n    let isShow &#x3D; ref(false);\n\n    return &#123;\n      isShow\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.mask &#123;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n&#125;\n.dialog &#123;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  text-align: center;\n  background-color: green;\n  width: 300px;\n  height: 300px;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n6.3 Suspense等待异步组件时渲染一些额外内容，让应用有更好的用户体验静态引入\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖）&lt;&#x2F;h1&gt;\n    &lt;Child &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Child from &#39;.&#x2F;components&#x2F;Child.vue&#39; &#x2F;&#x2F; 静态引入\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n将网速调慢，祖组件和后代组件是一起出来的异步引入\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖）&lt;&#x2F;h1&gt;\n    &lt;Child &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; import Child from &#39;.&#x2F;components&#x2F;Child.vue&#39; &#x2F;&#x2F;静态引入\nimport &#123; defineAsyncComponent &#125; from &#39;@vue&#x2F;runtime-core&#39; &#x2F;&#x2F; 静态引入\nconst Child &#x3D; defineAsyncComponent(() &#x3D;&gt; import(&#39;.&#x2F;components&#x2F;Child.vue&#39;)) &#x2F;&#x2F; 异步引入\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n网速慢的情况下，会先出现祖组件，再出现后代组件此时有个问题，假如 Child 组件没有加载出来，其所在的位置是空的，并不知道到底有没有内容。使用 Suspense 解决如下：\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h1&gt; App 组件（祖）&lt;&#x2F;h1&gt;\n    &lt;Suspense&gt;\n      &lt;template v-slot:default&gt;\n        &lt;Child &#x2F;&gt;\n      &lt;&#x2F;template&gt;\n      &lt;template v-slot:fallback&gt;\n        &lt;h3&gt;稍等，加载中...&lt;&#x2F;h3&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Suspense&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; import Child from &#39;.&#x2F;components&#x2F;Child.vue&#39; &#x2F;&#x2F;静态引入\nimport &#123; defineAsyncComponent &#125; from &#39;@vue&#x2F;runtime-core&#39; &#x2F;&#x2F; 静态引入\nconst Child &#x3D; defineAsyncComponent(() &#x3D;&gt; import(&#39;.&#x2F;components&#x2F;Child.vue&#39;)) &#x2F;&#x2F; 异步引入\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    Child\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n使用了异步引入后，该组件是一个异步组件，则 setup() 可以用 async 修一个异步函数\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Child&#39;,\n  async setup() &#123;\n    let sum &#x3D; ref(0)\n\n    let p &#x3D; new Promise((resove, reject) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        resove(sum)\n      &#125;, 3000);\n    &#125;)\n\n    return await p;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n之前是通过把网速调慢来实现等待 Child 组件出现的效果，使用异步函数之后，网速正常也能让 Child 组件等待后才出现\n7. 其他变化7.1 全局 API 的转移Vue 2.x 有许多全局 API 和配置，例如：注册全局组件、注册全局指令等\n&#x2F;&#x2F;注册全局组件\nVue.component(&#39;MyButton&#39;, &#123;\n  data: () &#x3D;&gt; (&#123;\n    count: 0\n  &#125;),\n  template: &#39;&lt;button @click&#x3D;&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;&#x2F;button&gt;&#39;\n&#125;)\n\n&#x2F;&#x2F;注册全局指令\nVue.directive(&#39;focus&#39;, &#123;\n  inserted: el &#x3D;&gt; el.focus()\n&#125;\n\nVue3.0 中对这些 API 做出了调整，将全局的 API，即：Vue.xxx 调整到应用实例（app）上\n\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\napp.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n7.2 其他改变\ndata 选项应始终被声明为一个函数&#x2F;&#x2F; data &#123; &#125; \ndata() &#123; &#125;\n过度类名的更改：\nVue2.x 写法.v-enter,\n.v-leave-to &#123;\n  opacity: 0;\n&#125;\n.v-leave,\n.v-enter-to &#123;\n  opacity: 1;\n&#125;\nVue3.x 写法.v-enter-from,\n.v-leave-to &#123;\n  opacity: 0;\n&#125;\n\n.v-leave-from,\n.v-enter-to &#123;\n  opacity: 1;\n&#125;\n\n\n移除 keyCode 作为 v-on 的修饰符，同时也不再支持 config.keyCodes&#x2F;&#x2F; @keyup.13\n&#x2F;&#x2F; Vue.config.keyCodes.enter &#x3D; 13\n移除 v-on.native 修饰符，给组件传递事件时，Vue2 会将 click 事件也认为是自定义事件，需要加 native 来表示是原生事件。Vue3 则用 emit 来指定自定义事件，没有指定的就是原生事件\n父组件中绑定事件&lt;my-component\n  v-on:close&#x3D;&quot;handleComponentEvent&quot;\n  v-on:click&#x3D;&quot;handleNativeClickEvent&quot;\n&#x2F;&gt;\n子组件中声明自定义事件&lt;script&gt;\n  export default &#123;\n    emits: [&#39;close&#39;]\n  &#125;\n&lt;&#x2F;script&gt;\n\n\n移除过滤器（filter）过滤器虽然看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器\n……\n\n","slug":"BlogRepository/Vue/Vue3 总结","date":"2022-11-06T15:57:57.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"凡"},{"id":"b576af472086ff634c008c948f90fb9b","title":"设计模式之美总结（创建型篇）","content":"前三篇见：\n\n设计模式之美总结（面向对象篇）_凡 223 的博客\n设计模式之美总结（设计原则篇）_凡 223 的博客\n设计模式之美总结（重构篇）_凡 223 的博客\n\n1. 单例模式（Singleton Design Pattern）1.1 为什么要使用单例？单例设计模式（Singleton Design Pattern） 理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式\n1.1.1 处理资源访问冲突如下例，自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：\npublic class Logger &#123;\n    private FileWriter writer;\n    public Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public void log(String message) &#123;\n        writer.write(mesasge);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Logger类的应用示例：\npublic class UserController &#123;\n    private Logger logger &#x3D; new Logger();\n    public void login(String username, String password) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        logger.log(username + &quot; logined!&quot;);\n    &#125;\n&#125;\npublic class OrderController &#123;\n    private Logger logger &#x3D; new Logger();\n    public void create(OrderVo order) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        logger.log(&quot;Created an order: &quot; + order.toString());\n    &#125;\n&#125;\n\n在上面的代码中，可以注意到，所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。在 UserController 和 OrderController 中，分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况\n为什么会出现互相覆盖呢？可以这么类比着理解。在多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了 2，而是只加了 1。同理，这里的 log.txt 文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况\n\n那如何来解决这个问题呢？最先想到的就是通过加锁的方式：给 log() 函数加互斥锁（Java 中可以通过 synchronized 的关键字），同一时刻只允许一个线程调用执行 log() 函数。具体的代码实现如下所示：\npublic class Logger &#123;\n    private FileWriter writer;\n    public Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public void log(String message) &#123;\n        synchronized(this) &#123;\n            writer.write(mesasge);\n        &#125;\n    &#125;\n&#125;\n\n不过，这真的能解决多线程写入日志时互相覆盖的问题吗？答案是否定的。这是因为，这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题\n\n还有，给 log() 函数加不加对象级别的锁，其实都没有关系。因为 FileWriter 本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用 write() 函数的时候，再加对象级别的锁实际上是多此一举。因为不同的 Logger 对象不共享 FileWriter 对象，所以，FileWriter 对象级别的锁也解决不了数据写入互相覆盖的问题\n那该怎么解决这个问题呢？实际上，要想解决这个问题也不难，只需要把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖问题。具体的代码实现如下所示：\npublic class Logger &#123;\n    private FileWriter writer;\n    public Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public void log(String message) &#123;\n        synchronized(Logger.class) &#123; &#x2F;&#x2F; 类级别的锁\n            writer.write(mesasge);\n        &#125;\n    &#125;\n&#125;\n\n除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂\n相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）\n将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题\n按照这个设计思路，实现了 Logger 单例类。具体代码如下所示：\npublic class Logger &#123;\n    private FileWriter writer;\n    private static final Logger instance &#x3D; new Logger();\n    private Logger() &#123;\n        File file &#x3D; new File(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;log.txt&quot;);\n        writer &#x3D; new FileWriter(file, true); &#x2F;&#x2F;true表示追加写入\n    &#125;\n    public static Logger getInstance() &#123;\n        return instance;\n    &#125;\n    public void log(String message) &#123;\n        writer.write(mesasge);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Logger类的应用示例：\npublic class UserController &#123;\n    public void login(String username, String password) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        Logger.getInstance().log(username + &quot; logined!&quot;);\n    &#125;\n&#125;\npublic class OrderController &#123;\n    private Logger logger &#x3D; new Logger();\n    public void create(OrderVo order) &#123;\n        &#x2F;&#x2F; ...省略业务逻辑代码...\n        Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());\n    &#125;\n&#125;\n\n1.1.2 表示全局唯一类从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类，比如，配置信息类。在系统中，只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份\n再比如，唯一递增 ID 号码生成器，如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，应该将 ID 生成器类设计为单例\nimport java.util.concurrent.atomic.AtomicLong;\npublic class IdGenerator &#123;\n    &#x2F;&#x2F; AtomicLong是一个Java并发库中提供的一个原子变量类型,\n    &#x2F;&#x2F; 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n    &#x2F;&#x2F; 比如下面会用到的incrementAndGet().\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; IdGenerator使用举例\nlong id &#x3D; IdGenerator.getInstance().getId();\n\n1.2 如何实现一个单例？要实现一个单例，需要关注的点无外乎下面几个：\n\n构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例\n考虑对象创建时的线程安全问题\n考虑是否支持延迟加载\n考虑 getInstance() 性能是否高（是否加锁）\n\n1.1.1 饿汉式饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例），从名字中也可以看出这一点。具体的代码实现如下所示：\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点\n如果初始化耗时长，那最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题\n如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java 中的 PermGen Space OOM），可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性\n1.1.2 懒汉式懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static synchronized IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new IdGenerator();\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n不过懒汉式的缺点也很明显，给 getInstance() 这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了\n1.1.3 双重检测饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式\n在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() &#123;&#125;\n    public static IdGenerator getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new IdGenerator();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了\n要解决这个问题，需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）\n1.1.4 静态内部类再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载，代码实现如下：\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private IdGenerator() &#123;&#125;\n    private static class SingletonHolder&#123;\n        private static final IdGenerator instance &#x3D; new IdGenerator();\n    &#125;\n    public static IdGenerator getInstance() &#123;\n        return SingletonHolder.instance;\n    &#125;\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\nSingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载\n1.1.5 枚举这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：\npublic enum IdGenerator &#123;\n    INSTANCE;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n\n1.3 单例存在哪些问题?尽管单例是一个很常用的设计模式，在实际的开发中，也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用\n大部分情况下，在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题\n1.3.1 单例对 OOP 特性的支持不友好OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好，如下例：\npublic class Order &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F;...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\npublic class User &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F; ...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nIdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大\npublic class Order &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F;...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F; 需要将上面一行代码，替换为下面一行代码\n        long id &#x3D; OrderIdGenerator.getIntance().getId();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\npublic class User &#123;\n    public void create(...) &#123;\n        &#x2F;&#x2F; ...\n        long id &#x3D; IdGenerator.getInstance().getId();\n        &#x2F;&#x2F; 需要将上面一行代码，替换为下面一行代码\n        long id &#x3D; UserIdGenerator.getIntance().getId();\n    &#125;\n&#125;\n\n除此之外，单例对继承、多态特性的支持也不友好。这里之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性\n1.3.2 单例会隐藏类之间的依赖关系代码的可读性非常重要。在阅读代码的时候，希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类\n1.3.3 单例对代码的扩展性不友好单例类只能有一个对象实例。如果未来某一天，需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。这时可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢？\n在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，把数据库连接池类设计成了单例类。但之后发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行\n如果将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类\n1.3.4 单例对代码的可测试性不友好单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换\n除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题\n1.3.5 单例不支持有参数的构造函数单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。针对这个问题，可以来看下都有哪些解决方案：\n1、创建完实例之后，再调用 init() 函数传递参数。需要注意的是，在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n    public static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            throw new RuntimeException(&quot;Run init() first.&quot;);\n        &#125;\n        return instance;\n    &#125;\n    public synchronized static Singleton init(int paramA, int paramB) &#123;\n        if (instance !&#x3D; null)&#123;\n            throw new RuntimeException(&quot;Singleton has been created!&quot;);\n        &#125;\n        instance &#x3D; new Singleton(paramA, paramB);\n        return instance;\n    &#125;\n&#125;\n\nSingleton.init(10, 50); &#x2F;&#x2F; 先init，再使用\nSingleton singleton &#x3D; Singleton.getInstance();\n\n2、将参数放到 getIntance() 方法中\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n    public synchronized static Singleton getInstance(int paramA, int paramB) &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton(paramA, paramB);\n        &#125;\n        return instance;\n    &#125;\n&#125;\nSingleton singleton &#x3D; Singleton.getInstance(10, 50);\n\n但上面的代码实现稍微有点问题。如果如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户\nSingleton singleton1 &#x3D; Singleton.getInstance(10, 50);\nSingleton singleton2 &#x3D; Singleton.getInstance(20, 30);\n\n3、将参数放到另外一个全局变量中\n具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的\npublic class Config &#123;\n    public static final int PARAM_A &#x3D; 123;\n    public static fianl int PARAM_B &#x3D; 245;\n&#125;\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n    private Singleton() &#123;\n        this.paramA &#x3D; Config.PARAM_A;\n        this.paramB &#x3D; Config.PARAM_B;\n    &#125;\n    public synchronized static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n1.4 有何替代解决方案？如果不用单例，怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如，上面讲到的 ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：\n&#x2F;&#x2F; 静态方法实现方式\npublic class IdGenerator &#123;\n    private static AtomicLong id &#x3D; new AtomicLong(0);\n    public static long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用举例\nlong id &#x3D; IdGenerator.getId();\n\n不过，静态方法这种实现思路，并不能解决之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。再来看看有没有其他办法。实际上，单例除了之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：\n&#x2F;&#x2F; 1. 老的使用方式\npublic demofunction() &#123;\n    &#x2F;&#x2F;...\n    long id &#x3D; IdGenerator.getInstance().getId();\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) &#123;\n    long id &#x3D; idGenerator.getId();\n&#125;\n&#x2F;&#x2F; 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator &#x3D; IdGenerator.getInsance();\ndemofunction(idGenerator);\n\n基于新的使用方式，将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决\n所以，如果要完全解决这些问题，可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的\n1.5 如何理解单例模式中的唯一性？首先看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。”\n定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的\n我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，完全可以简单地理解为就是代码本身\n当使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象\n进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的\n1.6 如何实现线程唯一的单例？“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，“进程唯一”还代表了线程内、线程间都唯一\n线程唯一单例的代码实现很简单，如下所示。在代码中，通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap\npublic class IdGenerator &#123;\n\tprivate AtomicLong id &#x3D; new AtomicLong(0);\n\tprivate static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances\n\t    &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate IdGenerator() &#123;&#125;\n\tpublic static IdGenerator getInstance() &#123;\n\t\tLong currentThreadId &#x3D; Thread.currentThread().getId();\n\t\tinstances.putIfAbsent(currentThreadId, new IdGenerator());\n\t\treturn instances.get(currentThreadId);\n\t&#125;\n\tpublic long getId() &#123;\n\t\treturn id.incrementAndGet();\n\t&#125;\n&#125;\n\n1.7 如何实现集群环境下的单例？“进程唯一”指的是进程内唯一、进程间不唯一。“线程唯一”指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象\n如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了。具体来说，需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。实现如下：\npublic class IdGenerator &#123;\n\tprivate AtomicLong id &#x3D; new AtomicLong(0);\n\tprivate static IdGenerator instance;\n\tprivate static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;** 省略入参 **&#x2F;);\n\tprivate static DistributedLock lock &#x3D; new DistributedLock();\n\tprivate IdGenerator() &#123;&#125;\n\tpublic synchronized static IdGenerator getInstance() &#123;\n\t\tif (instance &#x3D;&#x3D; null) &#123;\n\t\t\tlock.lock();\n\t\t\tinstance &#x3D; storage.load(IdGenerator.class);\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n\tpublic synchroinzed void freeInstance() &#123;\n\t\tstorage.save(this, IdGeneator.class);\n\t\tinstance &#x3D; null; &#x2F;&#x2F;释放对象\n\t\tlock.unlock();\n\t&#125;\n\tpublic long getId() &#123;\n\t\treturn id.incrementAndGet();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; IdGenerator使用举例\nIdGenerator idGeneator &#x3D; IdGenerator.getInstance();\nlong id &#x3D; idGenerator.getId();\nIdGenerator.freeInstance();\n\n1.7 如何实现一个多例模式？“单例”指的是，一个类只能创建一个对象。对应地，“多例”指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：\npublic class BackendServer &#123;\n\tprivate long serverNo;\n\tprivate String serverAddress;\n\tprivate static final int SERVER_COUNT &#x3D; 3;\n\tprivate static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\n\n\tstatic &#123;\n\t\tserverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n\t\tserverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n\t\tserverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n\t&#125;\n\tprivate BackendServer(long serverNo, String serverAddress) &#123;\n\t\tthis.serverNo &#x3D; serverNo;\n\t\tthis.serverAddress &#x3D; serverAddress;\n\t&#125;\n\tpublic BackendServer getInstance(long serverNo) &#123;\n\t\treturn serverInstances.get(serverNo);\n\t&#125;\n\tpublic BackendServer getRandomInstance() &#123;\n\t\tRandom r &#x3D; new Random();\n\t\tint no &#x3D; r.nextInt(SERVER_COUNT)+1;\n\t\treturn serverInstances.get(no);\n\t&#125;\n&#125;\n\n实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的“类型”如何理解呢？\n如下例，在代码中，loggerName 就是刚刚说的“类型”，同一个 loggerName 获取到的对象实例是相同的，不同的 loggerName 获取到的对象实例是不同的\npublic class Logger &#123;\n\tprivate static final ConcurrentHashMap&lt;String, Logger&gt; instances\n\t    &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate Logger() &#123;&#125;\n\tpublic static Logger getInstance(String loggerName) &#123;\n\t\tinstances.putIfAbsent(loggerName, new Logger());\n\t\treturn instances.get(loggerName);\n\t&#125;\n\tpublic void log() &#123;\n            &#x2F;&#x2F;...\n\t&#125;\n&#125;\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);\n\n这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，实际上，它还有点类似享元模式。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象\n2. 工厂模式（Factory Design Pattern）一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，这里沿用第一种分类方法\n在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。因此，重点是前两种工厂模式，搞清楚应用场景\n\n什么时候该用工厂模式？\n相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？\n\n2.1 简单工厂（Simple Factory）在下面这段代码中，根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig\npublic class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125; else &#123;\n\t\t\tthrow new InvalidRuleConfigException(\n\t\t\t    &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath)\n\t\t&#125;\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\n为了让代码逻辑更加清晰，可读性更好，要善于将功能独立的代码块封装成函数。按照这个设计思路，可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示：\npublic class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParser parser &#x3D; createParser(ruleConfigFileExtension);\n\t\tif (parser &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(\n\t\t\t    &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath\n\t\t&#125;\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n\tprivate IRuleConfigParser createParser(String configFormat) &#123;\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125;\n\t\treturn parser;\n\t&#125;\n&#125;\n\n为了让类的职责更加单一、代码更加清晰，还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是简单工厂模式类。具体的代码如下所示：\npublic class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParser parser &#x3D; RuleConfigParserFactory.createParser(ruleConfig);\n\t\tif (parser &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(\n\t\t\t    &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n\t\t&#125;\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\npublic class RuleConfigParserFactory &#123;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tIRuleConfigParser parser &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new JsonRuleConfigParser();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new XmlRuleConfigParser();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new YamlRuleConfigParser();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n\t\t\tparser &#x3D; new PropertiesRuleConfigParser();\n\t\t&#125;\n\t\treturn parser;\n\t&#125;\n&#125;\n\n大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如 Java 中的 DateFormat、Calender。除此之外，工厂类中创建对象的方法一般都是 create 开头，比如代码中的 createParser()，但有的也命名为 getInstance()、createInstance()、newInstance()，有的甚至命名为 valueOf()（比如 Java String 类的 valueOf() 函数）等等，这个根据具体的场景和习惯来命名就好\n在上面的代码实现中，每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用\n这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。这里把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法：\npublic class RuleConfigParserFactory &#123;\n\tprivate static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n\t\tcachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n\t\tcachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n\t\tcachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n\t&#125;\n\tpublic static IRuleConfigParser createParser(String configFormat) &#123;\n\t\tif (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;\n\t\t\treturn null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());\n\t\treturn parser;\n\t&#125;\n&#125;\n\n对于上面两种简单工厂模式的实现方法，如果要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的\n除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性\n2.2 工厂方法（Factory Method）如果非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：\npublic interface IRuleConfigParserFactory &#123;\n\tIRuleConfigParser createParser();\n&#125;\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n&#125;\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n&#125;\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new YamlRuleConfigParser();\n\t&#125;\n&#125;\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createParser() &#123;\n\t\treturn new PropertiesRuleConfigParser();\n\t&#125;\n&#125;\n\n实际上，这就是工厂方法模式的典型代码实现。这样当新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则\n从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：\npublic class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; null;\n\t\tif (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new JsonRuleConfigParserFactory();\n\t\t&#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new XmlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new YamlRuleConfigParserFactory();\n\t\t&#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n\t\t\tparserFactory &#x3D; new PropertiesRuleConfigParserFactory();\n\t\t&#125; else &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file format is not support&quot;);\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; parserFactory.createParser();\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\n从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？\n可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。代码实现如下，其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象\npublic class RuleConfigSource &#123;\n\tpublic RuleConfig load(String ruleConfigFilePath) &#123;\n\t\tString ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\t\tIRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n\t\tif (parserFactory &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new InvalidRuleConfigException(&quot;Rule config file format is not support&quot;);\n\t\t&#125;\n\t\tIRuleConfigParser parser &#x3D; parserFactory.createParser();\n\t\tString configText &#x3D; &quot;&quot;;\n\t\t&#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n\t\tRuleConfig ruleConfig &#x3D; parser.parse(configText);\n\t\treturn ruleConfig;\n\t&#125;\n\tprivate String getFileExtension(String filePath) &#123;\n\t\t&#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n\t\treturn &quot;json&quot;;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，\n&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n\tprivate static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n\tstatic &#123;\n\t\tcachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n\t\tcachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory())\n\t&#125;\n\tpublic static IRuleConfigParserFactory getParserFactory(String type) &#123;\n\t\tif (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\tIRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n\t\treturn parserFactory;\n\t&#125;\n&#125;\n\n当需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则\n实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适\n2.3 什么时候该用工厂方法模式，而非简单工厂模式呢？前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，完全没必要将它拆分成单独的函数或者类\n基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂\n除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果还想避免烦人的 if-else 分支逻辑，这个时候，就推荐使用工厂方法模式\n\n封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明\n代码复用：创建代码抽离到独立的工厂类之后可以复用\n隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象\n控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁\n\n2.4 抽象工厂（Abstract Factory）在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类\n针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n\n针对这种特殊的场景，如果还是继续用工厂方法来实现的话，要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。过多的类也会让系统难维护。这个问题该怎么解决呢？\n抽象工厂就是针对这种非常特殊的场景而诞生的。可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：\npublic interface IConfigParserFactory &#123;\n\tIRuleConfigParser createRuleParser();\n\tISystemConfigParser createSystemParser();\n        &#x2F;&#x2F; 此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new JsonRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new JsonSystemConfigParser();\n\t&#125;\n&#125;\npublic class XmlConfigParserFactory implements IConfigParserFactory &#123;\n\t@Override\n\tpublic IRuleConfigParser createRuleParser() &#123;\n\t\treturn new XmlRuleConfigParser();\n\t&#125;\n\t@Override\n\tpublic ISystemConfigParser createSystemParser() &#123;\n\t\treturn new XmlSystemConfigParser();\n\t&#125;\n&#125;\n&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n\n2.5 如何设计实现一个 Dependency Injection 框架？2.5.1 工厂模式和 DI 容器有何区别？实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”\nDI 容器相对于工厂模式来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建\n除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理\n2.5.2 DI 容器的核心功能有哪些？总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理\n1、配置解析\n在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是配置\n我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象\n下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter。\npublic class RateLimiter &#123;\n\tprivate RedisCounter redisCounter;\n\tpublic RateLimiter(RedisCounter redisCounter) &#123;\n\t\tthis.redisCounter &#x3D; redisCounter;\n\t&#125;\n\tpublic void test() &#123;\n\t\tSystem.out.println(&quot;Hello World!&quot;);\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\npublic class RedisCounter &#123;\n\tprivate String ipAddress;\n\tprivate int port;\n\tpublic RedisCounter(String ipAddress, int port) &#123;\n\t\tthis.ipAddress &#x3D; ipAddress;\n\t\tthis.port &#x3D; port;\n\t&#125;\n\t&#x2F;&#x2F;...\n&#125;\n\n配置文件beans.xml：\n&lt;beans&gt;\n\t&lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n\t\t&lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n\t&lt;&#x2F;bean&gt;\n\t&lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n\t&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n2、对象创建\n在 DI 容器中，如果给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难，只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。运用“反射”这种机制，在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的\n3、对象的生命周期管理\n简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象\n除此之外，还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)） 才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好\n不仅如此，还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件\n2.5.3 最小原型设计实际上，用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象\n这里只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，只支持下面配置文件中涉及的配置语法\n配置文件beans.xml：\n&lt;beans&gt;\n\t&lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n\t\t&lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n\t&lt;&#x2F;bean&gt;\n\t&lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n\t\t&lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n\t&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：\npublic class Demo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext\n\t\t&quot;beans.xml&quot;);\n\t\tRateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;RateLimiter&quot;);\n\t\trateLimiter.test();\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\n2.5.4 提供执行入口面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类\n通过刚刚的最小原型使用示例代码可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：\npublic interface ApplicationContext &#123;\n\tObject getBean(String beanId);\n&#125;\npublic class ClassPathXmlApplicationContext implements ApplicationContext &#123;\n\tprivate BeansFactory beansFactory;\n\tprivate BeanConfigParser beanConfigParser;\n\tpublic ClassPathXmlApplicationContext(String configLocation) &#123;\n\t\tthis.beansFactory &#x3D; new BeansFactory();\n\t\tthis.beanConfigParser &#x3D; new XmlBeanConfigParser();\n\t\tloadBeanDefinitions(configLocation);\n\t&#125;\n\tprivate void loadBeanDefinitions(String configLocation) &#123;\n\t\tInputStream in &#x3D; null;\n\t\ttry &#123;\n\t\t\tin &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);\n\t\t\tif (in &#x3D;&#x3D; null) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Can not find config file: &quot; + configLocatio\n\t\t\t&#125;\n\t\t\tList&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);\n\t\t\tbeansFactory.addBeanDefinitions(beanDefinitions);\n\t\t&#125; finally &#123;\n\t\t\tif (in !&#x3D; null) &#123;\n\t\t\t\ttry &#123;\n\t\t\t\t\tin.close();\n\t\t\t\t&#125; catch (IOException e) &#123;\n\t\t\t\t\t&#x2F;&#x2F; TODO: log error\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t@Override\n\tpublic Object getBean(String beanId) &#123;\n\t\treturn beansFactory.getBean(beanId);\n\t&#125;\n&#125;\n\n从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象\n2.5.5 配置文件解析配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象\n配置文件的解析比较繁琐，这里只给出两个类的大致设计思路，并未给出具体的实现代码\npublic interface BeanConfigParser &#123;\n\tList&lt;BeanDefinition&gt; parse(InputStream inputStream);\n\tList&lt;BeanDefinition&gt; parse(String configContent);\n&#125;\npublic class XmlBeanConfigParser implements BeanConfigParser &#123;\n\t@Override\n\tpublic List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;\n\t\tString content &#x3D; null;\n\t\t&#x2F;&#x2F; TODO:...\n\t\treturn parse(content);\n\t&#125;\n\t@Override\n\tpublic List&lt;BeanDefinition&gt; parse(String configContent) &#123;\n\t\tList&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();\n\t\t&#x2F;&#x2F; TODO:...\n\t\treturn beanDefinitions;\n\t&#125;\n&#125;\npublic class BeanDefinition &#123;\n\tprivate String id;\n\tprivate String className;\n\tprivate List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();\n\tprivate Scope scope &#x3D; Scope.SINGLETON;\n\tprivate boolean lazyInit &#x3D; false;\n\t&#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n\tpublic boolean isSingleton() &#123;\n\t\treturn scope.equals(Scope.SINGLETON);\n\t&#125;\n\tpublic static enum Scope &#123;\n\t\tSINGLETON,\n\t\tPROTOTYPE\n\t&#125;\n\tpublic static class ConstructorArg &#123;\n\t\tprivate boolean isRef;\n\t\tprivate Class type;\n\t\tprivate Object arg;\n\t\t&#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n\t&#125;\n&#125;\n\n2.5.6 核心工厂类设计最后来看 BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象\n如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回\n实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 自动完成了，需要利用 Java 提供的反射语法自己去编写代码\npublic class BeansFactory &#123;\n\tprivate ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();\n\tprivate ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n\tpublic void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;\n\t\tfor (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n\t\t\tthis.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition)\n\t\t&#125;\n\t\tfor (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n\t\t\tif (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;\n\t\t\t\tcreateBean(beanDefinition);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\tpublic Object getBean(String beanId) &#123;\n\t\tBeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);\n\t\tif (beanDefinition &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n\t\t&#125;\n\t\treturn createBean(beanDefinition);\n\t&#125;\n\n\t@VisibleForTesting\n\tprotected Object createBean(BeanDefinition beanDefinition) &#123;\n\t\tif (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition)) &#123;\n\t\t\treturn singletonObjects.get(beanDefinition.getId());\n\t\t&#125;\n\t\tObject bean &#x3D; null;\n\t\ttry &#123;\n\t\t\tClass beanClass &#x3D; Class.forName(beanDefinition.getClassName());\n\t\t\tList&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorA\n\t\t\tif (args.isEmpty()) &#123;\n\t\t\t\tbean &#x3D; beanClass.newInstance();\n\t\t\t&#125; else &#123;\n\t\t\t\tClass[] argClasses &#x3D; new Class[args.size()];\n\t\t\t\tObject[] argObjects &#x3D; new Object[args.size()];\n\t\t\t\tfor (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;\n\t\t\t\t\tBeanDefinition.ConstructorArg arg &#x3D; args.get(i);\n\t\t\t\t\tif (!arg.getIsRef()) &#123;\n\t\t\t\t\t\targClasses[i] &#x3D; arg.getType();\n\t\t\t\t\t\targObjects[i] &#x3D; arg.getArg();\n\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\tBeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());\n\t\t\t\t\t\tif (refBeanDefinition &#x3D;&#x3D; null) &#123;\n\t\t\t\t\t\t\tthrow new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot;);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\targClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());\n\t\t\t\t\t\targObjects[i] &#x3D; createBean(refBeanDefinition);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tbean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);\n\t\t\t&#125;\n\t\t&#125; catch (ClassNotFoundException | IllegalAccessException) &#123;\n\t\t\t| InstantiationException | NoSuchMethodException | InvocationTarget\n\t\t\tthrow new BeanCreationFailureException(&quot;&quot;, e);\n\t\t&#125;\n\t\tif (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;\n\t\t\tsingletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n\t\t\treturn singletonObjects.get(beanDefinition.getId());\n\t\t&#125;\n\t\treturn bean;\n\t&#125;\n&#125;\n\n3. 建造者&#x2F;构建者&#x2F;生成器模式（Builder Design Pattern）3.1 为什么需要建造者模式？在平时的开发中，创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。但什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢？如下例：\n假设有这样一道设计面试题：需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请编写代码实现这个 ResourcePoolConfig 类\n\npublic class ResourcePoolConfig &#123;\n\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\tprivate String name;\n\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\tpublic ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Int minIdle) &#123;\n\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;name should not be empty.&quot;);\n\t\t&#125;\n\t\tthis.name &#x3D; name;\n\t\tif (maxTotal !&#x3D; null) &#123;\n\t\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxTotal &#x3D; maxTotal;\n\t\t&#125;\n\t\tif (maxIdle !&#x3D; null) &#123;\n\t\t\tif (maxIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxIdle &#x3D; maxIdle;\n\t\t&#125;\n\t\tif (minIdle !&#x3D; null) &#123;\n\t\t\tif (minIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n\t\t\t&#125;\n\t\t\tthis.minIdle &#x3D; minIdle;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n&#125;\n\n现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。在使用构造函数的时候，就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug\n解决这个问题的办法就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。代码如下所示，其中，配置项 name 是必填的，所以把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以通过 set() 函数来设置，让使用者自主选择填写或者不填写\npublic class ResourcePoolConfig &#123;\n\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\tprivate String name;\n\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\tpublic ResourcePoolConfig(String name) &#123;\n\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;name should not be empty.&quot;);\n\t\t&#125;\n\t\tthis.name &#x3D; name;\n\t&#125;\n\tpublic void setMaxTotal(int maxTotal) &#123;\n\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;maxTotal should be positive.&quot;);\n\t\t&#125;\n\t\tthis.maxTotal &#x3D; maxTotal;\n\t&#125;\n\tpublic void setMaxIdle(int maxIdle) &#123;\n\t\tif (maxIdle &lt; 0) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;maxIdle should not be negative.&quot;);\n\t\t&#125;\n\t\tthis.maxIdle &#x3D; maxIdle;\n\t&#125;\n\tpublic void setMinIdle(int minIdle) &#123;\n\t\tif (minIdle &lt; 0) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;minIdle should not be negative.&quot;);\n\t\t&#125;\n\t\tthis.minIdle &#x3D; minIdle;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n&#125;\n\n接下来，来看新的 ResourcePoolConfig 类该如何使用。代码如下所示，没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多\n&#x2F;&#x2F; ResourcePoolConfig 使用举例\nResourcePoolConfig config &#x3D; new ResourcePoolConfig(&quot;dbconnectionpool&quot;);\nconfig.setMaxTotal(16);\nconfig.setMaxIdle(8);\n\n至此，仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现我们的设计需求。如果把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了\n\n刚刚讲到，name 是必填的，所以把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了\n除此之外，假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了\n如果希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，就不能在 ResourcePoolConfig 类中暴露 set() 方法\n\n为了解决这些问题，建造者模式就派上用场了。可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样创建出来的对象就是不可变对象了\npublic class ResourcePoolConfig &#123;\n\tprivate String name;\n\tprivate int maxTotal;\n\tprivate int maxIdle;\n\tprivate int minIdle;\n\tprivate ResourcePoolConfig(Builder builder) &#123;\n\t\tthis.name &#x3D; builder.name;\n\t\tthis.maxTotal &#x3D; builder.maxTotal;\n\t\tthis.maxIdle &#x3D; builder.maxIdle;\n\t\tthis.minIdle &#x3D; builder.minIdle;\n\t&#125;\n\t&#x2F;&#x2F;...省略getter方法...\n\t&#x2F;&#x2F; 将Builder类设计成了ResourcePoolConfig的内部类。\n\t&#x2F;&#x2F; 也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n\tpublic static class Builder &#123;\n\t\tprivate static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n\t\tprivate static final int DEFAULT_MAX_IDLE &#x3D; 8;\n\t\tprivate static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\t\tprivate String name;\n\t\tprivate int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n\t\tprivate int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n\t\tprivate int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\t\tpublic ResourcePoolConfig build() &#123;\n\t\t\t&#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (maxIdle &gt; maxTotal) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tif (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\treturn new ResourcePoolConfig(this);\n\t\t&#125;\n\t\tpublic Builder setName(String name) &#123;\n\t\t\tif (StringUtils.isBlank(name)) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.name &#x3D; name;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxTotal(int maxTotal) &#123;\n\t\t\tif (maxTotal &lt;&#x3D; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxTotal &#x3D; maxTotal;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMaxIdle(int maxIdle) &#123;\n\t\t\tif (maxIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.maxIdle &#x3D; maxIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t\tpublic Builder setMinIdle(int minIdle) &#123;\n\t\t\tif (minIdle &lt; 0) &#123;\n\t\t\t\tthrow new IllegalArgumentException(&quot;...&quot;);\n\t\t\t&#125;\n\t\t\tthis.minIdle &#x3D; minIdle;\n\t\t\treturn this;\n\t\t&#125;\n\t&#125;\n&#125;\n&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()\n\t.setName(&quot;dbconnectionpool&quot;)\n\t.setMaxTotal(16)\n\t.setMaxIdle(10)\n\t.setMinIdle(12)\n\t.build();\n\n\n实际上，使用建造者模式创建对象，还能避免对象存在无效状态。比如定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之前，对象处于无效状态。具体代码如下所示：\nRectangle r &#x3D; new Rectange(); &#x2F;&#x2F; r is invalid\nr.setWidth(2); &#x2F;&#x2F; r is invalid\nr.setHeight(3); &#x2F;&#x2F; r is valid\n\n为了避免这种无效状态的存在，就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态\n实际上，如果并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍\n3.2 与工厂模式有何区别？建造者模式是让建造者类来负责对象的创建工作。工厂模式是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？\n实际上，工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象\n有一个经典的例子很好地解释了两者的区别\n顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨\n实际上，也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题\n4. 原型模式（Prototype Design Pattern）对于熟悉 JavaScript 语言的前端程序员来说，原型模式是一种比较常用的开发模式。这是因为，有别于 Java、C++ 等基于类的面向对象编程语言，JavaScript 是一种基于原型的面向对象编程语言。即便 JavaScript 现在也引入了类的概念，但它也只是基于原型的语法糖而已。不过，如果熟悉的是 Java、C++ 等这些编程语言，那在实际的开发中，就很少用到原型模式了\n4.1 原型模式的原理与应用如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式\n何为“对象的创建成本比较大”？\n实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失\n但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作\n假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，给关键词建立一个散列表索引\n如果熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。只需要将数据从数据库中读取出来，放入 HashMap 就可以了\n不过，还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，对 v2 版本的数据进行更新，得到 v3 版本的数据。这里假设只有更新和新添关键词，没有删除关键词的行为\n\n为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。该如何实现这个需求呢？\n实际上，也不难。只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，就将它插入到散列表中\npublic class Demo &#123;\n\tprivate ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords &#x3D; new Concurren\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到currentKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (currentKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tcurrentKeywords.replace(searchWord.getKeyword(), searchWord);\n\t\t\t&#125; else &#123;\n\t\t\t\tcurrentKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t\t&#125;\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n\t\t&#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;\n\n不过，现在有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了。除此之外，还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。该如何实现现在这个需求呢？\n实际上，也不难。把正在使用的数据的版本定义为“服务版本”，当要更新内存中的数据的时候，并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在\npublic class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tpublic void refresh() &#123;\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new LinkedHashMap&lt;&gt;();\n                &#x2F;&#x2F; 从数据库中取出所有的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords();\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t&#125;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords() &#123;\n                &#x2F;&#x2F; TODO: 从数据库中取出所有的数据\n\t\treturn null;\n\t&#125;\n&#125;\n\n不过，在上面的代码实现中，newKeywords 构建的成本比较高。需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了\n拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，每次新增或者更新的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率\npublic class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tSearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n\t\t\t\toldSearchWord.setCount(searchWord.getCount());\n\t\t\t\toldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n\t\t\t&#125; else &#123;\n\t\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t\t&#125;\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n                &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;\n\n这里利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的\n不过，实际上，刚刚的代码实现是有问题的。这里需要先了解另外两个概念：深拷贝（Deep Copy）和浅拷贝（Shallow Copy）\n4.2 原型模式的实现方式：深拷贝和浅拷贝先来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。大致结构如下图所示，从图中可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外的内存空间中\n\n浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：\n\n\n在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身\n在上面的代码中，通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当通过 newKeywords 更新 SearchWord 对象的时候（比如，更新“设计模式”这个搜索关键词的访问次数），newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。又该如何来解决这个问题呢？\n可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了\n那如何实现深拷贝呢？总结一下的话，有下面两种方法：\n第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止\n根据这个思路对之前的代码进行重构。重构之后的代码如下所示：\npublic class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; Deep copy\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new HashMap&lt;&gt;();\n\t\tfor (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;\n\t\t\tSearchWord searchWord &#x3D; e.getValue();\n\t\t\tSearchWord newSearchWord &#x3D; new SearchWord(\n\t\t\t    searchWord.getKeyword(), searchWord.getCount(), searchWord.getLas\n\t\t\t    newKeywords.put(e.getKey(), newSearchWord);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tSearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n\t\t\t\toldSearchWord.setCount(searchWord.getCount());\n\t\t\t\toldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n\t\t\t&#125; else &#123;\n\t\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t\t&#125;\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n\t\t&#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;\n\n第二种方法：先将对象序列化，然后再反序列化成新的对象\npublic Object deepCopy(Object object) &#123;\n\tByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream();\n\tObjectOutputStream oo &#x3D; new ObjectOutputStream(bo);\n\too.writeObject(object);\n\tByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());\n\tObjectInputStream oi &#x3D; new ObjectInputStream(bi);\n\treturn oi.readObject();\n&#125;\n\n上面的两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对这个应用场景，有没有更快、更省内存的实现方式呢？\n可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，使用深度拷贝的方式创建一份老对象的备份，在 newKeywords 更新 SearchWord 对象之后再替换为原先 currentKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是在这个应用场景下，最快速 clone 散列表的方式\npublic class Demo &#123;\n\tprivate HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n\tprivate long lastUpdateTime &#x3D; -1;\n\tpublic void refresh() &#123;\n\t\t&#x2F;&#x2F; Shallow copy\n\t\tHashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\t\t&#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n\t\tList&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n\t\tlong maxNewUpdatedTime &#x3D; lastUpdateTime;\n\t\tfor (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n\t\t\tif (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n\t\t\t\tmaxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n\t\t\t&#125;\n\t\t\tif (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n\t\t\t\tnewKeywords.remove(searchWord.getKeyword());\n\t\t\t&#125;\n\t\t\tnewKeywords.put(searchWord.getKeyword(), searchWord);\n\t\t&#125;\n\t\tlastUpdateTime &#x3D; maxNewUpdatedTime;\n\t\tcurrentKeywords &#x3D; newKeywords;\n\t&#125;\n\tprivate List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n\t\t&#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n\t\treturn null;\n\t&#125;\n&#125;\n","slug":"BlogRepository/设计模式/设计模式之美总结（创建型篇）","date":"2022-11-03T05:58:36.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"b2a78a3230e27441fbeed95c211733e9","title":"设计模式之美总结（设计原则篇）","content":"上一篇见：\n\n设计模式之美总结（面向对象篇）_凡 223 的博客\n\n上一篇介绍了面向对象相关的知识。接下来介绍一些经典的设计原则，其中包括 SOLID、KISS、YAGNI、DRY、LOD 等\n1. 单一职责原则（SRP）1.1 如何理解单一职责原则？实际上，SOLID 原则并非单纯的 1 个原则，而是由 5个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母\n单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP\n\n\n\n\n\n\n\n\n\nA class or module should have a single reponsibility.一个类或者模块只负责完成一个职责（或者功能）\n这个原则描述的对象包含两个，一个是类（Class），一个是模块（Module）。关于这两个概念，这里有两种理解方式。\n\n一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块\n另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块\n\n不管哪种理解方式，单一职责原则在应用到这两个描述对象的时候，道理都是相通的。接下来只从“类”设计的角度，来结算如何应用这个设计原则。对于“模块”来说，可以自行引申\n单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类\n比如，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，将两个不相干的功能放到同一个类中，那就违反了单一职责原则。为了满足单一职责原则，需要将这个类拆分成两个粒度更细、功能更加单一的两个类：订单类和用户类\n1.2 如何判断类的职责是否足够单一？从上面这个例子来看，单一职责原则看似不难应用。那是因为举的这个例子比较极端，一眼就能看出订单和用户毫不相干。但大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难拿捏的。如下例：\n在一个社交产品中，用下面的 UserInfo 类来记录用户的信息。你觉得，UserInfo 类的设计是否满足单一职责原则呢？\npublic class UserInfo &#123;\n    private long userId;\n    private String username;\n    private String email;\n    private String telephone;\n    private long createTime;\n    private long lastLoginTime;\n    private String avatarUrl;\n    private String provinceOfAddress; &#x2F;&#x2F; 省\n    private String cityOfAddress; &#x2F;&#x2F; 市\n    private String regionOfAddress; &#x2F;&#x2F; 区\n    private String detailedAddress; &#x2F;&#x2F; 详细地址\n    &#x2F;&#x2F; ... 省略其他属性和方法...\n&#125;\n\n对于这个问题，有两种不同的观点。一种观点是，UserInfo 类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在 UserInfo 类中，所占的比重比较高，可以继续拆分成独立的 UserAddress类，UserInfo 只保留除 Address 之外的其他信息，拆分之后的两个类的职责更加单一\n实际上，要从中做出选择，不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 UserInfo 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那最好将地址信息从 UserInfo 中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）\n再进一步延伸一下。如果做这个社交产品的公司发展得越来越好，公司内部又开发出了跟多其他产品（可以理解为其他 App）。公司希望支持统一账号系统，也就是用户一个账号可以在公司内部的所有产品中登录。这个时候，就需要继续对 UserInfo 进行拆分，将跟身份认证相关的信息（比如，Email、Telephone 等）抽取成独立的类\n由此可以总结出，不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类\n除此之外，从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。比如，例子中的 UserInfo 类。如果从“用户”这个业务层面来看，UserInfo 包含的信息都属于用户，满足职责单一原则。如果从更加细分的“用户展示信息”“地址信息”“登录认证信息”等等这些更细粒度的业务层面来看，那 UserInfo 就应该继续拆分\n综上所述，评价一个类的职责是否足够单一，并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，也没必要过于未雨绸缪，过度设计。所以，可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构\n这里还有一些小技巧，能够很好地帮你，从侧面上判定一个类的职责是否够单一。而且，我个人觉得，下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：\n\n类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，就需要考虑对类进行拆分\n类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，就需要考虑对类进行拆分\n私有方法过多，就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性\n比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰\n类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来\n\n此时可能会有这样的疑问：在上面的判定原则中提到类中的代码行数、函数或者属性过多，就有可能不满足单一职责原则。那多少行代码才算是行数过多呢？多少个函数、属性才称得上过多呢？\n实际上，这个问题并不好定量地回答。比较宽泛的、可量化的标准，那就是一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个。实际上， 从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了\n1.3 类的职责是否设计得越单一越好？为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。如下例，Serialization 类实现了一个简单协议的序列化和反序列功能，具体代码如下：\npublic class Serialization &#123;\n    private static final String IDENTIFIER_STRING &#x3D; &quot;UEUEUE;&quot;;\n    private Gson gson;\n\n    public Serialization() &#123;\n        this.gson &#x3D; new Gson();\n    &#125;\n    public String serialize(Map&lt;String, String&gt; object) &#123;\n        StringBuilder textBuilder &#x3D; new StringBuilder();\n        textBuilder.append(IDENTIFIER_STRING);\n        textBuilder.append(gson.toJson(object));\n        return textBuilder.toString();\n    &#125;\n    public Map&lt;String, String&gt; deserialize(String text) &#123;\n        if (!text.startsWith(IDENTIFIER_STRING)) &#123;\n            return Collections.emptyMap();\n        &#125;\n        String gsonStr &#x3D; text.substring(IDENTIFIER_STRING.length());\n        return gson.fromJson(gsonStr, Map.class);\n    &#125;\n&#125;\n\n如果想让类的职责更加单一，对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。拆分后的具体代码如下所示：\npublic class Serializer &#123;\n    private static final String IDENTIFIER_STRING &#x3D; &quot;UEUEUE;&quot;;\n    private Gson gson;\n\n    public Serializer() &#123;\n        this.gson &#x3D; new Gson();\n    &#125;\n    public String serialize(Map&lt;String, String&gt; object) &#123;\n        StringBuilder textBuilder &#x3D; new StringBuilder();\n        textBuilder.append(IDENTIFIER_STRING);\n        textBuilder.append(gson.toJson(object));\n        return textBuilder.toString();\n    &#125;\n&#125;\n\npublic class Deserializer &#123;\n    private static final String IDENTIFIER_STRING &#x3D; &quot;UEUEUE;&quot;;\n    private Gson gson;\n\n    public Deserializer() &#123;\n        this.gson &#x3D; new Gson();\n    &#125;\n    public Map&lt;String, String&gt; deserialize(String text) &#123;\n        if (!text.startsWith(IDENTIFIER_STRING)) &#123;\n            return Collections.emptyMap();\n        &#125;\n        String gsonStr &#x3D; text.substring(IDENTIFIER_STRING.length());\n        return gson.fromJson(gsonStr, Map.class);\n    &#125;\n&#125;\n\n虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但也随之带来了新的问题。如果修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。而且，如果仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了\n实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准\n2. 开闭原则（OCP）作者个人觉得，开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则\n\n之所以说这条原则难理解，那是因为，“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等等这些问题，都比较难理解\n之所以说这条原则难掌握，那是因为，“如何做到‘对扩展开发、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？”等等这些问题，都比较难掌握\n之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则\n\n2.1 如何理解“对扩展开放、修改关闭”？开闭原则的英文全称是 Open Closed Principle，简写为 OCP\n\n\n\n\n\n\n\n\n\nsoftware entities (modules, classes, functions, etc.) should be open for extension, but closed for modification.软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”\n这个描述比较简略，如果详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。如下例，这是一段 API 接口监控告警的代码\n其中，AlertRule 存储告警规则，可以自由设置。Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。NotificationEmergencyLevel 表示通知的紧急程度，包括 SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道\npublic class Alert &#123;\n    private AlertRule rule;\n    private Notification notification;\n\n    public Alert(AlertRule rule, Notification notification) &#123;\n        this.rule &#x3D; rule;\n        this.notification &#x3D; notification;\n    &#125;\n    public void check(String api, long requestCount, long errorCount, long duration) &#123;\n        long tps &#x3D; requestCount &#x2F; durationOfSeconds;\n        if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;\n            notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n        &#125;\n        if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;\n            notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n        &#125;\n    &#125;\n&#125;\n\n上面这段代码非常简单，业务逻辑主要集中在 check() 函数中。当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队\n现在，如果需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，也要触发告警发送通知。这个时候，该如何改动代码呢？主要的改动有两处：第一处是修改 check() 函数的入参，添加一个新的统计数据 timeoutCount，表示超时接口请求数；第二处是在 check() 函数中添加新的告警逻辑。具体的代码改动如下所示：\npublic class Alert &#123;\n    &#x2F;&#x2F; ... 省略 AlertRule&#x2F;Notification 属性和构造函数...\n    &#x2F;&#x2F; 改动一：添加参数 timeoutCount\n    public void check(String api, long requestCount, long errorCount, long timeoutCount) &#123;\n        long tps &#x3D; requestCount &#x2F; durationOfSeconds;\n        if (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;\n            notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n        &#125;\n        if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;\n            notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n        &#125;\n        &#x2F;&#x2F; 改动二：添加接口超时处理逻辑\n        long timeoutTps &#x3D; timeoutCount &#x2F; durationOfSeconds;\n        if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;\n            notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n        &#125;\n    &#125;\n&#125;\n\n这样的代码修改实际上存在挺多问题的。一方面，对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改\n上面的代码改动是基于“修改”的方式来实现新功能的。如果遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？\n首先先重构一下之前的 Alert 代码，让它的扩展性更好一些。重构的内容主要包含两部分：\n\n将 check() 函数的多个入参封装成 ApiStatInfo 类；\n引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中\n\n具体的代码实现如下所示：\npublic class Alert &#123;\n    private List&lt;AlertHandler&gt; alertHandlers &#x3D; new ArrayList&lt;&gt;();\n\n    public void addAlertHandler(AlertHandler alertHandler) &#123;\n        this.alertHandlers.add(alertHandler);\n    &#125;\n    public void check(ApiStatInfo apiStatInfo) &#123;\n        for (AlertHandler handler : alertHandlers) &#123;\n            handler.check(apiStatInfo);\n        &#125;\n    &#125;\n&#125;\npublic class ApiStatInfo &#123;&#x2F;&#x2F; 省略 constructor&#x2F;getter&#x2F;setter 方法\n    private String api;\n    private long requestCount;\n    private long errorCount;\n    private long durationOfSeconds;\n&#125;\n\npublic abstract class AlertHandler &#123;\n    protected AlertRule rule;\n    protected Notification notification;\n\n    public AlertHandler(AlertRule rule, Notification notification) &#123;\n        this.rule &#x3D; rule;\n        this.notification &#x3D; notification;\n    &#125;\n    public abstract void check(ApiStatInfo apiStatInfo);\n&#125;\npublic class TpsAlertHandler extends AlertHandler &#123;\n    public TpsAlertHandler(AlertRule rule, Notification notification) &#123;\n        super(rule, notification);\n    &#125;\n    @Override\n    public void check(ApiStatInfo apiStatInfo) &#123;\n        long tps &#x3D; apiStatInfo.getRequestCount()&#x2F; apiStatInfo.getDurationOfSeconds\n        if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;\n            notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;);\n        &#125;\n    &#125;\n&#125;\npublic class ErrorAlertHandler extends AlertHandler &#123;\n    public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;\n        super(rule, notification);\n    &#125;\n    @Override\n    public void check(ApiStatInfo apiStatInfo) &#123;\n        if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()) &#123;\n            notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n        &#125;\n    &#125;\n&#125;\n\n上面的代码是对 Alert 的重构，重构之后的 Alert 该如何使用呢？如下，其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作\npublic class ApplicationContext &#123;\n    private AlertRule alertRule;\n    private Notification notification;\n    private Alert alert;\n\n    public void initializeBeans() &#123;\n        alertRule &#x3D; new AlertRule(&#x2F;*. 省略参数.*&#x2F;); &#x2F;&#x2F; 省略一些初始化代码\n        notification &#x3D; new Notification(&#x2F;*. 省略参数.*&#x2F;); &#x2F;&#x2F; 省略一些初始化代码\n        alert &#x3D; new Alert();\n        alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));\n        alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));\n    &#125;\n    public Alert getAlert() &#123; return alert; &#125;\n    &#x2F;&#x2F; 饿汉式单例\n    private static final ApplicationContext instance &#x3D; new ApplicationContext();\n    private ApplicationContext() &#123;\n        instance.initializeBeans();\n    &#125;\n    public static ApplicationContext getInstance() &#123;\n        return instance;\n    &#125;\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();\n        &#x2F;&#x2F; ... 省略设置 apiStatInfo 数据值的代码\n        ApplicationContext.getInstance().getAlert().check(apiStatInfo);\n    &#125;\n&#125;\n\n再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，又该如何改动代码呢？主要的改动有下面四处：\n\n在 ApiStatInfo 类中添加新的属性 timeoutCount\n添加新的 TimeoutAlertHander 类\n在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler\n在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值\n\npublic class Alert &#123; &#x2F;&#x2F; 代码未改动... &#125;\n\npublic class ApiStatInfo &#123;&#x2F;&#x2F; 省略 constructor&#x2F;getter&#x2F;setter 方法\n    private String api;\n    private long requestCount;\n    private long errorCount;\n    private long durationOfSeconds;\n    private long timeoutCount; &#x2F;&#x2F; 改动一：添加新字段\n&#125;\npublic abstract class AlertHandler &#123; &#x2F;&#x2F; 代码未改动... &#125;\npublic class TpsAlertHandler extends AlertHandler &#123; &#x2F;&#x2F; 代码未改动...&#125;\npublic class ErrorAlertHandler extends AlertHandler &#123; &#x2F;&#x2F; 代码未改动...&#125;\n\n&#x2F;&#x2F; 改动二：添加新的 handler\npublic class TimeoutAlertHandler extends AlertHandler &#123; &#x2F;&#x2F; 省略代码...&#125;\n\npublic class ApplicationContext &#123;\n    private AlertRule alertRule;\n    private Notification notification;\n    private Alert alert;\n\n    public void initializeBeans() &#123;\n        alertRule &#x3D; new AlertRule(&#x2F;*. 省略参数.*&#x2F;); &#x2F;&#x2F; 省略一些初始化代码\n        notification &#x3D; new Notification(&#x2F;*. 省略参数.*&#x2F;); &#x2F;&#x2F; 省略一些初始化代码\n        alert &#x3D; new Alert();\n        alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));\n        alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));\n        &#x2F;&#x2F; 改动三：注册 handler\n        alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));\n    &#125;\n    &#x2F;&#x2F;... 省略其他未改动代码...\n&#125;\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ApiStatInfo apiStatInfo &#x3D; new ApiStatInfo();\n        &#x2F;&#x2F; ... 省略 apiStatInfo 的 set 字段代码\n        apiStatInfo.setTimeoutCount(289); &#x2F;&#x2F; 改动四：设置 tiemoutCount 值\n        ApplicationContext.getInstance().getAlert().check(apiStatInfo);\n    &#125;\n&#125;\n\n重构之后的代码更加灵活和易扩展。如果要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改\n2.2 修改代码就意味着违背开闭原则吗？看了上面重构之后的代码，可能还会有疑问：在添加新的告警逻辑的时候，尽管改动二（添加新的 handler 类）是基于扩展而非修改的方式来完成的，但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗？\n1、改动一：往 ApiStatInfo 类中添加新的属性 timeoutCount\n实际上，不仅往 ApiStatInfo 类中添加了属性，还添加了对应的 getter&#x2F;setter 方法。那这个问题就转化为：给类中添加新的属性和方法，算作“修改”还是“扩展”？\n开闭原则的定义：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。从定义中，可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”\n实际上，也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，就可以说，这是一个合格的代码改动\n2、改动三和改动四：在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler；在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值\n这两处改动都是在方法内部进行的，不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。为什么这么说呢？\n在重构之后的 Alert 代码中，核心逻辑集中在 Alert 类及其各个 handler 中，当在添加新的告警逻辑的时候，Alert 类完全不需要修改，而只需要扩展一个新 handler 类。如果把 Alert 类及各个 handler 类合起来看作一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则\n而且，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则\n2.3 如何做到“对扩展开放、修改关闭”？在刚刚的例子中，通过引入一组 handler 的方式来实现支持开闭原则。如果没有太多复杂代码的设计和开发经验，这样的代码设计思路可能想不到。能想到，靠的就是理论知识和实战经验，这些需要慢慢学习和积累\n实际上，开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码\n在讲具体的方法论之前，先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要\n在写代码的时候后，要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”\n还有，在识别出代码可变部分和不可变部分之后，要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改\n讲完了实现开闭原则的一些偏向顶层的指导思想，现在再来看下，支持开闭原则的一些更加具体的方法论\n前面讲到，代码的扩展性是代码质量评判的最重要的标准之一。实际上，很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的\n在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。接下来重点讲一下，如何利用多态、依赖注入、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”\n实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想\n如下例，代码中通过 Kafka 来发送异步消息。对于这样一个功能的开发，要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：\n&#x2F;&#x2F; 这一部分体现了抽象意识\npublic interface MessageQueue &#123; &#x2F;&#x2F;... &#125;\npublic class KafkaMessageQueue implements MessageQueue &#123; &#x2F;&#x2F;... &#125;\npublic class RocketMQMessageQueue implements MessageQueue &#123;&#x2F;&#x2F;...&#125;\n\npublic interface MessageFromatter &#123; &#x2F;&#x2F;... &#125;\npublic class JsonMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;\npublic class ProtoBufMessageFromatter implements MessageFromatter &#123;&#x2F;&#x2F;...&#125;\n\npublic class Demo &#123;\n    private MessageQueue msgQueue; &#x2F;&#x2F; 基于接口而非实现编程\n\n    public Demo(MessageQueue msgQueue) &#123; &#x2F;&#x2F; 依赖注入\n        this.msgQueue &#x3D; msgQueue;\n    &#125;\n    &#x2F;&#x2F; msgFormatter：多态、依赖注入\n    public void sendNotification(Notification notification, MessageFormatter msg) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n2.4 如何在项目中灵活应用开闭原则？写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点。那问题是如何才能识别出所有可能的扩展点呢？\n如果开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。如果开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，需要了解“它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？”等问题\n不过，有一句话说得好，“唯一不变的只有变化本身”。即便对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计\n最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求\n而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如之前举的 Alert 告警的例子。为了更好地支持扩展性，对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。很多时候，都需要在扩展性和可读性之间做权衡。在某些场景下，代码的扩展性很重要，就可以适当地牺牲一些代码的可读性；在另一些场景下，代码的可读性更加重要，那就适当地牺牲一些代码的可扩展性\n在之前举的 Alert 告警的例子中，如果告警规则并不是很多、也不复杂，那 check() 函数中的 if 语句就不会很多，代码逻辑也不复杂，代码行数也不多，那最初的第一种代码实现思路简单易读，就是比较合理的选择。相反，如果告警规则很多、很复杂，check() 函数的 if 语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了\n3. 里式替换（LSP）3.1 如何理解“里式替换原则”？里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。这个原则最早是在 1986 年由 Barbara Liskov 提出，原文如下：\n\n\n\n\n\n\n\n\n\nIf S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.\n在 1996 年，Robert Martin 在他的 SOLID 原则中，重新描述了这个原则，原文如下：\n\n\n\n\n\n\n\n\n\nFunctions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.\n综合两者的描述，翻译成中文即：子类对象（object of subtype&#x2F;derived class）能够替换程序（program）中父类对象（object of base&#x2F;parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏\n如下例，父类 Transporter 使用 org.apache.http 库中的 HttpClient 类来传输网络数据。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息\npublic class Transporter &#123;\n    private HttpClient httpClient;\n\n    public Transporter(HttpClient httpClient) &#123;\n        this.httpClient &#x3D; httpClient;\n    &#125;\n    public Response sendRequest(Request request) &#123;\n        &#x2F;&#x2F; ...use httpClient to send request\n    &#125;\n&#125;\n\npublic class SecurityTransporter extends Transporter &#123;\n    private String appId;\n    private String appToken;\n\n    public SecurityTransporter(HttpClient httpClient, String appId, String appToken) &#123;\n        super(httpClient);\n        this.appId &#x3D; appId;\n        this.appToken &#x3D; appToken;\n    &#125;\n    @Override\n    public Response sendRequest(Request request) &#123;\n        if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;\n            request.addPayload(&quot;app-id&quot;, appId);\n            request.addPayload(&quot;app-token&quot;, appToken);\n        &#125;\n        return super.sendRequest(request);\n    &#125;\n&#125;\n\npublic class Demo &#123;\n    public void demoFunction(Transporter transporter) &#123;\n        Reuqest request &#x3D; new Request();\n        &#x2F;&#x2F;... 省略设置 request 中数据值的代码...\n        Response response &#x3D; transporter.sendRequest(request);\n        &#x2F;&#x2F;... 省略其他逻辑...\n    &#125;\n&#125;\n&#x2F;&#x2F; 里式替换原则\nDemo demo &#x3D; new Demo();\ndemo.demofunction(new SecurityTransporter(&#x2F;* 省略参数 *&#x2F;););\n\n在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏\n这样一看，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？\n假如需要对 SecurityTransporter 类中 sendRequest() 函数稍加改造一下。改造前，如果 appId 或者 appToken 没有设置，就不做校验；改造后，如果 appId 或者 appToken 没有设置，则直接抛出NoAuthorizationRuntimeException 未授权异常。改造前后的代码对比如下所示：\n&#x2F;&#x2F; 改造前：\npublic class SecurityTransporter extends Transporter &#123;\n    &#x2F;&#x2F;... 省略其他代码..\n    @Override\n    public Response sendRequest(Request request) &#123;\n        if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;\n            request.addPayload(&quot;app-id&quot;, appId);\n            request.addPayload(&quot;app-token&quot;, appToken);\n        &#125;\n        return super.sendRequest(request);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 改造后：\npublic class SecurityTransporter extends Transporter &#123;\n    &#x2F;&#x2F;... 省略其他代码..\n    @Override\n    public Response sendRequest(Request request) &#123;\n        if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) &#123;\n            throw new NoAuthorizationRuntimeException(...);\n        &#125;\n        request.addPayload(&quot;app-id&quot;, appId);\n        request.addPayload(&quot;app-token&quot;, appToken);\n        return super.sendRequest(request);\n    &#125;\n&#125;\n\n在改造之后的代码中，如果传递进 demoFunction() 函数的是父类 Transporter 对象，那 demoFunction() 函数并不会有异常抛出，但如果传递给 demoFunction() 函数的是子类 SecurityTransporter 对象，那 demoFunction() 有可能会有异常抛出。尽管代码中抛出的是运行时异常（Runtime Exception），可以不在代码中显式地捕获处理，但子类替换父类传递进 demoFunction 函数之后，整个程序的逻辑行为有了改变\n虽然改造之后的代码仍然可以通过 Java 的多态语法，动态地用子类 SecurityTransporter 来替换父类 Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的\n虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性\n3.2 哪些代码明显违背了 LSP？实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”\n看起来比较抽象，进一步解读一下就是子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。几个违反里式替换原则的例子如下：\n1、子类违背父类声明要实现的功能\n父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则\n2、子类违背父类对输入、输出、异常的约定\n在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则\n在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则\n在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则\n3、子类违背父类注释中所罗列的任何特殊说明\n父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的\n以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则\n实际上，里式替换这个原则是非常宽松的。一般情况下都不怎么会违背它\n4. 接口隔离原则（ISP）4.1 如何理解“接口隔离原则”？接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为 ISP。Robert Martin 在 SOLID 原则中是这样定义它的：\n\n\n\n\n\n\n\n\n\nClients should not be forced to depend upon interfaces that they do not use.客户端不应该强迫依赖它不需要的接口\n其中的“客户端”，可以理解为接口的调用者或者使用者\n实际上，“接口”这个名词可以用在很多场合中。在软件开发中，既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的 API 接口，还可以特指面向对象编程语言中的接口等。理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，可以把“接口”理解为下面三种东西：\n\n一组 API 接口集合\n单个 API 接口或函数\nOOP 中的接口概念\n\n4.1.1 把“接口”理解为一组 API 接口集合如下例，微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：\npublic interface UserService &#123;\n    boolean register(String cellphone, String password);\n    boolean login(String cellphone, String password);\n    UserInfo getUserInfoById(long id);\n    UserInfo getUserInfoByCellphone(String cellphone);\n&#125;\npublic class UserServiceImpl implements UserService &#123;\n    &#x2F;&#x2F;...\n&#125;\n\n现在，后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候该如何来做呢？可能会说只需要在 UserService 中新添加一个 deleteUserByCellphone() 或 deleteUserById() 接口就可以了。这个方法可以解决问题，但是也隐藏了一些安全隐患\n删除用户是一个非常慎重的操作，只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果把它放到 UserService 中，那所有使用到 UserService的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户\n当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。不过，如果暂时没有鉴权框架来支持，还可以从代码设计的层面，尽量避免接口被误用。参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。具体的代码实现如下所示：\npublic interface UserService &#123;\n    boolean register(String cellphone, String password);\n    boolean login(String cellphone, String password);\n    UserInfo getUserInfoById(long id);\n    UserInfo getUserInfoByCellphone(String cellphone);\n&#125;\npublic interface RestrictedUserService &#123;\n    boolean deleteUserByCellphone(String cellphone);\n    boolean deleteUserById(long id);\n&#125;\npublic class UserServiceImpl implements UserService, RestrictedUserService &#123;\n    &#x2F;&#x2F; ... 省略实现代码...\n&#125;\n\n在刚刚的这个例子中，把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口\n4.1.2 把“接口”理解为单个 API 接口或函数把接口理解为单个接口或函数（这里简称为“函数”）。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。如下例：\npublic class Statistics &#123;\n    private Long max;\n    private Long min;\n    private Long average;\n    private Long sum;\n    private Long percentile99;\n    private Long percentile999;\n    &#x2F;&#x2F;... 省略 constructor&#x2F;getter&#x2F;setter 等方法...\n&#125;\npublic Statistics count(Collection&lt;Long&gt; dataSet) &#123;\n    Statistics statistics &#x3D; new Statistics();\n    &#x2F;&#x2F;... 省略计算逻辑...\n    return statistics;\n&#125;\n\n在上面的代码中，count() 函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。按照接口隔离原则，应该把 count() 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：\npublic Long max(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;\npublic Long min(Collection&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;\npublic Long average(Colletion&lt;Long&gt; dataSet) &#123; &#x2F;&#x2F;... &#125;\n&#x2F;&#x2F; ... 省略其他统计函数...\n\n不过在某种意义上讲，count() 函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。在讲单一职责原则的时候，也提到过类似的问题。实际上，判定功能是否单一，除了很强的主观性，还需要结合具体的场景\n如果在项目中，对每个统计需求，Statistics 定义的那几个统计信息都有涉及，那 count() 函数的设计就是合理的。相反，如果每个统计需求只涉及 Statistics 罗列的统计信息中一部分，比如，有的只需要用到 max、min、average 这三类统计信息，有的只需要用到 average、sum。而 count() 函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。所以，在这个应用场景下，count() 函数的设计就有点不合理了，应该按照第二种设计思路，将其拆分成粒度更细的多个统计函数\n这里可以发现接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一\n4.1.3 把“接口”理解为 OOP 中的接口概念把“接口”理解为 OOP 中的接口概念，比如 Java 中的 interface，如下例：\n假设项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig。如下所示：\npublic class RedisConfig &#123;\n    private ConfigSource configSource; &#x2F;&#x2F; 配置中心（比如 zookeeper）\n    private String address;\n    private int timeout;\n    private int maxTotal;\n    &#x2F;&#x2F; 省略其他配置: maxWaitMillis,maxIdle,minIdle...\n\n    public RedisConfig(ConfigSource configSource) &#123;\n        this.configSource &#x3D; configSource;\n    &#125;\n    public String getAddress() &#123;\n        return this.address;\n    &#125;\n    &#x2F;&#x2F;... 省略其他 get()、init() 方法...\n    public void update() &#123;\n        &#x2F;&#x2F; 从 configSource 加载配置到 address&#x2F;timeout&#x2F;maxTotal...\n    &#125;\n&#125;\npublic class KafkaConfig &#123; &#x2F;&#x2F;... 省略... &#125;\npublic class MysqlConfig &#123; &#x2F;&#x2F;... 省略... &#125;\n\n现在，有一个新的功能需求，希望支持 Redis 和 Kafka 配置信息的热更新。所谓“热更新（hot update）”就是，如果在配置中心中更改了配置信息，希望在不用重启系统的情况下，能将最新的配置信息加载到内存中（也就是 RedisConfig、KafkaConfig 类中）。但是，因为某些原因，并不希望对 MySQL 的配置信息进行热更新\n为了实现这样一个功能需求，设计实现了一个 ScheduledUpdater 类，以固定时间频率（periodInSeconds）来调用 RedisConfig、KafkaConfig 的 update() 方法更新配置信息。具体的代码实现如下所示：\npublic interface Updater &#123;\n    void update();\n&#125;\npublic class RedisConfig implemets Updater &#123;\n    &#x2F;&#x2F;... 省略其他属性和方法...\n    @Override\n    public void update() &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class KafkaConfig implements Updater &#123;\n    &#x2F;&#x2F;... 省略其他属性和方法...\n    @Override\n    public void update() &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class MysqlConfig &#123; &#x2F;&#x2F;... 省略其他属性和方法... &#125;\n\npublic class ScheduledUpdater &#123;\n    private final ScheduledExecutorService executor &#x3D; Executors.newSingleThread\n    private long initialDelayInSeconds;\n    private long periodInSeconds;\n    private Updater updater;\n\n    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) &#123;\n        this.updater &#x3D; updater;\n        this.initialDelayInSeconds &#x3D; initialDelayInSeconds;\n        this.periodInSeconds &#x3D; periodInSeconds;\n    &#125;\n\n    public void run() &#123;\n        executor.scheduleAtFixedRate(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                updater.update();\n            &#125;\n        &#125;, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS)\n    &#125;\n&#125;\n\npublic class Application &#123;\n    ConfigSource configSource &#x3D; new ZookeeperConfigSource(&#x2F;* 省略参数 *&#x2F;);\n    public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource);\n    public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource);\n    public static final MySqlConfig mysqlConfig &#x3D; new MysqlConfig(configSource);\n\n    public static void main(String[] args) &#123;\n        ScheduledUpdater redisConfigUpdater &#x3D; new ScheduledUpdater(redisConfig, 300);\n        redisConfigUpdater.run();\n        ScheduledUpdater kafkaConfigUpdater &#x3D; new ScheduledUpdater(kafkaConfig, 60);\n        redisConfigUpdater.run();\n    &#125;\n&#125;\n\n刚刚的热更新的需求已经搞定了。现在，又有了一个新的监控功能需求。通过命令行来查看 Zookeeper 中的配置信息是比较麻烦的。所以，希望能有一种更加方便的配置信息查看方式\n可以在项目中开发一个内嵌的 SimpleHttpServer，输出项目的配置信息到一个固定的 HTTP 地址，比如：http://127.0.0.1:2389/config 。只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。不过，出于某些原因，只想暴露 MySQL 和 Redis 的配置信息，不想暴露 Kafka 的配置信息。为了实现这样一个功能，还需要对上面的代码做进一步改造。改造之后的代码如下所示：\npublic interface Updater &#123;\n    void update();\n&#125;\npublic interface Viewer &#123;\n    String outputInPlainText();\n    Map&lt;String, String&gt; output();\n&#125;\n\npublic class RedisConfig implemets Updater, Viewer &#123;\n    &#x2F;&#x2F;... 省略其他属性和方法...\n    @Override\n    public void update() &#123; &#x2F;&#x2F;... &#125;\n    @Override\n    public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;\n    @Override\n    public Map&lt;String, String&gt; output() &#123; &#x2F;&#x2F;...&#125;\n&#125;\n\npublic class KafkaConfig implements Updater &#123;\n    &#x2F;&#x2F;... 省略其他属性和方法...\n    @Override\n    public void update() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\npublic class MysqlConfig implements Viewer &#123;\n    &#x2F;&#x2F;... 省略其他属性和方法...\n    @Override\n    public String outputInPlainText() &#123; &#x2F;&#x2F;... &#125;\n    @Override\n    public Map&lt;String, String&gt; output () &#123; &#x2F;&#x2F;...&#125;\n&#125;\n\npublic class SimpleHttpServer &#123;\n    private String host;\n    private int port;\n    private Map&lt;String, List&lt;Viewer&gt;&gt; viewers &#x3D; new HashMap&lt;&gt;();\n\n    public SimpleHttpServer(String host, int port) &#123;&#x2F;&#x2F;...&#125;\n    public void addViewers (String urlDirectory, Viewer viewer)&#123;\n        if (!viewers.containsKey(urlDirectory)) &#123;\n            viewers.put(urlDirectory, new ArrayList&lt;Viewer&gt;());\n        &#125;\n        this.viewers.get(urlDirectory).add(viewer);\n    &#125;\n    public void run () &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\npublic class Application &#123;\n    ConfigSource configSource &#x3D; new ZookeeperConfigSource();\n    public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource)\n    public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource)\n    public static final MySqlConfig mysqlConfig &#x3D; new MySqlConfig(configSource)\n\n    public static void main(String[] args) &#123;\n        ScheduledUpdater redisConfigUpdater &#x3D; new ScheduledUpdater(redisConfig, 300, 300);\n        redisConfigUpdater.run();\n        ScheduledUpdater kafkaConfigUpdater &#x3D; new ScheduledUpdater(kafkaConfig, 60, 60);\n        redisConfigUpdater.run();\n        SimpleHttpServer simpleHttpServer &#x3D; new SimpleHttpServer(“ 127.0 .0 .1”,2\n        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, redisConfig);\n        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, mysqlConfig);\n        simpleHttpServer.run();\n    &#125;\n&#125;\n\n至此，热更新和监控的需求就都实现了。设计了两个功能非常单一的接口：Updater 和 Viewer。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则\n如果不遵守接口隔离原则，不设计 Updater 和 Viewer 两个小接口，而是设计一个大而全的 Config 接口，让 RedisConfig、KafkaConfig、MysqlConfig 都实现这个 Config 接口，并且将原来传递给 ScheduledUpdater 的 Updater 和传递给 SimpleHttpServer 的 Viewer，都替换为 Config，那会有什么问题呢？先看一下按照这个思路来实现的代码是什么样的\npublic interface Config &#123;\n    void update();\n    String outputInPlainText();\n    Map&lt;String, String&gt; output();\n&#125;\npublic class RedisConfig implements Config &#123;\n    &#x2F;&#x2F;... 需要实现 Config 的三个接口 update&#x2F;outputIn...&#x2F;output\n&#125;\npublic class KafkaConfig implements Config &#123;\n    &#x2F;&#x2F;... 需要实现 Config 的三个接口 update&#x2F;outputIn...&#x2F;output\n&#125;\npublic class MysqlConfig implements Config &#123;\n    &#x2F;&#x2F;... 需要实现 Config 的三个接口 update&#x2F;outputIn...&#x2F;output\n&#125;\n\npublic class ScheduledUpdater &#123;\n    &#x2F;&#x2F;... 省略其他属性和方法..\n    private Config config;\n\n    public ScheduleUpdater(Config config, long initialDelayInSeconds, long period) &#123;\n        this.config &#x3D; config;\n        &#x2F;&#x2F;...\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class SimpleHttpServer &#123;\n    private String host;\n    private int port;\n    private Map&lt;String, List&lt;Config&gt;&gt; viewers &#x3D; new HashMap&lt;&gt;();\n\n    public SimpleHttpServer(String host, int port) &#123;&#x2F;&#x2F;...&#125;\n    public void addViewer (String urlDirectory, Config config)&#123;\n        if (!viewers.containsKey(urlDirectory)) &#123;\n            viewers.put(urlDirectory, new ArrayList&lt;Config&gt;());\n        &#125;\n        viewers.get(urlDirectory).add(config);\n    &#125;\n    public void run () &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\n这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多。为什么这么说呢？主要有两点原因\n1、第一种设计思路更加灵活、易扩展、易复用\n因为 Updater、Viewer 职责更加单一，单一就意味了通用、复用性好。比如，现在又有一个新的需求，开发一个 Metrics 性能统计模块，并且希望将 Metrics 也通过 SimpleHttpServer 显示在网页上，以方便查看。这个时候，尽管 Metrics 跟 RedisConfig 等没有任何关系，但仍然可以让 Metrics 类实现非常通用的 Viewer 接口，复用 SimpleHttpServer 的代码实现。具体的代码如下所示：\npublic class ApiMetrics implements Viewer &#123;&#x2F;&#x2F;...&#125;\npublic class DbMetrics implements Viewer &#123;&#x2F;&#x2F;...&#125;\n\npublic class Application &#123;\n    ConfigSource configSource &#x3D; new ZookeeperConfigSource();\n    public static final RedisConfig redisConfig &#x3D; new RedisConfig(configSource)\n    public static final KafkaConfig kafkaConfig &#x3D; new KakfaConfig(configSource)\n    public static final MySqlConfig mySqlConfig &#x3D; new MySqlConfig(configSource)\n    public static final ApiMetrics apiMetrics &#x3D; new ApiMetrics();\n    public static final DbMetrics dbMetrics &#x3D; new DbMetrics();\n    public static void main(String[] args) &#123;\n        SimpleHttpServer simpleHttpServer &#x3D; new SimpleHttpServer(“127.0.0.1”, 2\n        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, redisConfig);\n        simpleHttpServer.addViewer(&quot;&#x2F;config&quot;, mySqlConfig);\n        simpleHttpServer.addViewer(&quot;&#x2F;metrics&quot;, apiMetrics);\n        simpleHttpServer.addViewer(&quot;&#x2F;metrics&quot;, dbMetrics);\n        simpleHttpServer.run();\n    &#125;\n&#125;\n\n2、第二种设计思路在代码实现上做了一些无用功\n因为 Config 接口中包含两类不相关的接口，一类是 update()，一类是 output() 和 outputInPlainText()。理论上，KafkaConfig 只需要实现 update() 接口，并不需要实现 output() 相关的接口。同理，MysqlConfig 只需要实现 output() 相关接口，并需要实现 update() 接口。但第二种设计思路要求 RedisConfig、KafkaConfig、MySqlConfig 必须同时实现 Config 的所有接口函数（update、output、outputInPlainText）。除此之外，如果要往 Config 中继续添加一个新的接口，那所有的实现类都要改动。相反，如果接口粒度比较小，那涉及改动的类就比较少\n5. 依赖反转（DIP）前面讲到，单一职责原则和开闭原则的原理比较简单，但是，想要在实践中用好却比较难。依赖反转原则正好相反。这个原则用起来比较简单，但概念理解起来比较难。比如如下问题：\n\n“依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两个字该如何理解？\n还有另外两个概念：“控制反转”和“依赖注入”。这两个概念跟“依赖反转”有什么区别和联系呢？它们说的是同一个事情吗？\nSpring 框架中的 IOC 跟这些概念又有什么关系呢？\n\n5.1 控制反转（IOC）控制反转的英文翻译是 Inversion Of Control，缩写为 IOC。如下例：\npublic class UserServiceTest &#123;\n    public static boolean doTest() &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n    public static void main(String[] args) &#123;&#x2F;&#x2F; 这部分逻辑可以放到框架中\n        if (doTest()) &#123;\n            System.out.println(&quot;Test succeed.&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;Test failed.&quot;);\n        &#125;\n    &#125;\n&#125;\n\n在上面的代码中，所有的流程都由程序员来控制。如果抽象出一个下面这样一个框架，再来看如何利用框架来实现同样的功能。具体的代码实现如下所示：\npublic abstract class TestCase &#123;\n    public void run() &#123;\n        if (doTest()) &#123;\n            System.out.println(&quot;Test succeed.&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;Test failed.&quot;);\n        &#125;\n    &#125;\n    public abstract void doTest();\n&#125;\n\npublic class JunitApplication &#123;\n    private static final List&lt;TestCase&gt; testCases &#x3D; new ArrayList&lt;&gt;();\n\n    public static void register(TestCase testCase) &#123;\n        testCases.add(testCase);\n    &#125;\n    public static final void main(String[] args) &#123;\n        for (TestCase case: testCases) &#123;\n            case.run();\n        &#125;\n    &#125;\n&#125;\n\n\n把这个简化版本的测试框架引入到工程中之后，只需要在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：\npublic class UserServiceTest extends TestCase &#123;\n    @Override\n    public boolean doTest() &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n&#x2F;&#x2F; 注册操作还可以通过配置的方式来实现，不需要程序员显示调用 register()\nJunitApplication.register(new UserServiceTest();\n\n\n上面这个例子，就是典型的通过框架来实现“控制反转”的例子。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行\n这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架\n实际上，实现控制反转的方法有很多，除了上面所示的类似于模板设计模式的方法之外，还有下面的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计\n5.2 依赖注入（DI）依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。依赖注入的英文翻译是 Dependency Injection，缩写为 DI。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价 25 美元，实际上只值 5 美分的概念。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单\n依赖注入用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用\n如下例，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：\n&#x2F;&#x2F; 非依赖注入实现方式\npublic class Notification &#123;\n    private MessageSender messageSender;\n\n    public Notification() &#123;\n        this.messageSender &#x3D; new MessageSender(); &#x2F;&#x2F; 此处有点像 hardcode\n    &#125;\n    public void sendMessage(String cellphone, String message) &#123;\n        &#x2F;&#x2F;... 省略校验逻辑等...\n        this.messageSender.send(cellphone, message);\n    &#125;\n&#125;\npublic class MessageSender &#123;\n    public void send(String cellphone, String message) &#123;\n        &#x2F;&#x2F;....\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用 Notification\nNotification notification &#x3D; new Notification();\n\n&#x2F;&#x2F; 依赖注入的实现方式\npublic class Notification &#123;\n    private MessageSender messageSender;\n\n    &#x2F;&#x2F; 通过构造函数将 messageSender 传递进来\n    public Notification(MessageSender messageSender) &#123;\n        this.messageSender &#x3D; messageSender;\n    &#125;\n    public void sendMessage(String cellphone, String message) &#123;\n        &#x2F;&#x2F;... 省略校验逻辑等...\n        this.messageSender.send(cellphone, message);\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用 Notification\nMessageSender messageSender &#x3D; new MessageSender();\nNotification notification &#x3D; new Notification(messageSender);\n\n通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，可以灵活地替换依赖的类。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还可以把 MessageSender 定义成接口，基于接口而非实现编程。改造后的代码如下所示：\npublic class Notification &#123;\n    private MessageSender messageSender;\n    public Notification(MessageSender messageSender) &#123;\n        this.messageSender &#x3D; messageSender;\n    &#125;\n    public void sendMessage(String cellphone, String message) &#123;\n        this.messageSender.send(cellphone, message);\n    &#125;\n&#125;\npublic interface MessageSender &#123;\n    void send(String cellphone, String message);\n&#125;\n\n&#x2F;&#x2F; 短信发送类\npublic class SmsSender implements MessageSender &#123;\n    @Override\n    public void send(String cellphone, String message) &#123;\n        &#x2F;&#x2F;....\n    &#125;\n&#125;\n&#x2F;&#x2F; 站内信发送类\npublic class InboxSender implements MessageSender &#123;\n    @Override\n    public void send(String cellphone, String message) &#123;\n        &#x2F;&#x2F;....\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用 Notification\nMessageSender messageSender &#x3D; new SmsSender();\nNotification notification &#x3D; new Notification(messageSender);\n\n实际上，只需要掌握刚刚举的这个例子，就等于完全掌握了依赖注入。尽管依赖注入非常简单，但却非常有用，它是编写可测试性代码最有效的手段\n5.3 依赖注入框架（DI Framework）在采用依赖注入实现的 Notification 类中，虽然不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要程序员自己来实现。具体代码如下所示：\npublic class Demo &#123;\n    public static final void main(String args[]) &#123;\n        MessageSender sender &#x3D; new SmsSender(); &#x2F;&#x2F; 创建对象\n        Notification notification &#x3D; new Notification(sender);&#x2F;&#x2F; 依赖注入\n        notification.sendMessage(&quot;13918942177&quot;, &quot; 短信验证码：2346&quot;);\n    &#125;\n&#125;\n\n在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，完全可以抽象成框架来自动完成\n这个框架就是“依赖注入框架”。只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情\n实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。不过，Spring 框架自己声称是控制反转容器（Inversion Of Control Container）\n实际上，这两种说法都没错。只是控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。因为前面讲到实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。不过这点区分并不是很明显，也不是很重要\n5.4 依赖反转原则（DIP）依赖反转原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。原文如下：\n\n\n\n\n\n\n\n\n\nHigh-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）\n所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。拿 Tomcat这个 Servlet 容器作为例子来解释一下\nTomcat 是运行 Java Web 应用程序的容器。编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范\n6. KISS 原则KISS 原则的英文描述有好几个版本，比如下面这几个：\n\nKeep It Simple and Stupid.\nKeep It Short and Simple.\nKeep It Simple and Straightforward.\n\n不过，仔细看就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单\nKISS 原则算是一个万金油类型的设计原则，可以应用在很多场景中。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、iPhone 手机的设计等等。不过，这里重点讲解如何在编码开发中应用这条原则\n代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单\n不过，这条原则只是告诉我们，要保持代码“Simple and Stupid”，但并没有讲到，什么样的代码才是“Simple and Stupid”的，更没有给出特别明确的方法论，来指导如何开发出“Simple and Stupid”的代码。所以，看着非常简单，但不能落地\n6.1 代码行数越少就越“简单”吗？先看一个例子。下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0\n&#x2F;&#x2F; 第一种实现方式: 使用正则表达式\npublic boolean isValidIpAddressV1(String ipAddress) &#123;\n    if (StringUtils.isBlank(ipAddress)) return false;\n\n    String regex &#x3D; &quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;\n        + &quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n        + &quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n        + &quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;;\n    return ipAddress.matches(regex);\n&#125;\n\n&#x2F;&#x2F; 第二种实现方式: 使用现成的工具类\npublic boolean isValidIpAddressV2(String ipAddress) &#123;\n    if (StringUtils.isBlank(ipAddress)) return false;\n\n    String[] ipUnits &#x3D; StringUtils.split(ipAddress, &#39;.&#39;);\n    if (ipUnits.length !&#x3D; 4) &#123;\n        return false;\n    &#125;\n    for (int i &#x3D; 0; i &lt; 4; ++i) &#123;\n        int ipUnitIntValue;\n        try &#123;\n            ipUnitIntValue &#x3D; Integer.parseInt(ipUnits[i]);\n        &#125; catch (NumberFormatException e) &#123;\n            return false;\n        &#125;\n        if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) &#123;\n            return false;\n        &#125;\n        if (i &#x3D;&#x3D; 0 &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\n&#x2F;&#x2F; 第三种实现方式: 不使用任何工具类\npublic boolean isValidIpAddressV3(String ipAddress) &#123;\n    char[] ipChars &#x3D; ipAddress.toCharArray();\n    int length &#x3D; ipChars.length;\n    int ipUnitIntValue &#x3D; -1;\n    boolean isFirstUnit &#x3D; true;\n    int unitsCount &#x3D; 0;\n\n    for (int i &#x3D; 0; i &lt; length; ++i) &#123;\n        char c &#x3D; ipChars[i];\n        if (c &#x3D;&#x3D; &#39;.&#39;) &#123;\n            if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;\n            if (isFirstUnit &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) return false;\n            if (isFirstUnit) isFirstUnit &#x3D; false;\n        ipUnitIntValue &#x3D; -1;\n        unitsCount++;\n        continue;\n    &#125;\n    if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &#123;\n        return false;\n    &#125;\n    if (ipUnitIntValue &#x3D;&#x3D; -1) ipUnitIntValue &#x3D; 0;\n        ipUnitIntValue &#x3D; ipUnitIntValue * 10 + (c - &#39;0&#39;);\n    &#125;\n    if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) return false;\n    if (unitsCount !&#x3D; 3) return false;\n    return true;\n&#125;\n\n第一种实现方式利用的是正则表达式，只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式\n一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。这种实现方式会导致代码的可读性和可维护性变差，所以，从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则\n第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 bug。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则\n不过可能会说，第三种实现方式虽然实现起来稍微有点复杂，但性能要比第二种实现方式高一些啊。从性能的角度来说，选择第三种实现方式是不是更好些呢？\n一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些\n不过，尽管第三种实现方式性能更高些，但还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显\n6.2 代码逻辑复杂就违背 KISS 原则吗？前面提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？先看下面的代码：\n&#x2F;&#x2F; KMP algorithm: a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度。\npublic static int kmp(char[] a, int n, char[] b, int m) &#123;\n    int[] next &#x3D; getNexts(b, m);\n    int j &#x3D; 0;\n    for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n        while (j &gt; 0 &amp;&amp; a[i] !&#x3D; b[j]) &#123; &#x2F;&#x2F; 一直找到 a[i] 和 b[j]\n            j &#x3D; next[j - 1] + 1;\n        &#125;\n        if (a[i] &#x3D;&#x3D; b[j]) &#123;\n            ++j;\n        &#125;\n        if (j &#x3D;&#x3D; m) &#123; &#x2F;&#x2F; 找到匹配模式串的了\n            return i - m + 1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n\n&#x2F;&#x2F; b 表示模式串，m 表示模式串的长度\nprivate static int[] getNexts(char[] b, int m) &#123;\n    int[] next &#x3D; new int[m];\n    next[0] &#x3D; -1;\n    int k &#x3D; -1;\n    for (int i &#x3D; 1; i &lt; m; ++i) &#123;\n        while (k !&#x3D; -1 &amp;&amp; b[k + 1] !&#x3D; b[i]) &#123;\n            k &#x3D; next[k];\n        &#125;\n        if (b[k + 1] &#x3D;&#x3D; b[i]) &#123;\n            ++k;\n        &#125;\n        next[i] &#x3D; k;\n    &#125;\n    return next;\n&#125;\n\n这段代码完全符合刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。为什么这么说呢？\nKMP 算法以快速高效著称。当需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，就应该选择尽可能高效的 KMP算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则\n不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了\n6.3 如何写出满足 KISS 原则的代码？\n不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等\n不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高\n不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性\n\n实际上，代码是否足够简单是一个挺主观的评判。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单。所以，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化\n在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力\n7. YAGNIYAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计\n比如，系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，没必要提前编写这部分代码。当然，这并不是说就不需要考虑代码的扩展性。还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码\n再比如，不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的\nYAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）\n8. DRY 原则英文描述为：Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码\n但只要两段代码长得一样，那就是违反 DRY 原则了吗？答案是否定的。这是很多人对这条原则存在的误解。实际上，重复的代码不一定违反 DRY 原则，而且有些看似不重复的代码也有可能违反 DRY 原则。三种典型的代码重复情况，它们分别是：\n\n实现逻辑重复\n功能语义重复\n代码执行重复\n\n这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了\n8.1 实现逻辑重复public class UserAuthenticator &#123;\n    public void authenticate(String username, String password) &#123;\n        if (!isValidUsername(username)) &#123;\n            &#x2F;&#x2F; ...throw InvalidUsernameException...\n        &#125;\n        if (!isValidPassword(password)) &#123;\n            &#x2F;&#x2F; ...throw InvalidPasswordException...\n        &#125;\n        &#x2F;&#x2F;... 省略其他代码...\n    &#125;\n    private boolean isValidUsername(String username) &#123;\n        &#x2F;&#x2F; check not null, not empty\n        if (StringUtils.isBlank(username)) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; check length: 4~64\n        int length &#x3D; username.length();\n        if (length &lt; 4 || length &gt; 64) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; contains only lowcase characters\n        if (!StringUtils.isAllLowerCase(username)) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; contains only a~z,0~9,dot\n        for (int i &#x3D; 0; i &lt; length; ++i) &#123;\n            char c &#x3D; username.charAt(i);\n            if (!(c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) || (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) || c &#x3D;&#x3D; &#39;.&#39;) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n    private boolean isValidPassword(String password) &#123;\n        &#x2F;&#x2F; check not null, not empty\n        if (StringUtils.isBlank(password)) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; check length: 4~64\n        int length &#x3D; password.length();\n        if (length &lt; 4 || length &gt; 64) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; contains only lowcase characters\n        if (!StringUtils.isAllLowerCase(password)) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; contains only a~z,0~9,dot\n        for (int i &#x3D; 0; i &lt; length; ++i) &#123;\n            char c &#x3D; password.charAt(i);\n            if (!(c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) || (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) || c &#x3D;&#x3D; &#39;.&#39;) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\n在上面的代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：\npublic class UserAuthenticatorV2 &#123;\n    public void authenticate(String userName, String password) &#123;\n        if (!isValidUsernameOrPassword(userName)) &#123;\n            &#x2F;&#x2F; ...throw InvalidUsernameException...\n        &#125;\n        if (!isValidUsernameOrPassword(password)) &#123;\n            &#x2F;&#x2F; ...throw InvalidPasswordException...\n        &#125;\n    &#125;\n    private boolean isValidUsernameOrPassword(String usernameOrPassword) &#123;\n        &#x2F;&#x2F; 省略实现逻辑\n        &#x2F;&#x2F; 跟原来的 isValidUsername() 或 isValidPassword() 的实现逻辑一样...\n        return true;\n    &#125;\n&#125;\n\n经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的\n单从名字上看就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题\n因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和isValidPassword() 的实现逻辑就会不相同。就要把合并后的函数，重新拆成合并前的那两个函数\n尽管代码的实现逻辑是相同的，但语义不同，判定它并不违反 DRY 原则。对于包含重复代码的问题，可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a~z、0~9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数\n8.2 功能语义重复在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的\n之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样用来校验 IP 地址是否合法的 checkIfIpValid() 函数。那在同一项目代码中，存在如下两个函数，是否违反 DRY 原则呢？\npublic boolean isValidIp(String ipAddress) &#123;\n    if (StringUtils.isBlank(ipAddress)) return false;\n    String regex &#x3D; &quot;^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.&quot;\n        + &quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n        + &quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.&quot;\n        + &quot;(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$&quot;;\n    return ipAddress.matches(regex);\n&#125;\n\npublic boolean checkIfIpValid(String ipAddress) &#123;\n    if (StringUtils.isBlank(ipAddress)) return false;\n    String[] ipUnits &#x3D; StringUtils.split(ipAddress, &#39;.&#39;);\n    if (ipUnits.length !&#x3D; 4) &#123;\n        return false;\n    &#125;\n    for (int i &#x3D; 0; i &lt; 4; ++i) &#123;\n        int ipUnitIntValue;\n        try &#123;\n            ipUnitIntValue &#x3D; Integer.parseInt(ipUnits[i]);\n        &#125; catch (NumberFormatException e) &#123;\n            return false;\n        &#125;\n        if (ipUnitIntValue &lt; 0 || ipUnitIntValue &gt; 255) &#123;\n            return false;\n        &#125;\n        if (i &#x3D;&#x3D; 0 &amp;&amp; ipUnitIntValue &#x3D;&#x3D; 0) &#123;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\n这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，认为它违反了 DRY 原则。应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数\n假设不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题\n除此之外，如果哪天项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，对 isValidIp() 的实现逻辑做了相应的修改，但却忘记了修改 checkIfIpValid() 函数。又或者，压根就不知道还存在一个功能相同的 checkIfIpValid() 函数，这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug\n8.3 代码执行重复前两个例子一个是实现逻辑重复，一个是语义重复，再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：\npublic class UserService &#123;\n    private UserRepo userRepo;&#x2F;&#x2F; 通过依赖注入或者 IOC 框架注入\n    public User login(String email, String password) &#123;\n        boolean existed &#x3D; userRepo.checkIfUserExisted(email, password);\n        if (!existed) &#123;\n            &#x2F;&#x2F; ... throw AuthenticationFailureException...\n        &#125;\n        User user &#x3D; userRepo.getUserByEmail(email);\n        return user;\n    &#125;\n&#125;\n\npublic class UserRepo &#123;\n    public boolean checkIfUserExisted(String email, String password) &#123;\n        if (!EmailValidation.validate(email)) &#123;\n            &#x2F;&#x2F; ... throw InvalidEmailException...\n        &#125;\n        if (!PasswordValidation.validate(password)) &#123;\n            &#x2F;&#x2F; ... throw InvalidPasswordException...\n        &#125;\n        &#x2F;&#x2F;...query db to check if email&amp;password exists...\n    &#125;\n    public User getUserByEmail(String email) &#123;\n        if (!EmailValidation.validate(email)) &#123;\n            &#x2F;&#x2F; ... throw InvalidEmailException...\n        &#125;\n        &#x2F;&#x2F;...query db to get user by email...\n    &#125;\n&#125;\n\n上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复”。我们一块儿来看下，到底哪些代码被重复执行了？\n重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了\n除此之外，代码中还有一处比较隐蔽的执行重复，实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功\n实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I&#x2F;O 操作是比较耗时的。在写代码的时候，应当尽量减少这类 I&#x2F;O 操作\n按照刚刚的修改思路，把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：\npublic class UserService &#123;\n    private UserRepo userRepo;&#x2F;&#x2F; 通过依赖注入或者 IOC 框架注入\n    public User login(String email, String password) &#123;\n        if (!EmailValidation.validate(email)) &#123;\n            &#x2F;&#x2F; ... throw InvalidEmailException...\n        &#125;\n        if (!PasswordValidation.validate(password)) &#123;\n            &#x2F;&#x2F; ... throw InvalidPasswordException...\n        &#125;\n        User user &#x3D; userRepo.getUserByEmail(email);\n        if (user &#x3D;&#x3D; null || !password.equals(user.getPassword()) &#123;\n            &#x2F;&#x2F; ... throw AuthenticationFailureException...\n        &#125;\n        return user;\n    &#125;\n&#125;\n\npublic class UserRepo &#123;\n    public boolean checkIfUserExisted(String email, String password) &#123;\n        &#x2F;&#x2F;...query db to check if email&amp;password exists\n    &#125;\n    public User getUserByEmail(String email) &#123;\n        &#x2F;&#x2F;...query db to get user by email...\n    &#125;\n&#125;\n\n8.4 代码复用性（Code Reusability）8.4.1 什么是代码的复用性？首先来区分三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则\n\n代码复用表示一种行为：在开发新功能的时候，尽量复用已经存在的代码\n代码的可复用性表示一段代码可被复用的特性或能力：在编写代码的时候，让代码尽量可复用\nDRY 原则是一条原则：不要写重复的代码\n\n从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的\n“不重复”并不代表“可复用”\n在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事\n“复用”和“可复用性”关注角度不同\n代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类\n尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少\n“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等\n8.4.2 怎么提高代码复用性？\n减少代码耦合对于高度耦合的代码，当希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合\n满足单一职责原则如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用\n模块化这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统\n业务与非业务逻辑分离越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等\n通用代码下沉从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码尽量下沉到更下层\n继承、多态、抽象、封装在讲面向对象特性的时候讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用\n应用模板等设计模式一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用\n\n除了上面这几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性\n8.5 辩证思考和灵活应用实际上，编写可复用的代码并不简单。如果在编写代码的时候，已经有复用的需求场景，那根据复用的需求去开发可复用的代码，可能还不算难。但是，如果当下并没有复用的需求，只是希望现在编写的代码具有可复用的特点，能在未来某个同事开发某个新功能的时候复用得上。在这种没有具体复用需求的情况下，就需要去预测将来代码会如何复用，这就比较有挑战了\n实际上，除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反之前讲到的 YAGNI 原则\n除此之外，有一个著名的原则，叫作“Rule of Three”。这条原则可以用在很多行业和场景中。如果把这个原则用在这里，那就是说，在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用\n也就是说，第一次编写代码的时候，不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，“Rule of Three”中的“Three”并不是真的就指确切的“三”，这里就是指“二”\n9. 迪米特法则（LOD）9.1 何为“高内聚、松耦合”？“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等\n实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。这里以“类”作为这个设计思想的应用对象来展开讲解\n在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持\n什么是“高内聚”？\n所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则\n什么是“松耦合”？\n所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合\n“内聚”和“耦合”之间的关系\n“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。如下图，图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”\n\n图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。只需要测试这一个依赖类是否还能正常工作就行了\n图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当修改这个类的某一个功能代码的时候，会影响依赖它的多个类。需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”\n除此之外，从图中也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多\n9.2 “迪米特法则”理论描述迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。原文如下：\n\n\n\n\n\n\n\n\n\nEach unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.\n每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely”related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）\n大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。这里对刚刚的定义重新描述一下。为了统一，把定义描述中的“模块”替换成了“类”\n\n\n\n\n\n\n\n\n\n不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）\n从上面的描述中，可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情\n9.2.1 不该有直接依赖关系的类之间，不要有依赖如下例，这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：\npublic class NetworkTransporter &#123;\n    &#x2F;&#x2F; 省略属性和其他方法...\n    public Byte[] send(HtmlRequest htmlRequest) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\npublic class HtmlDownloader &#123;\n    private NetworkTransporter transporter;&#x2F;&#x2F; 通过构造函数或 IOC 注入\n    public Html downloadHtml(String url) &#123;\n        Byte[] rawHtml &#x3D; transporter.send(new HtmlRequest(url));\n        return new Html(rawHtml);\n    &#125;\n&#125;\npublic class Document &#123;\n    private Html html;\n    private String url;\n\n    public Document(String url) &#123;\n        this.url &#x3D; url;\n        HtmlDownloader downloader &#x3D; new HtmlDownloader();\n        this.html &#x3D; downloader.downloadHtml(url);\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷\n1、首先来看 NetworkTransporter 类\n作为一个底层网络通信类，它的功能应尽可能通用，而不只是服务于下载 HTML，所以，不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲 NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类\n应该如何进行重构，让 NetworkTransporter 类满足迪米特法则呢？这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。应该把 address 和 content 交给 NetworkTransporter，而非直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：\npublic class NetworkTransporter &#123;\n    &#x2F;&#x2F; 省略属性和其他方法...\n    public Byte[] send(String address, Byte[] data) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n2、再来看 HtmlDownloader 类\n这个类的设计没有问题。不过修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以需要对它做相应的修改，修改后的代码如下所示：\npublic class HtmlDownloader &#123;\n    private NetworkTransporter transporter;&#x2F;&#x2F; 通过构造函数或 IOC 注入\n    &#x2F;&#x2F; HtmlDownloader 这里也要有相应的修改\n    public Html downloadHtml(String url) &#123;\n        HtmlRequest htmlRequest &#x3D; new HtmlRequest(url);\n        Byte[] rawHtml &#x3D; transporter.send(\n                htmlRequest.getAddress(), htmlRequest.getContent().getBytes());\n        return new Html(rawHtml);\n    &#125;\n&#125;\n\n3、最后看下 Document 类\n这个类的问题比较多，主要有三点。第一，构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则\n虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：\npublic class Document &#123;\n    private Html html;\n    private String url;\n    public Document(String url, Html html) &#123;\n        this.html &#x3D; html;\n        this.url &#x3D; url;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 通过一个工厂方法来创建 Document\npublic class DocumentFactory &#123;\n    private HtmlDownloader downloader;\n    public DocumentFactory(HtmlDownloader downloader) &#123;\n        this.downloader &#x3D; downloader;\n    &#125;\n    public Document createDocument(String url) &#123;\n        Html html &#x3D; downloader.downloadHtml(url);\n        return new Document(url, html);\n    &#125;\n&#125;\n\n9.2.2 有依赖关系的类之间，尽量只依赖必要的接口如下例，Serialization 类负责对象的序列化和反序列化\npublic class Serialization &#123;\n    public String serialize(Object object) &#123;\n        String serializedResult &#x3D; ...;\n        &#x2F;&#x2F;...\n        return serializedResult;\n    &#125;\n    public Object deserialize(String str) &#123;\n        Object deserializedResult &#x3D; ...;\n        &#x2F;&#x2F;...\n        return deserializedResult;\n    &#125;\n&#125;\n\n单看这个类的设计，没有一点问题。不过，如果把它放到一定的应用场景里，那就还有继续优化的空间。假设在项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口\n根据这个思路，应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。拆分之后的代码如下所示：\npublic class Serializer &#123;\n    public String serialize(Object object) &#123;\n        String serializedResult &#x3D; ...;\n        ...\n        return serializedResult;\n    &#125;\n&#125;\npublic class Deserializer &#123;\n    public Object deserialize(String str) &#123;\n        Object deserializedResult &#x3D; ...;\n        ...\n        return deserializedResult;\n    &#125;\n&#125;\n\n尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于上面这个例子来说，如果修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，只需要修改一个类即可。在拆分之后，需要修改两个类。显然，这种设计思路的代码改动范围变大了\n如果既不想违背高内聚的设计思想，也不想违背迪米特法则，那该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示：\npublic interface Serializable &#123;\n    String serialize(Object object);\n&#125;\npublic interface Deserializable &#123;\n    Object deserialize(String text);\n&#125;\n\npublic class Serialization implements Serializable, Deserializable &#123;\n    @Override\n    public String serialize(Object object) &#123;\n        String serializedResult &#x3D; ...;\n        ...\n        return serializedResult;\n    &#125;\n    @Override\n    public Object deserialize(String str) &#123;\n        Object deserializedResult &#x3D; ...;\n        ...\n        return deserializedResult;\n    &#125;\n&#125;\npublic class DemoClass_1 &#123;\n    private Serializable serializer;\n    public Demo(Serializable serializer) &#123;\n        this.serializer &#x3D; serializer;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\npublic class DemoClass_2 &#123;\n    private Deserializable deserializer;\n    public Demo(Deserializable deserializer) &#123;\n        this.deserializer &#x3D; deserializer;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n尽管还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是依赖的 Serializable 接口只包含序列化操作，DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求\n实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。实际上，新的设计模式和设计原则就是在大量的实践中，针对开发痛点总结归纳出来的套路\n9.3 辩证思考与灵活应用对应序列化与反序列化这个例子，整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？\n设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，在应用设计原则的时候，一定要具体问题具体分析\n对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，来重新考虑一下这个问题。修改之后的具体的代码如下：\npublic class Serializer &#123; &#x2F;&#x2F; 参看 JSON 的接口定义\n    public String serialize(Object object) &#123; &#x2F;&#x2F;... &#125;\n    public String serializeMap(Map map) &#123; &#x2F;&#x2F;... &#125;\n    public String serializeList(List list) &#123; &#x2F;&#x2F;... &#125;\n\n    public Object deserialize(String objectString) &#123; &#x2F;&#x2F;... &#125;\n    public Map deserializeMap(String mapString) &#123; &#x2F;&#x2F;... &#125;\n    public List deserializeList(String listString) &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\n在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。为了减少耦合和测试工作量，应该按照迪米特法则，将反序列化和序列化的功能隔离开来\n10. 针对业务系统的开发，如何做需求分析和设计？对于一个工程师来说，如果要追求长远发展，就不能一直只把自己放在执行者的角色，不能只是一个代码实现者，还要有独立负责一个系统的能力，能端到端（end to end）开发一个完整的系统。这其中的工作就包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等\n大部分工程师都是做业务开发的。很多工程师都觉得，做业务开发没啥技术含量，没有成长，就是简单的 CRUD，翻译业务逻辑，根本用不上专栏中讲的设计原则、思想、模式\n这里通过一个积分兑换系统的开发实战，一方面展示一个业务系统从需求分析到上线维护的整个开发套路，借此能举一反三地应用到所有其他系统的开发中，另一方面展示在看似没有技术含量的业务开发中，实际上都蕴含了哪些设计原则、思想、模式\n10.1 需求分析积分是一种常见的营销手段，很多产品都会通过它来促进消费、增加用户粘性，比如淘宝积分、信用卡积分、商场消费积分等等。假设你是一家类似淘宝这样的电商平台的工程师，平台暂时还没有积分系统。Leader 希望由你来负责开发这样一个系统，你会如何来做呢？\n作为技术人，该怎么做产品设计呢？首先，一定不要自己一个人闷头想。一方面，这样做很难想全面。另一方面，从零开始设计也比较浪费时间。所以，要学会“借鉴”。爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”\n可以找几个类似的产品，比如淘宝，看看他们是如何设计积分系统的，然后借鉴到自己的产品中。或者可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下“淘宝积分规则”。基于这两个输入，基本上就大致能摸清楚积分系统该如何设计了。除此之外，还要充分了解自己公司的产品，将借鉴来的东西糅合在自己的产品中，并做适当的微创新\n笼统地来讲，积分系统无外乎就两个大的功能点，一个是赚取积分，另一个是消费积分。赚取积分功能包括积分赚取渠道，比如下订单、每日签到、评论等；还包括积分兑换规则，比如订单金额与积分的兑换比例，每日签到赠送多少积分等。消费积分功能包括积分消费渠道，比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等；还包括积分兑换规则，比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等\n上面给出的只是非常笼统、粗糙的功能需求。在实际情况中，肯定还有一些业务细节需要考虑，比如积分的有效期问题。对于这些业务细节，还是那句话，闷头拍脑袋想是想不全面的。以防遗漏，还是要有方法可寻。除了刚刚讲的“借鉴”的思路之外，还可以通过产品的线框图、用户用例（user case ）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点\n用户用例有点儿类似单元测试用例。它侧重情景化，其实就是模拟用户如何使用产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。所以，它包含更多的细节，且更加容易被人理解。比如，有关积分有效期的用户用例，可以进行如下的设计：\n\n用户在获取积分的时候，会告知积分的有效期\n用户在使用积分的时候，会优先使用快过期的积分\n用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）\n用户在查询总可用积分的时候，会排除掉过期的积分\n\n10.1.1 积分赚取和兑换规则积分的赚取渠道包括：下订单、每日签到、评论等\n积分兑换规则可以是比较通用的。比如，签到送 10 积分。再比如，按照订单总金额的 10% 兑换成积分，也就是 100 块钱的订单可以积累 10 积分。除此之外，积分兑换规则也可以是比较细化的。比如，不同的店铺、不同的商品，可以设置不同的积分兑换比例\n对于积分的有效期，可以根据不同渠道，设置不同的有效期。积分到期之后会作废；在消费积分的时候，优先使用快到期的积分\n10.1.2 积分消费和兑换规则积分的消费渠道包括：抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等\n可以根据不同的消费渠道，设置不同的积分兑换规则。比如，积分换算成消费抵扣金额的比例是 10%，也就是 10 积分可以抵扣 1 块钱；100 积分可以兑换 15 块钱的优惠券等\n10.1.3 积分及其明细查询查询用户的总积分，以及赚取积分和消费积分的历史记录\n10.2 系统设计面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，也可以借鉴面向对象设计的四个步骤来做系统设计\n10.2.1 合理地将功能划分到不同模块面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰\n对于前面罗列的所有功能点，有下面三种模块划分方法：\n1、积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中\n这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作\n比如，用户通过下订单赚取积分。订单系统通过异步发送消息或者同步调用接口的方式，告知营销系统订单交易成功。营销系统根据拿到的订单信息，查询订单对应的积分兑换规则（兑换比例、有效期等），计算得到订单可兑换的积分数量，然后调用积分系统的接口给用户增加积分\n2、积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等\n用户下订单成功之后，订单系统根据商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分\n3、所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护\n用户下订单成功之后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分\n怎么判断哪种模块划分合理呢？实际上，可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重\n除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息\n所以，综合考虑，更倾向于第一种和第二种模块划分方式。但是，不管选择这两种中的哪一种，积分系统所负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询\n10.2.2 设计模块与模块之间的交互关系在面向对象设计中，类设计好之后，需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互\n比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好\n比如，用户下订单成功之后，订单系统推送一条消息到消息中间件，营销系统订阅订单成功消息，触发执行相应的积分兑换逻辑。这样订单系统就跟营销系统完全解耦，订单系统不需要知道任何跟积分相关的逻辑，而营销系统也不需要直接跟订单系统交互\n除此之外，上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用\n10.2.3 设计模块的接口、数据库、业务模型完成了模块的功能划分，模块之间的交互的设计，接下来再来看，模块本身如何来设计。实际上，业务系统本身的设计无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计\n10.3 代码实现前面把积分赚取和消费的渠道和规则的管理维护工作，划分到了上层系统中，所以，积分系统的功能变得非常简单。相应地，代码实现也比较简单。如果有一定的项目开发经验，那实现这样一个系统并不是件难事。所以，这里重点并不是如何来实现积分系统的每个功能、每个接口，更不是如何编写 SQL 语句来增删改查数据，而是展示一些更普适的开发思想。比如，为什么要分 MVC 三层来开发？为什么要针对每层定义不同的数据对象？以及这其中都蕴含哪些设计原则和思想，知其然知其所以然，做到真正地透彻理解\n业务开发包括哪些工作？\n实际上，平时做业务系统的设计与开发，无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计（也就是业务逻辑）\n数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。因此，在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意。相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大\n10.3.1 设计数据库数据库的设计比较简单。实际上，只需要一张记录积分流水明细的表就可以了。表中记录积分的赚取和消费流水。用户积分的各种统计数据，比如总积分、总可用积分等，都可以通过这张表来计算得到\n\n10.3.2 设计接口接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，但另一个接口执行失败了）。所以，为了兼顾易用性和性能，可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用\n积分系统需要设计如下这样几个接口：\n\n10.3.3 业务模型的设计从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑，也就是这里说的业务模型\n除此之外，前面还提到两种开发模式，基于贫血模型的传统开发模式和基于充血模型的 DDD 开发模式（见：设计模式之美总结（面向对象篇）_凡 223 的博客）。前者是一种面向过程的编程风格，后者是一种面向对象的编程风格。不管是 DDD 还是 OOP，高级开发模式的存在一般都是为了应对复杂系统，应对系统的复杂性。对于这里要开发的积分系统来说，因为业务相对比较简单，所以，选择简单的基于贫血模型的传统开发模式就足够了\n从开发的角度来说，可以把积分系统作为一个独立的项目，来独立开发，也可以跟其他业务代码（比如营销系统）放到同一个项目中进行开发。从运维的角度来说，可以将它跟其他业务一块部署，也可以作为一个微服务独立部署。具体选择哪种开发和部署方式，可以参考公司当前的技术架构来决定\n实际上，积分系统业务比较简单，代码量也不多，更倾向于将它跟营销系统放到一个项目中开发部署。只要做好代码的模块化和解耦，让积分相关的业务代码跟其他业务代码之间边界清晰，没有太多耦合，后期如果需要将它拆分成独立的项目来开发部署，那也并不困难\n10.4 为什么要分 MVC 三层开发？大部分业务系统的开发都可以分为三层：Contoller 层、Service 层、Repository 层。对于这种分层方式，大部分人都很认同，甚至成为了一种开发习惯，但为什么要分层开发？很多业务都比较简单，一层代码搞定所有的数据读取、业务逻辑、接口暴露不好吗？\n1、分层能起到代码复用的作用\n同一个 Repository 可能会被多个 Service 来调用，同一个 Service 可能会被多个 Controller 调用。比如，UserService 中的 getUserById() 接口封装了通过 ID 获取用户信息的逻辑，这部分逻辑可能会被 UserController 和 AdminController 等多个 Controller 使用。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则\n2、分层能起到隔离变化的作用\n分层体现了一种抽象和封装的设计思想。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当需要替换数据库的时候，比如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动 Repository层的代码，Service 层的代码完全不需要修改\n除此之外，Controller、Service、Repository 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。比如，Repository 层基于数据库表，而数据库表改动的可能性很小，所以 Repository 层的代码最稳定，而 Controller 层提供适配给外部使用的接口，代码经常会变动。分层之后，Controller 层中代码的频繁改动并不会影响到稳定的 Repository 层\n3、分层能起到隔离关注点的作用\nRepository 层只关注数据的读写。Service 层只关注业务逻辑，不关注数据的来源。Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好\n4、分层能提高代码的可测试性\n单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repsitory 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，可以用 mock 的数据源替代真实的数据库，注入到 Service 层代码中\n5、分层能应对系统的复杂性\n所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层\n不管是分层、模块化，还是 OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”\n10.5 BO、VO、Entity 存在的意义是什么？针对 Controller、Service、Repository 三层，每层都会定义相应的数据对象，它们分别是 VO（View Object）、BO（Business Object）、Entity，例如 UserVo、UserBo、UserEntity。在实际的开发中，VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，经常需要重复定义三个几乎一样的类，显然是一种重复劳动\n相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？\n实际上，更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 3 个方面的原因：\n\nVO、BO、Entity 并非完全一样。比如，可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去\nVO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。在前面讲到 DRY 原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题\n为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！\n\n既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？\n从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，对于代码重复的问题，也有一些办法来解决\n继承可以解决代码重复问题。可以将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段。因为这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂\n在讲“多用组合，少用继承”设计思想的时候，提到组合也可以解决代码重复的问题，所以，这里还可以将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码\n代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？\n当下一层的数据通过接口调用传递到上一层之后，需要将它转化成上一层对应的数据对象类型。比如，Service 层从 Repository 层获取的 Entity 之后，将其转化成 BO，再继续业务逻辑的处理。所以，整个开发的过程会涉及“Entity 到 BO”和“BO 到 VO”这两种转化\n最简单的转化方式是手动复制。自己写代码在两个对象之间，一个字段一个字段的赋值。但这样的做法显然是没有技术含量的低级劳动。Java 中提供了多种数据对象转化工具，比如 BeanUtils、Dozer 等（可见：MapStruct 总结_凡 223 的博客），可以大大简化繁琐的对象转化工作。如果是用其他编程语言来做开发，也可以借鉴 Java 这些工具类的设计思路，自己在项目中实现对象转化工具类\nVO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis），还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？\n前面也提到过，Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的 Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的\n不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用\n10.6 用到的设计原则和思想\n    高内聚、松耦合   将不同的功能划分到不同的模块，遵从的划分原则就是尽量让模块本身高内聚，让模块之间松耦合  \n    单一职责原则   模块的设计要尽量职责单一，符合单一职责原则。分层的一个目的也是为了更加符合单一职责原则  \n    依赖注入   在 MVC 三层结构的代码实现中，下一层的类通过依赖注入的方式注入到上一层代码中  \n    依赖反转原则   在业务系统开发中，如果通过类似 Spring IOC 这样的容器来管理对象的创建、生命周期，那就用到了依赖反转原则  \n    基于接口而非实现编程   在 MVC 三层结构的代码实现中，Service 层使用 Repository 层提供的接口，并不关心其底层是依赖的哪种具体的数据库，遵从基于接口而非实现编程的设计思想  \n    封装、抽象   分层体现了抽象和封装的设计思想，能够隔离变化，隔离关注点。尽管 VO、BO、Entity 存在代码重复，但功能语义不同，并不违反 DRY 原则  \n    DRY 与继承和组合   为了解决三者之间的代码重复问题，还用到了继承或组合  \n    DRY 面向对象设计   系统设计的过程可以参照面向对象设计的步骤来做。面向对象设计本质是将合适的代码放到合适的类中。系统设计是将合适的功能放到合适的模块中  \n\n\n11. 针对非业务的通用框架开发，如何做需求分析和设计？11.1 项目背景希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）输出到各种终端（Console 命令行、HTTP 网页、Email、日志文件、自定义输出终端等），以方便查看\n如果开发这样一个通用的框架，应用到各种业务系统中，支持实时计算、查看数据的统计信息，如何设计和实现呢？\n11.2 需求分析性能计数器作为一个跟业务无关的功能，完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。而作为可被复用的框架，除了功能性需求之外，非功能性需求也非常重要。所以，从这两个方面来做需求分析：\n11.2.1 功能性需求分析相对于一大长串的文字描述，人脑更容易理解短的、罗列的比较规整、分门别类的列表信息。显然，刚才那段需求描述不符合这个规律。需要把它拆解成一个一个的“干条条”：\n\n接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等\n统计信息的类型：max、min、avg、percentile、count、tps 等\n统计信息显示格式：Json、Html、自定义显示格式\n统计信息显示终端：Console、Email、HTTP 网页、日志、自定义显示终端\n\n除此之外，还可以借助设计产品的时候，经常用到的线框图，把最终数据的显示样式画出来，会更加一目了然。具体的线框图如下所示：\n\n实际上，从线框图中，还能挖掘出了下面几个隐藏的需求：\n\n统计触发方式：包括主动和被动两种主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户\n统计时间区间：框架需要支持自定义统计时间区间比如统计最近 10 分钟的某接口的 tps、访问次数，或者统计 12 月 11 日 00 点到 12 月 12 日 00 点之间某接口响应时间的最大值、最小值、平均值等\n统计时间间隔：对于主动触发统计，还要支持指定统计时间间隔也就是多久触发一次统计显示。比如，每间隔 10s 统计一次接口信息并显示到命令行中，每间隔 24 小时发送一封统计信息邮件\n\n11.2.2 非功能性需求分析对于这样一个通用的框架的开发，还需要考虑很多非功能性的需求。具体来说有以下几个比较重要的方面：\n\n易用性易用性听起来更像是一个评判产品的标准。在开发这样一个技术框架的时候，也要有产品意识。框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是应该花心思去思考和设计的。有的时候，文档写得好坏甚至都有可能决定一个框架是否受欢迎\n\n性能对于需要集成到业务系统的框架来说，不希望框架本身的代码执行效率，对业务系统有太多性能上的影响。对于性能计数器这个框架来说，一方面，希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间；另一方面，希望框架本身对内存的消耗不能太大\n\n扩展性这里说的扩展性跟之前讲到的代码的扩展性有点类似，都是指在不修改或尽量少修改代码的情况下添加新的功能。但是这两者也有区别。之前讲到的扩展是从框架代码开发者的角度来说的。这里所说的扩展是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。这就有点类似给框架开发插件。如下例：feign 是一个 HTTP 客户端框架，可以在不修改框架源码的情况下，用如下方式来扩展自己的编解码方式、日志、拦截器等\nFeign feign &#x3D; Feign.builder()\n        .logger(new CustomizedLogger())\n        .encoder(new FormEncoder(new JacksonEncoder()))\n        .decoder(new JacksonDecoder())\n        .errorDecoder(new ResponseErrorDecoder())\n        .requestInterceptor(new RequestHeadersInterceptor()).build();\n\npublic class RequestHeadersInterceptor implements RequestInterceptor &#123;\n    @Override\n    public void apply(RequestTemplate template) &#123;\n        template.header(&quot;appId&quot;, &quot;...&quot;);\n        template.header(&quot;version&quot;, &quot;...&quot;);\n        template.header(&quot;timestamp&quot;, &quot;...&quot;);\n        template.header(&quot;token&quot;, &quot;...&quot;);\n        template.header(&quot;idempotent-token&quot;, &quot;...&quot;);\n        template.header(&quot;sequence-id&quot;, &quot;...&quot;);\n    &#125;\n&#125;\n\npublic class CustomizedLogger extends feign.Logger &#123;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class ResponseErrorDecoder implements ErrorDecoder &#123;\n    @Override\n    public Exception decode(String methodKey, Response response) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n容错性对于性能计数器框架来说，不能因为框架本身的异常导致接口请求出错。所以，要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理\n\n通用性为了提高框架的复用性，能够灵活应用到各种场景中。框架在设计的时候，要尽可能通用。要多去思考一下，除了接口统计这样一个需求，还可以适用到其他哪些场景中，比如是否还可以处理其他事件的统计信息，比如 SQL 请求时间的统计信息、业务统计信息（比如支付成功率）等\n\n\n11.3 框架设计对于稍微复杂系统的开发，很多人觉得不知从何开始。作者个人喜欢借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，能够很有效地帮助我缕清更复杂的设计思路，是迭代设计的基础\n这就好比做算法题目。当想要一下子就想出一个最优解法时，可以先写几组测试数据，找找规律，再先想一个最简单的算法去解决它。虽然这个最简单的算法在时间、空间复杂度上可能都不令人满意，但是可以基于此来做优化，这样思路就会更加顺畅\n对于性能计数器这个框架的开发来说，可以先聚焦于一个非常具体、简单的应用场景，比如统计用户注册、登录这两个接口的响应时间的最大值和平均值、接口调用次数，并且将统计结果以 JSON 的格式输出到命令行中。现在这个需求简单、具体、明确，设计实现起来难度降低了很多\n&#x2F;&#x2F; 应用场景：统计下面两个接口 (注册和登录）的响应时间和访问次数\npublic class UserController &#123;\n    public void register(UserVo user) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    public UserVo login(String telephone, String password) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n要输出接口的响应时间的最大值、平均值和接口调用次数，首先要采集每次接口请求的响应时间，并且存储起来，然后按照某个时间间隔做聚合统计，最后才是将结果输出。在原型系统的代码实现中，可以把所有代码都塞到一个类中，暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单怎么来就行\n最小原型的代码实现如下所示。其中，recordResponseTime() 和 recordTimestamp() 两个函数分别用来记录接口请求的响应时间和访问时间。startRepeatedReport() 函数以指定的频率统计数据并输出结果\npublic class Metrics &#123;\n    &#x2F;&#x2F; Map 的 key 是接口名称，value 对应接口请求的响应时间或时间戳；\n    private Map&lt;String, List&lt;Double&gt;&gt; responseTimes &#x3D; new HashMap&lt;&gt;();\n    private Map&lt;String, List&lt;Double&gt;&gt; timestamps &#x3D; new HashMap&lt;&gt;();\n    private ScheduledExecutorService executor &#x3D; Executors.newSingleThreadSchedule;\n\n    public void recordResponseTime(String apiName, double responseTime) &#123;\n        responseTimes.putIfAbsent(apiName, new ArrayList&lt;&gt;());\n        responseTimes.get(apiName).add(responseTime);\n    &#125;\n\n    public void recordTimestamp(String apiName, double timestamp) &#123;\n        timestamps.putIfAbsent(apiName, new ArrayList&lt;&gt;());\n        timestamps.get(apiName).add(timestamp);\n    &#125;\n\n    public void startRepeatedReport(long period, TimeUnit unit) &#123;\n        executor.scheduleAtFixedRate(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                Gson gson &#x3D; new Gson();\n                Map&lt;String, Map&lt;String, Double&gt;&gt; stats &#x3D; new HashMap&lt;&gt;();\n                for (Map.Entry&lt;String, List&lt;Double&gt;&gt; entry : responseTimes.entrySet())\n                    String apiName &#x3D; entry.getKey();\n                    List&lt;Double&gt; apiRespTimes &#x3D; entry.getValue();\n                    stats.putIfAbsent(apiName, new HashMap&lt;&gt;());\n                    stats.get(apiName).put(&quot;max&quot;, max(apiRespTimes));\n                    stats.get(apiName).put(&quot;avg&quot;, avg(apiRespTimes));\n                 &#125;\n                for(Map.Entry&lt;String, List&lt;Double&gt;&gt; entry :timestamps.entrySet()) &#123;\n                    String apiName &#x3D; entry.getKey();\n                    List&lt;Double&gt; apiTimestamps &#x3D; entry.getValue();\n                    stats.putIfAbsent(apiName, new HashMap&lt;&gt;());\n                    stats.get(apiName).put(&quot;count&quot;, (double) apiTimestamps.size());\n                 &#125;\n                System.out.println(gson.toJson(stats));\n            &#125;\n        &#125;,0,period,unit);\n    &#125;\n\n    private double max(List&lt;Double&gt; dataset) &#123; &#x2F;&#x2F; 省略代码实现 &#125;\n    private double avg (List &lt; Double &gt; dataset) &#123; &#x2F;&#x2F; 省略代码实现 &#125;\n&#125;\n\n通过不到 50 行代码就实现了最小原型。接下来再来看，如何用它来统计注册、登录接口的响应时间和访问次数。具体的代码如下所示：\n&#x2F;&#x2F; 应用场景：统计下面两个接口 (注册和登录）的响应时间和访问次数\npublic class UserController &#123;\n    private Metrics metrics &#x3D; new Metrics();\n\n    public UserController() &#123;\n        metrics.startRepeatedReport(60, TimeUnit.SECONDS);\n    &#125;\n    public void register(UserVo user) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n        metrics.recordTimestamp(&quot;regsiter&quot;, startTimestamp);\n        &#x2F;&#x2F;...\n        long respTime &#x3D; System.currentTimeMillis() - startTimestamp;\n        metrics.recordResponseTime(&quot;register&quot;, respTime);\n    &#125;\n    public UserVo login(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n        metrics.recordTimestamp(&quot;login&quot;, startTimestamp);\n        &#x2F;&#x2F;...\n        long respTime &#x3D; System.currentTimeMillis() - startTimestamp;\n        metrics.recordResponseTime(&quot;login&quot;, respTime);\n    &#125;\n&#125;\n\n最小原型的代码实现虽然简陋，但它却帮我们将思路理顺了很多，现在就基于它做最终的框架设计。下面是针对性能计数器框架画的一个粗略的系统设计图。图可以非常直观地体现设计思想，并且能有效地帮助我们释放更多的脑空间，来思考其他细节问题\n\n如图所示，把整个框架分为四个模块：数据采集、存储、聚合统计、显示。每个模块负责的工作简单罗列如下：\n1、数据采集\n负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。数据采集过程要高度容错，不能影响到接口本身的可用性。除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集 API 的时候，也要尽量考虑其易用性\n2、存储\n负责将采集的原始数据保存下来，以便后面做聚合统计。数据的存储方式有多种，比如：Redis、MySQL、HBase、日志、文件、内存等。数据存储比较耗时，为了尽量地减少对接口性能（比如响应时间）的影响，采集和存储的过程异步完成\n3、聚合统计\n负责将原始数据聚合为统计数据，比如：max、min、avg、pencentile、count、tps 等。为了支持更多的聚合统计规则，代码希望尽可能灵活、可扩展\n4、显示\n负责将统计数据以某种格式显示到终端，比如：输出到命令行、邮件、网页、自定义显示终端等\n前面讲到面向对象分析、设计和实现的时候，讲到设计阶段最终输出的是类的设计，同时也讲到，软件设计开发是一个迭代的过程，分析、设计和实现这三个阶段的界限划分并不明显\n11.4 小步快跑、逐步迭代在上面，将整个框架分为数据采集、存储、聚合统计、显示这四个模块。除此之外，关于统计触发方式（主动推送、被动触发统计）、统计时间区间（统计哪一个时间段内的数据）、统计时间间隔（对于主动推送方法，多久统计推送一次）也做了简单的设计\n虽然最小原型为我们奠定了迭代开发的基础，但离我们最终期望的框架的样子还有很大的距离。我自己在写这篇文章的时候，试图去实现上面罗列的所有功能需求，希望写出一个完美的框架，发现这是件挺烧脑的事情，在写代码的过程中，一直有种“脑子不够使”的感觉。我这个有十多年工作经验的人尚且如此，对于没有太多经验的开发者来说，想一下子把所有需求都实现出来，更是一件非常有挑战的事情。一旦无法顺利完成，可能就会有很强的挫败感，就会陷入自我否定的情绪中\n不过，即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没有产出，你的 leader 会因此产生很强的不可控感。对于现在的互联网项目来说，小步快跑、逐步迭代是一种更好的开发模式。所以，应该分多个版本逐步完善这个框架。第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0……版本中继续迭代优化\n针对这个框架的开发，在 v1.0 版本中，暂时只实现下面这些功能。剩下的功能留在 v2.0、v3.0 版本\n\n数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间\n存储：负责将采集的原始数据保存下来，以便之后做聚合统计。数据的存储方式有很多种，暂时只支持 Redis 这一种存储方式，并且，采集与存储两个过程同步执行\n聚合统计：负责将原始数据聚合为统计数据，包括响应时间的最大值、最小值、平均值、99.9 百分位值、99 百分位值，以及接口请求的次数和 tps\n显示：负责将统计数据以某种格式显示到终端，暂时只支持主动推送给命令行和邮件。命令行间隔 n 秒统计显示上 m 秒的数据（比如，间隔 60s 统计上 60s 的数据）。邮件每日统计上日的数据\n\n现在这个版本的需求比之前的要更加具体、简单了，实现起来也更加容易一些。实际上，学会结合具体的需求，做合理的预判、假设、取舍，规划版本的迭代设计开发，也是一个资深工程师必须要具备的能力\n在之前，是把面向对象设计与实现分开来讲解，界限划分比较明显。在实际的软件开发中，这两个过程往往是交叉进行的。一般是先有一个粗糙的设计，然后着手实现，实现的过程发现问题，再回过头来补充修改设计。所以，对于这个框架的开发来说，把设计和实现放到一块来讲解\n最小原型的实现，所有的代码都耦合在一个类中，这显然是不合理的。接下来，就按照之前讲的面向对象设计的几个步骤，来重新划分、设计类\n11.4.1 划分职责进而识别出有哪些类根据需求描述，先大致识别出下面几个接口或类。这一步不难，完全就是翻译需求\n\nMetricsCollector 类负责提供 API，来采集接口请求的原始数据。可以为 MetricsCollector 抽象出一个接口，但这并不是必须的，因为暂时只能想到一个 MetricsCollector 的实现方式\nMetricsStorage 接口负责原始数据存储，RedisMetricsStorage 类实现 MetricsStorage 接口。这样做是为了今后灵活地扩展新的存储方法，比如用 HBase 来存储\nAggregator 类负责根据原始数据计算统计数据\nConsoleReporter 类、EmailReporter 类分别负责以一定频率统计并发送统计数据到命令行和邮件。至于 ConsoleReporter 和 EmailReporter 是否可以抽象出可复用的抽象类，或者抽象出一个公共的接口，暂时还不能确定\n\n11.4.2 定义类及类与类之间的关系接下来就是定义类及属性和方法，定义类与类之间的关系。这两步没法分得很开，所以，将它们合在一起来讲解\n大致地识别出几个核心的类之后，可以先在 IDE 中创建好这几个类，然后开始试着定义它们的属性和方法。在设计类、类与类之间交互的时候，不断地用之前学过的设计原则和思想来审视设计是否合理，比如，是否满足单一职责原则、开闭原则、依赖注入、KISS 原则、DRY 原则、迪米特法则，是否符合基于接口而非实现编程思想，代码是否高内聚、低耦合，是否可以抽象出可复用代码等等\nMetricsCollector 类的定义非常简单，具体代码如下所示。对比最小原型的代码，MetricsCollector 通过引入 RequestInfo 类来封装原始数据信息，用一个采集函数代替了之前的两个函数\npublic class MetricsCollector &#123;\n    private MetricsStorage metricsStorage; &#x2F;&#x2F; 基于接口而非实现编程\n    &#x2F;&#x2F; 依赖注入\n    public MetricsCollector(MetricsStorage metricsStorage) &#123;\n        this.metricsStorage &#x3D; metricsStorage;\n    &#125;\n    &#x2F;&#x2F; 用一个函数代替了最小原型中的两个函数\n    public void recordRequest(RequestInfo requestInfo) &#123;\n        if (requestInfo &#x3D;&#x3D; null || StringUtils.isBlank(requestInfo.getApiName())) &#123;\n            return;\n        &#125;\n        metricsStorage.saveRequestInfo(requestInfo);\n    &#125;\n&#125;\npublic class RequestInfo &#123;\n    private String apiName;\n    private double responseTime;\n    private long timestamp;\n    &#x2F;&#x2F;... 省略 constructor&#x2F;getter&#x2F;setter 方法...\n&#125;\n\nMetricsStorage 类和 RedisMetricsStorage 类的属性和方法也比较明确。具体的代码实现如下所示。注意，一次性取太长时间区间的数据，可能会导致拉取太多的数据到内存中，有可能会撑爆内存。对于 Java 来说，就有可能会触发 OOM（Out Of Memory）。而且，即便不出现 OOM，内存还够用，但也会因为内存吃紧，导致频繁的 Full GC，进而导致系统接口请求处理变慢，甚至超时\npublic interface MetricsStorage &#123;\n    void saveRequestInfo(RequestInfo requestInfo);\n    List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimeInMillis, long endTimeInMillis);\n    Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimeInMillis, long endTimeInMillis);\n&#125;\n\npublic class RedisMetricsStorage implements MetricsStorage &#123;\n    &#x2F;&#x2F;... 省略属性和构造函数等...\n    @Override\n    public void saveRequestInfo(RequestInfo requestInfo) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    @Override\n    public List&lt;RequestInfo&gt; getRequestInfos(String apiName, long startTimestamp) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    @Override\n    public Map&lt;String, List&lt;RequestInfo&gt;&gt; getRequestInfos(long startTimestamp, long endTimeInMillis) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nMetricsCollector 类和 MetricsStorage 类的设计思路比较简单，不同的人给出的设计结果应该大差不差。但是，统计和显示这两个功能就不一样了，可以有多种设计思路。实际上，如果把统计显示所要完成的功能逻辑细分一下的话，主要包含下面 4 点：\n\n根据给定的时间区间，从数据库中拉取数据\n根据原始数据，计算得到统计数据\n将统计数据显示到终端（命令行或邮件）\n定时触发以上 3 个过程的执行\n\n实际上，如果用一句话总结一下的话，面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。所以，现在要做的工作就是，把以上的 4 个功能逻辑划分到几个类中。划分的方法有很多种，比如，可以把前两个逻辑放到一个类中，第 3 个逻辑放到另外一个类中，第 4 个逻辑作为上帝类（God Class）组合前面两个类来触发前 3 个逻辑的执行。当然，也可以把第 2 个逻辑单独放到一个类中，第 1、3、4 都放到另外一个类中\n至于到底选择哪种排列组合方式，判定的标准是，让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等之前讲到的各种设计原则和思想，尽量地让设计满足代码易复用、易读、易扩展、易维护\n这里暂时选择把第 1、3、4 逻辑放到 ConsoleReporter 或 EmailReporter 类中，把第 2 个逻辑放到 Aggregator 类中。其中，Aggregator 类负责的逻辑比较简单，把它设计成只包含静态方法的工具类。具体的代码实现如下所示：\npublic class Aggregator &#123;\n    public static RequestStat aggregate(List&lt;RequestInfo&gt; requestInfos, long duration) &#123;\n        double maxRespTime &#x3D; Double.MIN_VALUE;\n        double minRespTime &#x3D; Double.MAX_VALUE;\n        double avgRespTime &#x3D; -1;\n        double p999RespTime &#x3D; -1;\n        double p99RespTime &#x3D; -1;\n        double sumRespTime &#x3D; 0;\n        long count &#x3D; 0;\n\n        for (RequestInfo requestInfo : requestInfos) &#123;\n            ++count;\n            double respTime &#x3D; requestInfo.getResponseTime();\n            if (maxRespTime &lt; respTime) &#123;\n                maxRespTime &#x3D; respTime;\n            &#125;\n            if (minRespTime &gt; respTime) &#123;\n                minRespTime &#x3D; respTime;\n            &#125;\n            sumRespTime +&#x3D; respTime;\n        &#125;\n        if (count !&#x3D; 0) &#123;\n            avgRespTime &#x3D; sumRespTime &#x2F; count;\n        &#125;\n        long tps &#x3D; (long) (count &#x2F; durationInMillis * 1000);\n        Collections.sort(requestInfos, new Comparator&lt;RequestInfo&gt;() &#123;\n            @Override\n            public int compare(RequestInfo o1, RequestInfo o2) &#123;\n                double diff &#x3D; o1.getResponseTime() - o2.getResponseTime();\n                if (diff &lt; 0.0) &#123;\n                    return -1;\n                &#125; else if (diff &gt; 0.0) &#123;\n                    return 1;\n                &#125; else &#123;\n                    return 0;\n                &#125;\n            &#125;\n        &#125;);\n        int idx999 &#x3D; (int) (count * 0.999);\n        int idx99 &#x3D; (int) (count * 0.99);\n        if (count !&#x3D; 0) &#123;\n            p999RespTime &#x3D; requestInfos.get(idx999).getResponseTime();\n            p99RespTime &#x3D; requestInfos.get(idx99).getResponseTime();\n        &#125;\n        RequestStat requestStat &#x3D; new RequestStat();\n        requestStat.setMaxResponseTime(maxRespTime);\n        requestStat.setMinResponseTime(minRespTime);\n        requestStat.setAvgResponseTime(avgRespTime);\n        requestStat.setP999ResponseTime(p999RespTime);\n        requestStat.setP99ResponseTime(p99RespTime);\n        requestStat.setCount(count);\n        requestStat.setTps(tps);\n        return requestStat;\n    &#125;\n&#125;\n\npublic class RequestStat &#123;\n    private double maxResponseTime;\n    private double minResponseTime;\n    private double avgResponseTime;\n    private double p999ResponseTime;\n    private double p99ResponseTime;\n    private long count;\n    private long tps;\n    &#x2F;&#x2F;... 省略 getter&#x2F;setter 方法...\n&#125;\n\nConsoleReporter 类相当于一个上帝类，定时根据给定的时间区间，从数据库中取出数据，借助 Aggregator 类完成统计工作，并将统计结果输出到命令行。具体的代码实现如下所示：\npublic class ConsoleReporter &#123;\n    private MetricsStorage metricsStorage;\n    private ScheduledExecutorService executor;\n\n    public ConsoleReporter(MetricsStorage metricsStorage) &#123;\n        this.metricsStorage &#x3D; metricsStorage;\n        this.executor &#x3D; Executors.newSingleThreadScheduledExecutor();\n    &#125;\n\n    &#x2F;&#x2F; 第 4 个代码逻辑：定时触发第 1、2、3 代码逻辑的执行；\n    public void startRepeatedReport(long periodInSeconds, long durationInSeconds) &#123;\n        executor.scheduleAtFixedRate(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                &#x2F;&#x2F; 第 1 个代码逻辑：根据给定的时间区间，从数据库中拉取数据；\n                long durationInMillis &#x3D; durationInSeconds * 1000;\n                long endTimeInMillis &#x3D; System.currentTimeMillis();\n                long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;\n                Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;\n                        metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n                Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();\n                for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet) &#123;\n                    String apiName &#x3D; entry.getKey();\n                    List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();\n                    &#x2F;&#x2F; 第 2 个代码逻辑：根据原始数据，计算得到统计数据；\n                    RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);\n                    stats.put(apiName, requestStat);\n                &#125;\n                &#x2F;&#x2F; 第 3 个代码逻辑：将统计数据显示到终端（命令行或邮件）；\n                System.out.println(&quot;Time Span: [&quot;+startTimeInMillis +&quot;, &quot;+endTimeInmillis);\n                Gson gson &#x3D; new Gson();\n                System.out.println(gson.toJson(stats));\n            &#125;\n        &#125;,0,periodInSeconds,TimeUnit.SECONDS);\n    &#125;\n&#125;\n\npublic class EmailReporter &#123;\n    private static final Long DAY_HOURS_IN_SECONDS &#x3D; 86400L;\n    private MetricsStorage metricsStorage;\n    private EmailSender emailSender;\n    private List&lt;String&gt; toAddresses &#x3D; new ArrayList&lt;&gt;();\n\n    public EmailReporter(MetricsStorage metricsStorage) &#123;\n        this(metricsStorage, new EmailSender(&#x2F;* 省略参数 *&#x2F;));\n    &#125;\n\n    public EmailReporter(MetricsStorage metricsStorage, EmailSender emailSender) &#123;\n        this.metricsStorage &#x3D; metricsStorage;\n        this.emailSender &#x3D; emailSender;\n    &#125;\n\n    public void addToAddress(String address) &#123;\n        toAddresses.add(address);\n    &#125;\n\n    public void startDailyReport() &#123;\n        Calendar calendar &#x3D; Calendar.getInstance();\n        calendar.add(Calendar.DATE, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        Date firstTime &#x3D; calendar.getTime();\n        Timer timer &#x3D; new Timer();\n        timer.schedule(new TimerTask() &#123;\n            @Override\n            public void run() &#123;\n                long durationInMillis &#x3D; DAY_HOURS_IN_SECONDS * 1000;\n                long endTimeInMillis &#x3D; System.currentTimeMillis();\n                long startTimeInMillis &#x3D; endTimeInMillis - durationInMillis;\n                Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos &#x3D;\n                        metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n                Map&lt;String, RequestStat&gt; stats &#x3D; new HashMap&lt;&gt;();\n                for (Map.Entry&lt;String, List&lt;RequestInfo&gt;&gt; entry : requestInfos.entrySet) &#123;\n                    String apiName &#x3D; entry.getKey();\n                    List&lt;RequestInfo&gt; requestInfosPerApi &#x3D; entry.getValue();\n                    RequestStat requestStat &#x3D; Aggregator.aggregate(requestInfosPerApi, durationInMillis);\n                    stats.put(apiName, requestStat);\n                &#125;\n                &#x2F;&#x2F; TODO: 格式化为 html 格式，并且发送邮件\n            &#125;\n        &#125;, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n    &#125;\n&#125;\n\n11.4.3 将类组装起来并提供执行入口因为这个框架稍微有些特殊，有两个执行入口：一个是 MetricsCollector 类，提供了一组 API 来采集原始数据；另一个是 ConsoleReporter 类和 EmailReporter 类，用来触发统计显示。框架具体的使用方式如下所示：\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        MetricsStorage storage &#x3D; new RedisMetricsStorage();\n        ConsoleReporter consoleReporter &#x3D; new ConsoleReporter(storage);\n        consoleReporter.startRepeatedReport(60, 60);\n\n        EmailReporter emailReporter &#x3D; new EmailReporter(storage);\n        emailReporter.addToAddress(&quot;wangzheng@xzg.com&quot;);\n        emailReporter.startDailyReport();\n\n        MetricsCollector collector &#x3D; new MetricsCollector(storage);\n        collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));\n        collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));\n        collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));\n        collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));\n        collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));\n        try &#123;\n            Thread.sleep(100000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n11.4.4 Review 设计与实现前面讲到了 SOLID、KISS、DRY、YAGNI、LOD 等设计原则，基于接口而非实现编程、多用组合少用继承、高内聚低耦合等设计思想。现在就来看下，上面的代码实现是否符合这些设计原则和思想\n1、MetricsCollector\nMetricsCollector 负责采集和存储数据，职责相对来说还算比较单一。它基于接口而非实现编程，通过依赖注入的方式来传递 MetricsStorage 对象，可以在不需要修改代码的情况下，灵活地替换不同的存储方式，满足开闭原则\n2、MetricsStorage、RedisMetricsStorage\nMetricsStorage 和 RedisMetricsStorage 的设计比较简单。当需要实现新的存储方式的时候，只需要实现 MetricsStorage 接口即可。因为所有用到 MetricsStorage 和 RedisMetricsStorage 的地方，都是基于相同的接口函数来编程的，所以，除了在组装类的地方有所改动（从 RedisMetricsStorage 改为新的存储实现类），其他接口函数调用的地方都不需要改动，满足开闭原则\n3、Aggregator\nAggregator 类是一个工具类，里面只有一个静态函数，有 50 行左右的代码量，负责各种统计数据的计算。当需要扩展新的统计功能的时候，需要修改 aggregate() 函数代码，并且一旦越来越多的统计功能添加进来之后，这个函数的代码量会持续增加，可读性、可维护性就变差了。所以，从刚刚的分析来看，这个类的设计可能存在职责不够单一、不易扩展等问题，需要在之后的版本中，对其结构做优化\n4、ConsoleReporter、EmailReporter\nConsoleReporter 和 EmailReporter 中存在代码重复问题。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了 DRY 原则。而且整个类负责的事情比较多，职责不是太单一。特别是显示部分的代码，可能会比较复杂（比如 Email 的展示方式），最好是将显示部分的代码逻辑拆分成独立的类。除此之外，因为代码中涉及线程操作，并且调用了 Aggregator 的静态函数，所以代码的可测试性不好\n这里给出的代码实现还是有诸多问题的，在后面会慢慢优化，展示整个设计演进的过程，这比直接给出最终的最优方案要有意义得多！实际上，优秀的代码都是重构出来的，复杂的代码都是慢慢堆砌出来的\n","slug":"BlogRepository/设计模式/设计模式之美总结（设计原则篇）","date":"2022-10-27T09:31:42.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"3633cc7e4d4924a572a2b641ca2db580","title":"设计模式之美总结（重构篇）","content":"前两篇见：\n\n设计模式之美总结（面向对象篇）_凡 223 的博客\n设计模式之美总结（设计原则篇）_凡 223 的博客\n\n1. 概述1.1 重构的目的：为什么要重构（why）？软件设计大师 Martin Fowler 是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。”\n实际上，当讲到重构的时候，很多书籍都会引用这个定义。这个定义中有一个值得强调的点：“重构不改变外部的可见行为”。可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量\n为什么要进行代码重构？\n1、重构是时刻保证代码质量的一个极其有效的手段\n项目在演进，代码不停地在堆砌。如果没有人为代码的质量负责任，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了\n优秀的代码或架构也不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法 100% 预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的\n2、重构是避免过度设计的有效手段\n在维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢\n3、重构对一个工程师本身技术的成长也有重要的意义\n重构实际上是对学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。重构实际上就是将这些理论知识，应用到实践的一个很好的场景，能够锻炼我们熟练使用这些理论知识的能力\n除此之外，重构能力也是衡量一个工程师代码能力的有效手段。所谓“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”，这句话的意思是说，初级工程师在已有代码框架下修改 bug、修改添加功能代码；高级工程师从零开始设计代码结构、搭建代码框架；而资深工程师为代码质量负责，需要发觉代码存在的问题，重构代码，时刻保证代码质量处于一个可控的状态（当然这里的初级、高级、资深只是一个相对概念，并不是一个确定的职级）\n1.2 重构的对象：到底重构什么（what）？根据重构的规模，可以笼统地分为大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）\n大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大\n小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多的是利用编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小\n1.3 重构的时机：什么时候重构（when）？搞清楚了为什么重构，到底重构什么，再来看一下，什么时候重构？是代码烂到一定程度之后才去重构吗？当然不是。因为当代码真的烂到出现“开发效率低，招了很多人，天天加班，出活却不多，线上 bug 频发，领导发飙，中层束手无策，工程师抱怨不断，查找 bug 困难”的时候，基本上重构也无法解决问题了\n个人比较反对，平时不注重代码质量，堆砌烂代码，实在维护不了了就大刀阔斧地重构、甚至重写的行为。有时候项目代码太多了，重构很难做得彻底，最后又搞出来一个“四不像的怪物”，这就更麻烦了！所以，寄希望于在代码烂到一定程度之后，集中重构解决所有问题是不现实的，必须探索一条可持续、可演进的方式\n提倡的重构策略是持续重构。平时没有事情的时候，可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分，如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处\n尽管说重构能力很重要，但持续重构意识更重要。要正确地看待代码质量和重构这件事情。技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降\n1.4 重构的方法：又该如何重构（how）？按照重构的规模，重构可以笼统地分为大型重构和小型重构。对于这两种不同规模的重构，要区别对待：\n对于大型重构来说，因为涉及的模块、代码会比较多，如果项目代码质量又比较差，耦合比较严重，往往会牵一发而动全身，本来觉得一天就能完成的重构，会发现越改越多、越改越乱，没一两个礼拜都搞不定。而新的业务开发又与重构相冲突，最后只能半途而废，revert 掉所有的改动，很失落地又去堆砌烂代码了\n在进行大型重构的时候，要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突\n大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要愿意并且有时间，随时都可以去做。实际上，除了人工去发现低层次的质量问题，还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化\n对于重构这件事情，资深的工程师、项目 leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码\n2. 单元测试（Unit Testing）很多程序员对重构这种做法还是非常认同的，面对项目中的烂代码，也想重构一下，但又担心重构之后出问题，出力不讨好。确实，如果要重构的代码是别的同事开发的，不是特别熟悉，在没有任何保障的情况下，重构引入 bug 的风险还是很大的\n那如何保证重构不出错呢？需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）了。当重构完成之后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变，符合重构的定义\n2.1 什么是单元测试？单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。常常将它跟集成测试放到一块来对比。单元测试相对于集成测试（Integration Testing）来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。如下例：\npublic class Text &#123;\n    private String content;\n    public Text(String content) &#123;\n        this.content &#x3D; content;\n    &#125;\n    &#x2F;**\n     * 将字符串转化成数字，忽略字符串中的首尾空格；\n     * 如果字符串中包含除首尾空格之外的非数字字符，则返回 null。\n     *&#x2F;\n    public Integer toNumber() &#123;\n        if (content &#x3D;&#x3D; null || content.isEmpty()) &#123;\n            return null;\n        &#125;\n        &#x2F;&#x2F;... 省略代码实现...\n        return null;\n    &#125;\n&#125;\n\n要测试 Text 类中的 toNumber() 函数的正确性，应该如何编写单元测试呢？\n实际上，写单元测试本身不需要什么高深技术。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行\n为了保证测试的全面性，针对 toNumber() 函数，需要设计下面这样几个测试用例：\n\n如果字符串只包含数字：“123”，toNumber() 函数输出对应的整数：123\n如果字符串是空或者 null，toNumber() 函数返回：null\n如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，toNumber() 返回对应的整数：123\n如果字符串包含多个首尾空格：“ 123 ”，toNumber() 返回对应的整数：123\n如果字符串包含非数字字符：“123a4”，“123 4”，toNumber() 返回 null\n\n当设计好测试用例之后，剩下的就是将其翻译成代码了。翻译成代码的过程非常简单，如下：（这里没有使用任何测试框架）\npublic class Assert &#123;\n    public static void assertEquals(Integer expectedValue, Integer actualValue) &#123;\n        if (actualValue !&#x3D; expectedValue) &#123;\n            String message &#x3D; String.format(\n                    &quot;Test failed, expected: %d, actual: %d.&quot;, expectedValue, actualVa\n                    System.out.println(message);\n        &#125; else &#123;\n            System.out.println(&quot;Test succeeded.&quot;);\n        &#125;\n    &#125;\n    public static boolean assertNull(Integer actualValue) &#123;\n        boolean isNull &#x3D; actualValue &#x3D;&#x3D; null;\n        if (isNull) &#123;\n            System.out.println(&quot;Test succeeded.&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;Test failed, the value is not null:&quot; + actualValue);\n        &#125;\n        return isNull;\n    &#125;\n&#125;\npublic class TestCaseRunner &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Run testToNumber()&quot;);\n        new TextTest().testToNumber();\n        System.out.println(&quot;Run testToNumber_nullorEmpty()&quot;);\n        new TextTest().testToNumber_nullorEmpty();\n        System.out.println(&quot;Run testToNumber_containsLeadingAndTrailingSpaces()&quot;);\n        new TextTest().testToNumber_containsLeadingAndTrailingSpaces();\n        System.out.println(&quot;Run testToNumber_containsMultiLeadingAndTrailingSpaces\n        new TextTest().testToNumber_containsMultiLeadingAndTrailingSpaces();\n        System.out.println(&quot;Run testToNumber_containsInvalidCharaters()&quot;);\n        new TextTest().testToNumber_containsInvalidCharaters();\n    &#125;\n&#125;\n\npublic class TextTest &#123;\n    public void testToNumber() &#123;\n        Text text &#x3D; new Text(&quot;123&quot;);\n        Assert.assertEquals(123, text.toNumber());\n    &#125;\n    public void testToNumber_nullorEmpty() &#123;\n        Text text1 &#x3D; new Text(null);\n        Assert.assertNull(text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;&quot;);\n        Assert.assertNull(text2.toNumber());\n    &#125;\n    public void testToNumber_containsLeadingAndTrailingSpaces() &#123;\n        Text text1 &#x3D; new Text(&quot; 123&quot;);\n        Assert.assertEquals(123, text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;123 &quot;);\n        Assert.assertEquals(123, text2.toNumber());\n        Text text3 &#x3D; new Text(&quot; 123 &quot;);\n        Assert.assertEquals(123, text3.toNumber());\n    &#125;\n    public void testToNumber_containsMultiLeadingAndTrailingSpaces() &#123;\n        Text text1 &#x3D; new Text(&quot; 123&quot;);\n        Assert.assertEquals(123, text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;123 &quot;);\n        Assert.assertEquals(123, text2.toNumber());\n        Text text3 &#x3D; new Text(&quot; 123 &quot;);\n        Assert.assertEquals(123, text3.toNumber());\n    &#125;\n    public void testToNumber_containsInvalidCharaters() &#123;\n        Text text1 &#x3D; new Text(&quot;123a4&quot;);\n        Assert.assertNull(text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;123 4&quot;);\n        Assert.assertNull(text2.toNumber());\n    &#125;\n&#125;\n\n2.2 为什么要写单元测试？单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。单元测试的好处如下：\n\n单元测试能有效地发现代码中的 bug能否写出 bug free 的代码，是判断工程师编码能力的重要标准之一，通过单元测试能发现代码中的很多考虑不全面的地方\n写单元测试能发现代码设计上的问题代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等\n单元测试是对集成测试的有力补充程序运行的 bug 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。而单元测试可以利用 mock 的方式，控制 mock 的对象返回需要模拟的异常，来测试代码在这些异常情况的表现除此之外，对于一些复杂系统来说，集成测试也无法覆盖得很全面。复杂系统往往有很多模块。每个模块都有各种输入、输出、异常情况，组合起来，整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，再强大的测试团队也无法穷举完备尽管单元测试无法完全替代集成测试，但如果能保证每个类、每个函数都能按照预期来执行，底层 bug 少了，那组装起来的整个系统，出问题的概率也就相应减少了\n写单元测试的过程本身就是代码重构的过程写单元测试实际上就是落地执行持续重构的一个有效途径。设计和实现代码的时候，很难把所有的问题都想清楚。而编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中，可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构\n阅读单元测试能快速熟悉代码读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。但程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到“不言自明”。在没有文档和注释的情况下，单元测试就起了替代性作用。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理\n单元测试是 TDD 可落地执行的改进方案测试驱动开发（Test-Driven Development，简称 TDD）是一个经常被提及但很少被执行的开发模式。它的核心指导思想就是测试用例先于代码编写。不过，要让程序员能彻底地接受和习惯这种开发模式还是挺难的，毕竟很多程序员连单元测试都懒得写，更何况在编写代码之前先写好测试用例了单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了 TDD 的优点\n\n2.3 如何编写单元测试？写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程\n在把测试用例翻译成代码的时候，可以利用单元测试框架，来简化测试代码的编写。比如，Java 中比较出名的单元测试框架有 Junit、TestNG、Spring Test 等。这些框架提供了通用的执行流程（比如执行测试用例的 TestCaseRunner）和工具类库（比如各种Assert 判断函数）等。借助它们，在编写测试代码的时候，只需要关注测试用例本身的编写即可，使用测试框架实现如下：\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class TextTest &#123;\n    @Test\n    public void testToNumber() &#123;\n        Text text &#x3D; new Text(&quot;123&quot;);\n        Assert.assertEquals(new Integer(123), text.toNumber());\n    &#125;\n    @Test\n    public void testToNumber_nullorEmpty() &#123;\n        Text text1 &#x3D; new Text(null);\n        Assert.assertNull(text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;&quot;);\n        Assert.assertNull(text2.toNumber());\n    &#125;\n    @Test\n    public void testToNumber_containsLeadingAndTrailingSpaces() &#123;\n        Text text1 &#x3D; new Text(&quot; 123&quot;);\n        Assert.assertEquals(new Integer(123), text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;123 &quot;);\n        Assert.assertEquals(new Integer(123), text2.toNumber());\n        Text text3 &#x3D; new Text(&quot; 123 &quot;);\n        Assert.assertEquals(new Integer(123), text3.toNumber());\n    &#125;\n    @Test\n    public void testToNumber_containsMultiLeadingAndTrailingSpaces() &#123;\n        Text text1 &#x3D; new Text(&quot; 123&quot;);\n        Assert.assertEquals(new Integer(123), text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;123 &quot;);\n        Assert.assertEquals(new Integer(123), text2.toNumber());\n        Text text3 &#x3D; new Text(&quot; 123 &quot;);\n        Assert.assertEquals(new Integer(123), text3.toNumber());\n    &#125;\n    @Test\n    public void testToNumber_containsInvalidCharaters() &#123;\n        Text text1 &#x3D; new Text(&quot;123a4&quot;);\n        Assert.assertNull(text1.toNumber());\n        Text text2 &#x3D; new Text(&quot;123 4&quot;);\n        Assert.assertNull(text2.toNumber());\n    &#125;\n&#125;\n\n2.4 总结2.4.1 写单元测试真的是件很耗时的事情吗？尽管单元测试的代码量可能是被测代码本身的 1～2 倍，写的过程很繁琐，但并不是很耗时。毕竟不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。不同测试用例之间的代码差别可能并不是很大，简单 copy-paste 改改就行\n2.4.2 对单元测试的代码质量有什么要求吗？单元测试毕竟不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。所以，相对于被测代码，对单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的\n2.4.3 单元测试只要覆盖率高就够了吗？单元测试覆盖率是比较容易量化的指标，常常作为单元测试写得好坏的评判标准。有很多现成的工具专门用来做覆盖率统计，比如，JaCoCo、Cobertura、Emma、Clover。覆盖率的计算方式有很多种，比较简单的是语句覆盖，稍微高级点的有：条件覆盖、判定覆盖、路径覆盖\n不管覆盖率的计算方式如何高级，将覆盖率作为衡量单元测试质量的唯一标准是不合理的。实际上，更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些 corner case。如下例：\npublic double cal(double a, double b) &#123;\n    if (b !&#x3D; 0) &#123;\n        return a &#x2F; b;\n    &#125;\n&#125;\n\n像上面这段代码，只需要一个测试用例就可以做到 100% 覆盖率，比如 cal(10.0, 2.0)，但并不代表测试足够全面了，还需要考虑，当除数等于 ０ 的情况下，代码执行是否符合预期\n实际上，过度关注单元测试的覆盖率会导致开发人员为了提高覆盖率，写很多没有必要的测试代码，比如 get、set 方法非常简单，没有必要测试。从过往的经验上来讲，一个项目的单元测试覆盖率在 60～70% 即可上线。如果项目对代码质量要求比较高，可以适当提高单元测试覆盖率的要求\n2.4.4 写单元测试需要了解代码的实现逻辑吗？单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也违背了写单元测试的初衷\n2.4.5 如何选择单元测试框架？写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足。在公司内部，起码团队内部需要统一单元测试框架。如果自己写的代码用已经选定的单元测试框架无法测试，那多半是代码写得不够好，代码的可测试性不够好。这个时候，要重构自己的代码，让其更容易测试，而不是去找另一个更加高级的单元测试框架\n2.4.6 单元测试为何难落地执行？虽然很多书籍中都会讲到，单元测试是保证重构不出错的有效手段；也有非常多人已经认识到单元测试的重要性。但是有多少项目有完善的、高质量的单元测试呢？非常非常少\n写单元测试确实是一件考验耐心的活儿。一般情况下，单元测试的代码量要大于被测试代码量，甚至是要多出好几倍。很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而不愿意去做。有很多团队和项目在刚开始推行单元测试的时候，还比较认真，执行得比较好。但当开发任务紧了之后，就开始放低对单元测试的要求，一旦出现破窗效应，慢慢的，大家就都不写了，这种情况很常见\n还有一种情况就是，由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试。这种情况下，首先要保证新写的代码都要有单元测试，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这要求工程师们有足够强的主人翁意识（ownership），毕竟光靠 leader 督促，很多事情是很难执行到位的\n除此之外，还有人觉得，有了测试团队，写单元测试就是浪费时间，没有必要。程序员这一行业本该是智力密集型的，但现在很多公司把它搞成劳动密集型的，包括一些大厂，在开发过程中，既没有单元测试，也没有 Code Review 流程。即便有，做的也是差强人意。写好代码直接提交，然后丢给黑盒测试狠命去测，测出问题就反馈给开发团队再修改，测不出的问题就留在线上出了问题再修复\n在这样的开发模式下，团队往往觉得没有必要写单元测试，但如果把单元测试写好、做好 Code Review，重视起代码质量，其实可以很大程度上减少黑盒测试的投入\n3. 代码的可测试性3.1 如何写出可测试性好的代码？如下，Transaction 是经过抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。Transaction 类中的 execute() 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用 WalletRpcService RPC 服务来完成的。除此之外，代码中还涉及一个分布式锁 DistributedLock 单例类，用来避免 Transaction 并发执行，导致用户的钱被重复转出\npublic class Transaction &#123;\n    private String id;\n    private Long buyerId;\n    private Long sellerId;\n    private Long productId;\n    private String orderId;\n    private Long createTimestamp;\n    private Double amount;\n    private STATUS status;\n    private String walletTransactionId;\n\n    &#x2F;&#x2F; ...get() methods...\n    public Transaction(String preAssignedId, Long buyerId, Long sellerId, Long p) &#123;\n        if (preAssignedId !&#x3D; null &amp;&amp; !preAssignedId.isEmpty()) &#123;\n            this.id &#x3D; preAssignedId;\n        &#125; else &#123;\n            this.id &#x3D; IdGenerator.generateTransactionId();\n        &#125;\n        if (!this.id.startWith(&quot;t_&quot;)) &#123;\n            this.id &#x3D; &quot;t_&quot; + preAssignedId;\n        &#125;\n        this.buyerId &#x3D; buyerId;\n        this.sellerId &#x3D; sellerId;\n        this.productId &#x3D; productId;\n        this.orderId &#x3D; orderId;\n        this.status &#x3D; STATUS.TO_BE_EXECUTD;\n        this.createTimestamp &#x3D; System.currentTimestamp();\n    &#125;\n\n    public boolean execute() throws InvalidTransactionException &#123;\n        if ((buyerId &#x3D;&#x3D; null || (sellerId &#x3D;&#x3D; null || amount &lt; 0.0) &#123;\n            throw new InvalidTransactionException(...);\n        &#125;\n        if (status &#x3D;&#x3D; STATUS.EXECUTED) return true;\n        boolean isLocked &#x3D; false;\n        try &#123;\n            isLocked &#x3D; RedisDistributedLock.getSingletonIntance().lockTransction(id)\n            if (!isLocked) &#123;\n                return false; &#x2F;&#x2F; 锁定未成功，返回 false，job 兜底执行\n            &#125;\n            if (status &#x3D;&#x3D; STATUS.EXECUTED) return true; &#x2F;&#x2F; double check\n            long executionInvokedTimestamp &#x3D; System.currentTimestamp();\n            if (executionInvokedTimestamp - createdTimestap &gt; 14d ays)&#123;\n                this.status &#x3D; STATUS.EXPIRED;\n                return false;\n            &#125;\n            WalletRpcService walletRpcService &#x3D; new WalletRpcService();\n            String walletTransactionId &#x3D; walletRpcService.moveMoney(id, buyerId, sell);\n            if (walletTransactionId !&#x3D; null) &#123;\n                this.walletTransactionId &#x3D; walletTransactionId;\n                this.status &#x3D; STATUS.EXECUTED;\n                return true;\n            &#125; else &#123;\n                this.status &#x3D; STATUS.FAILED;\n                return false;\n            &#125;\n        &#125; finally &#123;\n            if (isLocked) &#123;\n                RedisDistributedLock.getSingletonIntance().unlockTransction(id);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n对比前面的 Text 类的代码，这段代码要复杂很多。如果给这段代码编写单元测试，该如何来写呢？\n在 Transaction 类中，主要逻辑集中在 execute() 函数中，所以它是测试的重点对象。为了尽可能全面覆盖各种正常和异常情况，针对这个函数，设计了下面 6 个测试用例：\n\n正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的 walletTransactionId，交易状态设置为 EXECUTED，函数返回 true\nbuyerId、sellerId 为 null、amount 小于 0，返回 InvalidTransactionException\n交易已过期（createTimestamp 超过 14 天），交易状态设置为 EXPIRED，返回 false\n交易已经执行了（status&#x3D;&#x3D;EXECUTED），不再重复执行转钱逻辑，返回 true\n钱包（WalletRpcService）转钱失败，交易状态设置为 FAILED，函数返回 false\n交易正在执行着，不会被重复执行，函数直接返回 false\n\n测试用例设计完了。现在看起来似乎一切进展顺利。但是，事实是，当将测试用例落实到具体的代码实现时，就会发现有很多行不通的地方。对于上面的测试用例，第 2 个实现起来非常简单，重点来看其中的 1 和 3。测试用例 4、5、6 跟 3类似\n测试用例 1 的代码实现。具体如下所示：\npublic void testExecute() &#123;\n        Long buyerId &#x3D; 123L;\n        Long sellerId &#x3D; 234L;\n        Long productId &#x3D; 345L;\n        Long orderId &#x3D; 456L;\n\n        Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);\n        boolean executedResult &#x3D; transaction.execute();\n        assertTrue(executedResult);\n&#125;\n\nexecute() 函数的执行依赖两个外部的服务，一个是 RedisDistributedLock，一个 WalletRpcService。这就导致上面的单元测试代码存在下面几个问题：\n\n如果要让这个单元测试能够运行，需要搭建 Redis 服务和 Wallet RPC 服务。搭建和维护的成本比较高\n还需要保证将伪造的 transaction 数据发送给 Wallet RPC 服务之后，能够正确返回期望的结果，然而 Wallet RPC 服务有可能是第三方（另一个团队开发维护的）的服务，并不是可控的。换句话说，并不是想让它返回什么数据就返回什么\nTransaction 的执行跟 Redis、RPC 服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响\n网络的中断、超时、Redis、RPC 服务的不可用，都会影响单元测试的执行\n\n回到单元测试的定义上来看一下。单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统（分布式锁、Wallet RPC 服务）的逻辑正确性。所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据\n那如何来 mock 服务呢？mock 的方式主要有两种，手动 mock 和利用框架 mock。利用框架 mock 仅仅是为了简化代码编写，每个框架的 mock 方式都不大一样。这里只展示手动 mock\n通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。具体的代码实现如下所示。通过 mock 的方式，可以让 moveMoney() 返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信\npublic class MockWalletRpcServiceOne extends WalletRpcService &#123;\n    public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amoun) &#123;\n        return &quot;123bac&quot;;\n    &#125;\n&#125;\n\npublic class MockWalletRpcServiceTwo extends WalletRpcService &#123;\n    public String moveMoney(Long id, Long fromUserId, Long toUserId, Double amoun) &#123;\n        return null;\n    &#125;\n&#125;\n\n现在再来看，如何用 MockWalletRpcServiceOne、MockWalletRpcServiceTwo 来替换代码中的真正的 WalletRpcService 呢？\n因为 WalletRpcService 是在 execute() 函数中通过 new 的方式创建的，无法动态地对其进行替换。也就是说，Transaction 类中的 execute() 方法的可测试性很差，需要通过重构来让其变得更容易测试。该如何重构这段代码呢？\n依赖注入是实现代码可测试性的最有效的手段。可以应用依赖注入，将 WalletRpcService 对象的创建反转给上层逻辑，在外部创建好之后，再注入到 Transaction 类中。重构之后的 Transaction 类的代码如下所示：\npublic class Transaction &#123;\n    &#x2F;&#x2F;...\n    &#x2F;&#x2F; 添加一个成员变量及其 set 方法\n    private WalletRpcService walletRpcService;\n    public void setWalletRpcService(WalletRpcService walletRpcService) &#123;\n        this.walletRpcService &#x3D; walletRpcService;\n    &#125;\n    &#x2F;&#x2F; ...\n    public boolean execute() &#123;\n       &#x2F;&#x2F; ...\n       &#x2F;&#x2F; 删除下面这一行代码\n       &#x2F;&#x2F; WalletRpcService walletRpcService &#x3D; new WalletRpcService();\n       &#x2F;&#x2F; ...\n    &#125;\n&#125;\n\n现在，就可以在单元测试中，非常容易地将 WalletRpcService 替换成 MockWalletRpcServiceOne 或 WalletRpcServiceTwo 了。重构之后的代码对应的单元测试如下所示：\npublic void testExecute() &#123;\n        Long buyerId &#x3D; 123L;\n        Long sellerId &#x3D; 234L;\n        Long productId &#x3D; 345L;\n        Long orderId &#x3D; 456L;\n\n        Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);\n        &#x2F;&#x2F; 使用 mock 对象来替代真正的 RPC 服务\n        transaction.setWalletRpcService(new MockWalletRpcServiceOne()):\n        boolean executedResult &#x3D; transaction.execute();\n        assertTrue(executedResult);\n        assertEquals(STATUS.EXECUTED, transaction.getStatus());\n&#125;\n\nWalletRpcService 的 mock 和替换问题解决了，再来看 RedisDistributedLock。它的 mock 和替换要复杂一些，主要是因为 RedisDistributedLock 是一个单例类。单例相当于一个全局变量，无法 mock（无法继承和重写方法），也无法通过依赖注入的方式来替换\n如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改为非单例的模式，或者定义一个接口，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。这样就可以像前面 WalletRpcService 的替换方式那样，替换 RedisDistributedLock 为 MockRedisDistributedLock 了。但如果RedisDistributedLock 不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢？\n可以对 transaction 上锁这部分逻辑重新封装一下。具体代码实现如下所示：\npublic class TransactionLock &#123;\n    public boolean lock(String id) &#123;\n        return RedisDistributedLock.getSingletonIntance().lockTransction(id);\n    &#125;\n    public void unlock() &#123;\n        RedisDistributedLock.getSingletonIntance().unlockTransction(id);\n    &#125;\n&#125;\n\npublic class Transaction &#123;\n    &#x2F;&#x2F;...\n    private TransactionLock lock;\n    public void setTransactionLock(TransactionLock lock) &#123;\n        this.lock &#x3D; lock;\n    &#125;\n    public boolean execute() &#123;\n        &#x2F;&#x2F;...\n        try &#123;\n            isLocked &#x3D; lock.lock();\n        &#x2F;&#x2F;...\n        &#125; finally &#123;\n            if (isLocked) &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n针对重构过的代码，单元测试代码修改为下面这个样子。这样，就能在单元测试代码中隔离真正的 RedisDistributedLock 分布式锁这部分逻辑了\npublic void testExecute() &#123;\n    Long buyerId &#x3D; 123L;\n    Long sellerId &#x3D; 234L;\n    Long productId &#x3D; 345L;\n    Long orderId &#x3D; 456L;\n\n    TransactionLock mockLock &#x3D; new TransactionLock() &#123;\n        public boolean lock(String id) &#123;\n            return true;\n        &#125;\n        public void unlock() &#123;&#125;\n    &#125;;\n    Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId);\n    transaction.setWalletRpcService(new MockWalletRpcServiceOne());\n    transaction.setTransactionLock(mockLock);\n    boolean executedResult &#x3D; transaction.execute();\n    assertTrue(executedResult);\n    assertEquals(STATUS.EXECUTED, transaction.getStatus());\n&#125;\n\n至此，测试用例 1 就算写好了。通过依赖注入和 mock，让单元测试代码不依赖任何不可控的外部服务\n现在，再来看测试用例 3：交易已过期（createTimestamp 超过 14 天），交易状态设置为 EXPIRED，返回 false。针对这个单元测试用例，还是先把代码写出来，然后再来分析\npublic void testExecute_with_TransactionIsExpired() &#123;\n        Long buyerId &#x3D; 123L;\n        Long sellerId &#x3D; 234L;\n        Long productId &#x3D; 345L;\n        Long orderId &#x3D; 456L;\n\n        Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId,orderId);\n        transaction.setCreatedTimestamp(System.currentTimestamp() - 14days);\n        boolean actualResult &#x3D; transaction.execute();\n        assertFalse(actualResult);\n        assertEquals(STATUS.EXPIRED, transaction.getStatus());\n&#125;\n\n上面的代码看似没有任何问题。将 transaction 的创建时间 createdTimestamp 设置为 14 天前，也就是说，当单元测试代码运行的时候，transaction 一定是处于过期状态。但是，如果在 Transaction 类中，并没有暴露修改 createdTimestamp 成员变量的 set 方法（也就是没有定义 setCreatedTimestamp() 函数）呢？\n这时可能会说，如果没有 createTimestamp 的 set 方法，就重新添加一个呗！实际上，这违反了类的封装特性。在 Transaction 类的设计中，createTimestamp 是在交易生成时（也就是构造函数中）自动获取的系统时间，本来就不应该人为地轻易修改，所以，暴露 createTimestamp 的 set 方法，虽然带来了灵活性，但也带来了不可控性。因为，无法控制使用者是否会调用 set 方法重设 createTimestamp，而重设 createTimestamp 并非我们的预期行为\n那如果没有针对 createTimestamp 的 set 方法，那测试用例 3 又该如何实现呢？实际上，这是一类比较常见的问题，就是代码中包含跟“时间”有关的“未决行为”逻辑。一般的处理方式是将这种未决行为逻辑重新封装。针对 Transaction 类，只需要将交易是否过期的逻辑，封装到 isExpired() 函数中即可，具体的代码实现如下所示：\npublic class Transaction &#123;\n    protected boolean isExpired() &#123;\n        long executionInvokedTimestamp &#x3D; System.currentTimestamp();\n        return executionInvokedTimestamp - createdTimestamp &gt; 14days;\n    &#125;\n    public boolean execute() throws InvalidTransactionException &#123;\n        &#x2F;&#x2F;...\n        if (isExpired()) &#123;\n            this.status &#x3D; STATUS.EXPIRED;\n            return false;\n        &#125;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n针对重构之后的代码，测试用例 3 的代码实现如下所示：\npublic void testExecute_with_TransactionIsExpired() &#123;\n        Long buyerId &#x3D; 123L;\n        Long sellerId &#x3D; 234L;\n        Long productId &#x3D; 345L;\n        Long orderId &#x3D; 456L;\n  \n        Transction transaction &#x3D; new Transaction(null, buyerId, sellerId, productId, orderId) &#123;\n            protected boolean isExpired() &#123;\n                return true;\n            &#125;\n        &#125;;\n        boolean actualResult &#x3D; transaction.execute();\n        assertFalse(actualResult);\n        assertEquals(STATUS.EXPIRED, transaction.getStatus());\n&#125;\n\n通过重构，Transaction 代码的可测试性提高了。之前罗列的所有测试用例，现在都顺利实现了。不过，Transaction 类的构造函数的设计还有点不妥，如下：\npublic Transaction(String preAssignedId, Long buyerId, Long sellerId, Long p) &#123;\n        if (preAssignedId !&#x3D; null &amp;&amp; !preAssignedId.isEmpty()) &#123;\n            this.id &#x3D; preAssignedId;\n        &#125; else &#123;\n            this.id &#x3D; IdGenerator.generateTransactionId();\n        &#125;\n        if (!this.id.startWith(&quot;t_&quot;)) &#123;\n            this.id &#x3D; &quot;t_&quot; + preAssignedId;\n        &#125;\n        this.buyerId &#x3D; buyerId;\n        this.sellerId &#x3D; sellerId;\n        this.productId &#x3D; productId;\n        this.orderId &#x3D; orderId;\n        this.status &#x3D; STATUS.TO_BE_EXECUTD;\n        this.createTimestamp &#x3D; System.currentTimestamp();\n&#125;\n\n构造函数中并非只包含简单赋值操作。交易 id 的赋值逻辑稍微复杂。最好也要测试一下，以保证这部分逻辑的正确性。为了方便测试，可以把 id 赋值这部分逻辑单独抽象到一个函数中，具体的代码实现如下所示：\npublic Transaction(String preAssignedId, Long buyerId, Long sellerId, Long p\n        &#x2F;&#x2F;...\n        fillTransactionId(preAssignId);\n        &#x2F;&#x2F;...\n&#125;\n\nprotected void fillTransactionId(String preAssignedId) &#123;\n        if (preAssignedId !&#x3D; null &amp;&amp; !preAssignedId.isEmpty()) &#123;\n            this.id &#x3D; preAssignedId;\n        &#125; else &#123;\n            this.id &#x3D; IdGenerator.generateTransactionId();\n        &#125;\n        if (!this.id.startWith(&quot;t_&quot;)) &#123;\n            this.id &#x3D; &quot;t_&quot; + preAssignedId;\n        &#125;\n&#125;\n\n到此为止，一步一步将 Transaction 从不可测试代码重构成了测试性良好的代码。不过可能还会有疑问，Transaction 类中 isExpired() 函数就不用测试了吗？对于 isExpired() 函数，逻辑非常简单，肉眼就能判定是否有 bug，是可以不用写单元测试的\n实际上，可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了代码的可测试性可以从侧面上反应代码设计是否合理。除此之外，在平时的开发中，也要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于设计出好的代码\n3.2 其他常见的 Anti-Patterns总结一下，有哪些典型的、常见的测试性不好的代码，也就是常说的 Anti-Patterns：\n3.2.1 未决行为所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码\n3.2.2 全局变量全局变量是一种面向过程的编程风格，有种种弊端。实际上，滥用全局变量也让编写单元测试变得困难，如下例：\nRangeLimiter 表示一个 [-5, 5] 的区间，position 初始在 0 位置，move() 函数负责移动 position。其中，position 是一个静态全局变量。RangeLimiterTest 类是为其设计的单元测试，不过，这里面存在很大的问题\npublic class RangeLimiter &#123;\n    private static AtomicInteger position &#x3D; new AtomicInteger(0);\n    public static final int MAX_LIMIT &#x3D; 5;\n    public static final int MIN_LIMIT &#x3D; -5;\n    public boolean move(int delta) &#123;\n        int currentPos &#x3D; position.addAndGet(delta);\n        boolean betweenRange &#x3D; (currentPos &lt;&#x3D; MAX_LIMIT) &amp;&amp; (currentPos &gt;&#x3D; MIN_LIMI\n        return betweenRange;\n    &#125;\n&#125;\npublic class RangeLimiterTest &#123;\n    public void testMove_betweenRange() &#123;\n        RangeLimiter rangeLimiter &#x3D; new RangeLimiter();\n        assertTrue(rangeLimiter.move(1));\n        assertTrue(rangeLimiter.move(3));\n        assertTrue(rangeLimiter.move(-5));\n    &#125;\n    public void testMove_exceedRange() &#123;\n        RangeLimiter rangeLimiter &#x3D; new RangeLimiter();\n        assertFalse(rangeLimiter.move(6));\n    &#125;\n&#125;\n\n上面的单元测试有可能会运行失败。假设单元测试框架顺序依次执行 testMove_betweenRange() 和 testMove_exceedRange() 两个测试用例。在第一个测试用例执行完成之后，position 的值变成了 -1；再执行第二个测试用例的时候，position 变成了 5，move() 函数返回 true，assertFalse 语句判定失败。所以，第二个测试用例运行失败\n当然，如果 RangeLimiter 类有暴露重设（reset）position 值的函数，可以在每次执行单元测试用例之前，把 position 重设为 0，这样就能解决刚刚的问题\n不过，每个单元测试框架执行单元测试用例的方式可能是不同的。有的是顺序执行，有的是并发执行。对于并发执行的情况，即便每次都把 position 重设为 0，也并不奏效。如果两个测试用例并发执行，第 16、17、18、23 这四行代码可能会交叉执行，影响到 move() 函数的执行结果\n3.2.3 静态方法静态方法跟全局变量一样，也是一种面向过程的编程思维。在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难 mock。但是，这个要分情况来看。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，才需要在单元测试中 mock 这个静态方法。除此之外，如果只是类似 Math.abs() 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要 mock\n3.2.4 复杂继承相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。实际上，继承关系也更加难测试。这也印证了代码的可测试性跟代码质量的相关性\n如果父类需要 mock 某个依赖对象才能进行单元测试，那所有的子类、子类的子类……在编写单元测试的时候，都要 mock 这个依赖对象。对于层次很深（在继承关系类图中表现为纵向深度）、结构复杂（在继承关系类图中表现为横向广度）的继承关系，越底层的子类要 mock 的对象可能就会越多，这样就会导致，底层子类在写单元测试的时候，要一个一个 mock 很多依赖对象，而且还需要查看父类代码，去了解该如何 mock 这些依赖对象\n如果利用组合而非继承来组织类之间的关系，类之间的结构层次比较扁平，在编写单元测试的时候，只需要 mock 类所组合依赖的对象即可\n3.2.5 高耦合代码如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那在编写单元测试的时候，可能需要 mock 这十几个依赖的对象。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的\n4. 解耦前面讲到，重构可以分为大规模高层重构（简称“大型重构”）和小规模低层次重构（简称“小型重构”）。大型重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。对于大型重构来说，最有效的一个手段，那就是“解耦”。解耦的目的是实现代码高内聚、松耦合\n4.1 “解耦”为何如此重要？软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，个人认为最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段\n“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性\n不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类\n除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了\n4.2 代码是否需要“解耦”？该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合“高内聚、松耦合”呢？再或者说，如何判断系统是否需要解耦重构呢？\n间接的衡量标准有很多，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构\n如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用\n4.3 如何给代码“解耦”？4.3.1 封装与抽象封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口\n比如，Unix 系统提供的 open() 文件操作函数，用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。通过将其封装成一个抽象的 open() 函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中。除此之外，因为 open() 函数基于抽象而非具体的实现来定义，所以在改动 open() 函数的底层实现的时候，并不需要改动依赖它的上层代码，也符合前面提到的“高内聚、松耦合”代码的评判标准\n4.3.2 中间层引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰\n\n除此之外，在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，可以分下面四个阶段来完成接口的修改：\n\n引入一个中间层，包裹老的接口，提供新的接口定义\n新开发的代码依赖中间层提供的新接口\n将依赖老接口的代码改为调用新接口\n确保所有的代码都调用新接口之后，删除掉老的接口\n\n这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了\n4.3.3 模块化模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转\n聚焦到软件开发上面，很多大型软件（比如 Windows）之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好。不同的模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统\n再聚焦到代码层面。合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。所以，在开发代码的时候，一定要有模块化意识，将每个模块都当作一个独立的 lib 一样来开发，只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度\n实际上，模块化的思想无处不在，像 SOA、微服务、lib库、系统内模块划分，甚至是类、函数的设计，都体现了模块化思想。如果追本溯源，模块化思想更加本质的东西就是分而治之\n4.4 其他设计思想和原则“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，如下：\n4.4.1 单一职责原则内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了\n4.4.2 基于接口而非实现编程基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）\n4.4.3 依赖注入跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换\n4.4.4 多用组合少用继承继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段\n4.4.5 迪米特法则迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，明显可以看出，这条原则的目的就是为了实现代码的松耦合\n除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式\n5. 编程规范关于编码规范、如何编写可读代码，很多书籍已经讲得很好了。不过，这里总结罗列了 20 条个人觉得最好用的编码规范。掌握这 20 条编码规范，能最快速地改善代码质量。分为三个部分：命名与注释（Naming andComments）、代码风格（Code Style）和编程技巧（Coding Tips）\n5.1 命名大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，就逃不过“起名字”这一关。命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的。除此之外，命名能力也体现了一个程序员的基本编程素养\n5.1.1 命名多长最合适？这里有两种典型。第一种是特别喜欢用很长的命名方式，觉得命名一定要准确达意，哪怕长一点也没关系，所以项目里，类名、函数名都很长。第二种喜欢用短的命名方式，能用缩写就尽量用缩写，所以，项目里到处都是包含各种缩写的命名。这两种命名方式，哪种更值得推荐呢？\n尽管长的命名可以包含更多的信息，更能准确直观地表达意图，但是，如果函数、变量的命名很长，那由它们组成的语句就会很长。在代码列长度有限制的情况下，就会经常出现一条语句被分割成两行的情况，这其实会影响代码可读性\n实际上，在足够表达其含义的情况下，命名当然是越短越好。但是，大部分情况下，短的命名都没有长的命名更能达意。所以，很多书籍或者文章都不推荐在命名时使用缩写。但对于一些默认的、大家都比较熟知的词，比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec 表示 second、str 表示 string、num 表示 number、doc 表示 document。除此之外，对于作用域比较小的变量，可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，更推荐用长的命名方式\n总之，命名的一个原则就是以能准确达意为目标。不过，对于代码的编写者来说，自己对代码的逻辑很清楚，总感觉用什么样的命名都可以达意，实际上，对于不熟悉代码的同事来讲，可能就不这么认为了。所以，命名的时候，一定要学会换位思考，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否足够直观\n5.1.2 利用上下文简化命名如下例：\npublic class User &#123;\n    private String userName;\n    private String userPassword;\n    private String userAvatarUrl;\n    &#x2F;&#x2F;...\n&#125;\n\n在 User 类这样一个上下文中，没有必要在成员变量的命名中重复添加“user”这样一个前缀单词，而是直接命名为 name、password、avatarUrl。在使用这些属性时候，能借助对象这样一个上下文，表意也足够明确。具体代码如下所示：\nUser user &#x3D; new User();\nuser.getName(); &#x2F;&#x2F; 借助 user 对象这个上下文\n\n除了类之外，函数参数也可以借助函数这个上下文来简化命名，如下例：\npublic void uploadUserAvatarImageToAliyun(String userAvatarImageUri);\n&#x2F;&#x2F; 利用上下文简化为：\npublic void uploadUserAvatarImageToAliyun(String imageUri);\n\n5.1.3 命名要可读、可搜索什么是命名可读。这里所说的“可读”，指的是不要用一些特别生僻、难发音的英文单词来命名\n过去曾参加过两个项目，一个叫 plateaux，另一个叫 eyrie，从项目立项到结束，自始至终都没有几个人能叫对这两个项目的名字。在沟通的时候，每当有人提到这两个项目的名字的时候，都会尴尬地卡顿一下。虽然我们并不排斥一些独特的命名方式，但起码得让大部分人看一眼就能知道怎么读\n在 IDE 中编写代码的时候，经常会用“关键词联想”的方法来自动补全和搜索。比如，键入某个对象“.get”，希望 IDE 返回这个对象的所有 get开头的方法。再比如，通过在 IDE 搜索框中输入“Array”，搜索 JDK 中数组相关的类。所以，在命名的时候，最好能符合整个项目的命名习惯。大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX”，统一规约是很重要的，能减少很多不必要的麻烦\n5.1.4 如何命名接口和抽象类？对于接口的命名，一般有两种比较常见的方式。一种是加前缀“I”，表示一个 Interface。比如 IUserService，对应的实现类命名为 UserService。另一种是不加前缀，比如 UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl\n对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，比如 AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行\n5.2 注释命名很重要，注释跟命名同等重要。很多书籍认为，好的命名完全可以替代注释。如果需要注释，那说明命名不够好，需要在命名上下功夫，而不是添加注释。实际上，我个人觉得，这样的观点有点太过极端。命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充\n5.2.1 注释到底该写什么？注释的目的就是让代码更容易看懂。只要符合这个要求的内容，就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。如下例：\n&#x2F;**\n * (what) Bean factory to create beans.\n *\n * (why) The class likes Spring IOC framework, but is more lightweight.\n *\n * (how) Create objects from different sources sequentially:\n * user specified object &gt; SPI &gt; configuration &gt; default object.\n *&#x2F;\npublic class BeansFactory &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n有些人认为，注释是要提供一些代码没有的额外信息，所以不要写“做什么、怎么做”，这两方面在代码中都可以体现出来，只需要写清楚“为什么”，表明代码的设计意图即可。我个人不是特别认可这样的观点，理由主要有下面 3 点：\n1、注释比代码承载的信息更多\n命名的主要目的是解释“做什么”。比如，void increaseWalletAvailableBalance(BigDecimal amount) 表明这个函数用来增加钱包的可用余额，boolean isValidatedPassword 表明这个变量用来标识是否是合法密码。函数和变量如果命名得好，确实可以不用再在注释中解释它是做什么的。但是，对于类来说，包含的信息比较多，一个简单的命名就不够全面详尽了。这个时候，在注释中写明“做什么”就合情合理了\n2、注释起到总结性作用、文档的作用\n代码之下无秘密。阅读代码可以明确地知道代码是“怎么做”的，也就是知道代码是如何实现的，那注释中是不是就不用写“怎么做”了？实际上也可以写。在注释中，关于具体的代码实现思路，可以写一些总结性的说明、特殊情况的说明。这样能够让阅读代码的人通过注释就能大概了解代码的实现思路，阅读起来就会更加容易\n实际上，对于有些比较复杂的类或者接口，可能还需要在注释中写清楚“如何用”，举一些简单的 quick start 的例子，让使用者在不阅读代码的情况下，快速地知道该如何使用\n3、一些总结性注释能让代码结构更清晰\n对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用，那可以借助总结性的注释来让代码结构更清晰、更有条理\npublic boolean isValidPasword(String password) &#123;\n        &#x2F;&#x2F; check if password is null or empty\n        if (StringUtils.isBlank(password)) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; check if the length of password is between 4 and 64\n        int length &#x3D; password.length();\n        if (length &lt; 4 || length &gt; 64) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; check if password contains only lowercase characters\n        if (!StringUtils.isAllLowerCase(password)) &#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F; check if password contains only a~z,0~9,dot\n        for (int i &#x3D; 0; i &lt; length; ++i) &#123;\n            char c &#x3D; password.charAt(i);\n            if (!(c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) || (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) || c &#x3D;&#x3D; &#39;.&#39;) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n&#125;\n\n5.2.2 注释是不是越多越好？注释太多和太少都有问题。太多，有可能意味着代码写得不够可读，需要写很多注释来补充。除此之外，注释太多也会对代码本身的阅读起到干扰。而且，后期的维护成本也比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑。当然，如果代码中一行注释都没有，那只能说明这个程序员很懒，要适当督促一下，让他注意添加一些必要的注释\n按照经验来说，类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性\n5.3 代码风格（Code Style）5.3.1 类、函数多大才合适？总体上来讲，类或函数的代码行数不能太多，但也不能太少。类或函数的代码行数太多，一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。相反，类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在 n 多类或者 n 多函数之间跳来跳去，阅读体验也不好\n那一个类或函数有多少行代码才最合适呢？\n要给出一个精确的量化值是很难的。对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。比如，在我的电脑上，如果要让一个函数的代码完整地显示在 IDE 中，那最大代码行数不能超过 50。这个说法我觉得挺有道理的。因为超过一屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就可能需要频繁地上下滚动屏幕，阅读体验不好不说，还容易出错\n对于类的代码行数的最大限制，这个就更难给出一个确切的值了。在前面也给出过一个间接的判断标准，那就是，当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了\n5.3.2 一行代码多长最合适？在 Google Java Style Guide 文档中，一行代码最长限制为 100 个字符。不过，不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不相同。不管这个限制是多少，总体上来讲要遵循的一个原则是：一行代码最长不能超过 IDE 显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。当然，这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读\n5.3.3 善用空行分割单元块对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了可以用总结性注释的方法之外，还可以使用空行来分割各个代码块\n除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。写代码就类似写文章，善于应用空行，可以让代码的整体结构看起来更加有清晰、有条理\n5.3.4 四格缩进还是两格缩进？“PHP 是世界上最好的编程语言？代码换行应该四格缩进还是两格缩进？”这应该是程序员争论得最多的两个话题了。据我所知，Java 语言倾向于两格缩进，PHP 语言倾向于四格缩进。至于到底应该是两格缩进还是四格缩进，我觉得这个取决于个人喜好。只要项目内部能够统一就行了\n当然，还有一个选择的标准，那就是跟业内推荐的风格统一、跟著名开源项目统一。当我们需要拷贝一些开源的代码到项目里的时候，能够让引入的代码跟我们项目本身的代码，保持风格统一\n不过，个人比较推荐使用两格缩进，这样可以节省空间。特别是在代码嵌套层次比较深的情况下，累计缩进较多的话，容易导致一个语句被折成两行，影响代码可读性\n除此之外，值得强调的是，不管是用两格缩进还是四格缩进，一定不要用 Tab 键缩进。因为在不同的 IDE 下，Tab 键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。如果在同一个项目中，不同的同事使用不同的缩进方式（空格缩进或 Tab 键缩进），有可能会导致有的代码显示为两格缩进、有的代码显示为四格缩进，不过可以在 IDE 里设置 Tab 缩进的格数\n5.3.5 大括号是否要另起一行？左大括号是否要另起一行呢？这个也有争论。据我所知，PHP 程序员喜欢另起一行，Java程序员喜欢跟上一条语句放到一起。具体代码示例如下所示：\n&#x2F;&#x2F; PHP\nclass ClassName\n&#123;\n    public function foo()\n    &#123;\n        &#x2F;&#x2F; method body\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Java\npublic class ClassName &#123;\n    public void foo() &#123;\n        &#x2F;&#x2F; method body\n    &#125;\n&#125;\n\n个人还是比较推荐，将括号放到跟语句同一行的风格。理由跟上面类似，节省代码行数。但是将大括号另起新的一行的方式，也有它的优势。这样的话，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更一目了然\n不过，还是那句话，大括号跟上一条语句在同一行，还是另起新的一行，只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分\n5.3.6 类中成员的排列顺序在 Java 类文件中，先要书写类所属的包名，然后再罗列 import 引入的依赖类。在 Google 编码规范中，依赖类按照字母序从小到大排列\n在类中，成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的。除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 public 成员变量或函数，然后是 protected 的，最后是 private 的\n不过，不同的编程语言中，类内部成员的排列顺序可能会有比较大的差别。比如 C++ 中，成员变量会习惯性放到函数后面。除此之外，函数之间的排列顺序，会按照作用域的大小来排列。实际上，还有另外一种排列习惯，那就是把有调用关系的函数放到一块。比如，一个 public 函数调用了另外一个 private 函数，那就把这两者放到一块\n5.4 编程技巧5.4.1 把代码分割成更小的单元块大部分人阅读代码的习惯都是，先看整体再看细节。所以，要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。不过，只有代码逻辑比较复杂的时候，其实才建议提炼类或者函数。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本\n如下例，重构前，在 invest() 函数中，最开始的那段关于时间处理的代码，是不是很难看懂？重构之后，将这部分逻辑抽象成一个函数，并且命名为 isLastDayOfMonth，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性\n&#x2F;&#x2F; 重构前的代码\npublic void invest(long userId, long financialProductId) &#123;\n        Calendar calendar &#x3D; Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n\n        if (calendar.get(Calendar.DAY_OF_MONTH) &#x3D;&#x3D; 1) &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：提炼函数之后逻辑更加清晰\npublic void invest(long userId, long financialProductId) &#123;\n        if (isLastDayOfMonth(new Date())) &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F;...\n&#125;\npublic boolean isLastDayOfMonth(Date date) &#123;\n        Calendar calendar &#x3D; Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n\n        if (calendar.get(Calendar.DAY_OF_MONTH) &#x3D;&#x3D; 1) &#123;\n            return true;\n        &#125;\n        return false;\n&#125;\n\n5.4.2 避免函数参数过多函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候，就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有 2 种处理方法：\n1、考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数\npublic void getUser(String username, String telephone, String email);\n&#x2F;&#x2F; 拆分成多个函数\npublic void getUserByUsername(String username);\npublic void getUserByTelephone(String telephone);\npublic void getUserByEmail(String email);\n\n2、将函数的参数封装成对象\npublic void postBlog(String title, String summary, String keywords, String cont\n&#x2F;&#x2F; 将参数封装成对象\npublic class Blog &#123;\n    private String title;\n    private String summary;\n    private String keywords;\n    private Strint content;\n    private String category;\n    private long authorId;\n&#125;\npublic void postBlog(Blog blog);\n\n除此之外，如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了\n5.4.3 勿用函数参数来控制逻辑不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。建议将其拆成两个函数，可读性上也要更好。如下例：\npublic void buyCourse(long userId, long courseId, boolean isVip);\n&#x2F;&#x2F; 将其拆分成两个函数\npublic void buyCourse(long userId, long courseId);\npublic void buyCourseForVip(long userId, long courseId);\n\n不过，如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，可以酌情考虑保留标识参数。示例代码如下所示：\n&#x2F;&#x2F; 拆分成两个函数的调用方式\nboolean isVip &#x3D; false;\n&#x2F;&#x2F;...省略其他逻辑...\nif (isVip) &#123;\n    buyCourseForVip(userId, courseId);\n&#125; else &#123;\n    buyCourse(userId, courseId);\n&#125;\n&#x2F;&#x2F; 保留标识参数的调用方式更加简洁\nboolean isVip &#x3D; false;\n&#x2F;&#x2F;...省略其他逻辑...\nbuyCourse(userId, courseId, isVip);\n\n除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为 null”来控制逻辑的情况。针对这种情况，也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。具体代码示例如下所示：\npublic List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;\n    if (startDate !&#x3D; null &amp;&amp; endDate !&#x3D; null) &#123;\n        &#x2F;&#x2F; 查询两个时间区间的transactions\n    &#125;\n    if (startDate !&#x3D; null &amp;&amp; endDate &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; 查询startDate之后的所有transactions\n    &#125;\n    if (startDate &#x3D;&#x3D; null &amp;&amp; endDate !&#x3D; null) &#123;\n        &#x2F;&#x2F; 查询endDate之前的所有transactions\n    &#125;\n    if (startDate &#x3D;&#x3D; null &amp;&amp; endDate &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; 查询所有的transactions\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 拆分成多个public函数，更加清晰、易用\npublic List&lt;Transaction&gt; selectTransactionsBetween(Long userId, Date startDate, Date endDate) &#123;\n    return selectTransactions(userId, startDate, endDate);\n&#125;\npublic List&lt;Transaction&gt; selectTransactionsStartWith(Long userId, Date startDate, Date endDate) &#123;\n    return selectTransactions(userId, startDate, null);\n&#125;\npublic List&lt;Transaction&gt; selectTransactionsEndWith(Long userId, Date endDate) &#123;\n    return selectTransactions(userId, null, endDate);\n&#125;\npublic List&lt;Transaction&gt; selectAllTransactions(Long userId) &#123;\n    return selectTransactions(userId, null, null);\n&#125;\nprivate List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n\n5.4.4 函数设计要职责单一前面讲到单一职责原则的时候，针对的是类、模块这样的应用对象。实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一，如下例：\npublic boolean checkUserIfExisting(String telephone, String username, String email) &#123;\n        if (!StringUtils.isBlank(telephone)) &#123;\n            User user &#x3D; userRepo.selectUserByTelephone(telephone);\n            return user !&#x3D; null;\n        &#125;\n        if (!StringUtils.isBlank(username)) &#123;\n            User user &#x3D; userRepo.selectUserByUsername(username);\n            return user !&#x3D; null;\n        &#125;\n        if (!StringUtils.isBlank(email)) &#123;\n            User user &#x3D; userRepo.selectUserByEmail(email);\n            return user !&#x3D; null;\n        &#125;\n        return false;\n&#125;\n&#x2F;&#x2F; 拆分成三个函数\npublic boolean checkUserIfExistingByTelephone(String telephone);\npublic boolean checkUserIfExistingByUsername(String username);\npublic boolean checkUserIfExistingByEmail(String email);\n\n5.4.5 移除过深的嵌套层次代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的。个人建议，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁\n解决嵌套过深的方法也比较成熟，有下面 4 种常见的思路：\n1、去掉多余的 if 或 else 语句\n&#x2F;&#x2F; 示例一\npublic double caculateTotalAmount(List&lt;Order&gt; orders) &#123;\n        if (orders &#x3D;&#x3D; null || orders.isEmpty()) &#123;\n            return 0.0;\n        &#125; else &#123; &#x2F;&#x2F; 此处的else可以去掉\n            double amount &#x3D; 0.0;\n            for (Order order : orders) &#123;\n                if (order !&#x3D; null) &#123;\n                amount +&#x3D; (order.getCount() * order.getPrice());\n            &#125;\n        &#125;\n        return amount;\n        &#125;\n&#125;\n\n&#x2F;&#x2F; 示例二\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n        List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n        if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;\n            for (String str : strList) &#123;\n                if (str !&#x3D; null) &#123; &#x2F;&#x2F; 跟下面的if语句可以合并在一起\n                    if (str.contains(substr)) &#123;\n                        matchedStrings.add(str);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return matchedStrings;\n&#125;\n\n2、使用编程语言提供的 continue、break、return 关键字，提前退出嵌套\n&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n        List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n        if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null)&#123;\n            for (String str : strList) &#123;\n                if (str !&#x3D; null &amp;&amp; str.contains(substr)) &#123;\n                    matchedStrings.add(str);\n                    &#x2F;&#x2F; 此处还有10行代码...\n                &#125;\n            &#125;\n        &#125;\n        return matchedStrings;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：使用continue提前退出\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n        List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n        if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null)&#123;\n            for (String str : strList) &#123;\n                if (str &#x3D;&#x3D; null || !str.contains(substr)) &#123;\n                    continue;\n                &#125;\n                matchedStrings.add(str);\n                &#x2F;&#x2F; 此处还有10行代码...\n            &#125;\n        &#125;\n        return matchedStrings;\n&#125;\n\n3、调整执行顺序来减少嵌套\n&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n        List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n        if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;\n            for (String str : strList) &#123;\n                if (str !&#x3D; null) &#123;\n                    if (str.contains(substr)) &#123;\n                        matchedStrings.add(str);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return matchedStrings;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：先执行判空逻辑，再执行正常逻辑\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n        if (strList &#x3D;&#x3D; null || substr &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;先判空\n            return Collections.emptyList();\n        &#125;\n        List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n        for (String str : strList) &#123;\n            if (str !&#x3D; null) &#123;\n                if (str.contains(substr)) &#123;\n                    matchedStrings.add(str);\n                &#125;\n            &#125;\n        &#125;\n        return matchedStrings;\n&#125;\n\n4、将部分嵌套逻辑封装成函数调用，以此来减少嵌套\n&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) &#123;\n        if (passwords &#x3D;&#x3D; null || passwords.isEmpty()) &#123;\n            return Collections.emptyList();\n        &#125;\n        List&lt;String&gt; passwordsWithSalt &#x3D; new ArrayList&lt;&gt;();\n        for (String password : passwords) &#123;\n            if (password &#x3D;&#x3D; null) &#123;\n                continue;\n            &#125;\n            if (password.length() &lt; 8) &#123;\n                &#x2F;&#x2F; ...\n            &#125; else &#123;\n                &#x2F;&#x2F; ...\n            &#125;\n        &#125;\n        return passwordsWithSalt;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：将部分逻辑抽成函数\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) &#123;\n        if (passwords &#x3D;&#x3D; null || passwords.isEmpty()) &#123;\n            return Collections.emptyList();\n        &#125;\n        List&lt;String&gt; passwordsWithSalt &#x3D; new ArrayList&lt;&gt;();\n        for (String password : passwords) &#123;\n            if (password &#x3D;&#x3D; null) &#123;\n                continue;\n            &#125;\n            passwordsWithSalt.add(appendSalt(password));\n        &#125;\n        return passwordsWithSalt;\n&#125;\nprivate String appendSalt(String password) &#123;\n        String passwordWithSalt &#x3D; password;\n        if (password.length() &lt; 8) &#123;\n            &#x2F;&#x2F; ...\n        &#125; else &#123;\n            &#x2F;&#x2F; ...\n        &#125;\n        return passwordWithSalt;\n&#125;\n\n除此之外，常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法。这个思路涉及代码结构的改动\n5.4.6 学会使用解释性变量常用的用解释性变量来提高代码的可读性的情况有下面 2 种：\n1、常量取代魔法数字\npublic double CalculateCircularArea(double radius) &#123;\n    return (3.1415) * radius * radius;\n&#125;\n&#x2F;&#x2F; 常量替代魔法数字\npublic static final Double PI &#x3D; 3.1415;\npublic double CalculateCircularArea(double radius) &#123;\n    return PI * radius * radius;\n&#125;\n\n2、使用解释性变量来解释复杂表达式\nif (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;\n    &#x2F;&#x2F; ...\n&#125; else &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n&#x2F;&#x2F; 引入解释性变量后逻辑更加清晰\nboolean isSummer &#x3D; date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);\nif (isSummer) &#123;\n    &#x2F;&#x2F; ...\n&#125; else &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n6. 通过一段 ID 生成器代码，学习如何发现代码质量问题6.1 需求背景介绍“ID”中文翻译为“标识（Identifier）”。这个概念在生活、工作中随处可见，比如身份证、商品条形码、二维码、车牌号、驾照号。聚焦到软件开发中，ID 常用来表示一些业务信息的唯一标识，比如订单的单号或者数据库中的唯一主键，比如地址表中的 ID 字段（实际上是没有业务含义的，对用户来说是透明的，不需要关注）\n假设在一个后端业务系统的开发中，为了方便在请求出错时排查问题，在编写代码的时候会在关键路径上打印日志。某个请求出错之后，希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。而实际情况是，在日志文件中，不同请求的日志会交织在一起。如果没有东西来标识哪些日志属于同一个请求，就无法关联同一个请求的所有日志\n这听起来有点像微服务中的调用链追踪。不过，微服务中的调用链追踪是服务间的追踪，这里现在要实现的是服务内的追踪\n借鉴微服务调用链追踪的实现思路，可以给每个请求分配一个唯一 ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在 Java 语言中，可以将 ID 存储在 Servlet 线程的 ThreadLocal 中，或者利用 Slf4j 日志框架的 MDC（Mapped Diagnostic Contexts）来实现（实际上底层原理也是基于线程的 ThreadLocal）。每次打印日志的时候，从请求上下文中取出请求 ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求 ID 信息，就可以通过请求 ID 来搜索同一个请求的所有日志了\n6.2 一份“能用”的代码实现public class IdGenerator &#123;\n    private static final Logger logger &#x3D; LoggerFactory.getLogger(IdGenerator.class);\n\n    public static String generate() &#123;\n        String id &#x3D; &quot;&quot;;\n        try &#123;\n            String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n            String[] tokens &#x3D; hostName.split(&quot;\\\\.&quot;);\n            if (tokens.length &gt; 0) &#123;\n                hostName &#x3D; tokens[tokens.length - 1];\n            &#125;\n            char[] randomChars &#x3D; new char[8];\n            int count &#x3D; 0;\n            Random random &#x3D; new Random();\n            while (count &lt; 8) &#123;\n                int randomAscii &#x3D; random.nextInt(122);\n                if (randomAscii &gt;&#x3D; 48 &amp;&amp; randomAscii &lt;&#x3D; 57) &#123;\n                    randomChars[count] &#x3D; (char)(&#39;0&#39; + (randomAscii - 48));\n                    count++;\n                &#125; else if (randomAscii &gt;&#x3D; 65 &amp;&amp; randomAscii &lt;&#x3D; 90) &#123;\n                    randomChars[count] &#x3D; (char)(&#39;A&#39; + (randomAscii - 65));\n                    count++;\n                &#125; else if (randomAscii &gt;&#x3D; 97 &amp;&amp; randomAscii &lt;&#x3D; 122) &#123;\n                    randomChars[count] &#x3D; (char)(&#39;a&#39; + (randomAscii - 97));\n                    count++;\n                &#125;\n            &#125;\n            id &#x3D; String.format(&quot;%s-%d-%s&quot;, hostName,\n                    System.currentTimeMillis(), new String(randomChars));\n        &#125; catch (UnknownHostException e) &#123;\n            logger.warn(&quot;Failed to get the host name.&quot;, e);\n        &#125;\n        return id;\n    &#125;\n&#125;\n\n上面的代码生成的 ID 示例如下所示。整个 ID 由三部分组成。第一部分是本机名的最后一个字段。第二部分是当前时间戳，精确到毫秒。第三部分是 8 位的随机字符串，包含大小写字母和数字。尽管这样生成的 ID 并不是绝对唯一的，有重复的可能，但事实上重复的概率非常低。对于日志追踪来说，极小概率的 ID 重复是完全可以接受的\n103-1577456311467-3nR3Do45\n103-1577456311468-0wnuV5yw\n103-1577456311468-sdrnkFxN\n103-1577456311468-8lwk0BP0\n\n6.3 如何发现代码质量问题？从大处着眼的话，可以参考之前讲过的代码质量评判标准，看这段代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等等。落实到具体细节，可以从以下几个方面来审视代码：\n\n目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？\n是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？\n设计模式是否应用得当？是否有过度设计？\n代码是否容易扩展？如果要添加新功能，是否容易实现？\n代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？\n代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？\n代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？\n\n以上是一些通用的关注点，可以作为常规检查项，套用在任何代码的重构上。除此之外，还要关注代码实现是否满足业务本身特有的功能和非功能需求。这里罗列了一些比较有共性的问题，如下所示。这份列表可能还不够全面，剩下的需要针对具体的业务、具体的代码去具体分析：\n\n代码是否实现了预期的业务需求？\n逻辑是否正确？是否处理了各种异常情况？\n日志打印是否得当？是否方便 debug 排查问题？\n接口是否易用？是否支持幂等、事务等？\n代码是否存在并发问题？是否线程安全？\n性能是否有优化空间，比如，SQL、算法是否可以优化？\n是否有安全漏洞？比如输入输出校验是否全面？\n\n现在，对照上面的检查项，来看一下，6.2 的代码有哪些问题\n1、IdGenerator 的代码比较简单，只有一个类，所以，不涉及目录设置、模块划分、代码结构问题，也不违反基本的 SOLID、DRY、KISS、YAGNI、LOD 等设计原则。它没有应用设计模式，所以也不存在不合理使用和过度设计的问题\n2、IdGenerator 设计成了实现类而非接口，调用者直接依赖实现而非接口，违反基于接口而非实现编程的设计思想。实际上，将 IdGenerator 设计成实现类，而不定义接口，问题也不大。如果哪天 ID 生成算法改变了，只需要直接修改实现类的代码就可以。但是，如果项目中需要同时存在两种 ID 生成算法，也就是要同时存在两个 IdGenerator 实现类。比如，需要将这个框架给更多的系统来使用。系统在使用的时候，可以灵活地选择它需要的生成算法。这个时候，就需要将 IdGenerator 定义为接口，并且为不同的生成算法定义不同的实现类\n3、把 IdGenerator 的 generate() 函数定义为静态函数，会影响使用该函数的代码的可测试性。同时，generate() 函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以 generate() 函数本身的可测试性也不好，需要做比较大的重构。除此之外，也没有编写单元测试代码，需要在重构时对其进行补充\n4、虽然 IdGenerator 只包含一个函数，并且代码行数也不多，但代码的可读性并不好。特别是随机字符串生成的那部分代码，一方面，代码完全没有注释，生成算法比较难读懂，另一方面，代码里有很多魔法数，严重影响代码的可读性。在重构的时候，需要重点提高这部分代码的可读性\n刚刚参照跟业务本身无关的、通用的代码质量关注点，对代码进行了评价。现在，再对照业务本身的功能和非功能需求，重新审视一下代码\n1、前面提到，虽然代码生成的 ID 并非绝对的唯一，但是对于追踪打印日志来说，是可以接受小概率 ID 冲突的，满足预期的业务需求。不过，获取 hostName 这部分代码逻辑貌似有点问题，并未处理“hostName 为空”的情况。除此之外，尽管代码中针对获取不到本机名的情况做了异常处理，但是对异常的处理是在 IdGenerator 内部将其吐掉，然后打印一条报警日志，并没有继续往上抛出。这样的异常处理是否得当呢？\n2、代码的日志打印得当，日志描述能够准确反应问题，方便 debug，并且没有过多的冗余日志。IdGenerator 只暴露一个 generate() 接口供使用者使用，接口的定义简单明了，不存在不易用问题。generate() 函数代码中没有涉及共享变量，所以代码线程安全，多线程环境下调用 generate() 函数不存在并发问题\n3、性能方面，ID 的生成不依赖外部存储，在内存中生成，并且日志的打印频率也不会很高，所以代码在性能方面足以应对目前的应用场景。不过，每次生成 ID 都需要获取本机名，获取主机名会比较耗时，所以，这部分可以考虑优化一下。还有，randomAscii 的范围是 0～122，但可用数字仅包含三段子区间（0~9,a~z,A~Z），极端情况下会随机生成很多三段区间之外的无效数字，需要循环很多次才能生成随机字符串，所以随机字符串的生成算法也可以优化一下\n有一些代码质量问题不具有共性，没法一一罗列，需要针对具体的业务、具体的代码去具体分析。那像这份代码，还能发现有哪些具体问题吗？\n在 generate() 函数的 while 循环里面，三个 if 语句内部的代码非常相似，而且实现稍微有点过于复杂了，实际上可以进一步简化，将这三个 if 合并在一起\n6.4 重构前面讲到系统设计和实现的时候，多次讲到要循序渐进、小步快跑。重构代码的过程也应该遵循这样的思路。每次改动一点点，改好之后，再进行下一轮的优化，保证每次对代码的改动不会过大，能在很短的时间内完成。所以，将上面发现的代码质量问题，分成四次重构来完成，具体如下所示：\n\n提高代码的可读性\n提高代码的可测试性\n编写完善的单元测试\n所有重构完成之后添加注释\n\n6.4.1 提高代码的可读性首先，要解决最明显、最急需改进的代码可读性问题。具体有下面几点：\n\nhostName 变量不应该被重复使用，尤其当这两次使用时的含义还不同的时候\n将获取 hostName 的代码抽离出来，定义为 getLastfieldOfHostName() 函数\n删除代码中的魔法数，比如，57、90、97、122\n将随机数生成的代码抽离出来，定义为 generateRandomAlphameric() 函数\ngenerate() 函数中的三个 if 逻辑重复了，且实现过于复杂，我们要对其进行简化\n对 IdGenerator 类重命名，并且抽象出对应的接口\n\n这里重点讨论下最后一个修改。实际上，对于 ID 生成器的代码，有下面三种类的命名方式。哪种更合适呢？\n\n1、将接口命名为 IdGenerator，实现类命名为 LogTraceIdGenerator，这可能是很多人最先想到的命名方式了。在命名的时候，要考虑到，以后两个类会如何使用、会如何扩展。从使用和扩展的角度来分析，这样的命名就不合理了\n首先，如果扩展新的日志 ID 生成算法，也就是要创建另一个新的实现类，因为原来的实现类已经叫 LogTraceIdGenerator 了，命名过于通用，那新的实现类就不好取名了，无法取一个跟 LogTraceIdGenerator 平行的名字了\n其次可能会说，假设没有日志 ID 的扩展需求，但要扩展其他业务的 ID 生成算法，比如针对用户的（UserldGenerator）、订单的（OrderIdGenerator），第一种命名方式是不是就是合理的呢？答案也是否定的。基于接口而非实现编程，主要的目的是为了方便后续灵活地替换实现类。而 LogTraceIdGenerator、UserIdGenerator、OrderIdGenerator 三个类从命名上来看，涉及的是完全不同的业务，不存在互相替换的场景。也就是说，不可能在有关日志的代码中，进行下面这种替换。所以，让这三个类实现同一个接口，实际上是没有意义的\nIdGenearator idGenerator &#x3D; new LogTraceIdGenerator();\n替换为:\nIdGenearator idGenerator &#x3D; new UserIdGenerator();\n\n2、第二种命名方式是不是就合理了呢？答案也是否定的。其中，LogTraceIdGenerator 接口的命名是合理的，但是 HostNameMillisIdGenerator 实现类暴露了太多实现细节，只要代码稍微有所改动，就可能需要改动命名，才能匹配实现\n3、第三种命名方式是比较推荐的。在目前的 ID 生成器代码实现中，生成的 ID 是一个随机 ID，不是递增有序的，所以，命名成 RandomIdGenerator 是比较合理的，即便内部生成算法有所改动，只要生成的还是随机的 ID，就不需要改动命名。如果需要扩展新的 ID 生成算法，比如要实现一个递增有序的 ID 生成算法，那可以命名为 SequenceIdGenerator\n实际上，更好的一种命名方式是，抽象出两个接口，一个是 IdGenerator，一个是 LogTraceIdGenerator，LogTraceIdGenerator 继承 IdGenerator。实现类实现接口 LogTraceIdGenerator，命名为 RandomIdGenerator、SequenceIdGenerator 等。这样，实现类可以复用到多个业务模块中，比如前面提到的用户、订单\n根据上面的优化策略，对代码进行第一轮的重构，重构之后的代码如下所示：\npublic interface IdGenerator &#123;\n    String generate();\n&#125;\n\npublic interface LogTraceIdGenerator extends IdGenerator &#123;\n&#125;\n\npublic class RandomIdGenerator implements IdGenerator &#123;\n    private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);\n\n    @Override\n    public String generate() &#123;\n        String substrOfHostName &#x3D; getLastfieldOfHostName();\n        long currentTimeMillis &#x3D; System.currentTimeMillis();\n        String randomString &#x3D; generateRandomAlphameric(8);\n        String id &#x3D; String.format(&quot;%s-%d-%s&quot;,\n                substrOfHostName, currentTimeMillis, randomString);\n        return id;\n    &#125;\n    private String getLastfieldOfHostName() &#123;\n        String substrOfHostName &#x3D; null;\n        try &#123;\n            String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n            String[] tokens &#x3D; hostName.split(&quot;\\\\.&quot;);\n            substrOfHostName &#x3D; tokens[tokens.length - 1];\n            return substrOfHostName;\n        &#125; catch (UnknownHostException e) &#123;\n            logger.warn(&quot;Failed to get the host name.&quot;, e);\n        &#125;\n        return substrOfHostName;\n    &#125;\n    private String generateRandomAlphameric(int length) &#123;\n        char[] randomChars &#x3D; new char[length];\n        int count &#x3D; 0;\n        Random random &#x3D; new Random();\n        while (count &lt; length) &#123;\n            int maxAscii &#x3D; &#39;z&#39;;\n            int randomAscii &#x3D; random.nextInt(maxAscii);\n            boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;\n            boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;\n            boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;\n            if (isDigit|| isUppercase || isLowercase) &#123;\n                randomChars[count] &#x3D; (char) (randomAscii);\n                ++count;\n            &#125;\n        &#125;\n        return new String(randomChars);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 代码使用举例\nLogTraceIdGenerator logTraceIdGenerator &#x3D; new RandomIdGenerator();\n\n6.4.2 提高代码的可测试性关于代码可测试性的问题，主要包含下面两个方面：\n\ngenerate() 函数定义为静态函数，会影响使用该函数的代码的可测试性\ngenerate() 函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以 generate() 函数本身的可测试性也不好\n\n对于第一点，已经在第一轮重构中解决了。将 RandomIdGenerator 类中的 generate() 静态函数重新定义成了普通函数。调用者可以通过依赖注入的方式，在外部创建好 RandomIdGenerator 对象后注入到自己的代码中，从而解决静态函数调用影响代码可测试性的问题\n对于第二点，需要在第一轮重构的基础之上再进行重构。重构之后的代码如下所示，主要包括以下几个代码改动：\n\n从 getLastfieldOfHostName() 函数中，将逻辑比较复杂的那部分代码剥离出来，定义为 getLastSubstrSplittedByDot() 函数。因为 getLastfieldOfHostName() 函数依赖本地主机名，所以，剥离出主要代码之后这个函数变得非常简单，可以不用测试。重点测试 getLastSubstrSplittedByDot() 函数即可\n将 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 这两个函数的访问权限设置为 protected。这样做的目的是，可以直接在单元测试中通过对象来调用两个函数进行测试\n给 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 两个函数添加 Google Guava 的 annotation @VisibleForTesting。这个 annotation 没有任何实际的作用，只起到标识的作用，告诉其他人说，这两个函数本该是 private 访问权限的，之所以提升访问权限到 protected，只是为了测试，只能用于单元测试中\n\n\npublic class RandomIdGenerator implements LogTraceIdGenerator &#123;\n  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  @Override\n  public String generate() &#123;\n    String substrOfHostName &#x3D; getLastfieldOfHostName();\n    long currentTimeMillis &#x3D; System.currentTimeMillis();\n    String randomString &#x3D; generateRandomAlphameric(8);\n    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,\n            substrOfHostName, currentTimeMillis, randomString);\n    return id;\n  &#125;\n\n  private String getLastfieldOfHostName() &#123;\n    String substrOfHostName &#x3D; null;\n    try &#123;\n      String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n      substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);\n    &#125; catch (UnknownHostException e) &#123;\n      logger.warn(&quot;Failed to get the host name.&quot;, e);\n    &#125;\n    return substrOfHostName;\n  &#125;\n\n  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) &#123;\n    String[] tokens &#x3D; hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName &#x3D; tokens[tokens.length - 1];\n    return substrOfHostName;\n  &#125;\n\n  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) &#123;\n    char[] randomChars &#x3D; new char[length];\n    int count &#x3D; 0;\n    Random random &#x3D; new Random();\n    while (count &lt; length) &#123;\n      int maxAscii &#x3D; &#39;z&#39;;\n      int randomAscii &#x3D; random.nextInt(maxAscii);\n      boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;\n      boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;\n      boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;\n      if (isDigit|| isUppercase || isLowercase) &#123;\n        randomChars[count] &#x3D; (char) (randomAscii);\n        ++count;\n      &#125;\n    &#125;\n    return new String(randomChars);\n  &#125;\n&#125;\n\n打印日志的 Logger 对象被定义为 static final 的，并且在类内部创建，这是否影响到代码的可测试性？是否应该将 Logger 对象通过依赖注入的方式注入到类中呢？\n依赖注入之所以能提高代码可测试性，主要是因为，通过这样的方式能轻松地用 mock 对象替换依赖的真实对象。那为什么要 mock 这个对象呢？这是因为，这个对象参与逻辑执行（比如，要依赖它输出的数据做后续的计算）但又不可控。对于 Logger 对象来说，只往里写入数据，并不读取数据，不参与业务逻辑的执行，不会影响代码逻辑的正确性，所以，没有必要 mock Logger 对象\n除此之外，一些只是为了存储数据的值对象，比如 String、Map、UserVo，也没必要通过依赖注入的方式来创建，直接在类中通过 new 创建就可以了\n6.4.3 编写完善的单元测试经过上面的重构之后，代码存在的比较明显的问题，基本上都已经解决了。现在为代码补全单元测试。RandomIdGenerator 类中有 4 个函数：\npublic String generate();\nprivate String getLastfieldOfHostName();\n@VisibleForTesting\nprotected String getLastSubstrSplittedByDot(String hostName);\n@VisibleForTesting\nprotected String generateRandomAlphameric(int length);\n\n先来看后两个函数。这两个函数包含的逻辑比较复杂，是测试的重点。而且，在上一步重构中，为了提高代码的可测试性，已经将这两个部分代码跟不可控的组件（本机名、随机函数、时间函数）进行了隔离。所以，只需要设计完备的单元测试用例即可。具体的代码实现如下所示（注意，这里使用了 JUnit 测试框架）：\npublic class RandomIdGeneratorTest &#123;\n  @Test\n  public void testGetLastSubstrSplittedByDot() &#123;\n    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();\n    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1.field2.field3&quot;);\n    Assert.assertEquals(&quot;field3&quot;, actualSubstr);\n\n    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1&quot;);\n    Assert.assertEquals(&quot;field1&quot;, actualSubstr);\n\n    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;field1#field2#field3&quot;);\n    Assert.assertEquals(&quot;field1#field2#field3&quot;, actualSubstr);\n  &#125;\n\n  &#x2F;&#x2F; 此单元测试会失败，因为在代码中没有处理hostName为null或空字符串的情况\n  @Test\n  public void testGetLastSubstrSplittedByDot_nullOrEmpty() &#123;\n    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();\n    String actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(null);\n    Assert.assertNull(actualSubstr);\n\n    actualSubstr &#x3D; idGenerator.getLastSubstrSplittedByDot(&quot;&quot;);\n    Assert.assertEquals(&quot;&quot;, actualSubstr);\n  &#125;\n\n  @Test\n  public void testGenerateRandomAlphameric() &#123;\n    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();\n    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(6);\n    Assert.assertNotNull(actualRandomString);\n    Assert.assertEquals(6, actualRandomString.length());\n    for (char c : actualRandomString.toCharArray()) &#123;\n         Assert.assertTrue((&#39;0&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;9&#39;) || (&#39;a&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;z&#39;) || (&#39;A&#39; &lt;&#x3D; c &amp;&amp; c &lt;&#x3D; &#39;Z&#39;));\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 此单元测试会失败，因为在代码中没有处理length&lt;&#x3D;0的情况\n  @Test\n  public void testGenerateRandomAlphameric_lengthEqualsOrLessThanZero() &#123;\n    RandomIdGenerator idGenerator &#x3D; new RandomIdGenerator();\n    String actualRandomString &#x3D; idGenerator.generateRandomAlphameric(0);\n    Assert.assertEquals(&quot;&quot;, actualRandomString);\n\n    actualRandomString &#x3D; idGenerator.generateRandomAlphameric(-1);\n    Assert.assertNull(actualRandomString);\n  &#125;\n&#125;\n\n再来看 generate() 函数。这个函数也是我们唯一一个暴露给外部使用的 public 函数。虽然逻辑比较简单，最好还是测试一下。但是，它依赖主机名、随机函数、时间函数，我们该如何测试呢？需要 mock 这些函数的实现吗？\n实际上，这要分情况来看。前面讲过，写单元测试的时候，测试对象是函数定义的功能，而非具体的实现逻辑。这样才能做到，函数的实现逻辑改变了之后，单元测试用例仍然可以工作。那 generate() 函数实现的功能是什么呢？这完全是由代码编写者自己来定义的\n比如，针对同一份 generate() 函数的代码实现，可以有 3 种不同的功能定义，对应 3 种不同的单元测试：\n\n如果把 generate() 函数的功能定义为：“生成一个随机唯一 ID”，那只要测试多次调用 generate() 函数生成的 ID 是否唯一即可\n如果把 generate() 函数的功能定义为：“生成一个只包含数字、大小写字母和中划线的唯一 ID”，那不仅要测试 ID 的唯一性，还要测试生成的 ID 是否只包含数字、大小写字母和中划线\n如果把 generate() 函数的功能定义为：“生成唯一 ID，格式为：{主机名 substr}-{时间戳}-{8 位随机数}。在主机名获取失败时，返回：null-{时间戳}-{8 位随机数}”，那不仅要测试 ID 的唯一性，还要测试生成的 ID 是否完全符合格式要求\n\n单元测试用例如何写，关键看函数如何定义。针对 generate() 函数的前两种定义，不需要 mock 获取主机名函数、随机函数、时间函数等，但对于第 3 种定义，需要 mock 获取主机名函数，让其返回 null，测试代码运行是否符合预期\n最后来看下 getLastfieldOfHostName() 函数。实际上，这个函数不容易测试，因为它调用了一个静态函数（InetAddress.getLocalHost().getHostName();），并且这个静态函数依赖运行环境。但是，这个函数的实现非常简单，肉眼基本上可以排除明显的 bug，所以可以不为其编写单元测试代码。毕竟，写单元测试的目的是为了减少代码 bug，而不是为了写单元测试而写单元测试\n当然，如果真的想要对它进行测试，也是有办法的。一种办法是使用更加高级的测试框架。比如 PowerMock，它可以 mock 静态函数。另一种方式是将获取本机名的逻辑再封装为一个新的函数。不过，后一种方法会造成代码过度零碎，也会稍微影响到代码的可读性，这个需要自己去权衡利弊来做选择\n6.4.3 添加注释注释不能太多，也不能太少，主要添加在类和函数上。有人说，好的命名可以替代注释，清晰的表达含义。这点对于变量的命名来说是适用的，但对于类或函数来说就不一定对了。类或函数包含的逻辑往往比较复杂，单纯靠命名很难清晰地表明实现了什么功能，这个时候就需要通过注释来补充。比如，前面提到的对于 generate() 函数的 3 种功能定义，就无法用命名来体现，需要补充到注释里面\n对于如何写注释，主要就是写清楚：做什么、为什么、怎么做、怎么用，对一些边界条件、特殊情况进行说明，以及对函数输入、输出、异常进行说明\n&#x2F;**\n * Id Generator that is used to generate random IDs.\n *\n * &lt;p&gt;\n * The IDs generated by this class are not absolutely unique,\n * but the probability of duplication is very low.\n *&#x2F;\npublic class RandomIdGenerator implements LogTraceIdGenerator &#123;\n  private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);\n\n  &#x2F;**\n   * Generate the random ID. The IDs may be duplicated only in extreme situation.\n   *\n   * @return an random ID\n   *&#x2F;\n  @Override\n  public String generate() &#123;\n    &#x2F;&#x2F;...\n  &#125;\n\n  &#x2F;**\n   * Get the local hostname and\n   * extract the last field of the name string splitted by delimiter &#39;.&#39;.\n   *\n   * @return the last field of hostname. Returns null if hostname is not obtained.\n   *&#x2F;\n  private String getLastfieldOfHostName() &#123;\n    &#x2F;&#x2F;...\n  &#125;\n\n  &#x2F;**\n   * Get the last field of &#123;@hostName&#125; splitted by delemiter &#39;.&#39;.\n   *\n   * @param hostName should not be null\n   * @return the last field of &#123;@hostName&#125;. Returns empty string if &#123;@hostName&#125; is empty string.\n   *&#x2F;\n  @VisibleForTesting\n  protected String getLastSubstrSplittedByDot(String hostName) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n\n  &#x2F;**\n   * Generate random string which\n   * only contains digits, uppercase letters and lowercase letters.\n   *\n   * @param length should not be less than 0\n   * @return the random string. Returns empty string if &#123;@length&#125; is 0\n   *&#x2F;\n  @VisibleForTesting\n  protected String generateRandomAlphameric(int length) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n\n6.5 异常处理可以把函数的运行结果分为两类。一类是预期的结果，也就是函数在正常情况下输出的结果。一类是非预期的结果，也就是函数在异常（或叫出错）情况下输出的结果。比如，在上面获取本机名的函数，在正常情况下，函数返回字符串格式的本机名；在异常情况下，获取本机名失败，函数返回 UnknownHostException 异常对象\n在正常情况下，函数返回数据的类型非常明确，但是，在异常情况下，函数返回的数据类型却非常灵活，有多种选择。除了刚刚提到的类似 UnknownHostException 这样的异常对象之外，函数在异常情况下还可以返回错误码、NULL 值、特殊值（比如 -1）、空对象（比如空字符串、空集合）等\n每一种异常返回数据类型，都有各自的特点和适用场景。但有的时候，在异常情况下，函数到底该返回什么样的数据类型，并不那么容易判断。比如，在本机名获取失败的时候，ID 生成器的 generate() 函数应该返回什么呢？是异常？空字符？还是 NULL 值？又或者是其他特殊值（比如 null-15293834874-fd3A9KBn，null 表示本机名未获取到）呢？\n函数是代码的一个非常重要的编写单元，而函数的异常处理，又是在编写函数的时候，时刻都要考虑的。所以，如何设计函数在异常情况下的返回数据类型是很重要的\n前面把一份非常简单的 ID 生成器的代码，从“能用”重构成了“好用”。最终给出的代码看似已经很完美了，但是如果再用心推敲一下，代码中关于出错处理的方式，还有进一步优化的空间\npublic class RandomIdGenerator implements IdGenerator &#123;\n    private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);\n\n    @Override\n    public String generate() &#123;\n        String substrOfHostName &#x3D; getLastFiledOfHostName();\n        long currentTimeMillis &#x3D; System.currentTimeMillis();\n        String randomString &#x3D; generateRandomAlphameric(8);\n        String id &#x3D; String.format(&quot;%s-%d-%s&quot;,\n                substrOfHostName, currentTimeMillis, randomString);\n        return id;\n    &#125;\n    private String getLastFiledOfHostName() &#123;\n        String substrOfHostName &#x3D; null;\n        try &#123;\n            String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n            substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);\n        &#125; catch (UnknownHostException e) &#123;\n            logger.warn(&quot;Failed to get the host name.&quot;, e);\n        &#125;\n        return substrOfHostName;\n    &#125;\n    @VisibleForTesting\n    protected String getLastSubstrSplittedByDot(String hostName) &#123;\n        String[] tokens &#x3D; hostName.split(&quot;\\\\.&quot;);\n        String substrOfHostName &#x3D; tokens[tokens.length - 1];\n        return substrOfHostName;\n    &#125;\n    @VisibleForTesting\n    protected String generateRandomAlphameric(int length) &#123;\n        char[] randomChars &#x3D; new char[length];\n        int count &#x3D; 0;\n        Random random &#x3D; new Random();\n        while (count &lt; length) &#123;\n            int maxAscii &#x3D; &#39;z&#39;;\n            int randomAscii &#x3D; random.nextInt(maxAscii);\n            boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;\n            boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;\n            boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;\n            if (isDigit|| isUppercase || isLowercase) &#123;\n                randomChars[count] &#x3D; (char) (randomAscii);\n                ++count;\n            &#125;\n        &#125;\n        return new String(randomChars);\n    &#125;\n&#125;\n\n这段代码中有四个函数。针对这四个函数的出错处理方式，有下面这样几个问题：\n\n对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？\n对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志）？还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？\n对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么？\n对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么？\n\n6.5.1 函数出错应该返回啥？关于函数出错返回数据类型，总结了 4 种情况，它们分别是：错误码、NULL 值、空对象、异常对象\n6.5.1.1 返回错误码C 语言中没有异常这样的语法机制，因此，返回错误码便是最常用的出错处理方式。而在 Java、Python 等比较新的编程语言中，大部分情况下，都用异常来处理函数出错的情况，极少会用到错误码\n在 C 语言中，错误码的返回方式有两种：一种是直接占用函数的返回值，函数正常执行的返回值放到出参中；另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。针对这两种方式，示例如下：\n&#x2F;&#x2F; 错误码的返回方式一：pathname&#x2F;flags&#x2F;mode为入参；fd为出参，存储打开的文件句柄。\nint open(const char *pathname, int flags, mode_t mode, int* fd) &#123;\n    if (&#x2F;*文件不存在*&#x2F;) &#123;\n        return EEXIST;\n    &#125;\n    if (&#x2F;*没有访问权限*&#x2F;) &#123;\n        return EACCESS;\n    &#125;\n    if (&#x2F;*打开文件成功*&#x2F;) &#123;\n        return SUCCESS; &#x2F;&#x2F; C语言中的宏定义：#define SUCCESS 0\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F;使用举例\nint fd;\nint result &#x3D; open(“c:\\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO, &amp;fd);\nif (result &#x3D;&#x3D; SUCCESS) &#123;\n    &#x2F;&#x2F; 取出fd使用\n&#125; else if (result &#x3D;&#x3D; EEXIST) &#123;\n    &#x2F;&#x2F;...\n&#125; else if (result &#x3D;&#x3D; EACESS) &#123;\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 错误码的返回方式二：函数返回打开的文件句柄，错误码放到errno中。\nint errno; &#x2F;&#x2F; 线程安全的全局变量\nint open(const char *pathname, int flags, mode_t mode）&#123;\n    if (&#x2F;*文件不存在*&#x2F;) &#123;\n        errno &#x3D; EEXIST;\n        return -1;\n    &#125;\n    if (&#x2F;*没有访问权限*&#x2F;) &#123;\n        errno &#x3D; EACCESS;\n        return -1;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F; 使用举例\nint hFile &#x3D; open(“c:\\test.txt”, O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO);\nif (-1 &#x3D;&#x3D; hFile) &#123;\n    printf(&quot;Failed to open file, error no: %d.\\n&quot;, errno);\n    if (errno &#x3D;&#x3D; EEXIST ) &#123;\n        &#x2F;&#x2F; ...\n    &#125; else if(errno &#x3D;&#x3D; EACCESS) &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n\n实际上，如果你熟悉的编程语言中有异常这种语法机制，那就尽量不要使用错误码。异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息（exception 中可以有 message、stack trace 等信息）等\n6.5.1.2 返回 NULL 值在多数编程语言中，用 NULL 来表示“不存在”这种语义。不过，网上很多人不建议函数返回 NULL 值，认为这是一种不好的设计思路，主要的理由有以下两个：\n\n如果某个函数有可能返回 NULL 值，在使用它的时候，忘记了做 NULL 值判断，就有可能会抛出空指针异常（Null Pointer Exception，缩写为 NPE）\n如果定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性\n\n如下例：\npublic class UserService &#123;\n    private UserRepo userRepo; &#x2F;&#x2F; 依赖注入\n    public User getUser(String telephone) &#123;\n        &#x2F;&#x2F; 如果用户不存在，则返回null\n        return null;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 使用函数getUser()\nUser user &#x3D; userService.getUser(&quot;18917718965&quot;);\nif (user !&#x3D; null) &#123; &#x2F;&#x2F; 做NULL值判断，否则有可能会报NPE\n    String email &#x3D; user.getEmail();\n    if (email !&#x3D; null) &#123; &#x2F;&#x2F; 做NULL值判断，否则有可能会报NPE\n        String escapedEmail &#x3D; email.replaceAll(&quot;@&quot;, &quot;#&quot;);\n    &#125;\n&#125;\n\n那是否可以用异常来替代 NULL 值，在查找用户不存在的时候，让函数抛出 UserNotFoundException 异常呢？个人觉得，尽管返回 NULL 值有诸多弊端，但对于以 get、find、select、search、query 等单词开头的查找函数来说，数据不存在，并非一种异常情况，这是一种正常行为。所以，返回代表不存在语义的 NULL 值比返回异常更加合理\n不过，话说回来，刚刚讲的这个理由，也并不是特别有说服力。对于查找数据不存在的情况，函数到底是该用 NULL 值还是异常，有一个比较重要的参考标准是，看项目中的其他类似查找函数都是如何定义的，只要整个项目遵从统一的约定即可。如果项目从零开始开发，并没有统一约定和可以参考的代码，那选择两者中的任何一种都可以。只需要在函数定义的地方注释清楚，让调用者清晰地知道数据不存在的时候会返回什么就可以了\n再补充说明一点，对于查找函数来说，除了返回数据对象之外，有的还会返回下标位置，比如 Java 中的 indexOf() 函数，用来实现在某个字符串中查找另一个子串第一次出现的位置。函数的返回值类型为基本类型 int。这个时候，就无法用 NULL 值来表示不存在的情况了。对于这种情况，有两种处理思路，一种是返回 NotFoundException，一种是返回一个特殊值，比如 -1。不过，显然 -1 更加合理，理由也是同样的，也就是说“没有查找到”是一种正常而非异常的行为\n6.5.1.3 返回空对象上面讲到，返回 NULL 值有各种弊端。应对这个问题有一个比较经典的策略，那就是应用空对象设计模式（Null Object Design Pattern）。这里讲两种比较简单、比较特殊的空对象，那就是空字符串和空集合\n当函数返回的数据是字符串类型或者集合类型的时候，可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。这样，在使用函数的时候，就可以不用做 NULL 值判断。示例代码如下：\n&#x2F;&#x2F; 使用空集合替代NULL\npublic class UserService &#123;\n    private UserRepo userRepo; &#x2F;&#x2F; 依赖注入\n    public List&lt;User&gt; getUsers(String telephonePrefix) &#123;\n        &#x2F;&#x2F; 没有查找到数据\n        return Collectiosn.emptyList();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; getUsers使用示例\nList&lt;User&gt; users &#x3D; userService.getUsers(&quot;189&quot;);\nfor (User user : users) &#123; &#x2F;&#x2F;这里不需要做NULL值判断\n    &#x2F;&#x2F; ...\n&#125;\n\n&#x2F;&#x2F; 使用空字符串替代NULL\npublic String retrieveUppercaseLetters(String text) &#123;\n    &#x2F;&#x2F; 如果text中没有大写字母，返回空字符串，而非NULL值\n    return &quot;&quot;;\n&#125;\n&#x2F;&#x2F; retrieveUppercaseLetters()使用举例\nString uppercaseLetters &#x3D; retrieveUppercaseLetters(&quot;wangzheng&quot;);\nint length &#x3D; uppercaseLetters.length(); &#x2F;&#x2F; 不需要做NULL值判断\nSystem.out.println(&quot;Contains &quot; + length + &quot; upper case letters.&quot;);\n\n6.5.1.4 抛出异常对象尽管上面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式就是抛出异常。异常可以携带更多的错误信息，比如函数调用栈信息。除此之外，异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好\n不同的编程语言的异常语法稍有不同。像 C++ 和大部分的动态语言（Python、Ruby、JavaScript 等）都只定义了一种异常类型：运行时异常（Runtime Exception）。而像 Java，除了运行时异常外，还定义了另外一种异常类型：编译时异常（Compile Exception）\n对于运行时异常，在编写代码的时候，可以不用主动去 try-catch，编译器在编译代码的时候，并不会检查代码是否有对运行时异常做了处理。相反，对于编译时异常，在编写代码的时候，需要主动去 try-catch 或者在函数定义中声明，否则编译就会报错。所以，运行时异常也叫作非受检异常（Unchecked Exception），编译时异常也叫作受检异常（Checked Exception）\n如果你熟悉的编程语言中，只定义了一种异常类型，那用起来反倒比较简单。如果你熟悉的编程语言中（比如 Java），定义了两种异常类型，那在异常出现的时候，应该选择抛出哪种异常类型呢？是受检异常还是非受检异常？\n对于代码 bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便捕获了，也做不了太多事情，所以，倾向于使用非受检异常。对于可恢复异常、业务异常，比如提现金额大于余额的异常，更倾向于使用受检异常，明确告知调用者需要捕获处理\n如下例，当 Redis 的地址（参数 address）没有设置的时候，直接使用默认的地址（比如本地地址和默认端口）；当 Redis 的地址格式不正确的时候，希望程序能 fail-fast，也就是说，把这种情况当成不可恢复的异常，直接抛出运行时异常，将程序终止掉\n&#x2F;&#x2F; address格式：&quot;192.131.2.33:7896&quot;\npublic void parseRedisAddress(String address) &#123;\n    this.host &#x3D; RedisConfig.DEFAULT_HOST;\n    this.port &#x3D; RedisConfig.DEFAULT_PORT;\n    if (StringUtils.isBlank(address)) &#123;\n        return;\n    &#125;\n    String[] ipAndPort &#x3D; address.split(&quot;:&quot;);\n    if (ipAndPort.length !&#x3D; 2) &#123;\n        throw new RuntimeException(&quot;...&quot;);\n    &#125;\n    this.host &#x3D; ipAndPort[0];\n    &#x2F;&#x2F; parseInt()解析失败会抛出 NumberFormatException 运行时异常\n    this.port &#x3D; Integer.parseInt(ipAndPort[1]);\n&#125;\n\n实际上，Java 支持的受检异常一直被人诟病，很多人主张所有的异常情况都应该使用非受检异常。支持这种观点的理由主要有以下三个：\n\n受检异常需要显式地在函数定义中声明。如果函数会抛出很多受检异常，那函数的定义就会非常冗长，这就会影响代码的可读性，使用起来也不方便\n编译器强制必须显示地捕获所有的受检异常，代码实现会比较繁琐。而非受检异常正好相反，不需要在定义中显示声明，并且是否需要捕获处理，也可以自由决定\n受检异常的使用违反开闭原则。如果给某个函数新增一个受检异常，这个函数所在的函数调用链上的所有位于其之上的函数都需要做相应的代码修改，直到调用链中的某个函数将这个新增的异常 try-catch 处理掉为止。而新增非受检异常可以不改动调用链上的代码。可以灵活地选择在某个函数中集中处理，比如在 Spring 中的 AOP 切面中集中处理异常\n\n不过，非受检异常也有弊端，它的优点其实也正是它的缺点。从刚刚的表述中，可以看出，非受检异常使用起来更加灵活，怎么处理的主动权这里就交给了程序员。前面也讲到，过于灵活会带来不可控，非受检异常不需要显式地在函数定义中声明，那在使用函数的时候，就需要查看代码才能知道具体会抛出哪些异常。非受检异常不需要强制捕获处理，那程序员就有可能漏掉一些本应该捕获处理的异常\n对于应该用受检异常还是非受检异常，网上的争论有很多，但并没有一个非常强有力的理由能够说明一个就一定比另一个更好。所以，只需要根据团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可\n讲了两种异常类型，再来讲下，如何处理函数抛出的异常？总结一下，一般有下面三种处理方法：\n1、直接吞掉\npublic void func1() throws Exception1 &#123;\n    &#x2F;&#x2F; ...\n&#125;\npublic void func2() &#123;\n    &#x2F;&#x2F;...\n    try &#123;\n        func1();\n&#125; catch(Exception1 e) &#123;\n    log.warn(&quot;...&quot;, e); &#x2F;&#x2F;吐掉：try-catch打印日志\n&#125;\n    &#x2F;&#x2F;...\n&#125;\n\n2、原封不动地 re-throw\npublic void func1() throws Exception1 &#123;\n    &#x2F;&#x2F; ...\n&#125;\npublic void func2() throws Exception2 &#123;\n    &#x2F;&#x2F;...\n    try &#123;\n        func1();\n    &#125; catch(Exception1 e) &#123;\n        throw new Exception2(&quot;...&quot;, e); &#x2F;&#x2F; wrap成新的Exception2然后re-throw\n&#125;\n    &#x2F;&#x2F;...\n&#125;\n\n3、包装成新的异常 re-throw\npublic void func1() throws Exception1 &#123;\n    &#x2F;&#x2F; ...\n&#125;\npublic void func2() throws Exception2 &#123;\n    &#x2F;&#x2F;...\n    try &#123;\n        func1();\n    &#125; catch(Exception1 e) &#123;\n        throw new Exception2(&quot;...&quot;, e); &#x2F;&#x2F; wrap成新的Exception2然后re-throw\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n当面对函数抛出异常的时候，应该选择上面的哪种处理方式呢？这里总结了下面三个参考原则：\n\n如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，完全可以在 func2() 内将 func1() 抛出的异常吞掉\n如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，可以选择直接将 func1 抛出的异常 re-throw\n如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，可以将它重新包装成调用方可以理解的新异常，然后 re-throw\n\n总之，是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出\n6.5.2 重构 ID 生成器项目中各函数的异常处理代码平时进行软件设计开发的时候，除了要保证正常情况下的逻辑运行正确之外，还需要编写大量额外的代码，来处理有可能出现的异常情况，以保证代码在任何情况下，都在我们的掌控之内，不会出现非预期的运行结果。程序的 bug 往往都出现在一些边界条件和异常情况下，所以说，异常处理得好坏直接影响了代码的健壮性。全面、合理地处理各种异常能有效减少代码 bug，也是保证代码质量的一个重要手段\n1、重构 generate() 函数\n首先来看，对于 generate() 函数，如果本机名获取失败，函数返回什么？这样的返回值是否合理？\npublic String generate() &#123;\n    String substrOfHostName &#x3D; getLastFiledOfHostName();\n    long currentTimeMillis &#x3D; System.currentTimeMillis();\n    String randomString &#x3D; generateRandomAlphameric(8);\n    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,\n        substrOfHostName, currentTimeMillis, randomString);\n    return id;\n&#125;\n\nID 由三部分构成：本机名、时间戳和随机数。时间戳和随机数的生成函数不会出错，唯独主机名有可能获取失败。在目前的代码实现中，如果主机名获取失败，substrOfHostName 为 NULL，那 generate() 函数会返回类似“null-16723733647-83Ab3uK6”这样的数据。如果主机名获取失败，substrOfHostName 为空字符串，那 generate() 函数会返回类似“-16723733647-83Ab3uK6”这样的数据\n在异常情况下，返回上面两种特殊的 ID 数据格式，这样的做法是否合理呢？这个其实很难讲，要看具体的业务是怎么设计的。不过，更倾向于明确地将异常告知调用者。所以，这里最好是抛出受检异常，而非特殊值\n按照这个设计思路，我们对 generate() 函数进行重构。重构之后的代码如下所示：\npublic String generate() throws IdGenerationFailureException &#123;\n    String substrOfHostName &#x3D; getLastFiledOfHostName();\n    if (substrOfHostName &#x3D;&#x3D; null || substrOfHostName.isEmpty()) &#123;\n        throw new IdGenerationFailureException(&quot;host name is empty.&quot;);\n    &#125;\n    long currentTimeMillis &#x3D; System.currentTimeMillis();\n    String randomString &#x3D; generateRandomAlphameric(8);\n    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,\n    substrOfHostName, currentTimeMillis, randomString);\n    return id;\n&#125;\n\n2、重构 getLastFiledOfHostName() 函数\n对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉（try-catch 并打印日志），还是应该将异常继续往上抛出？如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出？\nprivate String getLastFiledOfHostName() &#123;\n    String substrOfHostName &#x3D; null;\n    try &#123;\n        String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n        substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);\n    &#125; catch (UnknownHostException e) &#123;\n        logger.warn(&quot;Failed to get the host name.&quot;, e);\n    &#125;\n    return substrOfHostName;\n&#125;\n\n现在的处理方式是当主机名获取失败的时候，getLastFiledOfHostName() 函数返回 NULL值。前面讲过，是返回 NULL 值还是异常对象，要看获取不到数据是正常行为，还是异常行为。获取主机名失败会影响后续逻辑的处理，并不是我们期望的，所以，它是一种异常行为。这里最好是抛出异常，而非返回 NULL 值\n至于是直接将 UnknownHostException 抛出，还是重新封装成新的异常抛出，要看函数跟异常是否有业务相关性。getLastFiledOfHostName() 函数用来获取主机名的最后一个字段，UnknownHostException 异常表示主机名获取失败，两者算是业务相关，所以可以直接将 UnknownHostException 抛出，不需要重新包裹成新的异常\n按照上面的设计思路，对 getLastFiledOfHostName() 函数进行重构。重构后的代码如下所示：\nprivate String getLastFiledOfHostName() throws UnknownHostException&#123;\n    String substrOfHostName &#x3D; null;\n    String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n    substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);\n\n    return substrOfHostName;\n&#125;\n\ngetLastFiledOfHostName() 函数修改之后，generate() 函数也要做相应的修改。需要在 generate() 函数中，捕获 getLastFiledOfHostName() 抛出的 UnknownHostException 异常。当捕获到这个异常之后，应该怎么处理呢？\n按照之前的分析，ID 生成失败的时候，需要明确地告知调用者。所以，不能在 generate() 函数中，将 UnknownHostException 这个异常吞掉。那应该原封不动地抛出，还是封装成新的异常抛出呢？\n这里选择后者。在 generate() 函数中，需要捕获 UnknownHostException 异常，并重新包裹成新的异常 IdGenerationFailureException 往上抛出。之所以这么做，有下面三个原因：\n\n调用者在使用 generate() 函数的时候，只需要知道它生成的是随机唯一 ID，并不关心 ID 是如何生成的。也就说是，这是依赖抽象而非实现编程。如果 generate() 函数直接抛出 UnknownHostException 异常，实际上是暴露了实现细节\n从代码封装的角度来讲，不希望将 UnknownHostException 这个比较底层的异常，暴露给更上层的代码，也就是调用 generate() 函数的代码。而且，调用者拿到这个异常的时候，并不能理解这个异常到底代表了什么，也不知道该如何处理\nUnknownHostException 异常跟 generate() 函数，在业务概念上没有相关性\n\n按照上面的设计思路，对 generate() 的函数再次进行重构。重构后的代码如下所示：\npublic String generate() throws IdGenerationFailureException &#123;\n    String substrOfHostName &#x3D; null;\n    try &#123;\n        substrOfHostName &#x3D; getLastFiledOfHostName();\n    &#125; catch (UnknownHostException e) &#123;\n        throw new IdGenerationFailureException(&quot;host name is empty.&quot;);\n    &#125;\n\n    long currentTimeMillis &#x3D; System.currentTimeMillis();\n    String randomString &#x3D; generateRandomAlphameric(8);\n    String id &#x3D; String.format(&quot;%s-%d-%s&quot;,\n    substrOfHostName, currentTimeMillis, randomString);\n\n    return id;\n&#125;\n\n3、重构 getLastSubstrSplittedByDot() 函数\n对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者空字符串，这个函数应该返回什么？\n@VisibleForTesting\nprotected String getLastSubstrSplittedByDot(String hostName) &#123;\n    String[] tokens &#x3D; hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName &#x3D; tokens[tokens.length - 1];\n    return substrOfHostName;\n&#125;\n\n理论上讲，参数传递的正确性应该由程序员来保证，无需做 NULL 值或者空字符串的判断和特殊处理。调用者本不应该把 NULL 值或者空字符串传递给 getLastSubstrSplittedByDot() 函数。如果传递了，那就是 code bug，需要修复。但是，话说回来，谁也保证不了程序员就一定不会传递 NULL 值或者空字符串。那到底该不该做 NULL 值或空字符串的判断呢？\n如果函数是 private 类私有的，只在类内部被调用，完全在你自己的掌控之下，自己保证在调用这个 private 函数的时候，不要传递 NULL 值或空字符串就可以了。所以，可以不在 private 函数中做 NULL 值或空字符串的判断。如果函数是 public 的，你无法掌控会被谁调用以及如何调用（有可能某个同事一时疏忽，传递进了 NULL 值，这种情况也是存在的），为了尽可能提高代码的健壮性，最好是在 public 函数中做 NULL 值或空字符串的判断\n这里可能会说，getLastSubstrSplittedByDot() 是 protected 的，既不是 private 函数，也不是 public 函数，那要不要做 NULL 值或空字符串的判断呢？\n之所以将它设置为 protected，是为了方便写单元测试。不过，单元测试可能要测试一些 corner case，比如输入是 NULL 值或者空字符串的情况。所以，这里最好也加上 NULL 值或空字符串的判断逻辑。虽然加上有些冗余，但多加些检验总归不会错的\n按照这个设计思路，我们对 getLastSubstrSplittedByDot() 函数进行重构。重构之后的代码如下所示：\n@VisibleForTesting\nprotected String getLastSubstrSplittedByDot(String hostName) &#123;\n    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;\n        throw IllegalArgumentException(&quot;...&quot;); &#x2F;&#x2F;运行时异常\n    &#125;\n    String[] tokens &#x3D; hostName.split(&quot;\\\\.&quot;);\n    String substrOfHostName &#x3D; tokens[tokens.length - 1];\n    return substrOfHostName;\n&#125;\n\n按照上面讲的，在使用这个函数的时候，自己也要保证不传递 NULL 值或者空字符串进去。所以，getLastFiledOfHostName() 函数的代码也要作相应的修改。修改之后的代码如下所示：\nprivate String getLastFiledOfHostName() throws UnknownHostException&#123;\n    String substrOfHostName &#x3D; null;\n    String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n    if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123; &#x2F;&#x2F; 此处做判断\n        throw new UnknownHostException(&quot;...&quot;);\n    &#125;\n    substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);\n    return substrOfHostName;\n&#125;\n\n4、重构 generateRandomAlphameric() 函数\n对于 generateRandomAlphameric(int length) 函数，如果 length &lt; 0 或 length &#x3D; 0，这个函数应该返回什么？\n@VisibleForTesting\nprotected String generateRandomAlphameric(int length) &#123;\n    char[] randomChars &#x3D; new char[length];\n    int count &#x3D; 0;\n    Random random &#x3D; new Random();\n\n    while (count &lt; length) &#123;\n        int maxAscii &#x3D; &#39;z&#39;;\n        int randomAscii &#x3D; random.nextInt(maxAscii);\n        boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;\n        boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;\n        boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;\n\n        if (isDigit|| isUppercase || isLowercase) &#123;\n            randomChars[count] &#x3D; (char) (randomAscii);\n            ++count;\n        &#125;\n    &#125;\n    return new String(randomChars);\n&#125;\n\n先来看 length &lt; 0 的情况。生成一个长度为负值的随机字符串是不符合常规逻辑的，是一种异常行为。所以，当传入的参数 length &lt; 0 的时候，抛出 IllegalArgumentException 异常\n再来看 length &#x3D; 0 的情况。length &#x3D; 0 是否是异常行为呢？这就看怎么定义了。既可以把它定义为一种异常行为，抛出 IllegalArgumentException 异常，也可以把它定义为一种正常行为，让函数在入参 length &#x3D; 0 的情况下，直接返回空字符串。不管选择哪种处理方式，最关键的一点是，要在函数注释中，明确告知 length &#x3D; 0 的情况下，会返回什么样的数据\n重构之后的 RandomIdGenerator 代码\npublic class RandomIdGenerator implements IdGenerator &#123;\n    private static final Logger logger &#x3D; LoggerFactory.getLogger(RandomIdGenerator.class);\n\n    @Override\n    public String generate() throws IdGenerationFailureException &#123;\n        String substrOfHostName &#x3D; null;\n        try &#123;\n            substrOfHostName &#x3D; getLastFiledOfHostName();\n        &#125; catch (UnknownHostException e) &#123;\n            throw new IdGenerationFailureException(&quot;...&quot;, e);\n        &#125;\n        long currentTimeMillis &#x3D; System.currentTimeMillis();\n        String randomString &#x3D; generateRandomAlphameric(8);\n        String id &#x3D; String.format(&quot;%s-%d-%s&quot;,\n                substrOfHostName, currentTimeMillis, randomString);\n        return id;\n    &#125;\n    private String getLastFiledOfHostName() throws UnknownHostException&#123;\n        String substrOfHostName &#x3D; null;\n        String hostName &#x3D; InetAddress.getLocalHost().getHostName();\n        if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;\n            throw new UnknownHostException(&quot;...&quot;);\n        &#125;\n        substrOfHostName &#x3D; getLastSubstrSplittedByDot(hostName);\n        return substrOfHostName;\n    &#125;\n    @VisibleForTesting\n    protected String getLastSubstrSplittedByDot(String hostName) &#123;\n        if (hostName &#x3D;&#x3D; null || hostName.isEmpty()) &#123;\n            throw new IllegalArgumentException(&quot;...&quot;);\n        &#125;\n        String[] tokens &#x3D; hostName.split(&quot;\\\\.&quot;);\n        String substrOfHostName &#x3D; tokens[tokens.length - 1];\n        return substrOfHostName;\n    &#125;\n    @VisibleForTesting\n    protected String generateRandomAlphameric(int length) &#123;\n        if (length &lt;&#x3D; 0) &#123;\n            throw new IllegalArgumentException(&quot;...&quot;);\n        &#125;\n        char[] randomChars &#x3D; new char[length];\n        int count &#x3D; 0;\n        Random random &#x3D; new Random();\n        while (count &lt; length) &#123;\n            int maxAscii &#x3D; &#39;z&#39;;\n            int randomAscii &#x3D; random.nextInt(maxAscii);\n            boolean isDigit&#x3D; randomAscii &gt;&#x3D; &#39;0&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;9&#39;;\n            boolean isUppercase&#x3D; randomAscii &gt;&#x3D; &#39;A&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;Z&#39;;\n            boolean isLowercase&#x3D; randomAscii &gt;&#x3D; &#39;a&#39; &amp;&amp; randomAscii &lt;&#x3D; &#39;z&#39;;\n            if (isDigit|| isUppercase || isLowercase) &#123;\n                randomChars[count] &#x3D; (char) (randomAscii);\n                ++count;\n            &#125;\n        &#125;\n        return new String(randomChars);\n    &#125;\n&#125;\n\n7. 总结包括前两篇：\n\n设计模式之美总结（面向对象篇）_凡 223 的博客\n设计模式之美总结（设计原则篇）_凡 223 的博客\n\n\n7.1 代码质量评判标准7.1.1 如何评价代码质量的高低？代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一维度去评价一段代码的好坏\n7.1.2 最常用的评价标准有哪几个？最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准\n7.1.3 如何才能写出高质量的代码？要写出高质量代码，就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等\n\n7.2 面向对象7.2.1 面向对象概述现在，主流的编程范式或者编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础\n7.2.2 面向对象四大特性封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性\n如果说封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息\n继承用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题\n多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础\n7.2.3 面向对象 VS 面向过程面向对象编程相比面向过程编程的优势主要有三个：\n\n对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发\n面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护\n从编程语言跟机器打交道方式的演进规律中，可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能\n\n面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的\n面向对象和面向过程两种编程风格并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码\n不管使用面向过程还是面向对象哪种风格来写代码，最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，就大可不用避讳在面向对象编程中写面向过程风格的代码\n7.2.4 面向对象分析、设计与编程面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程\n需求分析的过程实际上是一个不断迭代优化的过程。不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。这样一个思考过程能让我们摆脱无从下手的窘境\n面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护\n面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分：\n\n划分职责进而识别出有哪些类根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类\n定义类及其属性和方法识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选\n定义类与类之间的交互关系UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖\n将类组装起来并提供执行入口将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，就能触发整个代码跑起来\n\n7.2.5 接口 VS 抽象类抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法\n接口不能包含属性（Java 可以定义静态常量），只能声明方法，方法不能包含代码实现（Java8 以后可以有默认实现）。类实现接口的时候，必须实现接口中声明的所有方法\n抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性\n什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那就用接口\n7.2.6 基于接口而非实现编程应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性\n实际上，“基于接口而非实现编程”这条原则的另一个表述方式是，“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准\n越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一\n7.2.7 多用组合少用继承为什么不推荐使用继承？\n继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，应该尽量少用，甚至不用继承\n组合相比继承有哪些优势？\n继承主要有三个作用：表示 is-a 关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题\n如何判断该用组合还是继承？\n尽管鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，就可以大胆地使用继承。反之，就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合\n7.2.8 贫血模型 VS 充血模型平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构，把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格\n不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势\n基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作\n基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的\n\n7.3 设计原则7.3.1 SOLID 原则：SRP 单一职责原则一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性\n不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：\n\n类中的代码行数、函数或者属性过多\n类依赖的其他类过多或者依赖类的其他类过多\n私有方法过多\n比较难给类起一个合适的名字\n类中大量的方法都是集中操作类中的某几个属性\n\n7.3.2 SOLID 原则：OCP 开闭原则如何理解“对扩展开放、修改关闭”？\n添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”\n如何做到“对扩展开放、修改关闭”？\n要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上\n很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）\n7.3.3 SOLID 原则：LSP 里式替换原则子类对象（object of subtype&#x2F;derived class）能够替换程序（program）中父类对象（object of base&#x2F;parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏\n里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数的原有“约定”。这里的“约定”包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明\n理解这个原则，还要弄明白，里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性\n7.3.4 SOLID 原则：ISP 接口隔离原则接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解：\n\n如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口\n如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数\n如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数\n\n单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考的角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一\n7.3.5 SOLID 原则：DIP 依赖倒置原则控制反转： 实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架\n依赖注入： 依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或“注入”）给类来使用\n依赖注入框架： 通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情\n依赖反转原则： 依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象\n7.3.6 KISS、YAGNI 原则KISS 原则的中文描述是：尽量保持简单。KISS 原则是保持代码可读和可维护的重要手段。KISS 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用杂的方法解决，也并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了\n对于如何写出满足 KISS 原则的代码，总结了下面几条指导原则：\n\n不要使用同事可能不懂的技术来实现代码\n不要重复造轮子，善于使用已经有的工具类库\n不要过度优化\n\nYAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计\nYAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）\n7.3.7 DRY 原则DRY 原则中文描述是：不要重复自己，将它应用在编程中，可以理解为：不要写重复的代码，这里讲到了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复\n\n实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则\n实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则\n而代码执行重复也算是违反 DRY 原则\n\n除此之外，还讲到了提高代码复用性的一些手段，包括：减少代码耦合、满足单一职责原则、模块化、业务与非业务逻辑分离、通用代码下沉、继承、多态、抽象、封装、应用模板等设计模式。复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性\n在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那就重构这段代码，让其变得更加可复用\n相比于代码的可复用性，DRY 原则适用性更强些。可以不写可复用的代码，但一定不能写重复的代码\n7.3.8 LOD 原则如何理解“高内聚、松耦合”？\n“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓“松耦合”指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动\n如何理解“迪米特法则”？\n迪米特法则的描述为：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少\n\n7.4 规范与重构7.4.1 重构概述重构的目的：为什么重构（why）？\n对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场\n重构的对象：重构什么（what）？\n按照重构的规模，可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识\n重构的时机：什么时候重构（when）？\n一定要建立持续重构意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构\n重构的方法：如何重构（how）？\n大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做\n7.4.2 单元测试什么是单元测试？\n单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性。单元测试顾名思义是测试一个“单元”，这个“单元”一般是类或函数，而不是模块或者系统\n为什么要写单元测试？\n单元测试能有效地发现代码中的 Bug、代码设计上的问题。写单元测试的过程本身就是代码重构的过程。单元测试是对集成测试的有力补充，能帮助我们快速熟悉代码，是 TDD 可落地执行的折中方案\n如何编写单元测试？\n写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。可以利用一些测试框架来简化测试代码的编写。对于单元测试，需要建立以下正确的认知：\n\n编写单元测试尽管繁琐，但并不是太耗时\n可以稍微放低单元测试的质量要求\n覆盖率作为衡量单元测试好坏的唯一标准是不合理的\n写单元测试一般不需要了解代码的实现逻辑\n单元测试框架无法测试多半是代码的可测试性不好\n\n单元测试为何难落地执行？\n一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。另一方面，国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾，最后，没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好\n7.4.3 代码的可测试性什么是代码的可测试性？\n粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好\n编写可测试性代码的最有效手段\n依赖注入是编写可测试性代码的最有效手段。通过依赖注入，在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控，这也是在编写单元测试的过程中最有技术挑战的地方。除了 mock 方式，还可以利用二次封装来解决某些代码行为不可控的情况\n常见的 Anti-Patterns\n典型的、常见的测试不友好的代码有下面这 5 种：\n\n代码中包含未决行为逻辑\n滥用可变全局变量\n滥用静态方法\n使用复杂的继承关系\n高度耦合的代码\n\n7.4.4 大型重构：解耦“解耦”为何如此重要？\n过于复杂的代码往往在可读性、可维护性上都不友好。解耦，保证代码松耦合、高内聚，是控制代码复杂度的有效手段。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差\n代码是否需要“解耦”？\n间接的衡量标准有很多，比如：改动一个模块或类的代码受影响的模块或类是否有很多、改动一个模块或者类的代码依赖的模块或者类是否需要改动、代码的可测试性是否好等等。直接的衡量标准是把模块与模块之间及其类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构\n如何给代码“解耦”？\n给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。当然，还有一些设计模式，比如观察者模式\n7.4.5 小型重构：编码规范命名与注释\n\n命名的关键是能准确的达意。对于不同作用域的命名，可以适当的选择不同的长度，作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式。除此之外，命名中个也可以使用一些耳熟能详的缩写\n借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名\n命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名\n接口有两种命名方式。一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀“Impl”。两种命名方式都可以，关键是要在项目中统一。对于抽象类的命名，更倾向于带有前缀“Abstract”\n注释的目的就是让代码更容易看懂，只要符合这个要求，就可以写。总结一下的话，注释主要包含这样三个方面的内容：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”\n注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写的尽可能全面详细些，而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读\n\n编程技巧\n\n将复杂的逻辑提炼拆分成函数和类\n通过拆分成多个函数的方式来处理参数过多的情况\n通过将参数封装为对象来处理参数过多的情况\n函数中不要使用参数来做代码执行逻辑的控制\n移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数\n用字面常量取代魔法数\n利用解释性变量来解释复杂表达式\n\n\n","slug":"BlogRepository/设计模式/设计模式之美总结（重构篇）","date":"2022-10-27T09:31:42.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"245c60f16cbe1e87f80f18c4eff1ab55","title":"DataGrip 下载安装及使用教程","content":"1. 下载官网下载：DataGrip: The Cross-Platform IDE for Databases &amp;&amp; SQL by JetBrains\n\n点击 Download 跳转到下载界面\n\n下载最新版本的可以直接点击 Download 下载，下载其他版本的点击 Other versions 下载其他版本\n\n选择对应的版本进行下载，这里选择 2022.1.4\n\n下载完成得到 exe 文件，进行安装\n2. 安装双击打开 exe 文件，Next\n\n选择对应的安装路径，Next\n\n根据需求勾选，Next\n\nNext\n\n安装完成，可以选择立即打开，或直接结束\n\n3. 使用3.1 界面及连接打开 DataGrip，选择是否导入设置\n\n激活 DataGrip，没有激活的话这里可以先选择 Start trial 试用\n\n界面风格与同 JetBrains 的产品 IDEA 或 Pycharm 等类似\n\n新建一个项目，选择项目路径或输入新建的项目名\n\n进入主界面\n\n点击 “+” 号，选择对应的数据库\n\n进入连接界面，首次使用时可能需要下载对应的数据库驱动\n\n\n输入本次连接的名称。然后输入服务器地址、这里用的是 MySQL 端口默认为 3306、用户名、密码、数据库。会自动拼成 URL，点击 Test Connection 测试连接\n\n连接成功后即可查看对应的数据信息，同时会自动打开一个 console，相当于新建查询\n\n其实该功能在 IDEA 里也有嵌入\n3.2 常用操作3.2.1 新建查询右键创建 Query Console\n\n右上角可以选择使用的数据库，以及是哪个查询\n\n会以分号和绿框来标识一条查询语句\n\n3.2.2 更多数据库可以点击更多，选择其他数据库进行界面操作\n\n3.2.3 修改表结构右键，Modify Table\n\n\n3.2.4 查看&#x2F;修改表数据可以直接左键双击对应的表，或者右键 Edit Data\n\n3.2.5 复制表右键，Copy Table to\n\n选择目标数据库，复制后的表名、选择相应的属性等，点击 Import\n\n复制成功，但这种方式复制的表需要自己定义主键和索引，只复制了原表的数据，不包括主键和索引\n\n可以选择下面这种方式，3.2.6 导出数据（SQL），导出建表语句和数据，然后再执行脚本（手动修改表名）\n3.2.6 导出数据（SQL）右键，Export Data to File，导出全部数据\n\n选择文件格式和路径。支持导出为 Insert 或 Update 语句（也可复制到剪贴板，Copy to Clipboard）\n\n\n\n或者查询出数据，然后导出查询出来的数据\n\n可选择复制到剪贴板，Copy to Clipboard\n\n3.2.7 文件导入右键，Import Data from File\n\n选择对应文件\n\n只支持 CSV 格式和 TSV 格式文件，可以把 XLSX 等格式转为 CSV 再导入\n\n导入成功\n\n3.2.8 查看建表语句右键，Go to DDL\n\n或者在表数据的 DDL 选项\n\n\n即可查看建表语句\n\n3.2.9 设置单页显示数量即查询出来的数据，一页的最大数量\n\n3.3 实用功能3.3.1 快捷文档右键，Quick Documentation\n\n\n3.3.2 快捷 SQL右键，SQL Scripts\n\n快捷生成对应 SQL 语句\n\n3.3.3 多形式展示数据可以选择相应格式，然后点击小眼睛样式，选择对应的展示形式\n\n如：Insert SQL、Text 形式\n\n除此之外还包括数据比较，即上方小眼睛样式的左边一个选项、生成实体类等更多功能，可自行研究\n","slug":"BlogRepository/开发工具及环境/DataGrip 下载安装及使用教程","date":"2022-10-18T07:29:19.000Z","categories_index":"开发工具及环境","tags_index":"数据库","author_index":"凡"},{"id":"4d007a7b93e6f215777cd8e4cac0925d","title":"Easy Excel 使用总结","content":"1. 概述官网地址：EasyExcel 官方文档 - 基于 Java 的 Excel 处理工具 | Easy Excel (alibaba.com)\nEasyExcel 是一个基于 Java 的、快速、简洁、解决大文件内存溢出的 Excel 处理工具。他能让你在不用考虑性能、内存的等因素的情况下，快速完成 Excel 的读、写等功能\n\n导入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;easyexcel&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;最新版本&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2. 常用注解2.2.1 @ExcelProperty用于匹配 Excel 和实体类的匹配，参数如下：\n\n\n\n名称\n默认值\n描述\n\n\n\nvalue\n空\n用于匹配 Excel 中的头，必须全匹配，如果有多行头，会匹配最后一行头\n\n\norder\nInteger.MAX_VALUE\n优先级高于 value，会根据 order 的顺序来匹配实体和 excel 中数据的顺序\n\n\nindex\n-1\n优先级高于 value 和 order，会根据 index 直接指定到 excel 中具体的哪一列\n\n\nconverter\n自动选择\n指定当前字段用什么转换器，默认会自动选择。读的情况下只要实现 com.alibaba.excel.converters.Converter#convertToJavaData(com.alibaba.excel.converters.ReadConverterContext&lt;?&gt;) 方法即可\n\n\n2.2.2 @ExcelIgnore默认所有字段都会和 Excel 去匹配，加了这个注解会忽略该字段\n2.2.3 @ExcelIgnoreUnannotated默认不管加不加 ExcelProperty 的注解的所有字段都会参与读写，加了 ExcelIgnoreUnannotated 注解以后，不加 ExcelProperty 注解的字段就不会参与\n2.2.4 @DateTimeFormat日期转换，用 String 去接收 Excel 日期格式的数据会调用这个注解，参数如下：\n\n\n\n名称\n默认值\n描述\n\n\n\nvalue\n空\n参照 java.text.SimpleDateFormat 书写即可\n\n\nuse1904windowing\n自动选择\nExcel 中时间是存储 1900 年起的一个双精度浮点数，但是有时候默认开始日期是 1904，所以设置这个值改成默认 1904 年开始\n\n\n2.2.5 @NumberFormat数字转换，用 String 去接收 Excel 数字格式的数据会调用这个注解\n\n\n\n名称\n默认值\n描述\n\n\n\nvalue\n空\n参照 java.text.DecimalFormat 书写即可\n\n\nroundingMode\nRoundingMode.HALF_UP\n格式化的时候设置舍入模式\n\n\n3. 写 Excel（导出）3.1 常用参数\nWriteWorkbook：可以理解成一个 Excel\nWriteSheet：理解成一个 Excel 里面的一个表单\nWriteTable：一个表单里面如果有多个实际用的表格，则可以用 WriteTable\n\n3.1.1 通用参数WriteWorkbook，WriteSheet ，WriteTable 都会有的参数，如果为空，默认使用上级\n\n\n\n名称\n默认值\n描述\n\n\n\nconverter\n空\n默认加载了很多转换器，这里可以加入不支持的字段\n\n\nwriteHandler\n空\n写的处理器。可以实现 WorkbookWriteHandler，SheetWriteHandler，RowWriteHandler，CellWriteHandler，在写入 Excel 的不同阶段会调用\n\n\nrelativeHeadRowIndex\n0\n写入到 Excel 和上面空开几行\n\n\nhead\n空\n与 clazz 二选一。读取文件头对应的列表，会根据列表匹配数据，建议使用 class\n\n\nclazz\n空\n与 head 二选一。读取文件的头对应的 class，也可以使用注解。如果两个都不指定，则会读取全部数据\n\n\nautoTrim\ntrue\n会对头、读取数据等进行自动 trim\n\n\nuse1904windowing\nfalse\nExcel 中时间是存储 1900 年起的一个双精度浮点数，但是有时候默认开始日期是 1904，所以设置这个值改成默认 1904 年开始\n\n\nuseScientificFormat\nfalse\n数字转文本的时候在较大的数值的是否是否采用科学计数法\n\n\nneedHead\ntrue\n是否需要写入头到 Excel\n\n\nuseDefaultStyle\ntrue\n是否使用默认的样式\n\n\nautomaticMergeHead\ntrue\n自动合并头，头中相同的字段上下左右都会去尝试匹配\n\n\nexcludeColumnIndexes\n空\n需要排除对象中的 index 的数据\n\n\nexcludeColumnFieldNames\n空\n需要排除对象中的字段的数据\n\n\nincludeColumnIndexes\n空\n只要导出对象中的 index 的数据\n\n\nincludeColumnFieldNames\n空\n只要导出对象中的字段的数据\n\n\n3.1.2 WriteWorkbookEasyExcel.write(fileName, DemoData.class)\n           &#x2F;&#x2F; 在 write 方法之后， 在 sheet 方法之前都是设置 WriteWorkbook 的参数\n           .sheet(&quot;模板&quot;)\n           .doWrite(() -&gt; &#123;\n               &#x2F;&#x2F; 分页查询数据\n               return data();\n           &#125;);\n\n\n\n\n名称\n默认值\n描述\n\n\n\nexcelType\n空\n当前 Excel 的类型,支持 XLS、XLSX、CSV\n\n\noutputStream\n空\n与 file 二选一。写入文件的流\n\n\nfile\n空\n与 outputStream 二选一。写入的文件\n\n\ntemplateInputStream\n空\n模板的文件流\n\n\ntemplateFile\n空\n模板文件\n\n\ncharset\nCharset#defaultCharset\n只有 csv 文件有用，写入文件的时候使用的编码\n\n\nautoCloseStream\ntrue\n自动关闭写入的流\n\n\npassword\n空\n读取文件的密码\n\n\ninMemory\nfalse\n是否在内存处理，默认会生成临时文件以节约内存。内存模式效率会更好，但是容易 OOM\n\n\nwriteExcelOnException\nfalse\n写入过程中抛出异常了，是否尝试把数据写入到 Excel\n\n\n3.1.3 WriteSheetEasyExcel.write(fileName, DemoData.class)\n           .sheet(&quot;模板&quot;)\n            &#x2F;&#x2F; 在 sheet 方法之后，在 doWrite 方法之前都是设置 WriteSheet 的参数\n           .doWrite(() -&gt; &#123;\n               &#x2F;&#x2F; 分页查询数据\n               return data();\n           &#125;);\n\n\n\n\n名称\n默认值\n描述\n\n\n\nsheetNo\n0\n需要写入的编码\n\n\nsheetName\n空\n需要些的 Sheet 名称，默认同 sheetNo\n\n\n3.1.4 WriteTableEasyExcel.write(fileName, DemoData.class)\n    .sheet(&quot;模板&quot;)\n    .table()\n    &#x2F;&#x2F; 在 table 方法之后， 在 doWrite 方法之前都是设置 WriteTable 的参数\n    .doWrite(() -&gt; &#123;\n        &#x2F;&#x2F; 分页查询数据\n        return data();\n    &#125;);\n\n\n\n\n名称\n默认值\n描述\n\n\n\ntableNo\n0\n需要写入的编码\n\n\n3.2 简单的写省略其他获取数据和定义接口等实现\n\n3.2.1 定义表格实体类public class ExcelDO &#123;\n\n    @ExcelProperty(&quot;员工ID&quot;)\n    private String empId;\n    @ExcelProperty(&quot;员工姓名&quot;)\n    private String empName;\n    @ExcelProperty(&quot;员工工号&quot;)\n    private String empCode;\n    @ExcelProperty(&quot;身份证号&quot;)\n    private String idcardNo;\n    @ExcelProperty(&quot;性别&quot;)\n    private String gender;\n    @ExcelProperty(&quot;电话号码&quot;)\n    private String phone;\n    @ExcelProperty(&quot;地址&quot;)\n    private String address;\n    @ExcelProperty(&quot;邮箱&quot;)\n    private String email;\n    @ExcelProperty(&quot;备注&quot;)\n    private String remark;\n    @ExcelProperty(&quot;有效标志&quot;)\n    private String valiFlag;\n    @ExcelProperty(&quot;创建时间&quot;)\n    private Timestamp createTime;\n    @ExcelIgnore\n    private Timestamp updateTime;\n&#125;\n\n3.2.2 实现类@Service\npublic class ExcelServiceImpl implements ExcelService &#123;\n\n    @Resource\n    private EmployeeService employeeService;\n\n    @Override\n    public void simpleWrite() &#123;\n        String fileName &#x3D; &quot;D:&#x2F;&#x2F;simpleWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;\n\n        &#x2F;&#x2F; 写法1\n        EasyExcel.write(fileName, ExcelDO.class)\n                .sheet(&quot;模板&quot;)\n                .doWrite(() -&gt; getData());\n  \n        &#x2F;&#x2F; 写法2\n        EasyExcel.write(fileName, ExcelDO.class).sheet(&quot;模板&quot;).doWrite(getData());\n  \n        &#x2F;&#x2F; 写法3\n        try (ExcelWriter excelWriter &#x3D; EasyExcel.write(fileName, ExcelDO.class).build()) &#123;\n            WriteSheet writeSheet &#x3D; EasyExcel.writerSheet(&quot;模板&quot;).build();\n            excelWriter.write(getData(), writeSheet);\n        &#125;\n    &#125;\n\n    private List&lt;ExcelDO&gt; getData() &#123;\n        List&lt;ExcelDO&gt; list &#x3D; ListUtils.newArrayList();\n\n        List records &#x3D; employeeService.getEmployee().getRecords();\n        list.addAll(records);\n\n        return list;\n    &#125;\n&#125;\n\n3.2.3 Controller@RestController\npublic class ExcelController &#123;\n\n    @Resource\n    private ExcelService excelService;\n\n    @PostMapping(&quot;&#x2F;simpleWrite&quot;)\n    public void simpleWrite() &#123;\n        excelService.simpleWrite();\n    &#125;\n&#125;\n\n3.2.4 定义特殊格式转换 Convert当使用 LocalDateTime 或 Timestamp 等格式时，会报 ExcelWriteDataConvertException，此时需要自定义类型转换器\n\nTimestampConvert\npublic class TimestampConvert implements Converter&lt;Timestamp&gt; &#123;\n\n    &#x2F;&#x2F; 在Java中数据类型\n    @Override\n    public Class&lt;Timestamp&gt; supportJavaTypeKey() &#123;\n        return Timestamp.class;\n    &#125;\n\n    &#x2F;&#x2F; 在Excel中的数据类型\n    @Override\n    public CellDataTypeEnum supportExcelTypeKey() &#123;\n        return CellDataTypeEnum.STRING;\n    &#125;\n\n    &#x2F;&#x2F; 将Excel的数据类型转为Java数据类型\n    @Override\n    public Timestamp convertToJavaData(ReadCellData&lt;?&gt; cellData, ExcelContentProperty contentProperty,\n                                       GlobalConfiguration globalConfiguration) throws Exception &#123;\n        return Timestamp.valueOf(cellData.getStringValue());\n    &#125;\n\n    &#x2F;&#x2F; 将Java的数据类型转为Excel数据类型\n    @Override\n    public WriteCellData&lt;?&gt; convertToExcelData(Timestamp value, ExcelContentProperty contentProperty,\n                                               GlobalConfiguration globalConfiguration) throws Exception &#123;\n        return new WriteCellData&lt;&gt;(value.toString());\n    &#125;\n&#125;\n\n3.2.5 Convert 使用1、找到需要转换的字段，在 @ExcelProperty 上添加 converter 属性&#96;\n\n2、ExcelWriterBuilders 是支持对单次的操作添加 converter 的，那样就不需要为每个需要转换的字段单独添加 converter 了\n\n3、全局 Convert\n即将自定义的 Convert 添加到 EasyExcel 的 Convert Map 转换器 Map 里（Map&lt;ConverterKey, Converter&lt;?&gt;&gt; converterMap()）\n详细可见：EasyExcel 自定义 Converter 全局加载器以及加载 Converter\n4、第二种方法还能这样写，在单次操作中加入转换器 Map 里\npublic void simpleWrite() &#123;\n        String fileName &#x3D; &quot;D:&#x2F;&#x2F;simpleWrite&quot; + System.currentTimeMillis() + &quot;.xlsx&quot;;\n\n&#x2F;&#x2F;        EasyExcel.write(fileName, ExcelDO.class)\n&#x2F;&#x2F;                .registerConverter(new TimestampConvert())\n&#x2F;&#x2F;                .sheet(&quot;模板&quot;)\n&#x2F;&#x2F;                .doWrite(() -&gt; getData());\n        ExcelWriter excelWriter &#x3D; EasyExcel.write(fileName, ExcelDO.class).build();\n\n        TimestampConvert timestampConvert &#x3D; new TimestampConvert();\n        excelWriter.writeContext().currentWriteHolder().converterMap()\n                .put(ConverterKeyBuild.buildKey(timestampConvert.supportJavaTypeKey()), timestampConvert);\n        excelWriter.writeContext().currentWriteHolder().converterMap()\n                .put(ConverterKeyBuild.buildKey(timestampConvert.supportJavaTypeKey(), timestampConvert.supportExcelTypeKey()), timestampConvert);\n\n        WriteSheet writeSheet &#x3D; EasyExcel.writerSheet(&quot;模板&quot;).build();\n        excelWriter.write(getData(), writeSheet);\n&#125;\n\n3.2.6 定义内容转换 Convert导出后，发现性别和有效标志等字段，显示的是数据库中存储的数字，应该将其转换为对应的含义\n\nGenderConverter\npublic class GenderConverter implements Converter&lt;String&gt; &#123;\n\n    @Override\n    public Class&lt;String&gt; supportJavaTypeKey() &#123;\n        return String.class;\n    &#125;\n\n    @Override\n    public CellDataTypeEnum supportExcelTypeKey() &#123;\n        return CellDataTypeEnum.STRING;\n    &#125;\n\n    @Override\n    public String convertToJavaData(ReadCellData&lt;?&gt; cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123;\n        return &quot;男&quot;.equals(cellData.getStringValue()) ? &quot;1&quot; : &quot;0&quot;;\n    &#125;\n\n    @Override\n    public WriteCellData&lt;?&gt; convertToExcelData(String value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception &#123;\n        return new WriteCellData&lt;&gt;(value.equals(&quot;1&quot;) ? &quot;男&quot; : &quot;女&quot;);\n    &#125;\n&#125;\n\n使用 Convert 的第一种使用方法\n\n再导出后，性别已经由数字转换为对应的含义\n\n3.3 Web 中的写（下载）与简单的写类似\n@RestController\npublic class ExcelController &#123;\n\n    @Resource\n    private ExcelService excelService;\n\n    @GetMapping(&quot;&#x2F;download&quot;)\n    public void download(HttpServletResponse response) throws IOException &#123;\n        response.setContentType(&quot;application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;);\n        response.setCharacterEncoding(&quot;UTF-8&quot;);\n        &#x2F;&#x2F; 这里 URLEncoder.encode可以防止中文乱码，和 EasyExcel 没有关系\n        String fileName &#x3D; URLEncoder.encode(&quot;测试&quot;, &quot;UTF-8&quot;).replaceAll(&quot;\\\\+&quot;, &quot;%20&quot;);\n        response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename*&#x3D;utf-8&#39;&#39;&quot; + fileName + &quot;.xlsx&quot;);\n\n        EasyExcel.write(response.getOutputStream(), ExcelDO.class).sheet(&quot;模板&quot;).doWrite(excelService.getData());\n    &#125;\n&#125;\n\n浏览器地址栏输入接口地址，会弹出文件下载\n\n\n下载失败的时候返回 JSON\n@RestController\npublic class ExcelController &#123;\n\n    @Resource\n    private ExcelService excelService;\n\n    @GetMapping(&quot;&#x2F;download&quot;)\n    public void download(HttpServletResponse response) throws IOException &#123;\n        try &#123;\n            &#x2F;&#x2F; 正确设置 response 的 content-type；即设置正确的 mime type\n            response.setContentType(&quot;application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;);\n            response.setCharacterEncoding(&quot;UTF-8&quot;);\n            &#x2F;&#x2F; 这里 URLEncoder.encode可以防止中文乱码 当然和 EasyExcel 没有关系\n            String fileName &#x3D; URLEncoder.encode(&quot;测试&quot;, &quot;UTF-8&quot;).replaceAll(&quot;\\\\+&quot;, &quot;%20&quot;);\n            response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename*&#x3D;utf-8&#39;&#39;&quot; + fileName + &quot;.xlsx&quot;);\n  \n&#x2F;&#x2F;            int i &#x3D; 1 &#x2F; 0;\n            EasyExcel.write(response.getOutputStream(), ExcelDO.class).sheet(&quot;模板&quot;).doWrite(excelService.getData());\n        &#125; catch (Exception e) &#123;\n            response.reset();\n            response.setContentType(&quot;application&#x2F;json&quot;);\n            response.setCharacterEncoding(&quot;UTF-8&quot;);\n  \n            response.getWriter().println(JSON.toJSONString(Result.fail(&quot;下载文件失败&quot;)));\n        &#125;\n    &#125;\n&#125;\n\n\n4. 读 Excel（导入）4.1 常用参数\nReadWorkbook 可以理解成一个 excel\nReadSheet 理解成一个 excel 里面的一个表单\n\n4.1.1 通用参数ReadWorkbook,ReadSheet 都会有的参数，如果为空，默认使用上级\n\n\n\n名称\n默认值\n描述\n\n\n\nconverter\n空\n默认加载了很多转换器，这里可以加入不支持的字段\n\n\nreadListener\n空\n可以注册多个监听器，读取 Excel 的时候会不断的回调监听器中的方法\n\n\nheadRowNumber\n1\nexcel 中头的行数，默认 1 行\n\n\nhead\n空\n与 clazz 二选一。读取文件头对应的列表，会根据列表匹配数据，建议使用 class\n\n\nclazz\n空\n与 head 二选一。读取文件的头对应的 class，也可以使用注解。如果两个都不指定，则会读取全部数据\n\n\nautoTrim\ntrue\n会对头、读取数据等进行自动 trim\n\n\nuse1904windowing\nfalse\nExcel 中时间是存储 1900 年起的一个双精度浮点数，但是有时候默认开始日期是 1904，所以设置这个值改成默认 1904 年开始\n\n\nuseScientificFormat\nfalse\n数字转文本的时候在较大的数值的是否是否采用科学计数法\n\n\n4.1.2 ReadWorkbookEasyExcel.read(fileName, DemoData.class, new DemoDataListener())\n          &#x2F;&#x2F; 在 read 方法之后， 在 sheet方法之前都是设置ReadWorkbook的参数\n          .sheet()\n          .doRead();\n\n\n\n\n名称\n默认值\n描述\n\n\n\nexcelType\n空\n当前 excel 的类型,支持 XLS、XLSX、CSV\n\n\ninputStream\n空\n与 file 二选一。读取文件的流，如果接收到的是流就只用，不用流建议使用 file 参数。因为使用了 inputStream easyexcel 会帮忙创建临时文件，最终还是 file\n\n\nfile\n空\n与 inputStream 二选一。读取文件的文件。\n\n\nmandatoryUseInputStream\nfalse\n强制使用 inputStream 来创建对象，性能会变差，但是不会创建临文件。\n\n\ncharset\nCharset#defaultCharset\n只有 csv 文件有用，读取文件的时候使用的编码\n\n\nautoCloseStream\ntrue\n自动关闭读取的流。\n\n\nreadCache\n空\n默认小于 5M 用 内存，超过 5M 会使用 EhCache,这里不建议使用这个参数。\n\n\nreadCacheSelector\nSimpleReadCacheSelector\n用于选择什么时候用内存去存储临时数据，什么时候用磁盘存储临时数据\n\n\nignoreEmptyRow\ntrue\n忽略空的行\n\n\npassword\n空\n读取文件的密码\n\n\nxlsxSAXParserFactoryName\n空\n指定 sax 读取使用的 class 的名称，例如：com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl\n\n\nuseDefaultListener\ntrue\n@since 2.1.4 默认会加入 ModelBuildEventListener 来帮忙转换成传入 class 的对象，设置成 false 后将不会协助转换对象，自定义的监听器会接收到 Map&lt;Integer,CellData&gt; 对象，如果还想继续接听到 class 对象，请调用 readListener 方法，加入自定义的 beforeListener、 ModelBuildEventListener、 自定义的 afterListener 即可。\n\n\nextraReadSet\n空\n额外需要读取内容的 set，默认不读取这些数据\n\n\n4.1.3 ReadSheetEasyExcel.read(fileName, DemoData.class, new DemoDataListener())\n          .sheet()\n          &#x2F;&#x2F; 在 sheet 方法之后， 在 doRead方法之前都是设置ReadSheet的参数\n          .doRead();\n\n\n\n\n名称\n默认值\n描述\n\n\n\nsheetNo\n0\n需要读取 Sheet 的编码，建议使用这个来指定读取哪个 Sheet\n\n\nsheetName\n空\n根据名字去匹配 Sheet\n\n\n4.2 简单的读读取的表格就使用上面导出的表格\n4.2.1 表格实体类和 Convert表格实体类和 Convert 就使用写 Excel 的实体类和 Convert\n4.2.2 实现类@Service\npublic class ExcelServiceImpl implements ExcelService &#123;\n\n    @Resource\n    private EmployeeDAO employeeDAO;\n\n    public void simpleRead() &#123;\n        String fileName &#x3D; &quot;D:\\\\simpleWrite1665735316967.xlsx&quot;;\n\n        &#x2F;&#x2F; 写法1：不用额外写一个 ExcelListener\n        &#x2F;&#x2F; 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭\n        &#x2F;&#x2F; 这里每次会读取100条数据 然后返回过来 直接调用使用数据就行\n        EasyExcel.read(fileName, ExcelDO.class, new PageReadListener&lt;ExcelDO&gt;(excelDOS -&gt; &#123;\n            for (ExcelDO excelDO : excelDOS) &#123;\n                System.out.println(excelDO);\n            &#125;\n        &#125;)).sheet().doRead();\n\n        &#x2F;&#x2F; 写法2：匿名内部类 不用额外写一个 ExcelListener\n        EasyExcel.read(fileName, ExcelDO.class, new ReadListener&lt;ExcelDO&gt;() &#123;\n            &#x2F;&#x2F; 单次缓存的数据量\n            public static final int BATCH_COUNT &#x3D; 100;\n            &#x2F;&#x2F; 临时存储\n            private List&lt;ExcelDO&gt; cachedDataList &#x3D; ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);\n\n            @Override\n            public void invoke(ExcelDO data, AnalysisContext context) &#123;\n                cachedDataList.add(data);\n                if (cachedDataList.size() &gt;&#x3D; BATCH_COUNT) &#123;\n                    saveData();\n                    &#x2F;&#x2F; 存储完成清理 list\n                    cachedDataList &#x3D; ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 所有数据解析完成了 都会来调用\n            @Override\n            public void doAfterAllAnalysed(AnalysisContext context) &#123;\n                saveData();\n            &#125;\n\n            &#x2F;&#x2F; 存储到数据库，批量插入\n            private void saveData() &#123;\n                for (ExcelDO excelDO : cachedDataList) &#123;\n                    System.out.println(excelDO);\n                &#125;\n            &#125;\n        &#125;).sheet().doRead();\n\n        &#x2F;&#x2F; 写法3：有个很重要的点 ExcelListener 不能被Spring管理，要每次读取Excel都要new,然后里面用到Spring可以构造方法传进去\n        EasyExcel.read(fileName, ExcelDO.class, new ExcelListener(employeeDAO)).sheet().doRead();\n\n        &#x2F;&#x2F; 写法4：一个文件一个reader\n        try (ExcelReader excelReader &#x3D; EasyExcel.read(fileName, ExcelDO.class, new ExcelListener(employeeDAO)).build()) &#123;\n            &#x2F;&#x2F; 构建一个sheet 这里可以指定名字或者no\n            ReadSheet readSheet &#x3D; EasyExcel.readSheet(0).build();\n            &#x2F;&#x2F; 读取一个sheet\n            excelReader.read(readSheet);\n        &#125;\n    &#125;\n&#125;\n\n4.2.3 监听器即把第二种写法的匿名内部类单独抽出来，监听器不能被 Spring 管理，每次读取 Excel 都要 new，然后里面用到 Spring 可以构造方法传进去\npublic class ExcelListener implements ReadListener&lt;ExcelDO&gt; &#123;\n\n    &#x2F;&#x2F; 单次缓存的数据量\n    public static final int BATCH_COUNT &#x3D; 100;\n    &#x2F;&#x2F; 临时存储\n    private List&lt;ExcelDO&gt; cachedDataList &#x3D; ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);\n\n    private EmployeeDAO employeeDAO;\n\n    &#x2F;**\n     * 如果使用了Spring，使用这个构造方法。每次创建Listener的时候需要把Spring管理的类传进来\n     *\n     * @param employeeDAO\n     *&#x2F;\n    public ExcelListener(EmployeeDAO employeeDAO) &#123;\n        this.employeeDAO &#x3D; employeeDAO;\n    &#125;\n\n    &#x2F;**\n     * 这个每一条数据解析都会来调用\n     *\n     * @param data    one row value. Is same as &#123;@link AnalysisContext#readRowHolder()&#125;\n     * @param context\n     *&#x2F;\n    @Override\n    public void invoke(ExcelDO data, AnalysisContext context) &#123;\n        cachedDataList.add(data);\n        &#x2F;&#x2F; 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM\n        if (cachedDataList.size() &gt;&#x3D; BATCH_COUNT) &#123;\n            saveData();\n            &#x2F;&#x2F; 存储完成清理 list\n            cachedDataList &#x3D; ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 所有数据解析完成了 都会来调用\n     *\n     * @param context\n     *&#x2F;\n    @Override\n    public void doAfterAllAnalysed(AnalysisContext context) &#123;\n        &#x2F;&#x2F; 这里也要保存数据，确保最后遗留的数据也存储到数据库\n        saveData();\n    &#125;\n\n    &#x2F;&#x2F; 存储到数据库，批量存储\n    private void saveData() &#123;\n&#x2F;&#x2F;        employeeDAO.save(cachedDataList);\n        for (ExcelDO excelDO : cachedDataList) &#123;\n            System.out.println(excelDO);\n        &#125;\n    &#125;\n&#125;\n\n4.2.4 Controller@RestController\npublic class ExcelController &#123;\n\n    @Resource\n    private ExcelService excelService;\n\n    @PostMapping(&quot;&#x2F;simpleRead&quot;)\n    public void simpleRead() &#123;\n        excelService.simpleRead();\n    &#125;\n&#125;\n\n\n4.3 Web 中的读（上传）与简单的读类似\n@RestController\npublic class ExcelController &#123;\n\n    @Resource\n    private EmployeeDAO employeeDAO;\n\n    @PostMapping(&quot;upload&quot;)\n    public Result upload(MultipartFile file) throws IOException &#123;\n        EasyExcel.read(file.getInputStream(), ExcelDO.class, new ExcelListener(employeeDAO)).sheet().doRead();\n        return Result.success(&quot;上传成功&quot;);\n    &#125;\n&#125;\n\n\n\n更多读写相关操作详见官方文档：关于 Easyexcel | Easy Excel (alibaba.com)\n","slug":"BlogRepository/开发技术及框架/Easy Excel 使用总结","date":"2022-10-14T09:33:57.000Z","categories_index":"开发技术及框架","tags_index":"Excel","author_index":"凡"},{"id":"e080051a012a1ddc507e547da7a01efc","title":"Spring Validation 使用总结","content":"1. 概述及常用注解数据的校验是交互式网站一个不可或缺的功能，前端的 JS 校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用 HTTP 工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落到数据库中\n常用校验\n1、SR303&#x2F;JSR-349\nJSR303 是一项标准，只提供规范不提供实现，规定一些校验规范即校验注解，如 @Null，@Pattern，位于 javax.validation.constraints 包下。JSR-349 是其的升级版本，添加了一些新特性\n\n@Null：被注释的元素必须为 null\n@NotNull ：被注释的元素必须不为 null\n@AssertTrue：被注释的元素必须为 true\n@AssertFalse：被注释的元素必须为 false\n@Min(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n@Max(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n@DecimalMin(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n@DecimalMax(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n@Size(max, min)：被注释的元素的大小必须在指定的范围内\n@Digits (integer, fraction)：被注释的元素必须是一个数字，其值必须在可接受的范围内\n@Past：被注释的元素必须是一个过去的日期\n@Future：被注释的元素必须是一个将来的日期\n@Pattern(value)：被注释的元素必须符合指定的正则表达式\n\n2、Hibernate Validation\nHibernate Validation 是对这个规范的实现，并增加了一些其他校验注解，如 @Email，@Length，@Range 等等\n\n@Email：被注释的元素必须是电子邮箱地址\n@Length：被注释的字符串的大小必须在指定的范围内\n@NotEmpty：被注释的字符串的必须非空\n@Range：被注释的元素必须在合适的范围内\n\n3、Spring Validation\nSpring Validation 对Hibernate Validation 进行了二次封装，在 SpringMVC 模块中添加了自动校验，并将校验信息封装进了特定的类中\n\n     注解   含义 \n    \n         空值判断   @Null   验证对象是否为NULL \n    \n    \n         @NotNull   验证对象是否不为NULL，但可以为 EMPTY(\"\", \" \", \"  \")，无法查检长度为 0 的字符串 \n    \n    \n         @NotBlank   验证String 对象是否不为 NULL，还有被 Trim 的长度是否大于 0，只能用在 String 字符串类型上，且会去掉前后空格 \n    \n    \n         @NotEmpty   验证对象是否不为NULL 或者是 EMPTY(\"\")，长度必须大于 0 (\" \", \"  \") \n    \n    \n         布尔检查   @AssertTrue   验证 Boolean 对象是否为 True \n    \n    \n         @AssertFalse   验证 Boolean 对象是否为 False \n    \n    \n         长度检查   @Size(min, max)   验证对象（Array, Collection , Map, String）长度是否在给定的范围之内 \n    \n    \n         @Length(min, max)   验证字符串长度是否介于 min 和 max 之间 \n    \n    \n         日期检查   @Past   验证 Date 和 Calendar 对象是否在当前时间之前，即过去的日期 \n    \n    \n         @Future   验证 Date 和 Calendar 对象是否在当前时间之前，即过去的日期 \n    \n    \n         正则检查   @Pattern(regexp, flags) \n        \n            验证 String 对象是否符合正则表达式的规则\n            \n                 regexp：正则表达式 \n                 flags：指定 Pattern.Flag 的数组，表示正则表达式的相关选项 \n            \n        \n    \n    \n         数值检查 \n            （建议使用在 String，Integer 类型不建议使用在 int 类型上\n            因为表单值为 \"\" 时无法转换为 int但可以转换为 String 为 \"\"Integer 为 NULL）\n        \n         @Min(val)   验证 Number 和 String 对象是否大等于指定的值 \n    \n    \n         @Max(val)   验证 Number 和 String 对象是否小等于指定的值 \n    \n    \n         @DecimalMax(val)   被标注的值必须不大于约束中指定的最大值，这个约束的参数是一个通过 BigDecimal 定义的最大值的字符串表示 .小数 存在精度 \n    \n    \n         @DecimalMin(val)   被标注的值必须不小于约束中指定的最小值，这个约束的参数是一个通过 BigDecimal 定义的最小值的字符串表示 .小数 存在精度 \n    \n    \n         @Digits   验证 Number 和 String 的构成是否合法 \n    \n    \n         @Digits(integer, fraction)   验证字符串是否是符合指定格式的数字，integer 指定整数精度，fraction 指定小数精度 \n    \n    \n         @Range(min, max)   被指定的元素必须在合适的范围内 \n    \n    \n         @Email   验证是否是邮件地址，如果为 NULL，不进行验证，算通过验证 \n    \n    \n         @CreditCardNumber   信用卡验证 \n    \n    \n         @ScriptAssert(lang, script, alias) \n    \n    \n         @URL(protocol, host, port, regexp, flags) \n    \n    \n         @Valid   递归的对关联对象进行校验, 如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个 Map，则对其中的值部分进行校验.(是否进行递归验证) \n    \n\n\n2. @Valid 和 @Validated 注解@Valid、@Validated 注解都可以实现数据的验证，表示开启数据验证\n1、包位置不同\n\n@Valid：位于 javax.validation.Valid\n@Validated：位于 org.springframework.validation.annotation.Validated，是 @Valid 的一次封装，Spring 提供的校验机制使用\n\n\n2、Spring Validation 验证框架提供了 @Validated 注解对参数进行验证，符合 Spring’s JSR-303 规范；而 @Valid 注解是 javax 提供的，符合标准的 JSR-303 规范\n3、当使用仅是注解字段属性并验证规范，@Validated 和 @Valid 注解的功能是相同的\n4、@Validated 注解可以用于方法、构造函数、方法参数上；而 @Valid 还可以用于成员属性（字段）之上\n5、@Validated 注解可以使用分组校验的功能，为同一个对象属性提供不同分组，并根据分组来校验属性参数；而 @Valid 注解不支持分组验证\n6、@Valid 注解支持嵌套验证，当类的属性是一个复杂对象时，可以使用 @Valid 对该属性对象中的属性同时进行校验；@Validated 并不支持在属性上使用\n3. 使用3.1 POM导入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n3.2 简单参数校验服务接口接收单个简单参数时，可以在方法参数中直接使用校验注解。单参数校验时，还需要在 Controller 层控制器类中使用 @Validated 标注才会生效\n@RestController\n@Validated\npublic class ValidateController &#123;\n\n    @PostMapping(&quot;&#x2F;simple&quot;)\n    public Result simple(@RequestParam(&quot;validate&quot;) @NotBlank(message &#x3D; &quot;用户编码不能为空&quot;) String validate) &#123;\n        System.out.println(validate + &quot;参数值&quot;);\n\n        return Result.success(&quot;成功&quot;);\n    &#125;\n&#125;\n\n\n\n传入多个单参数为空时：\n@RestController\n@Validated\npublic class ValidateController &#123;\n\n    @PostMapping(&quot;&#x2F;simple&quot;)\n    public Result simple(@RequestParam(&quot;validate&quot;) @NotBlank(message &#x3D; &quot;用户编码不能为空&quot;) String validate,\n                         @RequestParam(&quot;id&quot;) @NotBlank(message &#x3D; &quot;ID 不能为空&quot;) String id) &#123;\n        System.out.println(validate + &quot;参数值&quot; + id);\n\n        return Result.success(&quot;成功&quot;);\n    &#125;\n&#125;\n\n\n\n3.3 实体类校验在实体类中使用校验注解标注需要校验的字段后，还需要在请求层接收参数时开启参数校验，只需要在 Controller 接口层的参数中使用 @Validated 标注，在接口接收到请求参数时会自动进行校验\n校验时可以使用 BindingResult 返回错误信息（注：添加了 BindingResult 就不会报错了），需配合 @RequestBody 或 RequestPart 一起使用，同时请求参数要在请求体里（重点是这个），否则会报 IllegalStateException 异常\n\n@RestController\npublic class ValidateController &#123;\n\n    @PostMapping(&quot;&#x2F;getUser&quot;)\n    public Result getUser(@Validated @RequestBody User user, BindingResult result) &#123;\n\n        if (result.hasErrors()) &#123;\n            return Result.fail(&quot;校验失败&quot; + result.getFieldError().getDefaultMessage());\n        &#125;\n        return Result.success(&quot;success&quot;);\n    &#125;\n&#125;\n\n实体类得加上 @Data 注解，即 getter&#x2F;setter 方法，不然校验不到\n@Data\npublic class User &#123;\n\n    @NotNull(message &#x3D; &quot;id 不能为空&quot;)\n    private Integer id;\n\n    @NotBlank(message &#x3D; &quot;姓名不能为空&quot;)\n    private String name;\n\n    private String gender;\n\n    @Pattern(regexp &#x3D; &quot;^((?:19[2-9]\\\\d&#123;1&#125;)|(?:20(?:(?:0[0-9])|(?:1[0-8]))))\\\\-((?:0?[1-9])|(?:1[0-2]))\\\\-((?:0?[1-9])|(?:[1-2][0-9])|30|31)$&quot;)\n    private String birthday;\n\n    @DecimalMin(&quot;0&quot;)\n    private BigDecimal balance;\n\n    @Valid\n    private List&lt;Pet&gt; pets;\n&#125;\n\n@Data\nclass Pet &#123;\n\n    @Min(0)\n    private double weight;\n\n    private String name;\n&#125;\n\n\n\n3.4 全局异常使用 Validation 校验异常后，当参数发生异常时，会抛出 MethodArgumentNotValidException 类型的异常，为了程序报错更通俗易懂以及方便，无需在每个接口都手动返回异常信息，可以定义全局异常来捕获该类型的异常，并统一返回结果信息\n\n@RestControllerAdvice\n&#x2F;&#x2F;@ControllerAdvice\n@Slf4j\npublic class GlobalExceptionHandler &#123;\n\n    &#x2F;&#x2F;    @ResponseBody\n    @ExceptionHandler(value &#x3D; MethodArgumentNotValidException.class)\n    public Result notValidException(MethodArgumentNotValidException exception) &#123;\n        String message &#x3D; exception.getBindingResult().getFieldError().getDefaultMessage();\n        log.error(&quot;参数校验异常: &#123;&#125;&quot;, message);\n\n        return Result.fail(message);\n    &#125;\n&#125;\n\n\n\n当参数传递异常时，可能还会出现 BindingException，使用简单参数校验时，会出现  ConstraintViolationException，可根据实际情况定义全局异常\n","slug":"BlogRepository/Spring/Spring Validation 使用总结","date":"2022-10-12T09:35:57.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"凡"},{"id":"ffaf8c18c9c334b55a0bf75e7c8818f0","title":"设计模式之美总结（面向对象篇）","content":"1. 代码质量的好坏下面这些几乎涵盖我们所能听到的描述代码质量的所有常用词汇，这些描述方法语义更丰富、更专业、更细化\n\n\n\n\n\n\n\n\n\n灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well\u0002documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……\n实际上，很难通过其中的某个或者某几个词汇来全面地评价代码质量。因为这些词汇都是从不同维度来说的。并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那也不能说这段代码质量高\n除此之外，不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。比如，代码的可读性好、可扩展性好，就意味着代码的可维护性好。而且，各种评价维度也不是非黑即白的。比如，不能简单地将代码分为可读与不可读。如果用数字来量化代码的可读性的话，它应该是一个连续的区间值，而非 0、1 这样的离散值\n对一段代码的质量评价，常常有很强的主观性。正是因为代码质量评价的主观性，使得这种主观评价的准确度，跟工程师自身经验有极大的关系。越是有经验的工程师，给出的评价也就越准确。常用的评价标准为：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性\n1.1 可维护性（maintainability）落实到编码开发，所谓的“维护”无外乎就是修改 bug、修改老的代码、添加新的代码之类的工作。所谓“代码易维护”就是指，在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成\n如何来判断代码可维护性的好坏？\n\n代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护\n更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护\n除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关\n所以，从正面去分析一个代码是否易维护稍微有点难度。不过可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护\n\n代码质量的评价有很强的主观性\n1.2 可读性（readability）代码的可读性应该是评价代码质量最重要的指标之一\n\n\n\n\n\n\n\n\n\n软件设计大师 Martin Fowler 曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”\n“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”\n如何评价一段代码的可读性？\n\n要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等\n从正面上，很难给出一个覆盖所有评价指标的列表。这也是无法量化可读性的原因\n实际上，Code Review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了\n\n1.3 可扩展性（extensibility）代码的可扩展性是评价代码质量非常重要的标准，可扩展性表示代码应对未来需求变化的能力。和可读性一样，代码是否易扩展也很大程度上决定代码是否易维护\n代码的可扩展性表示，在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。直白说法就是，代码预留了一些功能扩展点，可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码\n关于代码的扩展性，涉及到“对修改关闭，对扩展开放”这条设计原则\n1.4 灵活性（flexibility）灵活性是一个很抽象的评价标准，可以设想几个场景：\n\n当添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，除了可以说代码易扩展，还可以说代码写得灵活\n当要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，除了可以说代码易复用之外，还可以说代码写得灵活\n当使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，除了可以说接口易用之外，还可以说这个接口设计得灵活或者代码写得灵活\n\n从上面列举的场景来看，如果一段代码易扩展、易复用或者易用，都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛\n1.5 简洁性（simplicity）有一条非常著名的设计原则，KISS 原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。思从深而行从简，用最简单的方法解决最复杂的问题\n1.6 可复用性（reusability）代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码\n\n当讲到面向对象特性的时候，会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性\n当讲到设计原则的时候，会讲到单一职责原则也跟代码的可复用性相关\n当讲到重构技巧的时候，会讲到解耦、高内聚、模块化等都能提高代码的可复用性\n\n可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系也很紧密\n1.7 可测试性（testability）相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计有问题\n如何才能写出高质量的代码？针对什么是高质量的代码，前面讲到了七个最常用、最重要的评价指标。所以问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码\n要写出满足这些评价标准的高质量代码，需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。比如：\n\n面向对象中的继承、多态能让我们写出可复用的代码\n编码规范能让我们写出可读性好的代码\n设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码\n设计模式可以让我们写出易扩展的代码\n持续重构可以时刻保持代码的可维护性等等\n\n2. 面向对象、设计原则、设计模式、编程规范、重构 之间的关系1、面向对象\n现在，主流的编程范式或者是编程风格有三种，分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础\n\n面向对象的四大特性：封装、抽象、继承、多态\n面向对象编程与面向过程编程的区别和联系\n面向对象分析、面向对象设计、面向对象编程\n接口和抽象类的区别以及各自的应用场景\n基于接口而非实现编程的设计思想\n多用组合少用继承的设计思想\n面向过程的贫血模型和面向对象的充血模型\n\n2、设计原则\n设计原则是指导代码设计的一些经验总结。设计原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。对于每一种设计原则，需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，才能在项目中灵活恰当地应用这些原则\n\nSOLID 原则 -SRP 单一职责原则\nSOLID 原则 -OCP 开闭原则\nSOLID 原则 -LSP 里式替换原则\nSOLID 原则 -ISP 接口隔离原则\nSOLID 原则 -DIP 依赖倒置原则\nDRY 原则、KISS 原则、YAGNI 原则、LOD 法则\n\n3、设计模式\n设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题\n经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。它们又可以分为三大类：创建型、结构型、行为型\n\n创建型常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式不常用的有：原型模式\n结构型常用的有：代理模式、桥接模式、装饰者模式、适配器模式不常用的有：门面模式、组合模式、享元模式\n行为型常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式\n\n4、编程规范\n编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。对于编码规范，很多书籍已经讲得很好了（比如《重构》《代码大全》《代码整洁之道》等\n5、代码重构\n在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步\n而重构的工具就是前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。对于重构，需要掌握以下几个知识点：\n\n重构的目的（why）、对象（what）、时机（when）、方法（how）\n保证重构不出错的技术手段：单元测试和代码的可测试性；\n两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）\n\n五者之间的联系\n\n面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础\n设计原则是指导代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则\n设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行\n编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范\n重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论\n\n实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等\n\n3. 面向对象与面向过程3.1 什么是面向对象编程和面向对象编程语言？面向对象编程的英文缩写是 OOP，全称是 Object Oriented Programming。对应地，面向对象编程语言的英文缩写是 OOPL，全称是 Object Oriented Programming Language\n面向对象编程中有两个非常重要、非常基础的概念，那就是类（Class）和对象（Object）。这两个概念最早出现在 1960 年，在 Simula 这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在 Smalltalk 这种编程语言中。Smalltalk 被认为是第一个真正意义上的面向对象编程语言\n直到今天，如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP、Perl 等等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程\n什么是面向对象编程？什么语言才算是面向对象编程语言？\n\n面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石\n面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言\n\n一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，照样可以进行面向对象编程。反过来讲，即便使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的\n理解面向对象编程及面向对象编程语言两个概念，其中最关键的一点就是理解面向对象编程的四大特性。这四大特性分别是：封装、抽象、继承、多态。不过也有另外一种说法，那就是只包含三大特性：封装、继承、多态，不包含抽象\n3.2 如何判定某编程语言是否是面向对象编程语言？对于什么是面向对象编程、什么是面向对象编程语言，并没有一个官方的、统一的定义。而且，从 1960 年，也就是 60 年前面向对象编程诞生开始，这两个概念就在不停地演化，所以，也无法给出一个明确的定义，也没有必要给出一个明确定义\n实际上，面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，来进行编程的一种编程范式或者编程风格，并不一定需要封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性，我们就能更容易地实现各种面向对象的代码设计思路\n比如，在面向对象编程的过程中，经常会遇到 is-a 这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并且解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是随着编程语言的不断迭代、演化，人们发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言。但是，并不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象编程语言了\n只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言\n3.3 什么是面向对象分析和面向对象设计？面向对象分析英文缩写是 OOA，全称是 Object Oriented Analysis；面向对象设计的英文缩写是 OOD，全称是 Object Oriented Design。OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段\n面向对象分析与设计中的“分析”和“设计”这两个词，简单类比软件开发中的需求分析、系统设计。之所以在前面加“面向对象”这几个字，因为是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点\n3.4 封装、抽象、继承、多态分别可以解决哪些编程问题?1、封装（Encapsulation）\n封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。对于封装这个特性，需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。Java 语言中的 private、public 等关键字就是访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问\npublic class Wallet &#123;\n    private BigDecimal balance;\n    private long balanceLastModifiedTime;\n\n    public Wallet() &#123;\n        this.balance &#x3D; BigDecimal.ZERO;\n        this.balanceLastModifiedTime &#x3D; System.currentTimeMillis();\n    &#125;\n\n    public void increaseBalance(BigDecimal increasedAmount) &#123;\n        if (increasedAmount.compareTo(BigDecimal.ZERO) &lt; 0) &#123;\n            throw new InvalidAmountException(&quot;...&quot;);\n        &#125;\n        this.balance.add(increasedAmount);\n        this.balanceLastModifiedTime &#x3D; System.currentTimeMillis();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n上面代码中只暴露了 increaseBalance() 方法，并没有暴露 set() 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 方法，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性\n封装的意义是什么？它能解决什么编程问题？\n\n如果对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性\n除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多\n\n2、抽象（Abstraction）\n抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。在面向对象编程中，常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。这里用“接口类”而不是“接口”，是因为“接口”这个词太泛化，可以指很多概念，比如 API 接口等，所以用“接口类”特指编程语言提供的接口语法\npublic interface IPictureStorage &#123;\n    void savePicture(Picture picture);\n    Image getPicture(String pictureId);\n    void deletePicture(String pictureId);\n    void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);\n&#125;\npublic class PictureStorage implements IPictureStorage &#123;\n    &#x2F;&#x2F; ... 省略其他属性...\n    @Override\n    public void savePicture(Picture picture) &#123; ... &#125;\n    @Override\n    public Image getPicture(String pictureId) &#123; ... &#125;\n    @Override\n    public void deletePicture(String pictureId) &#123; ... &#125;\n    @Override\n    public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) &#123; ... &#125;\n&#125;\n\n\n实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性\n之所以这么说，是因为类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了，并不需要了解它的底层代码是怎么实现的\n前面提到，抽象有时候会被排除在面向对象的四大特性之外，因为抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一\n抽象的意义是什么？它能解决什么编程问题？\n\n上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息\n抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等\n在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义\n\n3、继承（Inheritance）\n继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物\n为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()，Ruby 使用 &lt;。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等\n继承存在的意义是什么？它能解决什么编程问题？\n\n继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复。不过，这一点也并不是继承所独有的，也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系\n上升一个思维层面，去思考继承这一特性，从人类认知的角度上来说，是一种 is-a 关系。通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感\n但过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类\n\n所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。应该尽量少用，甚至不用。可以联系“多用组合少用继承”这种设计思想进行理解\n4、多态（Polymorphism）\n多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现\npublic class DynamicArray &#123;\n    private static final int DEFAULT_CAPACITY &#x3D; 10;\n    protected int size &#x3D; 0;\n    protected int capacity &#x3D; DEFAULT_CAPACITY;\n    protected Integer[] elements &#x3D; new Integer[DEFAULT_CAPACITY];\n\n    public int size() &#123;\n        return this.size;\n    &#125;\n\n    public Integer get(int index) &#123;\n        return elements[index];\n    &#125;\n\n    &#x2F;&#x2F;... 省略 n 多方法...\n    public void add(Integer e) &#123;\n        ensureCapacity();\n        elements[size++] &#x3D; e;\n    &#125;\n\n    protected void ensureCapacity() &#123;\n        &#x2F;&#x2F;... 如果数组满了就扩容... 代码省略...\n    &#125;\n&#125;\n\npublic class SortedDynamicArray extends DynamicArray &#123;\n    @Override\n    public void add(Integer e) &#123;\n        ensureCapacity();\n        for (int i &#x3D; size - 1; i &gt;&#x3D; 0; --i) &#123; &#x2F;&#x2F; 保证数组中的数据有序\n            if (elements[i] &gt; e) &#123;\n                elements[i + 1] &#x3D; elements[i];\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n        elements[i + 1] &#x3D; e;\n        ++size;\n    &#125;\n&#125;\n\npublic class Example &#123;\n    public static void test(DynamicArray dynamicArray) &#123;\n        dynamicArray.add(5);\n        dynamicArray.add(1);\n        dynamicArray.add(3);\n        for (int i &#x3D; 0; i &lt; dynamicArray.size(); ++i)\n    &#125;\n        System.out.println(dynamicArray[i]);\n&#125;\n\n    public static void main(String args[]) &#123;\n        DynamicArray dynamicArray &#x3D; new SortedDynamicArray();\n        test(dynamicArray); &#x2F;&#x2F; 打印结果：1、3、5\n    &#125;\n&#125;\n\n多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，用到了三个语法机制来实现多态\n\n第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray\n第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray\n第三个语法机制是编程语言要支持子类可以重写（Override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法\n\n通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add()方法，也就是实现了多态特性\n对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等\n利用接口类来实现多态特性\npublic interface Iterator &#123;\n    String hasNext();\n\n    String next();\n\n    String remove();\n&#125;\n\npublic class Array implements Iterator &#123;\n    private String[] data;\n\n    public String hasNext() &#123; ...&#125;\n\n    public String next() &#123; ...&#125;\n\n    public String remove() &#123; ...&#125;\n    &#x2F;&#x2F;... 省略其他方法...\n&#125;\n\npublic class LinkedList implements Iterator &#123;\n    private LinkedListNode head;\n\n    public String hasNext() &#123; ...&#125;\n\n    public String next() &#123; ...&#125;\n\n    public String remove() &#123; ...&#125;\n    &#x2F;&#x2F;... 省略其他方法...\n&#125;\n\npublic class Demo &#123;\n    private static void print(Iterator iterator) &#123;\n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.next());\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Iterator arrayIterator &#x3D; new Array();\n        print(arrayIterator);\n        Iterator linkedListIterator &#x3D; new LinkedList();\n        print(linkedListIterator);\n    &#125;\n&#125;\n\n在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现\n用 duck-typing 来实现多态特性\nclass Logger:\n        def record(self):\n        print(“I write a log into file.”)\nclass DB:\n        def record(self):\n        print(“I insert data into db. ”)\ndef test(recorder):\n        recorder.record()\ndef demo():\n        logger &#x3D; Logger()\n        db &#x3D; DB()\n        test(logger)\n        test(db)\n\nduck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法\n也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口\n多态特性存在的意义是什么？它能解决什么编程问题？\n\n多态特性能提高代码的可扩展性和复用性\n多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等\n\n3.5 什么是面向过程编程与面向过程编程语言？面向过程编程也是一种编程范式或编程风格。它以过程（可以为理解方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能\n面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程\n用如下案例来看看用面向过程和面向对象两种编程风格，编写出来的代码有什么不同\n\n\n\n\n\n\n\n\n\n有一个记录了用户信息的文本文件 users.txt，每行文本的格式是 name&amp;age&amp;gender（比如，小王 &amp;28&amp; 男）。现在想要从 users.txt 文件中逐行读取用户信息，然后格式化成 name\\tage\\tgender（其中，\\t 是分隔符）这种文本格式，并且按照 age 从小到达排序之后，重新写入到另一个文本文件 formatted_users.txt 中\n使用 C 语言这种面向过程的编程语言来编写：\nstruct User &#123;\n    char name[64];\n    int age;\n    char gender[16];\n&#125;;\nstruct User parse_to_user(char* text) &#123;\n    &#x2F;&#x2F; 将 text(“小王 &amp;28&amp; 男”) 解析成结构体 struct User\n&#125;\nchar* format_to_text(struct User user) &#123;\n    &#x2F;&#x2F; 将结构体 struct User 格式化成文本（&quot; 小王\\t28\\t 男 &quot;）\n&#125;\nvoid sort_users_by_age(struct User users[]) &#123;\n    &#x2F;&#x2F; 按照年龄从小到大排序 users\n&#125;\nvoid format_user_file(char* origin_file_path, char* new_file_path) &#123;\n    &#x2F;&#x2F; open files...\n    struct User users[1024]; &#x2F;&#x2F; 假设最大 1024 个用户\n    int count &#x3D; 0;\n    while(1) &#123; &#x2F;&#x2F; read until the file is empty\n        struct User user &#x3D; parse_to_user(line);\n        users[count++] &#x3D; user;\n    &#125;\n    sort_users_by_age(users);\n    for (int i &#x3D; 0; i &lt; count; ++i) &#123;\n        char* formatted_user_text &#x3D; format_to_text(users[i]);\n        &#x2F;&#x2F; write to new file...\n    &#125;\n    &#x2F;&#x2F; close files...\n&#125;\nint main(char** args, int argv) &#123;\n    format_user_file(&quot;&#x2F;home&#x2F;zheng&#x2F;user.txt&quot;, &quot;&#x2F;home&#x2F;zheng&#x2F;formatted_users.txt&quot;);\n&#125;\n\n使用 Java 这种面向对象的编程语言来编写：\npublic class User &#123;\n    private String name;\n    private int age;\n    private String gender;\n\n    public User(String name, int age, String gender) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n        this.gender &#x3D; gender;\n    &#125;\n    public static User praseFrom(String userInfoText) &#123;\n        &#x2F;&#x2F; 将 text(“小王 &amp;28&amp; 男”) 解析成类 User\n    &#125;\n    public String formatToText() &#123;\n        &#x2F;&#x2F; 将类 User 格式化成文本（&quot; 小王\\t28\\t 男 &quot;）\n    &#125;\n&#125;\npublic class UserFileFormatter &#123;\n    public void format(String userFile, String formattedUserFile) &#123;\n        &#x2F;&#x2F; Open files...\n        List users &#x3D; new ArrayList&lt;&gt;();\n        while (1) &#123; &#x2F;&#x2F; read until file is empty\n            &#x2F;&#x2F; read from file into userText...\n            User user &#x3D; User.parseFrom(userText);\n            users.add(user);\n        &#125;\n        &#x2F;&#x2F; sort users by age...\n        for (int i &#x3D; 0; i &lt; users.size(); ++i) &#123;\n            String formattedUserText &#x3D; user.formatToText();\n            &#x2F;&#x2F; write to new file...\n        &#125;\n        &#x2F;&#x2F; close files...\n    &#125;\n&#125;\npublic class MainApplication &#123;\n    public static void main(Sring[] args) &#123;\n        UserFileFormatter userFileFormatter &#x3D; new UserFileFormatter();\n        userFileFormatter.format(&quot;&#x2F;home&#x2F;zheng&#x2F;users.txt&quot;, &quot;&#x2F;home&#x2F;zheng&#x2F;formatted_us\n    &#125;\n&#125;\n\n从上面的代码中，可以看出面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中\n3.6 面向对象编程相比面向过程编程有哪些优势？1、OOP 更加能够应对大规模复杂程序的开发\n当需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现\n但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力\n面向对象编程是以类为思考对象。在进行面向对象编程的时候，并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能在应对复杂程序开发的时候，思路更加清晰\n除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如开发一个系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段\n像 C 语言这种面向过程的编程语言，也可以按照功能的不同，把函数和数据结构放到不同的文件里，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求\n实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点\n2、OOP 风格的代码更易复用、易扩展、易维护\n面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码\n\n封装特性：封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性\n抽象特性：函数本身就是一种抽象，它隐藏了具体的实现在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。但面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性\n继承特性：继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性\n多态特性：在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性\n\n基于这四大特性，利用面向对象编程，可以更轻松地写出易复用、易扩展、易维护的代码。当然，不能说利用面向过程风格就不可以写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些\n3、OOP 语言更加人性化、更加高级、更加智能\n人类最开始跟机器打交道是通过 0、1 这样的二进制指令，然后是汇编语言，再之后才出现了高级编程语言。在高级编程语言中，面向过程编程语言又早于面向对象编程语言出现。之所以先出现面向过程编程语言，是因为跟机器交互的方式，从二进制指令、汇编语言到面向过程编程语言，是一个非常自然的过渡，都是一种流程化的、面条式的编程风格，用一组指令顺序操作数据，来完成一项任务\n从指令到汇编再到面向过程编程语言，跟机器打交道的方式在不停地演进，从中很容易发现这样一条规律，那就是编程语言越来越人性化，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。实际上，在面向过程编程语言之后，面向对象编程语言的出现，也顺应了这样的发展规律，也就是说，面向对象编程语言比面向过程编程语言更加高级！\n跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。在用前面三种语言编程的时候，是在思考如何设计一组指令，告诉机器去执行这组指令，操作某些数据，完成某个任务。而在进行面向对象编程时候，是在思考如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越“远”，离人类越“近”，越“智能”\n3.7 哪些代码设计看似是面向对象，实际是面向过程的？1、滥用 getter、setter 方法\n目前开发中，通常在定义完类的属性之后，会顺手把这些属性的 getter、setter 方法都定义上。或者直接用 IDE 或者 Lombok 插件（如果是 Java 项目的话）自动生成所有属性的 getter、setter 方法。面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了\n如下例：\npublic class ShoppingCart &#123;\n    private int itemsCount;\n    private double totalPrice;\n    private List&lt;ShoppingCartItem&gt; items &#x3D; new ArrayList&lt;&gt;();\n\n    public int getItemsCount() &#123;\n        return this.itemsCount;\n    &#125;\n    public void setItemsCount(int itemsCount) &#123;\n        this.itemsCount &#x3D; itemsCount;\n    &#125;\n    public double getTotalPrice() &#123;\n        return this.totalPrice;\n    &#125;\n    public void setTotalPrice(double totalPrice) &#123;\n        this.totalPrice &#x3D; totalPrice;\n    &#125;\n    public List&lt;ShoppingCartItem&gt; getItems() &#123;\n        return this.items;\n    &#125;\n    public void addItem(ShoppingCartItem item) &#123;\n        items.add(item);\n        itemsCount++;\n        totalPrice +&#x3D; item.getPrice();\n    &#125;\n   &#x2F;&#x2F; ... 省略其他方法...\n&#125;\n\n在这段代码中有三个私有（private）属性：itemsCount、totalPrice、items\n\n对于 itemsCount、totalPrice 两个属性，定义了它们的 getter、setter 方法。这样一来，虽然将它们定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。外部可以通过 setter 方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致\n\n对于 items 属性，定义了它的 getter 方法和 addItem() 方法，并没有定义它的 setter 方法。但 items 属性的 getter 方法，返回的是一个 List 集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据，如：\nShoppingCart cart &#x3D; new ShoppCart();\n...\ncart.getItems().clear(); &#x2F;&#x2F; 清空购物车\n\n这样的代码写法，会导致 itemsCount、totalPrice、items 三者数据不一致。不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。如下：\npublic class ShoppingCart &#123;\n    &#x2F;&#x2F; ... 省略其他代码...\n    public void clear() &#123;\n        items.clear();\n        itemsCount &#x3D; 0;\n        totalPrice &#x3D; 0.0;\n    &#125;\n&#125;\n\n假如需要查看购物车中都买了啥，那这个时候，ShoppingCart 类不得不提供 items 属性的 getter 方法了，可以通过 Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改，如：\npublic class ShoppingCart &#123;\n    &#x2F;&#x2F; ... 省略其他代码...\n    public List&lt;ShoppingCartItem&gt; getItems() &#123;\n        return Collections.unmodifiableList(this.items);\n    &#125;\n&#125;\npublic class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt; implements List&lt;E&gt; &#123;\n    public boolean add(E e) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public void clear() &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    &#x2F;&#x2F; ... 省略其他代码...\n&#125;\nShoppingCart cart &#x3D; new ShoppingCart();\nList&lt;ShoppingCartItem&gt; items &#x3D; cart.getItems();\nitems.clear(); &#x2F;&#x2F; 抛出 UnsupportedOperationException 异常\n\n这样还是存在问题，当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然没法修改容器中的数据，但仍然可以修改容器中每个对象（ShoppingCartItem）的数据，如：\nShoppingCart cart &#x3D; new ShoppingCart();\ncart.add(new ShoppingCartItem(...));\nList&lt;ShoppingCartItem&gt; items &#x3D; cart.getItems();\nShoppingCartItem item &#x3D; items.get(0);\nitem.setPrice(19.0); &#x2F;&#x2F; 这里修改了 item 的价格属性\n\n2、滥用全局变量和全局方法\n在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法\n\n单例类对象在全局代码中只有一份，所以，它相当于一个全局变量\n静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量\n常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中\n静态方法一般用来操作静态变量或者外部数据。如各种 Utils 类，里面的方法一般都会定义成静态方法，在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格\n\nConstants 类\npublic class Constants &#123;\n    public static final String MYSQL_ADDR_KEY &#x3D; &quot;mysql_addr&quot;;\n    public static final String MYSQL_DB_NAME_KEY &#x3D; &quot;db_name&quot;;\n    public static final String MYSQL_USERNAME_KEY &#x3D; &quot;mysql_username&quot;;\n    public static final String MYSQL_PASSWORD_KEY &#x3D; &quot;mysql_password&quot;;\n    public static final String REDIS_DEFAULT_ADDR &#x3D; &quot;192.168.7.2:7234&quot;;\n    public static final int REDIS_DEFAULT_MAX_TOTAL &#x3D; 50;\n    public static final int REDIS_DEFAULT_MAX_IDLE &#x3D; 50;\n    public static final int REDIS_DEFAULT_MIN_IDLE &#x3D; 20;\n    &#x2F;&#x2F; ...\n&#125;\n\n在上面这段代码中，把程序中所有用到的常量，都集中地放到这个 Constants 类中。但定义一个如此大而全的 Constants 类，并不是一种很好的设计思路\n\n首先，这样的设计会影响代码的可维护性如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率\n其次，这样的设计还会增加代码的编译时间当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率\n最后，这样的设计还会影响代码的复用性如果要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中\n\n如何改进 Constants 类的设计？\n第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，放到 MysqlConstants 类中；跟 Redis 配置相关的常量，放到RedisConstants 类中\n另一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性\nUtils 类\nUtils 类的出现是基于：如果有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复，不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍\n面向对象特性的继承可以实现代码复用。利用继承特性，把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性\n既然继承不能解决这个问题，可以定义一个新的的类，实现 URL 拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，就可以把它定义为只包含静态方法的 Utils 类了\n实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，就要杜绝使用 Utils 类了。实际上，从 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类\n3、定义数据和方法分离的类\n传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层\n\nController 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写\n而在每一层中，又会定义相应的 VO（View Object）、BO（Business Object）、Entity\n一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格\n\n实际上，这种开发模式叫作基于贫血模型的开发模式，也是现在非常常用的一种 Web 项目的开发模式\n3.8 在面向对象编程中，为什么容易写出面向过程风格的代码？在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式\n而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯\n除此之外，面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题\n面向对象编程和面向过程编程的使用\n\n如果开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些\n实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗\n除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码\n不管使用面向过程还是面向对象哪种风格来写代码，最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码\n\n4. 接口与抽象类在面向对象编程中，抽象类和接口是两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。比如，可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等\n不过，并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++ 这种编程语言只支持抽象类，不支持接口；而像 Python 这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，但仍然可以通过一些手段来模拟实现这两个语法概念\n4.1 什么是抽象类和接口？1、抽象类的定义\n下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger 是一个记录日志的抽象类，FileLogger 和 MessageQueueLogger 继承 Logger，分别实现两种不同的日志记录方式：记录日志到文件中和记录日志到消息队列中。FileLogger 和 MessageQueueLogger 两个子类复用了父类 Logger 中的 name、enabled、minPermittedLevel 属性和 log() 方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的 doLog() 方法\n&#x2F;&#x2F; 抽象类\npublic abstract class Logger &#123;\n    private String name;\n    private boolean enabled;\n    private Level minPermittedLevel;\n\n    public Logger(String name, boolean enabled, Level minPermittedLevel) &#123;\n        this.name &#x3D; name;\n        this.enabled &#x3D; enabled;\n        this.minPermittedLevel &#x3D; minPermittedLevel;\n    &#125;\n    public void log(Level level, String message) &#123;\n        boolean loggable &#x3D; enabled &amp;&amp; (minPermittedLevel.intValue() &lt;&#x3D; level.intVal\n        if (!loggable) return;\n        doLog(level, message);\n    &#125;\n    protected abstract void doLog(Level level, String message);\n&#125;\n&#x2F;&#x2F; 抽象类的子类：输出日志到文件\npublic class FileLogger extends Logger &#123;\n    private Writer fileWriter;\n\n    public FileLogger(String name, boolean enabled, Level minPermittedLevel, String filepath) &#123;\n        super(name, enabled, minPermittedLevel);\n        this.fileWriter &#x3D; new FileWriter(filepath);\n    &#125;\n    @Override\n    public void doLog(Level level, String mesage) &#123;\n        &#x2F;&#x2F; 格式化 level 和 message, 输出到日志文件\n        fileWriter.write(...);\n    &#125;\n&#125;\n&#x2F;&#x2F; 抽象类的子类: 输出日志到消息中间件 (比如 kafka)\npublic class MessageQueueLogger extends Logger &#123;\n    private MessageQueueClient msgQueueClient;\n\n    public MessageQueueLogger(String name, boolean enabled,\n                              Level minPermittedLevel, MessageQueueClient msgQueueClient) &#123;\n        super(name, enabled, minPermittedLevel);\n        this.msgQueueClient &#x3D; msgQueueClient;\n    &#125;\n    @Override\n    protected void doLog(Level level, String mesage) &#123;\n        &#x2F;&#x2F; 格式化 level 和 message, 输出到消息中间件\n        msgQueueClient.send(...);\n    &#125;\n&#125;\n\n\n抽象类不允许被实例化，只能被继承。也就是说，不能 new 一个抽象类的对象出来（Logger logger = new Logger(…); 会报编译错误）\n抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的方法叫作抽象方法\n子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到示例代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法\n\n2、接口的定义\n下面这段代码是一个比较典型的接口的使用场景。通过 Java 中的 interface 关键字定义了一个 Filter 接口。AuthencationFilter 和 RateLimitFilter 是接口的两个实现类，分别实现了对 RPC 请求鉴权和限流的过滤功能\n&#x2F;&#x2F; 接口\npublic interface Filter &#123;\n    void doFilter(RpcRequest req) throws RpcException;\n&#125;\n&#x2F;&#x2F; 接口实现类：鉴权过滤器\npublic class AuthencationFilter implements Filter &#123;\n    @Override\n    public void doFilter(RpcRequest req) throws RpcException &#123;\n        &#x2F;&#x2F;... 鉴权逻辑..\n    &#125;\n&#125;\n&#x2F;&#x2F; 接口实现类：限流过滤器\npublic class RateLimitFilter implements Filter &#123;\n    @Override\n    public void doFilter(RpcRequest req) throws RpcException &#123;\n        &#x2F;&#x2F;... 限流逻辑...\n    &#125;\n&#125;\n&#x2F;&#x2F; 过滤器使用 demo\npublic class Application &#123;\n    &#x2F;&#x2F; filters.add(new AuthencationFilter());\n    &#x2F;&#x2F; filters.add(new RateLimitFilter());\n    private List&lt;Filter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n    public void handleRpcRequest(RpcRequest req) &#123;\n        try &#123;\n            for (Filter filter : fitlers) &#123;\n                filter.doFilter(req);\n            &#125;\n        &#125; catch(RpcException e) &#123;\n            &#x2F;&#x2F; ... 处理过滤结果...\n        &#125;\n        &#x2F;&#x2F; ... 省略其他处理逻辑...\n    &#125;\n&#125;\n\n\n接口不能包含属性（也就是成员变量）\n接口只能声明方法，方法不能包含代码实现\n类实现接口的时候，必须实现接口中声明的所有方法\n\n3、区别\n从语法特性上对比，两者有比较大的区别，比如抽象类中可以定义属性、方法的实现，而接口中不能定义属性，方法也不能包含代码实现等等。除了语法特性，从设计的角度，两者也有比较大的区别\n抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。继承关系是一种 is-a 的关系，那抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）\n4.2 抽象类和接口能解决什么编程问题？为什么需要抽象类？它能够解决什么编程问题？\n抽象类不能实例化，只能被继承。继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码\n不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那不使用抽象类，照样也可以实现继承和复用。从这个角度上来讲，貌似并不需要抽象类这种语法。拿打印日志的例子来说，把代码改造一下，Logger 不再是抽象类，只是一个普通的父类\n&#x2F;&#x2F; 父类：非抽象类，就是普通的类. 删除了 log(),doLog()，新增了 isLoggable().\npublic class Logger &#123;\n    private String name;\n    private boolean enabled;\n    private Level minPermittedLevel;\n\n    public Logger(String name, boolean enabled, Level minPermittedLevel) &#123;\n        &#x2F;&#x2F;... 构造函数不变，代码省略...\n    &#125;\n    protected boolean isLoggable() &#123;\n        boolean loggable &#x3D; enabled &amp;&amp; (minPermittedLevel.intValue() &lt;&#x3D; level.intVal\n        return loggable;\n    &#125;\n&#125;\n&#x2F;&#x2F; 子类：输出日志到文件\npublic class FileLogger extends Logger &#123;\n    private Writer fileWriter;\n\n    public FileLogger(String name, boolean enabled,\n                      Level minPermittedLevel, String filepath) &#123;\n        &#x2F;&#x2F;... 构造函数不变，代码省略...\n    &#125;\n    public void log(Level level, String mesage) &#123;\n        if (!isLoggable()) return;\n        &#x2F;&#x2F; 格式化 level 和 message, 输出到日志文件\n        fileWriter.write(...);\n    &#125;\n&#125;\n&#x2F;&#x2F; 子类: 输出日志到消息中间件 (比如 kafka)\npublic class MessageQueueLogger extends Logger &#123;\n    private MessageQueueClient msgQueueClient;\n\n    public MessageQueueLogger(String name, boolean enabled,\n                              Level minPermittedLevel, MessageQueueClient msgQueueClient) &#123;\n&#x2F;       &#x2F;... 构造函数不变，代码省略...\n    &#125;\n    public void log(Level level, String mesage) &#123;\n        if (!isLoggable()) return;\n        &#x2F;&#x2F; 格式化 level 和 message, 输出到消息中间件\n        msgQueueClient.send(...);\n    &#125;\n&#125;\n\n这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。像下面这样编写代码，就会出现编译错误，因为 Logger 中并没有定义 log() 方法\nLogger logger &#x3D; new FileLogger(&quot;access-log&quot;, true, Level.WARN, &quot;&#x2F;users&#x2F;wangzhen\nlogger.log(Level.ERROR, &quot;This is a test log message.&quot;);\n\n这个问题解决起来很简单。在 Logger 父类中，定义一个空的 log() 方法，让子类重写父类的 log() 方法，实现自己的记录日志的逻辑，但这个设计思路显然没有之前通过抽象类的实现思路优雅\n\n在 Logger 中定义一个空的方法，会影响代码的可读性如果不熟悉 Logger 背后的设计思想，代码注释又不怎么给力，在阅读 Logger 代码的时候，就可能对为什么定义一个空的 log() 方法而感到疑惑\n当创建一个新的子类继承 Logger 父类的时候，有可能会忘记重新实现 log() 方法之前基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误\nLogger 可以被实例化，换句话说，可以 new 一个 Logger 出来，并且调用空的 log() 方法。这也增加了类被误用的风险当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅\n\n为什么需要接口？它能够解决什么编程问题？\n抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性\n实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想\n4.3 如何模拟抽象类和接口两个语法概念？1、通过抽象类来模拟接口\n接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。只要满足这样几点，从设计的角度上来说，就可以把它叫作接口。如下 C++ 代码：\nclass Strategy &#123; &#x2F;&#x2F; 用抽象类模拟接口\n    public:\n        ~Strategy();\n        virtual void algorithm()&#x3D;0;\n    protected:\n        Strategy();\n&#125;;\n\n抽象类 Strategy 没有定义任何属性，并且所有的方法都声明为 virtual 类型（等同于 Java中的 abstract 关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口\n2、普通类来模拟接口\n如果既不是 Java，也不是 C++，而是现在比较流行的动态编程语言，比如 Python、Ruby 等，在这些动态语言中，不仅没有接口的概念，也没有类似 abstract、virtual 这样的关键字来定义抽象类，那该如何实现呢？实际上，除了用抽象类来模拟接口之外，还可以用普通类来模拟接口，Java 代码实现如下：\npublic class MockInteface &#123;\n    protected MockInteface() &#123;&#125;\n    public void funcA() &#123;\n        throw new MethodUnSupportedException();\n    &#125;\n&#125;\n\n类中的方法必须包含实现，这个不符合接口的定义。但是，可以让类中的方法抛出 MethodUnSupportedException 异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。那又如何避免这个类被实例化呢？实际上很简单，只需要将这个类的构造函数声明为 protected 访问权限就可以了\n实际上，对于动态编程语言来说，还有一种对接口支持的策略，那就是 duck-typing\n4.4 如何决定该用抽象类还是接口？判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口\n从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。在编程的时候，一般都是先设计接口，再去考虑具体的实现\n5. 基于接口而非实现编程5.1 如何解读原则中的“接口”二字？“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想，并不局限于编程语言的“接口”语法\n从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。这些对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类\n这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性\n实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一\n5.2 如何运用这条原则？假设系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：\npublic class AliyunImageStore &#123;\n    &#x2F;&#x2F;... 省略属性、构造函数等...\n\n    public void createBucketIfNotExisting(String bucketName) &#123;\n        &#x2F;&#x2F; ... 创建 bucket 代码逻辑...\n        &#x2F;&#x2F; ... 失败会抛出异常..\n    &#125;\n\n    public String generateAccessToken() &#123;\n        &#x2F;&#x2F; ... 根据 accesskey&#x2F;secrectkey 等生成 access token\n    &#125;\n\n    public String uploadToAliyun(Image image, String bucketName, String accessTok\n    &#x2F;&#x2F;... 上传图片到阿里云...\n    &#x2F;&#x2F;... 返回图片存储在阿里云上的地址 (url）...\n&#125;\n\n    public Image downloadFromAliyun(String url, String accessToken) &#123;\n        &#x2F;&#x2F;... 从阿里云下载图片...\n    &#125;\n&#125;\n&#x2F;&#x2F; AliyunImageStore 类的使用举例\npublic class ImageProcessingJob &#123;\n    private static final String BUCKET_NAME &#x3D; &quot;ai_images_bucket&quot;;\n    &#x2F;&#x2F;... 省略其他无关代码...\n\n    public void process() &#123;\n        Image image &#x3D; ...; &#x2F;&#x2F; 处理图片，并封装为 Image 对象\n        AliyunImageStore imageStore &#x3D; new AliyunImageStore(&#x2F;* 省略参数 *&#x2F;);\n        imageStore.createBucketIfNotExisting(BUCKET_NAME);\n        String accessToken &#x3D; imageStore.generateAccessToken();\n        imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);\n    &#125;\n&#125;\n\n整个上传流程包含三个步骤：创建 bucket（可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码完全能满足将图片存储在阿里云的业务需求\n过了一段时间后，假如自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，该如何修改代码呢？这时需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象\n新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题：\n\n首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()最初只考虑将图片存储在阿里云上。而把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大\n其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整\n\n这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体如下 3 点：\n\n函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()\n封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。可以对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用\n为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程\n\npublic interface ImageStore &#123;\n    String upload(Image image, String bucketName);\n    Image download(String url);\n&#125;\npublic class AliyunImageStore implements ImageStore &#123;\n    &#x2F;&#x2F;... 省略属性、构造函数等...\n    public String upload(Image image, String bucketName) &#123;\n        createBucketIfNotExisting(bucketName);\n        String accessToken &#x3D; generateAccessToken();\n        &#x2F;&#x2F;... 上传图片到阿里云...\n        &#x2F;&#x2F;... 返回图片在阿里云上的地址 (url)...\n    &#125;\n    public Image download(String url) &#123;\n        String accessToken &#x3D; generateAccessToken();\n        &#x2F;&#x2F;... 从阿里云下载图片...\n    &#125;\n    private void createBucketIfNotExisting(String bucketName) &#123;\n        &#x2F;&#x2F; ... 创建 bucket...\n        &#x2F;&#x2F; ... 失败会抛出异常..\n    &#125;\n    private String generateAccessToken() &#123;\n        &#x2F;&#x2F; ... 根据 accesskey&#x2F;secrectkey 等生成 access token\n    &#125;\n&#125;\n&#x2F;&#x2F; 上传下载流程改变：私有云不需要支持 access token\npublic class PrivateImageStore implements ImageStore &#123;\n    public String upload(Image image, String bucketName) &#123;\n        createBucketIfNotExisting(bucketName);\n        &#x2F;&#x2F;... 上传图片到私有云...\n        &#x2F;&#x2F;... 返回图片的 url...\n    &#125;\n    public Image download(String url) &#123;\n        &#x2F;&#x2F;... 从私有云下载图片...\n    &#125;\n    private void createBucketIfNotExisting(String bucketName) &#123;\n        &#x2F;&#x2F; ... 创建 bucket...\n        &#x2F;&#x2F; ... 失败会抛出异常..\n    &#125;\n&#125;\n&#x2F;&#x2F; ImageStore 的使用举例\npublic class ImageProcessingJob &#123;\n    private static final String BUCKET_NAME &#x3D; &quot;ai_images_bucket&quot;;\n    &#x2F;&#x2F;... 省略其他无关代码...\n    public void process() &#123;\n        Image image &#x3D; ...;&#x2F;&#x2F; 处理图片，并封装为 Image 对象\n        ImageStore imageStore &#x3D; new PrivateImageStore(...);\n        imagestore.upload(image, BUCKET_NAME);\n    &#125;\n&#125;\n\n除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法\n在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动\n5.3 是否需要为每个类定义接口？做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，做权衡的根本依据，还是要回归到设计原则诞生的初衷上来\n这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性\n从这个设计初衷上来看，如果在业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了\n除此之外，越是不稳定的系统，越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那就没有必要为其扩展性，投入不必要的开发时间\n6. 组合优于继承，多用组合少用继承在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？\n6.1 为什么不推荐使用继承？继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？如下例：\n1、假设要设计一个关于鸟的类。将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类\n2、大部分鸟都会飞，那可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，可以在鸵鸟这个子类中重写（Override）fly() 方法，让它抛出 UnSupportedMethodException 异常就可以了。代码实现如下：\npublic class AbstractBird &#123;\n    &#x2F;&#x2F;... 省略其他属性和方法...\n    public void fly() &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class Ostrich extends AbstractBird &#123; &#x2F;&#x2F; 鸵鸟\n    &#x2F;&#x2F;... 省略其他属性和方法...\n    public void fly() &#123;\n        throw new UnSupportedMethodException(&quot;I can&#39;t fly.&#39;&quot;);\n    &#125;\n&#125;\n\n3、这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率\n4、这时可以再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类。具体的继承关系如下：\n\n5、从图中可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。再继续加点难度。在刚刚这个场景中，只关注“鸟会不会飞”，但如果还关注“鸟会不会叫”，那这个时候，又该如何设计类之间的继承关系呢？\n6、是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）\n\n7、如果还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑\n总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么不推荐使用继承\n6.2 组合相比继承有哪些优势？实际上，可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题\n前面讲到接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，可以类似地定义 Tweetable 接口、EggLayable 接口。将这个设计思路翻译成 Java 代码如下：\npublic interface Flyable &#123;\n    void fly();\n&#125;\n\npublic interface Tweetable &#123;\n    void tweet();\n&#125;\n\npublic interface EggLayable &#123;\n    void layEgg();\n&#125;\n\npublic class Ostrich implements Tweetable, EggLayable &#123;&#x2F;&#x2F; 鸵鸟\n    &#x2F;&#x2F;... 省略其他属性和方法...\n\n    @Override\n    public void tweet() &#123; &#x2F;&#x2F;... &#125;\n    @Override\n    public void layEgg () &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class Sparrow impelents Flayable,Tweetable,EggLayable &#123;&#x2F;&#x2F; 麻雀\n    &#x2F;&#x2F;... 省略其他属性和方法...\n\n    @Override\n    public void fly() &#123; &#x2F;&#x2F;... &#125;\n    @Override\n    public void tweet () &#123; &#x2F;&#x2F;... &#125;\n    @Override\n    public void layEgg () &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\n不过，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？\n可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。代码实现如下所示：\npublic interface Flyable &#123;\n    void fly()；\n&#125;\npublic class FlyAbility implements Flyable &#123;\n    @Override\n    public void fly() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n&#x2F;&#x2F; 省略 Tweetable&#x2F;TweetAbility&#x2F;EggLayable&#x2F;EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable &#123;&#x2F;&#x2F; 鸵鸟\n    private TweetAbility tweetAbility &#x3D; new TweetAbility(); &#x2F;&#x2F; 组合\n    private EggLayAbility eggLayAbility &#x3D; new EggLayAbility(); &#x2F;&#x2F; 组合\n    &#x2F;&#x2F;... 省略其他属性和方法...\n\n    @Override\n    public void tweet() &#123;\n        tweetAbility.tweet(); &#x2F;&#x2F; 委托\n    &#125;\n    @Override\n    public void layEgg() &#123;\n        eggLayAbility.layEgg(); &#x2F;&#x2F; 委托\n    &#125;\n&#125;\n\n继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成\n\n比如 is-a 关系，可以通过组合和接口的 has-a 关系来替代\n多态特性可以利用接口来实现\n代码复用我们可以通过组合和委托来实现\n\n所以，从理论上讲，通过组合、接口、委托三个技术手段，完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系\n6.3 如何判断该用组合还是继承？尽管鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合\n如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承\n除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系\n有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。这个时候，使用组合就更加合理、更加灵活。代码实现如下：\npublic class Url &#123;\n    &#x2F;&#x2F;... 省略属性和方法\n&#125;\npublic class Crawler &#123;\n    private Url url; &#x2F;&#x2F; 组合\n    public Crawler() &#123;\n        this.url &#x3D; new Url();\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\npublic class PageAnalyzer &#123;\n    private Url url; &#x2F;&#x2F; 组合\n    public PageAnalyzer() &#123;\n        this.url &#x3D; new Url();\n    &#125;\n    &#x2F;&#x2F;..\n&#125;\n\n还有一些特殊的场景要求必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是希望能重写这个类在运行时执行的 encode() 函数。这个时候，只能采用继承来实现了\npublic class FeignClient &#123; &#x2F;&#x2F; feighn client 框架代码\n    &#x2F;&#x2F;... 省略其他代码...\n    public void encode(String url) &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic void demofunction(FeignClient feignClient) &#123;\n    &#x2F;&#x2F;...\n    feignClient.encode(url);\n    &#x2F;&#x2F;...\n&#125;\npublic class CustomizedFeignClient extends FeignClient &#123;\n    @Override\n    public void encode(String url) &#123; &#x2F;&#x2F;... 重写 encode 的实现...&#125;\n&#125;\n&#x2F;&#x2F; 调用\nFeignClient client &#x3D; new CustomizedFeignClient();\ndemofunction(client);\n\n组合并不完美，继承也不是一无是处。控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合\n7. 基于贫血模型的 MVC 架构很多业务系统都是基于 MVC 三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的 MVC 三层架构开发模式。虽然这种开发模式已经成为标准的 Web 项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为反模式（anti-pattern）。特别是领域驱动设计（Domain Driven Design，简称 DDD）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的 DDD 开发模式越来越被人提倡\n7.1 什么是基于贫血模型的传统开发模式？MVC 三层架构\nMVC 三层架构中的 M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整\n很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，一般就将后端项目分为 Repository 层、Service 层、Controller 层。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的 Web 项目，基本的分层思路都大差不差\n什么是贫血模型？\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Controller+VO(View Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 通过构造函数或者 IOC 框架注入\n\n    public UserVo getUserById(Long userId) &#123;\n        UserBo userBo &#x3D; userService.getUserById(userId);\n        UserVo userVo &#x3D; [...convert userBo to userVo...];\n        return userVo;\n    &#125;\n&#125;\npublic class UserVo &#123;&#x2F;&#x2F; 省略其他属性、get&#x2F;set&#x2F;construct 方法\n    private Long id;\n    private String name;\n    private String cellphone;\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Service+BO(Business Object) &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserService &#123;\n    private UserRepository userRepository; &#x2F;&#x2F; 通过构造函数或者 IOC 框架注入\n\n    public UserBo getUserById(Long userId) &#123;\n        UserEntity userEntity &#x3D; userRepository.getUserById(userId);\n        UserBo userBo &#x3D; [...convert userEntity to userBo...];\n        return userBo;\n    &#125;\n&#125;\npublic class UserBo &#123;&#x2F;&#x2F; 省略其他属性、get&#x2F;set&#x2F;construct 方法\n    private Long id;\n    private String name;\n    private String cellphone;\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; Repository+Entity &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserRepository &#123;\n    public UserEntity getUserById(Long userId) &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class UserEntity &#123;&#x2F;&#x2F; 省略其他属性、get&#x2F;set&#x2F;construct 方法\n   private Long id;\n   private String name;\n   private String cellphone;\n&#125;\n\n平时开发 Web 后端项目的时候，基本上都是这么组织代码的。其中，UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层\n从代码中可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格\n7.2 什么是基于充血模型的 DDD 开发模式？什么是充血模型？\n在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格\n什么是领域驱动设计？\n领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在 2004 年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是微服务\n除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行\n领域驱动设计有点儿类似敏捷开发、SOA、PAAS 等概念，听起来很高大上，但实际上只值“五分钱”。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计\n实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层\n\n在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中\n在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄\n\n总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain\n7.3 为什么基于贫血模型的传统开发模式如此受欢迎？基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的\n前面也讲过，面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，总结了下面三点原因：\n\n大部分情况下，开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义\n充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，只需要定义数据，之后有什么功能开发需求，就在 Service 层定义什么操作，不需要事先做太多设计\n思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。随便问一个旁边的大龄同事，基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的\n\n7.4 什么项目应该考虑使用基于充血模型的 DDD 开发模式？基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统\n除了代码层面的区别之外（一个业务逻辑放到 Service 层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？首先先看基于贫血模型的传统的开发模式都是怎么实现一个功能需求的\n\n平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式。接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码\n业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满天飞\n所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护\n\n如果在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成\n越复杂的系统，对代码的复用性、易维护性要求就越高，就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好需要前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发\n7.5 如何利用基于充血模型的 DDD 开发一个虚拟钱包系统？7.5.1 钱包业务背景介绍很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面：\n\n一般来讲，每个虚拟钱包账户都会对应用户的一个真实的支付账户，有可能是银行卡账户，也有可能是三方支付账户（比如支付宝、微信钱包）。这里限定钱包暂时只支持充值、提现、支付、查询余额、查询交易流水这五个核心的功能，其他比如冻结、透支、转赠等不常用的功能，暂不考虑。接下来一块儿看下它们的业务实现流程\n1、充值\n用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，可以分解为三个主要的操作流程：\n\n第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户\n第二个操作是将用户的充值金额加到虚拟钱包余额上\n第三个操作是记录刚刚这笔交易流水\n\n\n2、支付\n用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上，然后触发真正的银行转账操作，从应用的公共银行账户转钱到商家的银行账户（注意，这里并不是从用户的银行账户转钱到商家的银行账户）。除此之外，也需要记录这笔支付的交易流水信息\n\n3、提现\n除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，也需要记录这笔提现的交易流水信息\n\n4、查询余额\n查询余额功能比较简单，看一下虚拟钱包中的余额数字即可\n5、查询交易流水\n查询交易流水也比较简单。这里只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，会记录相应的交易信息。在需要查询的时候，只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可\n7.5.2 钱包系统的设计思路根据上面的业务实现流程和数据流转图，可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统\n\n如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作？\n\n从图中可以看出，虚拟钱包系统要支持的操作非常简单，就是余额的加加减减。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作，而支付功能涉及两个账户的余额加减操作：一个账户减余额，另一个账户加余额。图中问号的部分，也就是交易流水该如何记录和查询？先看一下交易流水都需要包含哪些信息：\n\n从图中可以发现，交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。为什么要有两个账号信息呢？这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，只需要记录一个钱包账户信息就够了，所以，这样的交易流水数据格式的设计稍微有点浪费存储空间\n实际上，还有另外一种交易流水数据格式的设计思路，可以解决这个问题。把“支付”这个交易类型，拆为两个子类型：支付和被支付。支付单纯表示出账，余额扣减，被支付单纯表示入账，余额增加。这样在设计交易流水数据格式的时候，只需要记录一个账户信息即可\n\n这两种交易流水数据格式的设计思路，哪一个更好呢？\n第一种设计思路更好些。因为交易流水有两个功能：一个是业务功能，比如，提供用户查询交易流水信息；另一个是非业务功能，保证数据的一致性。这里主要是指支付操作数据的一致性\n支付实际上就是一个转账的操作，在一个账户上加上一定的金额，在另一个账户上减去相应的金额。需要保证加金额和减金额这两个操作，要么都成功，要么都失败。如果一个成功，一个失败，就会导致数据的不一致，一个账户明明减掉了钱，另一个账户却没有收到钱\n保证数据一致性的方法有很多，比如依赖数据库事务的原子性，将两个操作放在同一个事务中执行。但是，这样的做法不够灵活，因为有可能做了分库分表，支付涉及的两个账户可能存储在不同的库中，无法直接利用数据库本身的事务特性，在一个事务中执行两个账户的操作。当然，还有一些支持分布式事务的开源框架，但是，为了保证数据的强一致性，它们的实现逻辑一般都比较复杂、本身的性能也不高，会影响业务的执行时间。所以，更加权衡的一种做法就是，不保证数据的强一致性，只实现数据的最终一致性，也就是刚刚提到的交易流水要实现的非业务功能\n对于支付这样的类似转账的操作，在操作两个钱包账户余额之前，先记录交易流水，并且标记为“待执行”，当两个钱包的加减金额都完成之后，再回过头来，将交易流水标记为“成功”。在给两个钱包加减金额的过程中，如果有任意一个操作失败，就将交易记录的状态标记为“失败”。通过后台补漏 Job，拉取状态为“失败”或者长时间处于“待执行”状态的交易记录，重新执行或者人工介入处理\n如果选择第二种交易流水的设计思路，使用两条交易流水来记录支付操作，那记录两条交易流水本身又存在数据的一致性问题，有可能入账的交易流水记录成功，出账的交易流水信息记录失败。所以，权衡利弊，选择第一种稍微有些冗余的数据格式设计思路\n充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？换句话说，是否应该在虚拟钱包系统的交易流水中记录这三种类型？\n答案是否定的。虚拟钱包系统不应该感知具体的业务交易类型。前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中\n如果不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？\n从系统设计的角度，不应该在虚拟钱包系统的交易流水中记录交易类型。从产品需求的角度来说，又必须记录交易流水的交易类型。听起来比较矛盾，这个问题该如何解决呢？\n可以通过记录两条交易流水信息的方式来解决。前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息\n\n通过查询上层钱包系统的交易流水信息，去满足用户查询交易流水的功能需求，而虚拟钱包中的交易流水就只是用来解决数据一致性问题。实际上，它的作用还有很多，比如用来对账等\n7.5.3 基于贫血模型的传统开发模式典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示（省略了具体的代码实现）：\npublic class VirtualWalletController &#123;\n    &#x2F;&#x2F; 通过构造函数或者 IOC 框架注入\n    private VirtualWalletService virtualWalletService;\n\n    public BigDecimal getBalance(Long walletId) &#123; ... &#125; &#x2F;&#x2F; 查询余额\n    public void debit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F; 出账\n    public void credit(Long walletId, BigDecimal amount) &#123; ... &#125; &#x2F;&#x2F; 入账\n    public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123; ...&#125; &#x2F;&#x2F; 转账\n&#125;\n\nService 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。Repository 这一层的代码实现比较简单，也省略掉了。Service 层的代码如下所示。这里省略了一些不重要的校验代码，比如，对 amount 是否小于 0、钱包是否存在的校验等等\npublic class VirtualWalletBo &#123;&#x2F;&#x2F; 省略 getter&#x2F;setter&#x2F;constructor 方法\n   private Long id;\n   private Long createTime;\n   private BigDecimal balance;\n&#125;\n\npublic class VirtualWalletService &#123;\n    &#x2F;&#x2F; 通过构造函数或者 IOC 框架注入\n    private VirtualWalletRepository walletRepo;\n    private VirtualWalletTransactionRepository transactionRepo;\n\n    public VirtualWalletBo getVirtualWallet(Long walletId) &#123;\n        VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);\n        VirtualWalletBo walletBo &#x3D; convert(walletEntity);\n        return walletBo;\n    &#125;\n    public BigDecimal getBalance(Long walletId) &#123;\n        return virtualWalletRepo.getBalance(walletId);\n    &#125;\n    public void debit(Long walletId, BigDecimal amount) &#123;\n        VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);\n        BigDecimal balance &#x3D; walletEntity.getBalance();\n        if (balance.compareTo(amount) &lt; 0) &#123;\n            throw new NoSufficientBalanceException(...);\n        &#125;\n        walletRepo.updateBalance(walletId, balance.subtract(amount));\n    &#125;\n    public void credit(Long walletId, BigDecimal amount) &#123;\n        VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);\n        BigDecimal balance &#x3D; walletEntity.getBalance();\n        walletRepo.updateBalance(walletId, balance.add(amount));\n    &#125;\n    public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;\n        VirtualWalletTransactionEntity transactionEntity &#x3D; new VirtualWalletTransac\n        transactionEntity.setAmount(amount);\n        transactionEntity.setCreateTime(System.currentTimeMillis());\n        transactionEntity.setFromWalletId(fromWalletId);\n        transactionEntity.setToWalletId(toWalletId);\n        transactionEntity.setStatus(Status.TO_BE_EXECUTED);\n        Long transactionId &#x3D; transactionRepo.saveTransaction(transactionEntity);\n        try &#123;\n            debit(fromWalletId, amount);\n            credit(toWalletId, amount);\n        &#125; catch (InsufficientBalanceException e) &#123;\n            transactionRepo.updateStatus(transactionId, Status.CLOSED);\n            ...rethrow exception e...\n        &#125; catch (Exception e) &#123;\n            transactionRepo.updateStatus(transactionId, Status.FAILED);\n            ...rethrow exception e...\n        &#125;\n        transactionRepo.updateStatus(transactionId, Status.EXECUTED);\n    &#125;\n&#125;\n\n以上便是利用基于贫血模型的传统开发模式来实现的虚拟钱包系统。尽管对代码稍微做了简化，但整体的业务逻辑就是上面这样子。其中大部分代码逻辑都非常简单，最复杂的是 Service 中的 transfer() 转账函数。为了保证转账操作的数据一致性，添加了一些跟 transaction 相关的记录和状态更新的代码\n7.5.4 基于充血模型的 DDD 开发模式基于充血模型的 DDD 开发模式，跟基于贫血模型的传统开发模式的主要区别就在 Service 层，Controller 层和 Repository 层的代码基本上相同。所以，重点看一下，Service 层按照基于充血模型的 DDD 开发模式该如何来实现\n在这种开发模式下，把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。代码实现如下：\npublic class VirtualWallet &#123; &#x2F;&#x2F; Domain 领域模型 (充血模型)\n    private Long id;\n    private Long createTime &#x3D; System.currentTimeMillis();;\n    private BigDecimal balance &#x3D; BigDecimal.ZERO;\n\n    public VirtualWallet(Long preAllocatedId) &#123;\n        this.id &#x3D; preAllocatedId;\n    &#125;\n    public BigDecimal balance() &#123;\n        return this.balance;\n    &#125;\n    public void debit(BigDecimal amount) &#123;\n        if (this.balance.compareTo(amount) &lt; 0) &#123;\n            throw new InsufficientBalanceException(...);\n        &#125;\n        this.balance.subtract(amount);\n    &#125;\n    public void credit(BigDecimal amount) &#123;\n        if (amount.compareTo(BigDecimal.ZERO) &lt; 0) &#123;\n            throw new InvalidAmountException(...);\n        &#125;\n        this.balance.add(amount);\n    &#125;\n&#125;\n\npublic class VirtualWalletService &#123;\n    &#x2F;&#x2F; 通过构造函数或者 IOC 框架注入\n    private VirtualWalletRepository walletRepo;\n    private VirtualWalletTransactionRepository transactionRepo;\n\n    public VirtualWallet getVirtualWallet(Long walletId) &#123;\n        VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);\n        VirtualWallet wallet &#x3D; convert(walletEntity);\n        return wallet;\n    &#125;\n    public BigDecimal getBalance(Long walletId) &#123;\n        return virtualWalletRepo.getBalance(walletId);\n    &#125;\n    public void debit(Long walletId, BigDecimal amount) &#123;\n        VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);\n        VirtualWallet wallet &#x3D; convert(walletEntity);\n        wallet.debit(amount);\n        walletRepo.updateBalance(walletId, wallet.balance());\n    &#125;\n    public void credit(Long walletId, BigDecimal amount) &#123;\n        VirtualWalletEntity walletEntity &#x3D; walletRepo.getWalletEntity(walletId);\n        VirtualWallet wallet &#x3D; convert(walletEntity);\n        wallet.credit(amount);\n        walletRepo.updateBalance(walletId, wallet.balance());\n    &#125;\n    public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) &#123;\n        &#x2F;&#x2F;... 跟基于贫血模型的传统开发模式的代码一样...\n    &#125;\n&#125;\n\n上面的代码中领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，要支持透支一定额度和冻结部分余额的功能。这个时候，重新来看一下 VirtualWallet 类的实现代码\npublic class VirtualWallet &#123;\n    private Long id;\n    private Long createTime &#x3D; System.currentTimeMillis();;\n    private BigDecimal balance &#x3D; BigDecimal.ZERO;\n    private boolean isAllowedOverdraft &#x3D; true;\n    private BigDecimal overdraftAmount &#x3D; BigDecimal.ZERO;\n    private BigDecimal frozenAmount &#x3D; BigDecimal.ZERO;\n\n    public VirtualWallet(Long preAllocatedId) &#123;\n        this.id &#x3D; preAllocatedId;\n    &#125;\n    public void freeze(BigDecimal amount) &#123; ... &#125;\n    public void unfreeze(BigDecimal amount) &#123; ...&#125;\n    public void increaseOverdraftAmount(BigDecimal amount) &#123; ... &#125;\n    public void decreaseOverdraftAmount(BigDecimal amount) &#123; ... &#125;\n    public void closeOverdraft() &#123; ... &#125;\n    public void openOverdraft() &#123; ... &#125;\n    public BigDecimal balance() &#123;\n        return this.balance;\n    &#125;\n    public BigDecimal getAvaliableBalance() &#123;\n        BigDecimal totalAvaliableBalance &#x3D; this.balance.subtract(this.frozenAmount)\n        if (isAllowedOverdraft) &#123;\n            totalAvaliableBalance +&#x3D; this.overdraftAmount;\n        &#125;\n        return totalAvaliableBalance;\n    &#125;\n    public void debit(BigDecimal amount) &#123;\n        BigDecimal totalAvaliableBalance &#x3D; getAvaliableBalance();\n        if (totoalAvaliableBalance.compareTo(amount) &lt; 0) &#123;\n            throw new InsufficientBalanceException(...);\n        &#125;\n        this.balance.subtract(amount);\n    &#125;\n    public void credit(BigDecimal amount) &#123;\n        if (amount.compareTo(BigDecimal.ZERO) &lt; 0) &#123;\n            throw new InvalidAmountException(...);\n        &#125;\n        this.balance.add(amount);\n    &#125;\n&#125;\n\n领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id 字段）自动生成的逻辑（不是通过构造函数经外部传入ID，而是通过分布式 ID 生成算法来自动生成 ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了\n7.5.5 辩证思考与灵活应用1、在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄，但在代码设计与实现中，并没有完全将 Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？\n区别于 Domain 的职责，Service 类主要有下面这样几个职责\n\nService 类负责与 Repository 交流VirtualWalletService 类负责与 Repository 层打交道，调用 Respository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用Repository 类的方法，将数据存回数据库\n之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用\n\nService 类负责跨领域模型的业务聚合功能VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，暂且把转账业务放到 VirtualWalletService 类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，也可以将转账业务抽取出来，设计成一个独立的领域模型\n\nService 类负责一些非功能性及与三方系统交互的工作比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中\n\n\n2、在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？\n没有必要。Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪\n尽管这样的设计是一种面向过程的编程风格，但只要控制好面向过程编程风格的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？\n拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面相对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。Entity 的生命周期到此就结束了，所以也并不会被到处任意修改\n再来说说 Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，将它设计成贫血模型也是比较合理的\n7.6 如何对接口鉴权这样一个功能开发做面向对象分析？7.6.1 面向对象分析&#x2F;需求分析（OOA）假设，你正在参与开发一个微服务。微服务通过 HTTP 协议暴露接口给其他系统调用，说直白点就是，其他系统通过 URL 来调用微服务的接口。“为了保证接口调用的安全性，希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用接口，没有认证过的系统调用接口会被拒绝”。这个时候，你该如何来做呢？\n前面讲过，面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，首先要做的都是将笼统的需求细化到足够清晰、可执行。需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的\n实际上，这跟做算法题类似，先从最简单的方案想起，然后再优化。所以，这里把整个的分析过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表\n1、第一轮基础分析\n对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。给每个允许访问服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求\n2、第二轮分析优化\n不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果借助加密算法（比如 SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码及 AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问接口。这就是典型的“重放攻击”\n提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚这个问题，可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求\n\n3、第三轮分析优化\n不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 URL 拼接上 AppID、密码生成的 token 都是固定的。未认证系统截获 URL、token 和 AppID 之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个 URL 对应的接口\n为了解决这个问题，可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。可以选择时间戳作为随机变量。原来的 token 是对 URL、AppID、密码三者进行加密生成的，现在将 URL、AppID、密码、时间戳四者进行加密来生成 token。调用方在进行接口请求的时候，将 token、AppID、时间戳，随 URL 一并传递给微服务端\n微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定 token 过期，拒绝接口请求。如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 生成算法，在服务端生成新的 token，与调用方传递过来的 token 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求\n\n4、第四轮分析优化\n虽然这样还是不够安全，未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用接口。但攻与防之间，本来就没有绝对的安全。能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了\n实际上，还有一个细节没有考虑到，那就是，如何在微服务端存储每个授权调用方的AppID 和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如 MySQL。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合\n针对 AppID 和密码的存储，最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在切换存储方式的时候，尽可能地减少代码的改动\n5、最终确定需求\n到此，需求已经足够细化和具体了。现在按照鉴权的流程，对需求再重新描述一下：\n\n调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端\n微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳\n微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求\n如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用\n\n这就是需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过“提出问题 -解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述\n7.6.2 面向对象设计（OOD）面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。在面向对象设计环节，将需求描述转化为具体的类的设计。把这一设计环节拆解细化一下，主要包含以下几个部分：\n\n划分职责进而识别出有哪些类\n定义类及其属性和方法\n定义类与类之间的交互关系\n将类组装起来并提供执行入口\n\n7.6.2.1 划分职责进而识别出有哪些类在面向对象有关书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应。对于一些抽象的概念，是无法通过映射现实世界中的事物的方式来定义类的\n所以，大多数讲面向对象的书籍中，还会讲到另外一种识别类的方法，那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。不过，作者个人更喜欢另外一种方法，那就是根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类\n首先，要做的是逐句阅读需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是“单一职责”）。逐句拆解需求分析第五点的最终需求描述之后，得到的功能点列表如下：\n\n把 URL、AppID、密码、时间戳拼接为一个字符串\n对字符串通过加密算法加密生成 token\n将 token、AppID、时间戳拼接到 URL 中，形成新的 URL\n解析 URL，得到 token、AppID、时间戳等信息\n从存储中取出 AppID 和对应的密码\n根据时间戳判断 token 是否过期失效\n验证两个 token 是否匹配\n\n从上面的功能列表中发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作\n当然，这是一个初步的类的划分，其他一些不重要的、边边角角的类，可能暂时没法一下子想全，但这也没关系，面向对象分析、设计、编程本来就是一个循环迭代、不断优化的过程。根据需求，先给出一个粗糙版本的设计方案，然后基于这样一个基础，再去迭代优化，会更加容易一些，思路也会更加清晰一些\n不过，接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多。但如果面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会有点凌乱、没有规律。针对这种复杂的需求开发，首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用上面讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路\n7.6.2.2 定义类及其属性和方法通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage。现在来看每个类都有哪些属性和方法。还是从功能点列表中挖掘\n1、AuthToken 类\n相关的功能点有四个：\n\n把 URL、AppID、密码、时间戳拼接为一个字符串\n对字符串通过加密算法加密生成 token\n根据时间戳判断 token 是否过期失效\n验证两个 token 是否匹配\n\n对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。借用这个思路，根据功能点描述，识别出来 AuthToken 类的属性和方法如下：\n\n从上面的类图中，可以发现这样三个小细节：\n\n并不是所有出现的名词都被定义为类的属性，比如 URL、AppID、密码、时间戳这几个名词，把它作为了方法的参数\n还需要挖掘一些没有出现在功能点描述中属性，比如 createTime，expireTimeInterval，它们用在 isExpired() 函数中，用来判定 token 是否过期\n还给 AuthToken 类添加了一个功能点描述中没有提到的方法 getToken()\n\n第一个细节告诉我们，从业务模型上来说，不应该属于这个类的属性和方法，不应该被放到这个类里。比如 URL、AppID 这些信息，从业务模型上来说，不应该属于 AuthToken，所以我们不应该放到这个类中\n第二、第三个细节告诉我们，在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备\n2、Url 类\n相关的功能点有两个：\n\n将 token、AppID、时间戳拼接到 URL 中，形成新的 URL\n解析 URL，得到 token、AppID、时间戳等信息\n\n虽然需求描述中，都是以 URL 来代指接口请求，但是，接口请求并不一定是以 URL 的形式来表达，还有可能是 dubbo RPC 等其他形式。为了让这个类更加通用，命名更加贴切，接下来把它命名为 ApiRequest。下面是根据功能点描述设计的 ApiRequest 类：\n\n3、CredentialStorage 类\n相关的功能点有一个：\n\n从存储中取出 AppID 和对应的密码\n\nCredentialStorage 类非常简单，类图如下所示。为了做到抽象封装具体的存储方式，这里将 CredentialStorage 设计成了接口，基于接口而非具体的实现编程\n\n7.6.2.3 定义类与类之间的交互关系类与类之间都哪些交互关系呢？UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合。各关系如下：\n\n泛化（Generalization）可以简单理解为继承关系\npublic class A &#123; ... &#125;\npublic class B extends A &#123; ... &#125;\n实现（Realization）一般是指接口和实现类之间的关系\npublic interface A &#123;...&#125;\npublic class B implements A &#123; ... &#125;\n\n聚合（Aggregation）一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程与学生之间的关系\npublic class A &#123;\n    private B b;\n\n    public A(B b) &#123;\n        this.b &#x3D; b;\n    &#125;\n&#125;\n组合（Composition）也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系\npublic class A &#123;\n    private B b;\n\n    public A() &#123;\n        this.b &#x3D; new B();\n    &#125;\n&#125;\n关联（Association）一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系\npublic class A &#123;\n    private B b;\n\n    public A(B b) &#123;\n        this.b &#x3D; b;\n    &#125;\n&#125;\n或者\npublic class A &#123;\n    private B b;\n\n    public A() &#123;\n        this.b &#x3D; new B();\n    &#125;\n&#125;\n依赖（Dependency）一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，都称它们有依赖关系\npublic class A &#123;\n    private B b;\n\n    public A(B b) &#123;\n        this.b &#x3D; b;\n    &#125;\n&#125;\n或者\npublic class A &#123;\n    private B b;\n\n    public A() &#123;\n        this.b &#x3D; new B();\n    &#125;\n&#125;\n或者\npublic class A &#123;\n    public void func(B b) &#123; ... &#125;\n&#125;\n\n个人觉得这样拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。这里对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖\n泛化、实现、依赖的定义不变，组合关系替代 UML 中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分 UML 中的组合和聚合两个概念。之所以这样重新命名，是为了跟前面讲的“多用组合少用继承”设计原则中的“组合”统一含义。只要 B 类对象是 A 类对象的成员变量，那就称，A 类跟 B 类是组合关系\n因为目前只有三个核心的类，所以只用到了实现关系，也即 CredentialStorage 和 MysqlCredentialStorage 之间的关系。下面组装类的时候，还会用到依赖关系、组合关系，但是泛化关系暂时没有用到\n7.6.2.4 将类组装起来并提供执行入口类定义好了，类之间必要的交互关系也设计好了，接下来要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，便能触发整个代码跑起来\n接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，所以，封装所有的实现细节，设计了一个最顶层的 ApiAuthencator 接口类，暴露一组给外部调用者使用的 API 接口，作为触发执行鉴权逻辑的入口。具体的类的设计如下所示：\n\n7.6.3 面向对象编程（OOP）面向对象设计完成之后，已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。有了前面的类图，这部分工作相对来说就比较简单了。这里只给出比较复杂的 ApiAuthencator 的实现：\npublic interface ApiAuthencator &#123;\n    void auth(String url);\n    void auth(ApiRequest apiRequest);\n&#125;\n\npublic class DefaultApiAuthencatorImpl implements ApiAuthencator &#123;\n    private CredentialStorage credentialStorage;\n\n    public ApiAuthencator() &#123;\n        this.credentialStorage &#x3D; new MysqlCredentialStorage();\n    &#125;\n    public ApiAuthencator(CredentialStorage credentialStorage) &#123;\n        this.credentialStorage &#x3D; credentialStorage;\n    &#125;\n\n    @Override\n    public void auth(String url) &#123;\n        ApiRequest apiRequest &#x3D; ApiRequest.buildFromUrl(url);\n        auth(apiRequest);\n    &#125;\n    @Override\n    public void auth(ApiRequest apiRequest) &#123;\n        String appId &#x3D; apiRequest.getAppId();\n        String token &#x3D; apiRequest.getToken();\n        long timestamp &#x3D; apiRequest.getTimestamp();\n        String originalUrl &#x3D; apiRequest.getOriginalUrl();\n        AuthToken clientAuthToken &#x3D; new AuthToken(token, timestamp);\n\n        if (clientAuthToken.isExpired()) &#123;\n            throw new RuntimeException(&quot;Token is expired.&quot;);\n        &#125;\n        String password &#x3D; credentialStorage.getPasswordByAppId(appId);\n        AuthToken serverAuthToken &#x3D; AuthToken.generate(originalUrl, appId, password\n        if (!serverAuthToken.match(clientAuthToken)) &#123;\n            throw new RuntimeException(&quot;Token verfication failed.&quot;);\n        &#125;\n    &#125;\n&#125;\n\n7.6.4 辩证思考与灵活应用在之前的讲解中，面向对象分析、设计、实现，每个环节的界限划分都比较清楚。而且，设计和实现基本上是按照功能点的描述，逐句照着翻译过来的。这样做的好处是先做什么、后做什么，非常清晰、明确，有章可循\n不过，在平时的工作中，大部分程序员往往都是在脑子里或者草纸上完成面向对象分析和设计，然后就开始写代码了，边写边思考边重构，并不会严格地按照刚刚的流程来执行。而且，说实话，即便在写代码之前，花很多时间做分析和设计，绘制出完美的类图、UML 图，也不可能把每个细节、交互都想得很清楚。在落实到代码的时候，还是要反复迭代、重构、打破重写\n毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。没法严格地按照顺序执行各个步骤\n","slug":"BlogRepository/设计模式/设计模式之美总结（面向对象篇）","date":"2022-10-11T09:02:54.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"凡"},{"id":"91927c15e1d4404177918c3eb486f6d5","title":"记SpringBoot拦截器报错getWriter() has already been called for this response","content":"1. 问题在拦截器中返回信息时，使用 response.getWriter() 报错 getWriter() has already been called for this response。这里使用的 getWriter()操作的是字符，所以使用 print() 或 write()都可以（print()和 wirte区别见 3）\n\n\n\n2. 原因分析这里先确定一个前提，上面的拦截器返回的是 true，还会走后面的拦截器或过滤器，假如返回 false 直接结束，则不会有上述问题。 通过跟踪 getWriter()方法，在类 Response.class 源码中\n\n可以看到在调用 getWriter()方法时，首先会判断 usingOutputStream，如果是 true，就抛出异常，否则设置 usingWriter=true;。所以调用 getWriter()方法后，会导致：usingWriter=true;\n同样在类 Response.class 源码中再查看 getOutputStream()的源码\n\n可以看到在调用 getOutputStream()方法时，首先会判断 usingWriter，如果是 true，就抛出异常，否则设置 usingOutputStream=true;。所以调用 getOutputStream()方法后，会导致：usingOutputStream=true;\n在这样的设定下，就无法同时使用 getWriter() 和 getOutputStream() 方法，调用其中一个之后必然会使其标记为 true，从而调用另一个方法时会报错\n之所以两者互相排斥，调用一个方法后不能再调用另一方法，因为 getWriter()是字符流，getOutputStream()是字节流，缓存区不可能同时存在两种格式\n3. 解决在所有的 Filter 和 Interceptor 中，要么都使用 getWriter() 方法，要么都使用 getOutputStream() 方法，不能两者都使用\n我这里后面并没有再自定义拦截器或过滤器，推测 SpringBoot 可能默认使用的是 getOutputStream()返回白页等信息，而我并没有 retrun false，同时存在两种格式导致报错。重新修改如下（测试 return false 时下图忘记改成 return true 了，但不影响引出问题）：\n\n这里使用的是 print()，会报错 Not an ISO 8859-1 character，因为 Stream 输出的是二进制流，没有对字符进行编码，Stream 只适用于 ISO 8859-1编码的字符。Writer 输出的是文本的信息， 是进行过系统编码后的\n\n使用 write() ，将数据用字节传输则正常\n\n\n","slug":"BlogRepository/问题记录/记SpringBoot拦截器报错getWriter() has already been called for this response","date":"2022-09-01T02:40:59.000Z","categories_index":"问题记录","tags_index":"SpringBoot","author_index":"凡"},{"id":"6381587c82bf912786d507cd9ab0bca2","title":"轻量应用服务器使用总结","content":"本文使用系统为 CentOS 7.6，服务器为腾讯轻量应用服务器\n1. 设置 root 密码初始化实例后，默认 root 是没有密码的，可以登录云服务器自带的 WebShell，通过 sudo passwd root 命令，设置密码\n2. 宝塔面板服务器管理软件，支持 Windows 和 Linux 系统，可以通过 Web 端轻松管理服务器，提升效率。可安装可不安装\n2.1 安装通过 su 命令，输入上面设置好的密码，切换到 root 用户，再使用\nyum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh\n\n安装宝塔面板输入 y 确认，安装完成后会显示地址和用户名密码安装宝塔面板，会创建一个 www 的用户，创建的用户位于 &#x2F;home 目录下\n2.2 使用在防火墙规则里开放 8888 端口（该端口为页面显示的访问端口）通过地址访问宝塔面板，使用用户名密码登录绑定账号可以选择安装套件，也可以不安装后续自行进行安装点击面板设置，修改用户名密码修改访问端口和地址，修改后的端口同样需要在防火墙规则里放行可以通过宝塔面板，安装对应的套件来简化环境的搭建和项目部署等操作，以及还有文件可视化页面、终端等\n3. 远程连接3.1 SSH 密码SSH 密码即为 root 密码，用户名为 root1、开启密码登录权限，编辑 /etc/ssh/sshd_config 文件，将 PermitRootLogin 设置为 yes，开启 root 登录。将 PasswordAuthentication 设置为 yes，开启密码认证2、假如有改动的，重启 SSH 服务，需要 root 权限\n&#x2F;bin&#x2F;systemctl restart sshd.service\n或 systemctl restart sshd.service\n\n3、SSH 连接，这里用的 MobaXterm_Portable_v20.2 连接工具。输入服务器地址，再输入登录的用户名及对应密码即可连接\n3.2 SSH 私钥1、进入用户（该用户为需要使用私钥登录的用户，root 就是 root 目录下，进入 root 目录需要 root 权限，其他创建的用户在 home 文件夹下对应的用户目录里）目录下的 .ssh 目录2、生成密钥对，使用 ssh-keygen -t rsa 命令，之后一路回车即可，中间会要求输入密钥的密码，不需要密码直接回车即可3、查看生成文件，其中 id_rsa 是私钥（客户端使用），id_rsa.pub 是公钥（服务器使用）4、开启密钥登录权限（这一步可跳过，无论对不对其进行配置，在腾讯云轻量应用服务器 CentOS 7.6 上不影响，原因可参考 3.3）编辑 /etc/ssh/sshd_config 文件，将 RSAAuthentication 设置为 yes，开启私钥认证（但 CentOS7.4 之后的配置文件中没有这一行，跳过这个设置）。将 PubkeyAuthentication 设置为 yes，开启公钥认证5、假如有改动的，重启 SSH 服务，需要 root 权限\n&#x2F;bin&#x2F;systemctl restart sshd.service\n或 systemctl restart sshd.service\n\n6、之后就可以通过私钥直接连接服务器（先从服务器上下载私钥），不需要每次输密码7、但腾讯云服务器这里有一个服务器绑定密钥的配置文件 authorized_keys，该文件内容即为公钥 id_rsa.pub，只有有这个配置文件才能通过私钥连接没有的话可以自己创建该文件，然后把公钥复制进去即可，同时权限所有者为 root正常生成该文件的步骤为：在服务器管理页面创建密钥，然后绑定到服务器把公钥复制进来，点击确定，创建密钥然后服务器绑定密钥，在 .ssh 目录下就会生成 authorized_keys 文件8、安装了宝塔面板的也可在宝塔面板安全页面开启配置，但这里的开启 SSH 密钥登录会添加上 RSAAuthentication 配置项，实际上不需要这个配置项，原因见 3.3而且按照上面的操作开启密码登录和密钥登录，宝塔面板这里也不会显示启动，实际上功能都已经成功开启，两种方式都可连接\n3.3 配置文件中没有 RSAAuthenticationCentOS7.4 相对于之前版本，做了一些与 sshd 相关的安全更新来加强 sshd 的安全性。其中之一就是弃用 RSAAuthentication 支持\n目前 SSH 的通讯协议分为第一代和第二代，第二代有更多功能、选项、和更高的安全性，在 2006 正式由 IETF 发表，至今已有十年。由于两代 SSH 协定并不兼容，所以只能二选其一，CentOS 7 的 SSH 预设使用第二代协定\n在同时支持这两个协议的系统中，可以通过  &#x2F;etc&#x2F;ssh&#x2F;sshd_config 配置文件中的\nProtocol 2\n\n来指定使用哪一个版本。RSAAuthentication （RSA认证）是只支持第 1 代 SSH 通讯协议使用的配置项，在 CentOS7.4 中被废除了，而且 CentOS7 开始预设使用第二代通讯协议，在 CentOS7.4 中没有找到指定协议版本的配置行，应该是 CentOS7.4 全面抛弃第 1 代协议\n第 2 代 SSH 通讯协议的密钥验证选项是\n\n\n\n\n\n\n\n\n\n#PubkeyAuthentication yes\n该配置默认是注释掉的，同时似乎是默认开启的，即使注释也能使用密钥登录。 因此在使用第二代 SSH 通讯协议时不需要再去纠结 RSAAuthentication 选项，在 CentOS7.4 中其强行添加 RSAAuthentication 配置会触发系统对它的废除提示\n\n\n\n\n\n\n\n\n\nreprocess config line 38: Deprecated option RSAAuthentication\n4. JDK4.1 安装1、首先下载 JDK 安装包，官网下载路径：https://www.oracle.com/java/technologies/downloads/2、下载后上传到服务器3、解压文件，tar -zxvf jdk-8u341-linux-x64.tar.gz4、配置环境变量，找到 /etc/profile 文件添加如下环境变量\n#set java environment\nexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk&#x2F;jdk1.8.0_341\nexport JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk&#x2F;jdk1.8.0_341&#x2F;jre\nexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib:$JRE_HOME&#x2F;lib:$CLASSPATH\nexport PATH&#x3D;$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$JAVA_HOME:$PATH\n\n5、生效环境配置 source /etc/profile6、查看 JDK 版本，输入 java -version，如下提示则表示安装成功\n4.2 卸载1、查看安装路径，which java2、删除该路径下的文件夹\n# rm -rf JDK路径\nrm -rf &#x2F;usr&#x2F;jdk&#x2F;jdk1.8.0_172&#x2F;\n\n3、删除环境配置4、生效环境配置 source /etc/profile\n5. MySQL5.1 安装1、去官网下载：https://downloads.mysql.com/archives/community/，选择 MySQL 版本，操作系统，操作系统版本。CentOS 为 Red Hat 的社区发行版，可以选择该操作系统，同时选择对应的 CentOS 版本，或者也可选择 Linux Generic 通用版这里选择通用版本进行下载，下载 tar.xz 压缩包文件，或者也可下载没有压缩的 tar 包文件（选择 Red Hat 版本的下载 tar.gz 文件）2、将文件上传到服务器上3、进行解压，进入压缩包所在目录，执行 tar  -Jxvf  mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz（如果下载的是 Red Hat 的 tar.gz 文件执行 tar -zxvf mysql-8.0.19-el7-x86_64.tar.gz）4、卸载 MariaDB在 CentOS中 默认安装有 MariaDB，是 MySQL 的一个分支，主要由开源社区维护。CentOS 7及以上版本已经不再使用 MySQL 数据库，而是使用 MariaDB 数据库。安装 MySQL 的话可以先卸载 MariaDB 数据库\n先查看版本，rpm -qa|grep mariadb，然后执行 rpm -e --nodeps 文件名 进行卸载5、创建 mysql 用户组和 mysql 用户先检查是否有 mysql 用户组和 mysql 用户，groups mysql，没有再添加，有就跳过这一步没有的话再创建 mysql 用户组并创建 mysql 用户添加到用户组， groupadd mysql &amp;&amp; useradd -r -g mysql mysql6、mysql 的自启动脚本会优先检索 /etc 目录下 my.cnf 的配置文件，创建该配置文件，配置如下：\n[client]\n# MySQL 客户端连接服务器端时使用的端口号，默认为 3306\nport &#x3D; 3306\n# 套接字文件所在目录\nsocket &#x3D; &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;run&#x2F;mysql.sock\n\n[mysqldump]\n# 支持较大的数据库转储，导出非常巨大的表时需要此项 。\nquick\n# 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小（当与大的BLOB字段一起工作时相当必要），每个连接独立的大小，大小动态增加\nmax_allowed_packet &#x3D; 16M\n# 以上参数会被 MySQL 客户端应用读取\n\n[mysqld]\n# mysqld 程序在启动后将在给定 UNIX&#x2F;Linux 账户下执行。mysqld 必须从 root 账户启动才能在启动后切换到另一个账户下执行。mysqld_safe 脚本将默认使用 user&#x3D;mysql 选项来启动 mysqld 程序\nuser &#x3D; mysql\n# 服务端口号，默认为 3306\nport &#x3D; 3306\n# socket 文件所在目录\nsocket &#x3D; &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;run&#x2F;mysql.sock\n# MySQL 服务的唯一编号，每个 MySQL 服务的 id 需唯一\nserver-id &#x3D; 1\n# 进程 id 存放文件\npid_file &#x3D; &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;run&#x2F;mysql.pid\n# 指定 MySQL 安装的绝对路径\nbasedir &#x3D; &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64\n# 指定 MySQL 数据存放的绝对路径\ndatadir &#x3D; &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;data\n\n# 数据库默认字符集，主流字符集支持一些特殊表情符号（特殊表情符占用 4 个字节）\ncharacter-set-server &#x3D; utf8mb4\n# 数据库字符集对应一些排序等规则，要和 character-set-server 对应\ncollation-server &#x3D; utf8mb4_general_ci\n# 设置 client 连接 mysql 时的字符集，防止乱码\ninit_connect &#x3D; &#39;SET NAMES utf8mb4&#39;\n# 是否对 sql 语句大小写敏感，1 表示不敏感\nlower_case_table_names &#x3D; 1\n\n# 用于指定索引缓冲区的大小\nkey_buffer_size &#x3D; 64M\n# 仅仅允许使用键值的 UPDATES 和 DELETES\n#no-auto-rehash\n# 表示 SQL 模式的参数，通过这个参数可以设置检验 SQL 语句的严格程度\n#sql_mode&#x3D;TRADITIONAL\n\n# 日志文件位置\nlog-error &#x3D; &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;log&#x2F;mysql_error.log\n\n7、根据配置文件，创建对应的 log、run、data 等文件夹，mkdir data log run8、赋予权限，chown -R mysql:mysql ./9、初始化 mysql\nbin&#x2F;mysqld --initialize --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64 --datadir&#x3D;&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;data\n\n\ndefaults-file：指定配置文件（要放在–initialize 前面）\nuser： 指定用户\nbasedir：指定安装目录\ndatadir：指定初始化数据目录\nintialize-insecure：初始化无密码\n\n控制台没有输出，可以去日志文件里查看临时密码10、添加 mysqld 服务到系统\ncp -a &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld\n\n11、启动服务，service mysqld start12、查看是否启动服务，ps -ef | grep mysql13、查看 mysql 运行状态，service mysqld status\n5.2 使用1、登录\n&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql-8.0.19-linux-glibc2.12-x86_64&#x2F;bin&#x2F;mysql -u root -p\n\n会提示输入初始化的时候生成的临时密码2、修改密码\nalter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;新密码&#39;;\n\n3、远程连接进入 mysql 数据库，use mysql，修改 user 表，host 默认值都是 localhost，需要修改 root 用户的 host 值为 %，update user set host=&#39;%&#39; where user =&#39;root&#39;;，刷新权限，flush privileges;开放对应的端口使用 Navicat 进行连接，成功4、退出，quit\n6. Nginx6.1 安装1、GCC 安装，安装 Nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装先通过 gcc --version 查看有无 gcc没有的话再通过 yum install gcc-c++ 进行安装2、PCRE 安装，PCRE(Perl Compatible Regular Expressions) 是一个 Perl 库，包括 perl 兼容的正则表达式库。Nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 Linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。Nginx 也需要此库可以先通过 rpm -qa pcre 查看有无 PCRE没有的话可以通过 yum install -y pcre pcre-devel 来安装3、Zlib 安装，zlib 库提供了很多种压缩和解压缩的方式， Nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要安装 zlib 库可以通过 yum list installed | grep zlib 查看是否安装了 Zlib没有的话通过 yum install -y zlib zlib-devel 进行安装4、OpenSSL 安装，OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。Nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要安装 OpenSSL 库先通过 rpm -qa pcre 查看是否安装了 OpenSSL没有的话通过 yum install -y openssl openssl-devel 进行安装5、去官网下载 Nginx，https://nginx.org/en/download.html6、上传到服务器上7、解压到当前目录，tar -zxvf nginx-1.22.0.tar.gz8、进入解压后的目录，运行 ./configure --with-http_stub_status_module --with-http_ssl_module 配置环境，默认安装路径在 /usr/local/nginx，这里安装了 ssl 模块用于部署证书假如要指定安装路径，可以通过 -prefix 设置安装路径，./configure --prefix=/usr/java/nginx --with-http_stub_status_module --with-http_ssl_module9、再执行 make  &amp;&amp;  make install 编译并安装环境10、进入安装目录的 sbin 目录下，启动 Nginx 服务，./nginx11、查看是否开启了服务，netstat -ntlp | grep nginx12、在浏览器输入服务器地址，看见如下界面即表示成功\n6.2 使用相关指令，先到 Nginx 安装目录的 sbin 目录下\n\n启动服务：./nginx\n停止服务，此方式停止步骤是待 Nginx 进程处理任务完毕进行停止。./nginx -s stop\n退出服务，此方式相当于先查出 Nginx 进程 id 再使用 kill 命令强制杀掉进程。./nginx -s quit\n重新加载，当 Nginx 的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload不用先停止 nginx再启动 nginx 即可将配置信息在 nginx 中生效。./nginx -s reload\n查询 nginx 进程：ps aux|grep nginx\n\n项目部署相关配置见 8\n6.3 查看有无安装总结\nrpm 包安装的，可以用 rpm -qa 看到，如果要查找某软件包是否安装，用 rpm -qa | grep “软件或者包的名字”\n以 deb 包安装的，可以用 dpkg -l 看到。如果是查找指定软件包，用 dpkg -l | grep “软件或者包的名字”\nyum 方法安装的，可以用 yum list installed 查找，如果是查找指定包，用 yum list installed | grep “软件名或者包名”\n\n7. Redis见另一篇博客： 服务器安装Redis和配置后台远程连接\n8. 前端与后端项目部署见另一篇博客：轻量应用服务器部署 SpringBoot 前后端分离项目\n","slug":"BlogRepository/服务器/轻量应用服务器使用总结","date":"2022-08-14T18:33:49.000Z","categories_index":"服务器","tags_index":"服务器","author_index":"凡"},{"id":"3dca1d49253087e654c27123d044ed56","title":"Java 数据结构总结","content":"1. 链表链表（LinkedList） 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据\n链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n)\n使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点\n1.1 单向链表单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把**第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)**，通过头结点我们可以遍历整个链表。尾结点通常指向 null\n1.1.1 定义节点类 Node节点类：\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Node&lt;T&gt; &#123;\n    T val;  &#x2F;&#x2F; 节点值\n    public Node next; &#x2F;&#x2F; 指向后续节点\n    Node(T val) &#123;\n        this.val &#x3D; val;\n    &#125;\n&#125;\n\n1.1.2 直接对节点类操作1. 生成链表\npublic static void main(String[] args) &#123;\n        Node head &#x3D; new Node();\n        Node node1 &#x3D; new Node&lt;&gt;(&quot;王五&quot;);\n        Node node2 &#x3D; new Node&lt;&gt;(1);\n\n        Node node3 &#x3D; new Node&lt;&gt;(&quot;李四&quot;);\n        Node node4 &#x3D; new Node&lt;&gt;(2);\n\n        head.next &#x3D; node1;\n        node1.next &#x3D; node2;\n        node2.next &#x3D; node3;\n        node3.next &#x3D; node4;\n&#125;\n\n2. 遍历链表\nqueryAll(head);\n\npublic static void queryAll(Node node)&#123;\n        Node currentNode &#x3D; node;\n        while (currentNode.next !&#x3D; null)&#123;\n            currentNode &#x3D; currentNode.next;\n            System.out.println(currentNode.val);\n        &#125;\n&#125;\n\n3. 直接添加\nNode addNode &#x3D; new Node(&quot;赵六&quot;);\nhead &#x3D; add(head, addNode);\n\npublic static Node add(Node head, Node addNode)&#123;\n        Node currentNode &#x3D; head;\n\n\t\t&#x2F;&#x2F; 找到链表的最后一个节点\n        while (currentNode.next !&#x3D; null)&#123;\n            currentNode  &#x3D; currentNode.next;\n        &#125;\n        &#x2F;&#x2F; 让该节点的后一个节点为添加的节点，即将该节点添加到链表\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;\n\n4. 添加到指定位置\nNode addIndexNode &#x3D; new Node(&quot;11&quot;);\nhead &#x3D; add(head, addIndexNode, 2);\n\npublic static Node add(Node head, Node addNode, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n\t\t&#x2F;&#x2F; 找到指定位置的上一个节点\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n\n\t\t&#x2F;&#x2F; 让添加节点的下一个节点为该节点的下一个节点\n        addNode.next &#x3D; currentNode.next;\n        &#x2F;&#x2F; 再让该节点的下一个节点为添加节点，即在指定位置插入一个节点\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;\n\n5. 删除指定位置的元素\nhead &#x3D; delete(head, 4);\n\npublic static Node delete(Node head, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n\t\t&#x2F;&#x2F; 找到指定位置的上一个节点\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw  new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 该节点的下一个节点就是要删除的节点\n        Node delNode &#x3D; currentNode.next;\n        &#x2F;&#x2F; 让该节点的下一个节点为删除节点的下一个节点，指定位置的节点就被删除了\n        currentNode.next &#x3D; delNode.next;\n        return head;\n&#125;\n\n完整示例如下：\npublic static void main(String[] args) throws Exception &#123;\n        Node head &#x3D; new Node();\n        Node node1 &#x3D; new Node&lt;&gt;(&quot;王五&quot;);\n        Node node2 &#x3D; new Node&lt;&gt;(1);\n\n        Node node3 &#x3D; new Node&lt;&gt;(&quot;李四&quot;);\n        Node node4 &#x3D; new Node&lt;&gt;(2);\n\n        head.next &#x3D; node1;\n        node1.next &#x3D; node2;\n        node2.next &#x3D; node3;\n        node3.next &#x3D; node4;\n\n        Node addNode &#x3D; new Node(&quot;赵六&quot;);\n        head &#x3D; add(head, addNode);\n\n        Node addIndexNode &#x3D; new Node(&quot;11&quot;);\n        head &#x3D; add(head, addIndexNode, 2);\n\n        head &#x3D; delete(head, 4);\n        queryAll(head);\n&#125;\n\npublic static Node delete(Node head, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw  new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n        Node delNode &#x3D; currentNode.next;\n        currentNode.next &#x3D; delNode.next;\n        return head;\n&#125;\n\npublic static Node add(Node head, Node addNode, int index) throws Exception &#123;\n        Node currentNode &#x3D; head;\n\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next !&#x3D; null ? currentNode.next : null;\n            if (currentNode &#x3D;&#x3D; null) &#123;\n                throw new Exception(&quot;位置不存在&quot;);\n            &#125;\n        &#125;\n\n        addNode.next &#x3D; currentNode.next;\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;\n\npublic static Node add(Node head, Node addNode) &#123;\n        Node currentNode &#x3D; head;\n\n        while (currentNode.next !&#x3D; null) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        currentNode.next &#x3D; addNode;\n        return head;\n&#125;\n\npublic static void queryAll(Node node) &#123;\n        Node currentNode &#x3D; node;\n        while (currentNode.next !&#x3D; null) &#123;\n            currentNode &#x3D; currentNode.next;\n            System.out.println(currentNode.val);\n        &#125;\n&#125;\n\n1.1.3 封装节点操作类定义一个类，封装对节点进行操作的方法。实现 Iterable 接口，用来遍历\npublic class LinkNode&lt;T&gt; implements Iterable&lt;T&gt;&#123;\n    private Node headNode; &#x2F;&#x2F; 头结点，链表的 headNode 是不可以动的\n    private int length; &#x2F;&#x2F; 结点个数\n\n    public LinkNode()&#123;\n        headNode &#x3D; new Node();\n        length &#x3D; 0;\n    &#125;\n\n\t&#x2F;&#x2F; 清空\n    public void clear()&#123;\n        headNode.next &#x3D; null; &#x2F;&#x2F; 头节点 next 为 null 就是空链表\n        headNode.val &#x3D; null;\n        length &#x3D; 0;\n    &#125;\n\n\t&#x2F;&#x2F; 是否非空\n    public boolean isEmpty()&#123;\n        return length &#x3D;&#x3D; 0;\n    &#125;\n\n\t&#x2F;&#x2F; 获取长度\n    public int length()&#123;\n        return length;\n    &#125;\n\n    &#x2F;&#x2F; 读取链表第 i 位置的元素值并返回\n    public T get(int index)&#123;\n        if (index &lt; 0 || index &gt; length)&#123;\n            System.out.println(&quot;不存在该位置&quot;);\n        &#125;\n\n        &#x2F;&#x2F; 头指针不可以移动，不然就无法再找到链表\n        &#x2F;&#x2F; 定义一个临时的Node也指向头指针，通过该指针来进行操作\n        Node&lt;T&gt; currentNode &#x3D; headNode;\n        for (int i &#x3D; 0; i &lt; index; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        return currentNode.val;\n    &#125;\n\n    &#x2F;&#x2F; 插入到链表末尾\n    public void insert(T val)&#123;\n        Node&lt;T&gt; addNode &#x3D; new Node&lt;&gt;(val);\n\n        Node currentNode &#x3D; headNode;\n\n        &#x2F;&#x2F; 找到最后一个节点\n        while (currentNode.next !&#x3D; null)&#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        currentNode.next &#x3D; addNode;\n        length++;\n    &#125;\n\n    &#x2F;&#x2F; 插入到 i 位置\n    public void insert(T val, int index)&#123;\n        if (index &lt; 0 || index &gt; length)&#123;\n            System.out.println(&quot;不存在该位置&quot;);\n        &#125;\n\n        Node currentNode &#x3D; headNode;\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        Node&lt;T&gt; addNode &#x3D; new Node&lt;&gt;(val);\n        addNode.next &#x3D; currentNode.next;\n        currentNode.next &#x3D; addNode;\n        length++;\n    &#125;\n\n    &#x2F;&#x2F; 移除并返回 i 位置的元素值\n    public T remove(int index)&#123;\n        if (index &lt; 0 || index &gt; length)&#123;\n            System.out.println(&quot;不存在该位置&quot;);\n        &#125;\n\n        Node currentNode &#x3D; headNode;\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        &#x2F;&#x2F; 要删除的节点\n        Node&lt;T&gt; delCurrent &#x3D; currentNode.next;\n\n        currentNode.next &#x3D; delCurrent.next;\n        length --;\n        return delCurrent.val;\n    &#125;\n\n    &#x2F;&#x2F; 查找元素在链表中第一次出现的位置，索引值\n    public int indexOf(T value)&#123;\n        Node currentNode &#x3D; headNode;\n\n        for (int i &#x3D; 0; currentNode.next !&#x3D; null; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n            if (currentNode.val.equals(value))&#123;\n                return i;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n    @Override\n    public Iterator&lt;T&gt; iterator() &#123;\n        return new Iterator&lt;T&gt;() &#123;\n            Node currentNode &#x3D; headNode;\n\n            @Override\n            public boolean hasNext() &#123;\n                return currentNode.next !&#x3D; null;\n            &#125;\n\n            @Override\n            public T next() &#123;\n                currentNode &#x3D; currentNode.next;\n                return (T) currentNode.val;\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n测试类：\npublic static void main(String[] args) &#123;\n        LinkNode linkNode &#x3D; new LinkNode&lt;&gt;();\n&#x2F;&#x2F;        LinkNode&lt;String&gt; linkNode &#x3D; new LinkNode&lt;&gt;(); &#x2F;&#x2F; 限制泛型\n\n        linkNode.insert(&quot;张三11&quot;);\n        linkNode.insert(22);\n        linkNode.insert(&quot;王五33&quot;);\n\n        for (Object o : linkNode) &#123;\n            System.out.print(o + &quot; &quot;);\n        &#125;\n\n        System.out.println();\n\n        linkNode.insert(&quot;赵六&quot;, 2);\n        for (Object o : linkNode) &#123;\n            System.out.print(o + &quot; &quot;);\n        &#125;\n        System.out.println();\n\n        System.out.println(&quot;删除的元素：&quot; + linkNode.remove(3));\n        for (Object o : linkNode) &#123;\n            System.out.print(o + &quot; &quot;);\n        &#125;\n        System.out.println();\n\n        System.out.println(linkNode.indexOf(&quot;赵六&quot;));\n&#125;\n\n\n1.2 双向链表包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点\n1.2.1 定义节点类@AllArgsConstructor\n@NoArgsConstructor\npublic class DoubleNode&lt;T&gt; &#123;\n    T val;\n    DoubleNode prev;\n    DoubleNode next;\n\n    public DoubleNode(T val) &#123;\n        this.val &#x3D; val;\n    &#125;\n&#125;\n\n1.2.2 封装节点操作类public class DoubleLinkNode&lt;T&gt; &#123;\n    private DoubleNode head;\n    private DoubleNode last;\n    private int length;\n\n    public DoubleLinkNode()&#123;\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 遍历\n    public void queryAll()&#123;\n        DoubleNode currentNode &#x3D; head;\n\n        while (currentNode !&#x3D; null)&#123;\n            System.out.print(currentNode.val + &quot; &quot;);\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 获取长度\n    public int getLength()&#123;\n        return length;\n    &#125;\n\n    &#x2F;&#x2F; 头插法\n    public void addFirst(T val)&#123;\n        &#x2F;&#x2F; 插入的节点\n        DoubleNode addNode &#x3D; new DoubleNode(val);\n\n        &#x2F;&#x2F; 加入链表为空，则插入的节点就是头节点和尾结点\n        if (head &#x3D;&#x3D; null)&#123;\n            head &#x3D; addNode;\n            last &#x3D; addNode;\n            length ++;\n        &#125; else &#123;\n            &#x2F;&#x2F; 让添加节点的下一个节点为头结点\n            addNode.next &#x3D; head;\n            &#x2F;&#x2F; 再让头结点的上一个为添加节点\n            head.prev &#x3D; addNode;\n            &#x2F;&#x2F; 再把头节点设为添加节点\n            head &#x3D; addNode;\n            length ++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 尾插法\n    public void addLast(T val)&#123;\n        DoubleNode addNode &#x3D; new DoubleNode(val);\n\n        if (head &#x3D;&#x3D; null)&#123;\n            head &#x3D; addNode;\n            last &#x3D; addNode;\n            length ++;\n        &#125; else &#123;\n            &#x2F;&#x2F; 让尾结点的下一个节点为添加节点\n            last.next &#x3D; addNode;\n            &#x2F;&#x2F; 再让添加节点的上一个为尾结点\n            addNode.prev &#x3D; last;\n            &#x2F;&#x2F; 再把尾结点设为添加节点\n            last &#x3D; addNode;\n            length ++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 在任意位置插入\n    public void addIndex(T val, int index) throws Exception &#123;\n        &#x2F;&#x2F; 假如添加位置为头结点位置，就是头插法\n        if (index &lt;&#x3D; 0)&#123;\n            addFirst(val);\n            return;\n        &#125;\n        &#x2F;&#x2F; 假如添加位置为尾结点的位置，就是尾插法\n        if (index &gt; length)&#123;\n            addLast(val);\n            return;\n        &#125;\n\n        DoubleNode addNode &#x3D; new DoubleNode(val);\n        DoubleNode currentNode &#x3D; head;\n        &#x2F;&#x2F; 找到指定位置的节点\n        for (int i &#x3D; 0; i &lt; index - 1; i++) &#123;\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        &#x2F;&#x2F; 让添加节点的下一个节点为指定位置的节点\n        addNode.next &#x3D; currentNode;\n        &#x2F;&#x2F; 让指定位置节点的上一个节点的下一个节点为添加节点，即在指定位置插入添加节点\n        currentNode.prev.next &#x3D; addNode;\n        &#x2F;&#x2F; 再让添加节点的上一个节点为指定位置节点的上一个节点\n        addNode.prev &#x3D; currentNode.prev;\n        &#x2F;&#x2F; 再让指定位置的上一个节点为添加节点\n        currentNode.prev &#x3D; addNode;\n        length ++;\n    &#125;\n&#125;\n\n测试类：\npublic class DoubleLinkNodeTest &#123;\n    public static void main(String[] args) throws Exception &#123;\n        DoubleLinkNode&lt;Object&gt; doubleLinkNode &#x3D; new DoubleLinkNode&lt;&gt;();\n        doubleLinkNode.addFirst(&quot;张三&quot;); &#x2F;&#x2F; 张三\n        doubleLinkNode.addFirst(1); &#x2F;&#x2F; 1 张三\n        doubleLinkNode.queryAll();\n\n        doubleLinkNode.addLast(&quot;李四&quot;); &#x2F;&#x2F; 1 张三 李四\n        doubleLinkNode.queryAll();\n\n        doubleLinkNode.addIndex(&quot;王五&quot;, 3); &#x2F;&#x2F; 1 张三 王五 李四\n\n        doubleLinkNode.queryAll();\n        System.out.println(&quot;长度：&quot; + doubleLinkNode.getLength());\n    &#125;\n&#125;\n\n\n1.3 循环列表与双向循环列表只需把单链表与双向链表的尾结点的下一个节点指向头结点即可\n1.4 应用场景与数组比较1.4.1 应用场景\n如果需要支持随机访问的话，链表没办法做到\n如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适\n如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适\n\n1.4.2 与数组比较\n数组支持随机访问，而链表不支持\n数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反\n数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的\n\n2. 栈栈 (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 后进先出（LIFO, Last In First Out） 的原理运作。在栈中，push 和 pop 的操作都发生在栈顶\n栈常用一维数组或链表来实现，用数组实现的栈叫作 数组栈（顺序栈），用链表实现的栈叫作 链式栈。其时间复杂度为：\n\n访问：O（n）最坏情况\n插入删除：O（1）顶端插入和删除元素\n\n2.1 数组栈public class MyStack&lt;T&gt; &#123;\n    private T[] storage; &#x2F;&#x2F; 存放栈中元素的数组\n    private int capacity; &#x2F;&#x2F; 栈的容量\n    private int count; &#x2F;&#x2F; 栈中元素数量\n    private static final int GROW_FACTOR &#x3D; 2; &#x2F;&#x2F; 扩容倍数\n\n    &#x2F;&#x2F; 无参构造方法。默认容量为 8\n    public MyStack()&#123;\n        capacity &#x3D; 8;\n        storage &#x3D; (T[]) new Object[8];\n        count &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 带初始容量的构造方法\n    public MyStack(int initialCapacity)&#123;\n        if (initialCapacity &lt; 1) &#123;\n            throw new IllegalArgumentException(&quot;Capacity too small.&quot;);\n        &#125;\n        capacity &#x3D; initialCapacity;\n        storage &#x3D; (T[]) new Object[initialCapacity];\n        count &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 入栈\n    public void push(T val)&#123;\n        if (count &#x3D;&#x3D; capacity)&#123;\n            expansion();\n        &#125;\n        storage[count++] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 扩容，使用 Arrays.copyOf() 复制原数组并扩容\n    public void expansion()&#123;\n        int newCapacity &#x3D; capacity * GROW_FACTOR;\n        storage &#x3D; Arrays.copyOf(storage, newCapacity);\n        capacity &#x3D; newCapacity;\n    &#125;\n\n    &#x2F;&#x2F; 返回栈顶元素并出栈\n    public T pop()&#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            throw new IllegalArgumentException(&quot;Stack is empty.&quot;);\n        &#125;\n        return storage[--count];\n    &#125;\n\n    &#x2F;&#x2F; 返回栈顶元素不出栈\n    public T peek()&#123;\n        if (count &#x3D;&#x3D; 0)&#123;\n            throw new IllegalArgumentException(&quot;Stack is empty.&quot;);\n        &#125; else &#123;\n            return storage[count - 1];\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 判断栈是否为空\n    public boolean isEmpty()&#123;\n        return count &#x3D;&#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 返回栈中元素的个数\n    public int size()&#123;\n        return count;\n    &#125;\n&#125;\n\n测试类：\npublic static void main(String[] args) &#123;\n        MyStack myStack &#x3D; new MyStack(3);\n        myStack.push(1);\n        myStack.push(&quot;张三&quot;);\n        myStack.push(2);\n        myStack.push(&quot;李四&quot;);\n\n        System.out.println(myStack.peek()); &#x2F;&#x2F; 李四\n        System.out.println(myStack.isEmpty()); &#x2F;&#x2F; false\n        System.out.println(myStack.size()); &#x2F;&#x2F; 4\n        for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n            System.out.println(myStack.pop());\n        &#125;\n&#125;\n\n\n2.2 链栈与链表实现类似，入栈即使用头插法插入，出栈即把头结点指向下一个节点定义节点类：\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Node&lt;T&gt; &#123;\n    T val;  &#x2F;&#x2F; 节点值\n    public Node next; &#x2F;&#x2F; 指向后续节点\n\n    Node(T val) &#123;\n        this.val &#x3D; val;\n    &#125;\n&#125;\n\n操作类：\npublic class LinkStack&lt;T&gt; &#123;\n    private Node head;\n    private int length;\n\n    public LinkStack()&#123;\n        head &#x3D; new Node();\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 清空\n    public void clear()&#123;\n        head.next &#x3D; null;\n        head.val &#x3D; null;\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 入栈，头插法\n    public void push(T val)&#123;\n        Node addNode &#x3D; new Node&lt;&gt;(val);\n        if (head.val &#x3D;&#x3D; null)&#123;\n            head &#x3D; addNode;\n        &#125; else &#123;\n            addNode.next &#x3D; head;\n            head &#x3D; addNode;\n        &#125;\n        length ++;\n    &#125;\n\n    &#x2F;&#x2F; 出栈，将头结点指向下一个，并返回值\n    public T pop()&#123;\n        T val &#x3D; (T) head.val;\n        head &#x3D; head.next;\n        length --;\n        return val;\n    &#125;\n\n    public int getLength()&#123;\n        return length;\n    &#125;\n\n    public T peek()&#123;\n        return (T) head.val;\n    &#125;\n\n    public void queryAll()&#123;\n        Node currentNode &#x3D; head;\n\n        while (currentNode !&#x3D; null)&#123;\n            System.out.println(currentNode.val);\n            currentNode &#x3D; currentNode.next;\n        &#125;\n    &#125;\n&#125;\n\n测试类：\npublic static void main(String[] args) &#123;\n        LinkStack&lt;Object&gt; linkStack &#x3D; new LinkStack&lt;&gt;();\n        linkStack.push(&quot;张三&quot;);\n        linkStack.push(1);\n        linkStack.push(2);\n\n        linkStack.pop();\n        System.out.println(&quot;栈顶元素：&quot; + linkStack.peek());\n        System.out.println(&quot;链表长度：&quot; + linkStack.getLength());\n        linkStack.queryAll();\n&#125;\n\n\n2.3 应用场景当要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，就可以使用栈这个数据结构\n2.3.1 实现浏览器的回退和前进功能只需要使用两个栈(Stack1 和 Stack2)就能实现这个功能。比如按顺序查看了 1,2,3,4 这四个页面，依次把 1,2,3,4 这四个页面压入 Stack1 中。当想回头看 2 这个页面的时候，点击回退按钮，依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如又想回到页面 3，你点击前进按钮，将 3 页面从 Stack2 弹出，然后压入到 Stack1 中\n2.3.2 检查符号是否成对出现\n\n\n\n\n\n\n\n\n给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断该字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。比如 “()”、”()[]{}”、”{[]}” 都是有效字符串，而 “(]” 、”([)]” 则不是。\n首先将括号间的对应规则存放在 Map 中。然后将字符串转为数组进行遍历，假如是左符号，就直接压入栈中；右符号则将栈顶元素出栈进行比较。因为栈是后入先出，刚好可以与成对符号进行匹配。判断左右符号则由 Map 的 Key,Value 进行判断，Key 为右符号，Value 为左符号\npublic boolean isValid(String s)&#123;\n    &#x2F;&#x2F; 括号之间的对应规则\n    HashMap&lt;Character, Character&gt; mappings &#x3D; new HashMap&lt;Character, Character&gt;();\n    mappings.put(&#39;)&#39;, &#39;(&#39;);\n    mappings.put(&#39;&#125;&#39;, &#39;&#123;&#39;);\n    mappings.put(&#39;]&#39;, &#39;[&#39;);\n    Stack&lt;Character&gt; stack &#x3D; new Stack&lt;Character&gt;();\n    char[] chars &#x3D; s.toCharArray();\n    for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n        if (mappings.containsKey(chars[i])) &#123;\n            char topElement &#x3D; stack.empty() ? &#39;#&#39; : stack.pop();\n            if (topElement !&#x3D; mappings.get(chars[i])) &#123;\n                return false;\n            &#125;\n        &#125; else &#123;\n            stack.push(chars[i]);\n        &#125;\n    &#125;\n    return stack.isEmpty();\n&#125;\n\n2.3.3 反转字符串先压栈再出栈即可\n2.3.4 维护函数调用最后一个被调用的函数必须先完成执行，符合栈的 后进先出（LIFO, Last In First Out） 特性\n3. 队列队列 是 先进先出( FIFO，First In, First Out) 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 。队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue\n队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加\n3.1 单队列单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 顺序队列（数组实现） 和 链式队列（链表实现）\n顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况上图是一个顺序队列，将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 ”假溢出“ 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）\n为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列\n3.1.1 数组单队列只能使用一次\npublic class ArrayQueue&lt;T&gt; &#123;\n    private T[] storage; &#x2F;&#x2F; 存放队列元素的数组\n    private int front; &#x2F;&#x2F; 队列头\n    private int rear; &#x2F;&#x2F; 队列尾\n    private int maxsize; &#x2F;&#x2F; 队列最大容量\n\n    &#x2F;&#x2F; 无参构造，默认大小为8\n    public ArrayQueue()&#123;\n        storage &#x3D; (T[]) new Object[8];\n        front &#x3D; -1;\n        rear &#x3D; -1;\n        maxsize &#x3D; 8;\n    &#125;\n\n    &#x2F;&#x2F; 带初始大小的构造方法\n    public ArrayQueue(int size)&#123;\n        storage &#x3D; (T[]) new Object[size];\n        front &#x3D; -1;\n        rear &#x3D; -1;\n        maxsize &#x3D; size;\n    &#125;\n\n    &#x2F;&#x2F; 判断是否队列已满\n    public boolean isFull()&#123;\n        return rear &#x3D;&#x3D; maxsize - 1;\n    &#125;\n\n    &#x2F;&#x2F; 判断队列是否为空\n    public boolean isEmpty()&#123;\n        return front &#x3D;&#x3D; rear;\n    &#125;\n\n    &#x2F;&#x2F; 入队\n    public void enqueue(T val)&#123;\n        if (isFull())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列已满&quot;);\n        &#125;\n        storage[++rear] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 遍历队列\n    public void queryQueue()&#123;\n        if (isEmpty())&#123;\n            System.out.println(&quot;队列为空&quot;);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; storage.length; i++) &#123;\n            if (storage[i] !&#x3D; null)&#123;\n                System.out.print(storage[i] + &quot; &quot;);\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 出队\n    public T dequeue()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        T result &#x3D; storage[++front];\n        storage[front] &#x3D; null;\n        return result;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列头元素\n    public T peek()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        return storage[front + 1];\n    &#125;\n&#125;\n\n测试类：\npublic class Demo&#123;\n    public static void main(String[] args) &#123;\n        ArrayQueue&lt;Object&gt; arrayQueue &#x3D; new ArrayQueue&lt;&gt;();\n        arrayQueue.enqueue(1); &#x2F;&#x2F; 1\n        arrayQueue.enqueue(&quot;张三&quot;); &#x2F;&#x2F; 张三 1\n        arrayQueue.enqueue(2); &#x2F;&#x2F; 2 张三 1\n        arrayQueue.enqueue(&quot;李四&quot;); &#x2F;&#x2F; 李四 2 张三 1\n\n        System.out.println(&quot;队列是否已满：&quot; + arrayQueue.isFull()); &#x2F;&#x2F; false\n\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;获取队头元素不出队：&quot; + arrayQueue.peek());\n\n        arrayQueue.queryQueue();\n\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;出队元素：&quot; + arrayQueue.dequeue());\n        System.out.println(&quot;队列是否为空：&quot; + arrayQueue.isEmpty());\n    &#125;\n&#125;\n\n\n3.1.2 链式单队列\n插入元素时：每次直接插到末尾即可（尾插法），新插入的元素即为新的尾结点（区别于栈的头插法）\n取出元素时：返回首结点指向的下一个元素即可。（先进先出），此时和弹栈一样\n\n队列为尾插头取，栈为头插头取\npublic class LinkQueue&lt;T&gt; &#123;\n    private Node head;\n    private Node last;\n    private int length;\n\n    public LinkQueue() &#123;\n        length &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 判断队列是否为空\n    public boolean isEmpty() &#123;\n        return length &#x3D;&#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F; 入队\n    public void enqueue(T val) &#123;\n        Node node &#x3D; new Node(val);\n\n        if (isEmpty()) &#123;\n            head &#x3D; node;\n            last &#x3D; node;\n        &#125; else &#123;\n            last.next &#x3D; node;\n        &#125;\n        last &#x3D; node;\n        length++;\n    &#125;\n\n    &#x2F;&#x2F; 遍历队列\n    public void queryQueue() &#123;\n        Node currentNode &#x3D; head;\n        while (currentNode !&#x3D; null) &#123;\n            System.out.print(currentNode.val + &quot; &quot;);\n            currentNode &#x3D; currentNode.next;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 出队\n    public T dequeue() &#123;\n        if (isEmpty()) &#123;\n            return null;\n        &#125;\n        T val &#x3D; (T) head.val;\n        head &#x3D; head.next;\n        length--;\n        return val;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列长度\n    public int getLength() &#123;\n        return length;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列头元素\n    public T getHead() &#123;\n        if (isEmpty()) &#123;\n            return null;\n        &#125;\n        return (T) head.val;\n    &#125;\n\n    &#x2F;&#x2F; 获取队列尾元素\n    public T getLast() &#123;\n        if (isEmpty()) &#123;\n            return null;\n        &#125;\n        return (T) last.val;\n    &#125;\n&#125;\n\n测试类：\npublic class Demo05&#123;\n    public static void main(String[] args) &#123;\n        LinkQueue&lt;Object&gt; linkQueue &#x3D; new LinkQueue&lt;&gt;();\n        linkQueue.enqueue(1); &#x2F;&#x2F; 1\n        linkQueue.enqueue(&quot;张三&quot;); &#x2F;&#x2F; 张三 1\n        linkQueue.enqueue(2); &#x2F;&#x2F; 2 张三 1\n        linkQueue.enqueue(&quot;李四&quot;); &#x2F;&#x2F; 李四 2 张三 1\n\n        System.out.println(&quot;出队元素：&quot; + linkQueue.dequeue()); &#x2F;&#x2F; 1\n        System.out.println(&quot;队头元素：&quot; + linkQueue.getHead()); &#x2F;&#x2F; 张三\n        System.out.println(&quot;队尾元素：&quot; + linkQueue.getLast()); &#x2F;&#x2F; 李四\n        System.out.println(&quot;出队元素：&quot; + linkQueue.dequeue()); &#x2F;&#x2F; 张三\n\n        linkQueue.queryQueue();\n        System.out.println(&quot;队列长度：&quot; + linkQueue.getLength()); &#x2F;&#x2F; 2\n    &#125;\n&#125;\n\n\n3.2 循环队列循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当再向队列中添加元素的时候， rear 向后移动顺序队列中，front &#x3D;&#x3D; rear 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：\n\n可以设置一个标志变量 flag，当 front == rear 并且 flag&#x3D;0 的时候队列为空，当 front == rear 并且 flag&#x3D;1 的时候队列为满\n队列为空的时候就是 front == rear ，队列满的时候，保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： (rear+1) % QueueSize= front\n\n3.2.1 数组循环队列\nfront 变量的含义做一个调整：front 指向队列的第一个元素,也就是说 arr[front] 就是队列的第一个元素，front 的初始值&#x3D;0\nrear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置，因为希望空出一个位置来进行判断，rear 的初始值&#x3D;0\n当队列满时，条件是 (rear +1) % maxSize = front【满】\n对队列为空的条件，rear == front 空\n队列中有效的数据的个数 （rear + maxSize -front) % maxSize\n\npublic class CircularQueue&lt;T&gt; &#123;\n    private T[] storage; &#x2F;&#x2F; 存放队列元素的数组\n    private int front; &#x2F;&#x2F; 队列头\n    private int rear; &#x2F;&#x2F; 队列尾\n    private int maxsize; &#x2F;&#x2F; 队列最大容量\n\n    &#x2F;&#x2F; 无参构造，默认大小为8\n    public CircularQueue()&#123;\n        storage &#x3D; (T[]) new Object[8];\n        maxsize &#x3D; 8;\n        &#x2F;&#x2F; front &#x3D; 0; 指向第一个元素,默认是0可以不写\n        &#x2F;&#x2F; rear &#x3D; 0;  指向最后一个元素的下一位，默认是0可以不写\n    &#125;\n\n    &#x2F;&#x2F; 带初始大小的构造方法\n    public CircularQueue(int size)&#123;\n        storage &#x3D; (T[]) new Object[size];\n        maxsize &#x3D; size;\n        &#x2F;&#x2F; front &#x3D; 0; 指向第一个元素,默认是0可以不写\n        &#x2F;&#x2F; rear &#x3D; 0;  指向最后一个元素的下一位，默认是0可以不写\n    &#125;\n\n    &#x2F;&#x2F; 判断是否队列已满\n    public boolean isFull()&#123;\n        return (rear + 1) % maxsize &#x3D;&#x3D; front;\n    &#125;\n\n    &#x2F;&#x2F; 判断队列是否为空\n    public boolean isEmpty()&#123;\n        return front &#x3D;&#x3D; rear;\n    &#125;\n\n    &#x2F;&#x2F; 入队\n    public void enqueue(T val)&#123;\n        if (isFull())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列已满&quot;);\n        &#125;\n        storage[rear] &#x3D; val;\n        rear &#x3D; (rear + 1) % maxsize;\n    &#125;\n\n    &#x2F;&#x2F; 求出当前有效数据\n    public int getEffectiveSize()&#123;\n        return (rear + maxsize - front) % maxsize;\n    &#125;\n\n    &#x2F;&#x2F;遍历\n    public void queryQueue() &#123;\n        if (isEmpty()) &#123;\n            System.out.println(&quot;队列为空&quot;);\n            return;\n        &#125;\n        for (int i &#x3D; front; i &lt; front + getEffectiveSize(); i++) &#123;\n            System.out.print(storage[i % maxsize] + &quot; &quot;);\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 出队\n    public T dequeue()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        T val &#x3D; storage[front];\n        storage[front] &#x3D; null;\n        front &#x3D; (front + 1) % maxsize;\n        return val;\n    &#125;\n\n    &#x2F;&#x2F; 取队首元素\n    public T getFront()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        return storage[front];\n    &#125;\n\n    &#x2F;&#x2F; 取队尾元素\n    public T getRear()&#123;\n        if (isEmpty())&#123;\n            throw new ArrayIndexOutOfBoundsException(&quot;队列为空&quot;);\n        &#125;\n        return storage[(rear - 1 + maxsize) % maxsize];\n    &#125;\n&#125;\n\n测试类：\npublic class Demo&#123;\n    public static void main(String[] args) &#123;\n        CircularQueue&lt;Object&gt; circularQueue &#x3D; new CircularQueue&lt;&gt;(4);\n\n        circularQueue.enqueue(1); &#x2F;&#x2F; 1\n        circularQueue.enqueue(&quot;张三&quot;); &#x2F;&#x2F; 张三 1\n        circularQueue.enqueue(&quot;李四&quot;); &#x2F;&#x2F; 李四 张三 1\n\n        System.out.println(&quot;出队元素：&quot; + circularQueue.dequeue());\n        System.out.println(&quot;队头元素：&quot; + circularQueue.getFront());\n        System.out.println(&quot;出队元素：&quot; + circularQueue.dequeue());\n        circularQueue.queryQueue();\n\n        circularQueue.enqueue(&quot;王五&quot;); &#x2F;&#x2F; 王五 李四\n        circularQueue.enqueue(&quot;赵六&quot;); &#x2F;&#x2F; 赵六 王五 李四\n        circularQueue.queryQueue();\n\n        System.out.println(&quot;队尾元素：&quot; + circularQueue.getRear());\n    &#125;\n&#125;\n\n\n3.2.2 链式循环队列在链式单队列的基础上，让尾结点的 next 指向头结点即可\n3.3 常见应用场景\n阻塞队列： 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现 “生产者 - 消费者“ 模型\n线程池中的请求 &#x2F; 任务队列： 当线程池中没有空闲线程时，新的任务请求线程资源时，将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列（基于链表）和有界队列（基于数组）。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：FixedThreadPool 使用无界队列 LinkedBlockingQueue。但是有界队列就不一样了，当队列满的话后面再有任务&#x2F;请求就会拒绝，在 Java 中的体现就是会抛出 java.util.concurrent.RejectedExecutionException 异常\nLinux 内核进程队列（按优先级排队）\n播放器上的播放列表\n消息队列\n等等……\n\n4. 树树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。一棵树具有以下特点：\n\n一棵树中的任意两个结点有且仅有唯一的一条路径连通\n一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边\n一棵树不包含回路\n\n树中的常用概念：\n\n节点 ：树中的每个元素都可以统称为节点。\n根节点 ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。\n父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。\n子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。\n兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。\n叶子节点 ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。\n节点的高度 ：该节点到叶子节点的最长路径所包含的边数。\n节点的深度 ：根节点到该节点的路径所包含的边数\n节点的层数 ：节点的深度+1。\n树的高度 ：根节点的高度\n\n4.1 二叉树的分类\n二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构\n二叉树 的分支通常被称作 “左子树” 或 “右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒\n二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^(k+1) - 1 个节点（满二叉树的情况），至少有 2^(k) 个节点\n\n4.1.1 满二叉树一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 K，且结点总数是 (2^k) -1 ，则它就是 满二叉树。如下图所示：\n4.1.2 完全二叉树除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 完全二叉树 。\n即一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：完全二叉树有一个很好的性质：父结点和子节点的序号有着对应关系\n当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点\n4.1.3 二叉排序树一棵空树，或者是具有下列性质的二叉树：\n\n若左子树不空，则左子树上所有结点的值均小于它的根结点的值\n若右子树不空，则右子树上所有结点的值均大于它的根结点的值\n左、右子树也分别为二叉排序树\n\n1. 查找 Find\n\n查找的值 x 从根节点开始\n如果 x 小于根节点的值,则在左子树中继续查找\n如果 x 大于根节点的值,则在右子树中继续查找\n如果x等于根节点的值则返回该节点\n查不到就返回 null\n\n查找的效率决定于树的高度，最大元素在树的最右支的节点，最小元素在树的最左支的节点上2. 插入 Insert\n\n插入的值从根节点开始查找\n如果 x 小于根节点的值,则在左子树中继续查找\n如果 x 大于根节点的值,则在右子树中继续查找\n如果该节点是叶节点，x 小于该节点值则插入左子节点，否则插入右节点\n\n3. 删除 delete，删除节点分为3类\n\n无儿子节点的节点,也就是叶子结点（删除节点分为左叶子节点和右叶子节点）找到要删除的节点及其父节点，然后判断删除节点是父节点的左节点还是右节点，再将对应的删除节点置为 null\n只有一个儿子的节点（删除节点分为只有一个左子节点或只有一个右子节点，同时删除节点也分为左节点和右节点）找到要删除的节点及其父节点，判断删除节点拥有左子节点还是右子节点，再判断删除节点是父节点的左节点还是右节点，再将父亲节点链接删除节点的子节点，相当于删除要删除的节点\n有两个儿子的节点（应考虑用哪个节点替换该节点的位置,并保证新的树也是个二叉排序树）找到删除节点，再找到其右子树的最小值，即删除节点的右子节点的最左子节点，其为替换节点，同时找到替换节点的父节点，然后将删除节点与替换节点进行替换，再删掉替换节点，即置为 null。假如没有最左子节点，删除节点的右子节点就是替换节点\n\n定义树节点：\n@Data\npublic class TreeNode &#123;\n    public Integer data;\n    public TreeNode leftChild;\n    public TreeNode rightChild;\n\n    public TreeNode(Integer data) &#123;\n        this.data &#x3D; data;\n    &#125;\n&#125;\n\n二叉排序树操作类：\npublic class BinarySortedTree &#123;\n\n    public TreeNode root;\n\n    &#x2F;&#x2F; 非递归构建二叉排序树\n    public void insert(int val) &#123;\n        TreeNode addTreeNode &#x3D; new TreeNode(val);\n\n        if (root &#x3D;&#x3D; null) &#123;\n            root &#x3D; addTreeNode;\n        &#125; else &#123;\n            TreeNode currentTreeNode &#x3D; root;\n            TreeNode parentTreeNode;\n\n            while (true) &#123;\n                parentTreeNode &#x3D; currentTreeNode;\n\n                if (addTreeNode.data &gt; currentTreeNode.data) &#123;\n                    currentTreeNode &#x3D; currentTreeNode.rightChild;\n\n                    if (currentTreeNode &#x3D;&#x3D; null) &#123;\n                        parentTreeNode.rightChild &#x3D; addTreeNode;\n                        return;\n                    &#125;\n                &#125; else &#123;\n                    currentTreeNode &#x3D; currentTreeNode.leftChild;\n\n                    if (currentTreeNode &#x3D;&#x3D; null) &#123;\n                        parentTreeNode.leftChild &#x3D; addTreeNode;\n                        return;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 递归构建二叉排序树\n    public TreeNode insert(TreeNode treeNode, int val) &#123;\n        TreeNode addTreeNode &#x3D; new TreeNode(val);\n\n        if (root &#x3D;&#x3D; null) &#123;\n            return root &#x3D; addTreeNode;\n        &#125;\n\n        if (val &gt; treeNode.data) &#123;\n            if (treeNode.rightChild &#x3D;&#x3D; null) &#123;\n                treeNode.rightChild &#x3D; addTreeNode;\n                return root;\n            &#125;\n            return insert(treeNode.rightChild, val);\n        &#125; else &#123;\n            if (treeNode.leftChild &#x3D;&#x3D; null) &#123;\n                treeNode.leftChild &#x3D; addTreeNode;\n                return root;\n            &#125;\n            return insert(treeNode.leftChild, val);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 先序遍历二叉排序树\n    public void preOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        System.out.print(treeNode.data + &quot; &quot;);\n        preOrder(treeNode.leftChild);\n        preOrder(treeNode.rightChild);\n    &#125;\n\n    &#x2F;&#x2F; 中序遍历二叉排序树\n    public void inOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        inOrder(treeNode.leftChild);\n        System.out.print(treeNode.data + &quot; &quot;);\n        inOrder(treeNode.rightChild);\n    &#125;\n\n    &#x2F;&#x2F; 后序遍历二叉排序树\n    public void postOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        postOrder(treeNode.leftChild);\n        postOrder(treeNode.rightChild);\n        System.out.print(treeNode.data + &quot; &quot;);\n    &#125;\n\n    &#x2F;&#x2F; 层序遍历二叉排序树\n    public void levelOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        LinkedList&lt;TreeNode&gt; linkedList &#x3D; new LinkedList&lt;&gt;();\n        linkedList.offer(treeNode);\n        TreeNode currentTreeNode;\n\n        while (!linkedList.isEmpty()) &#123;\n            currentTreeNode &#x3D; linkedList.poll();\n            System.out.print(currentTreeNode.data + &quot; &quot;);\n\n            if (currentTreeNode.leftChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.leftChild);\n            &#125;\n            if (currentTreeNode.rightChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.rightChild);\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;\n\n    &#x2F;&#x2F; 查找元素是否在二叉排序树中，如果在返回该节点，否则返回null\n    public TreeNode find(int val) &#123;\n        TreeNode currentTreeNode &#x3D; root;\n\n        while (currentTreeNode !&#x3D; null) &#123;\n            if (currentTreeNode.data &#x3D;&#x3D; val) &#123;\n                return currentTreeNode;\n            &#125; else if (currentTreeNode.data &gt; val) &#123;\n                currentTreeNode &#x3D; currentTreeNode.leftChild;\n            &#125; else &#123;\n                currentTreeNode &#x3D; currentTreeNode.rightChild;\n            &#125;\n        &#125;\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 查找二叉排序树中最小值\n    public int findMin() &#123;\n        TreeNode deleteTreeNode &#x3D; root;\n\n        while (deleteTreeNode.leftChild !&#x3D; null) &#123;\n            deleteTreeNode &#x3D; deleteTreeNode.leftChild;\n        &#125;\n        return deleteTreeNode.data;\n    &#125;\n\n    &#x2F;&#x2F; 删除节点\n    public void delete(int val) &#123;\n        TreeNode deleteTreeNode &#x3D; root;\n        TreeNode parentTreeNode &#x3D; root;\n\n        &#x2F;&#x2F; 找到要删除的节点\n        while (deleteTreeNode.data !&#x3D; val) &#123;\n            parentTreeNode &#x3D; deleteTreeNode;\n\n            if (deleteTreeNode.data &gt; val) &#123;\n                deleteTreeNode &#x3D; deleteTreeNode.leftChild;\n            &#125; else &#123;\n                deleteTreeNode &#x3D; deleteTreeNode.rightChild;\n            &#125;\n            if (deleteTreeNode &#x3D;&#x3D; null) &#123;\n                break;\n            &#125;\n        &#125;\n\n        if (deleteTreeNode !&#x3D; null) &#123;\n            if (deleteTreeNode.leftChild &#x3D;&#x3D; null &amp;&amp; deleteTreeNode.rightChild &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 叶子节点\n                if (deleteTreeNode &#x3D;&#x3D; root) &#123;\n                    root &#x3D; null;\n                &#125; else if (parentTreeNode.leftChild &#x3D;&#x3D; deleteTreeNode) &#123; &#x2F;&#x2F; 左子节点\n                    parentTreeNode.leftChild &#x3D; null;\n                &#125; else &#123; &#x2F;&#x2F; 右子节点\n                    parentTreeNode.rightChild &#x3D; null;\n                &#125;\n            &#125; else if (deleteTreeNode.leftChild &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 只有一个右子节点\n                if (deleteTreeNode &#x3D;&#x3D; root) &#123;\n                    root &#x3D; deleteTreeNode.rightChild;\n                &#125; else if (parentTreeNode.leftChild &#x3D;&#x3D; deleteTreeNode) &#123; &#x2F;&#x2F; 左子节点\n                    parentTreeNode.leftChild &#x3D; deleteTreeNode.rightChild;\n                &#125; else &#123; &#x2F;&#x2F; 右子节点\n                    parentTreeNode.rightChild &#x3D; deleteTreeNode.rightChild;\n                &#125;\n            &#125; else if (deleteTreeNode.rightChild &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 只有一个左子节点\n                if (deleteTreeNode &#x3D;&#x3D; root) &#123;\n                    root &#x3D; deleteTreeNode.leftChild;\n                &#125; else if (parentTreeNode.leftChild &#x3D;&#x3D; deleteTreeNode) &#123; &#x2F;&#x2F; 左子节点\n                    parentTreeNode.leftChild &#x3D; deleteTreeNode.leftChild;\n                &#125; else &#123; &#x2F;&#x2F; 右子节点\n                    parentTreeNode.rightChild &#x3D; deleteTreeNode.leftChild;\n                &#125;\n            &#125; else &#123; &#x2F;&#x2F; 有两个子节点\n                &#x2F;&#x2F; 先定义一个 替换节点 保存要删除节点的右子树的最小值\n                TreeNode replaceTreeNode &#x3D; deleteTreeNode.rightChild;\n                &#x2F;&#x2F; 定义一个 替换节点的父节点 保存要删除节点的右子树的最小值的父节点\n                TreeNode replaceParentTreeNode &#x3D; deleteTreeNode;\n\n                &#x2F;&#x2F; 找到删除节点的右节点的最左子节点，即右子树的最小值\n                while (replaceTreeNode.leftChild !&#x3D; null) &#123;\n                    &#x2F;&#x2F; 将其赋值给 替换节点的父节点\n                    replaceParentTreeNode &#x3D; replaceTreeNode;\n                    &#x2F;&#x2F; 将其 左节点 赋值给替换节点\n                    replaceTreeNode &#x3D; replaceTreeNode.leftChild;\n                &#125;\n                &#x2F;&#x2F; 将替换节点的值赋值给要删除节点\n                deleteTreeNode.data &#x3D; replaceTreeNode.data;\n                &#x2F;&#x2F; 如果替换节点的父节点的左节点是替换节点，则将替换节点的右节点赋值给替换节点的父节点的左节点\n                &#x2F;&#x2F; 即有最左子节点的情况\n                if (replaceParentTreeNode.leftChild &#x3D;&#x3D; replaceTreeNode) &#123;\n                    replaceParentTreeNode.leftChild &#x3D; replaceTreeNode.rightChild;\n                &#125; else &#123;\n                    &#x2F;&#x2F; 如果替换节点的父节点的右节点是替换节点，则将替换节点的右节点赋值给替换节点的父节点的右节点\n                    &#x2F;&#x2F; 即没有左子节点的情况，删除节点的右子节点就是替换节点，同时其并没有左子节点，所以使用替换节点的右节点\n                    replaceParentTreeNode.rightChild &#x3D; replaceTreeNode.rightChild;\n                &#125;\n            &#125;\n        &#125; else &#123;\n            System.out.println(&quot;要删除的节点不存在！&quot;);\n        &#125;\n    &#125;\n&#125;\n\n测试类：\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        BinarySortedTree binarySortedTree &#x3D; new BinarySortedTree();\n\n        &#x2F;&#x2F; binarySortedTree.insert(binarySortedTree.root, 1);\n        binarySortedTree.insert(5);\n        binarySortedTree.insert(7);\n        binarySortedTree.insert(2);\n        binarySortedTree.insert(1);\n        binarySortedTree.insert(3);\n        binarySortedTree.insert(4);\n        binarySortedTree.insert(6);\n        binarySortedTree.insert(12);\n        binarySortedTree.insert(10);\n        binarySortedTree.insert(9);\n        binarySortedTree.insert(11);\n        binarySortedTree.insert(13);\n\n        System.out.print(&quot;先序遍历：&quot;);\n        binarySortedTree.preOrder(binarySortedTree.root); &#x2F;&#x2F; 5 2 4 8\n        System.out.println();\n        System.out.print(&quot;中序遍历：&quot;);\n        binarySortedTree.inOrder(binarySortedTree.root); &#x2F;&#x2F; 2 4 5 8\n        System.out.println();\n        System.out.print(&quot;后序遍历：&quot;);\n        binarySortedTree.postOrder(binarySortedTree.root); &#x2F;&#x2F; 1 4 2 6 9 8 5\n        System.out.println();\n        System.out.print(&quot;层次遍历：&quot;);\n        binarySortedTree.levelOrder(binarySortedTree.root); &#x2F;&#x2F; 5 2 8 1 4 6 9\n\n        System.out.println(&quot;查找值【3】对应的节点：&quot; + binarySortedTree.find(3));\n\n        binarySortedTree.delete(7);\n        System.out.print(&quot;删除值【7】后的二叉排序树：&quot;);\n        binarySortedTree.levelOrder(binarySortedTree.root);\n    &#125;\n&#125;\n\n\n4.1.4 平衡二叉树平衡二叉树 是一棵二叉排序树，且具有以下性质：\n\n可以是一棵空树\n如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树（左右高度差小于等于 1）\n\n平衡二叉树的常用实现方法有：红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等\n如下这棵树已经退化为一个链表了，管它叫 斜树二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得在树中对数据进行搜索和修改时，相对于链表更加快捷便利\n但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，希望每个父结点分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：\n4.2 二叉树的存储二叉树的存储主要分为 链式存储 和 顺序存储 两种\n4.2.1 顺序存储顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置\n一棵完全二叉树的数组顺序存储如下图所示：如果存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低简单实现\npublic class ArrayTree &#123;\n    private int[] storage;\n\n    public ArrayTree()&#123;\n        storage &#x3D; new int[8];\n    &#125;\n\n    public ArrayTree(int length)&#123;\n        storage &#x3D; new int[length];\n    &#125;\n\n    &#x2F;&#x2F; 添加根节点\n    public void addRoot(int val)&#123;\n        storage[1] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 添加左子节点\n    public void addLeft(int index, int val)&#123;\n        if(index &gt; storage.length || index &lt; 0)&#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n\n        storage[2 * index] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 添加右子节点\n    public void addRight(int index, int val)&#123;\n        storage[ 2 * index + 1] &#x3D; val;\n    &#125;\n\n    &#x2F;&#x2F; 获取一个节点的父节点\n    public int getParent(int index)&#123;\n        if(index &gt; storage.length || index &lt; 0)&#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return storage[index &#x2F; 2];\n    &#125;\n\n    &#x2F;&#x2F; 遍历\n    public void query()&#123;\n        for(int i &#x3D; 1; i &lt; storage.length; i++)&#123;\n            System.out.print(storage[i] + &quot; &quot;);\n        &#125;\n        System.out.println();\n    &#125;\n&#125;\n\n测试类：\npublic class Demo05 &#123;\n    public static void main(String[] args) &#123;\n        ArrayTree arrayTree &#x3D; new ArrayTree(10);\n        arrayTree.addRoot(1);\n        arrayTree.addLeft(1, 2);\n        arrayTree.addRight(1, 3);\n\n        arrayTree.addLeft(2, 4);\n        arrayTree.addLeft(4, 5);\n        arrayTree.query();\n\n        System.out.println(arrayTree.getParent(8));\n    &#125;\n&#125;\n\n\n4.2.2 链式存储和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。每个节点包括三个属性：\n\n数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据\n左节点指针 left\n右节点指针 right\n\n\n4.3 二叉树的遍历4.3.1 先序遍历二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，可以递归实现先序遍历\npublic void preOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n\n        System.out.print(treeNode.data + &quot; &quot;);\n        preOrder(treeNode.leftChild);\n        preOrder(treeNode.rightChild);\n    &#125;\n\n4.3.2 中序遍历二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：\npublic void inOrder(TreeNode root)&#123;\n\tif(root &#x3D;&#x3D; null)&#123;\n\t\treturn;\n\t&#125;\n\tinOrder(root.left);\n\tsystem.out.println(root.data);\n\tinOrder(root.right);\n&#125;\n\n4.3.3 后序遍历二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值\npublic void postOrder(TreeNode root)&#123;\n\tif(root &#x3D;&#x3D; null)&#123;\n\t\treturn;\n\t&#125;\n\tpostOrder(root.left);\n\tpostOrder(root.right);\n\tsystem.out.println(root.data);\n&#125;\n\n4.3.4 层次遍历即一层一层往下遍历。使用链表，先将根节点加到链表中，然后再将根节点的左节点和右节点加入到链表中，这里定义一个 Current 节点，用来将左右节点加入到链表里以及遍历链表，这里用 poll 方式来给 Current 节点赋值\npublic void levelOrder(TreeNode treeNode) &#123;\n        if (treeNode &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        LinkedList&lt;TreeNode&gt; linkedList &#x3D; new LinkedList&lt;&gt;();\n        linkedList.offer(treeNode);\n        TreeNode currentTreeNode;\n\n        while (!linkedList.isEmpty()) &#123;\n            currentTreeNode &#x3D; linkedList.poll();\n            System.out.print(currentTreeNode.data + &quot; &quot;);\n\n            if (currentTreeNode.leftChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.leftChild);\n            &#125;\n            if (currentTreeNode.rightChild !&#x3D; null) &#123;\n                linkedList.offer(currentTreeNode.rightChild);\n            &#125;\n        &#125;\n        System.out.println();\n    &#125;\n\n\n4.4 哈夫曼树（最优⼆叉树）4.4.1 概述\n路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。如下图中，从根结点到结点 a 之间的通路就是一条路径\n路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。下图中从根结点到结点 c 的路径长度为 3\n结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，下图 中结点 a 的权为 7，结点 b 的权为 5\n结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，下图中结点 b 的带权路径长度为 2 * 5 &#x3D; 10\n树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如下图中所示的这颗树的带权路径长度为：WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3\n\n当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为 “最优二叉树”，有时也叫 “赫夫曼树” 或者 “哈夫曼树”\n在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在上图中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。\n构建方法：\n\n在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和\n在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推\n重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树\n\n4.4.2 实现定义节点类：\npublic class TreeNode&lt;T&gt; &#123;\n    public T data;\n    public int weight;\n    public TreeNode&lt;T&gt; leftChild;\n    public TreeNode&lt;T&gt; rightChild;\n\n    public TreeNode(T data, int weight) &#123;\n        this.data &#x3D; data;\n        this.weight &#x3D; weight;\n    &#125;\n\n    public String toString()&#123;\n        return data + &quot; &quot; + weight;\n    &#125;\n&#125;\n\n哈夫曼树构建：\npublic class HuffmanTree &#123;\n    &#x2F;&#x2F; 构建Huffman树\n    public &lt;T&gt; TreeNode&lt;T&gt; buildHuffmanTree(List&lt;TreeNode&gt; treeNodes) &#123;\n        while (treeNodes.size() &gt; 1)&#123;\n            sortTreeNode(treeNodes);\n\n            &#x2F;&#x2F; 左边比右边小\n            TreeNode left &#x3D; treeNodes.get(0);\n            TreeNode right &#x3D; treeNodes.get(1);\n\n            &#x2F;&#x2F; 生成一个新的节点,父结点权重为两个子结点之和\n            TreeNode parent &#x3D; new TreeNode(null, left.weight + right.weight);\n\n            &#x2F;&#x2F; 让子结点与父结点连接\n            parent.leftChild &#x3D; left;\n            parent.rightChild &#x3D; right;\n\n            &#x2F;&#x2F; 删除最小的\n            treeNodes.remove(0);\n            &#x2F;&#x2F; 删除第二小的\n            treeNodes.remove(0);\n            &#x2F;&#x2F; 把新的父结点加入到 list 中\n            treeNodes.add(parent);\n        &#125;\n        &#x2F;&#x2F; 返回哈夫曼树的根节点\n        return treeNodes.get(0);\n    &#125;\n\n    &#x2F;&#x2F; 对节点进行排序，从小到大\n    public void sortTreeNode(List&lt;TreeNode&gt; treeNodes) &#123;\n        for (int i &#x3D; 0; i &lt; treeNodes.size(); i++)&#123;\n            for (int j &#x3D; 0; j &lt; treeNodes.size() - 1 - i; j++)&#123;\n                if (treeNodes.get(j).weight &gt; treeNodes.get(j + 1).weight) &#123;\n                    TreeNode temp &#x3D; treeNodes.get(j + 1);\n                    treeNodes.set(j+1,treeNodes.get(j));\n                    treeNodes.set(j,temp);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 打印哈夫曼树\n    public void printTree(TreeNode root) &#123;\n        System.out.println(&quot;Node-&quot; + root.toString());\n        if(root.leftChild !&#x3D; null)&#123;\n            System.out.print(&quot;left:&quot;);\n            printTree(root.leftChild);\n        &#125;\n        if(root.rightChild !&#x3D;null)&#123;\n            System.out.print(&quot;right:&quot;);\n            printTree(root.rightChild);\n        &#125;\n    &#125;\n&#125;\n\n测试类：\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        HuffmanTree huffmanTree &#x3D; new HuffmanTree();\n\n        List&lt;TreeNode&gt; treeNodes &#x3D; new ArrayList&lt;TreeNode&gt;();\n        &#x2F;&#x2F;把节点加入至list中\n        treeNodes.add(new TreeNode(&quot;张三&quot;, 10));\n        treeNodes.add(new TreeNode(1, 15));\n        treeNodes.add(new TreeNode(&quot;李四&quot;, 12));\n        treeNodes.add(new TreeNode(2, 3));\n        treeNodes.add(new TreeNode(&quot;王五&quot;, 4));\n        treeNodes.add(new TreeNode(3, 13));\n        treeNodes.add(new TreeNode(&quot;赵六&quot;, 1));\n\n        &#x2F;&#x2F; 进行哈夫曼树的构造\n        TreeNode root &#x3D; huffmanTree.buildHuffmanTree(treeNodes);\n        &#x2F;&#x2F; 打印哈夫曼树\n        huffmanTree.printTree(root);\n    &#125;\n&#125;\n\n\n4.5 AVL 树4.5.1 概述AVL 树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1），一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡。不管是插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此 AVL 树适合用于插入与删除次数比较少，但查找多的情况\n由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。如果应用场景中对插入删除不频繁，只是对查找要求较高，那么 AVL 还是较优于红黑树（AVL 树查找比红黑树快）\n二叉平衡树的调整：调整原则根据插入的节点和失衡节点的位置上关系来划分\n\nLL旋转，让失衡节点的左子节点成为新节点，让新节点的右子节点成为失衡节点的左子节点，再让失衡节点成为新节点的右子节点\nRR旋转，让失衡节点的右子节点成为新节点，让新节点的左子节点成为失衡节点的右子节点，再让失衡节点成为新节点的左子节点\nLR旋转，对失衡节点的左子树做一次RR旋转，再对失衡节点做一次LL旋转\nRL旋转\n\n4.5.2 实现节点类\npublic class AVLTreeNode &#123;\n    Integer data; &#x2F;&#x2F; 数据\n    AVLTreeNode leftChild; &#x2F;&#x2F; 左子节点\n    AVLTreeNode rightChild; &#x2F;&#x2F; 右子节点\n    int height; &#x2F;&#x2F; 记录该节点所在的高度\n\n    public AVLTreeNode(int data) &#123;\n        this.data &#x3D; data;\n    &#125;\n&#125;\n\nAVL树实现类\npublic class AVLTree &#123;\n    public AVLTreeNode root;\n    private int size;\n\n    public AVLTree() &#123;\n        this.root &#x3D; null;\n        this.size &#x3D; 0;\n    &#125;\n\n    public int getSize()&#123;\n        return size;\n    &#125;\n\n    &#x2F;&#x2F; 获取节点的高度，让空节点高度为-1\n    public int getHeight(AVLTreeNode avlTreeNode) &#123;\n        return avlTreeNode &#x3D;&#x3D; null ? -1 : avlTreeNode.height;\n    &#125;\n\n    &#x2F;&#x2F; 先序遍历\n    public void printTree(AVLTreeNode root) &#123;\n        System.out.print(root.data + &quot; &quot;);\n        if(root.leftChild !&#x3D; null)&#123;\n            printTree(root.leftChild);\n        &#125;\n        if(root.rightChild !&#x3D; null)&#123;\n            printTree(root.rightChild);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 插入节点\n    public AVLTreeNode insert(AVLTreeNode avlTreeNode, int val) &#123;\n        if (avlTreeNode &#x3D;&#x3D; null)&#123;\n            avlTreeNode &#x3D; new AVLTreeNode(val);\n            size ++;\n            return avlTreeNode;\n        &#125;\n\n        if (val &lt; avlTreeNode.data) &#123;\n            &#x2F;&#x2F; 如果插入的值小于当前节点的值，则插入到左子树中\n            avlTreeNode.leftChild &#x3D; insert(avlTreeNode.leftChild, val);\n            &#x2F;&#x2F; 如果左子树与右子树的高度差大于1，则需要进行平衡调整，这里使用左子树的高度减右子树的高度，节点为空高度为-1\n            if (getHeight(avlTreeNode.leftChild) - getHeight(avlTreeNode.rightChild) &gt; 1) &#123;\n                &#x2F;&#x2F; 如果插入的值小于当前节点（即失衡节点）的左子节点的值，即插入的节点在失衡节点的左子节点的左边，则进行LL型旋转\n                if (val &lt; avlTreeNode.leftChild.data) &#123;\n                    System.out.println(&quot;LL型旋转&quot;);\n                    avlTreeNode &#x3D; LLRotate(avlTreeNode);\n                &#125; else &#123; &#x2F;&#x2F; 如果插入的值不小于当前节点（即失衡节点）的左子节点的值，即插入的节点在失衡节点的左子节点的右边，则进行LR型旋转\n                    System.out.println(&quot;LR型旋转&quot;);\n                    avlTreeNode &#x3D; LRRotate(avlTreeNode);\n                &#125;\n            &#125;\n        &#125; else &#123; &#x2F;&#x2F; 如果插入的值不小于当前节点的值，则插入到右子树中\n            avlTreeNode.rightChild &#x3D; insert(avlTreeNode.rightChild, val);\n            &#x2F;&#x2F; 平衡调整\n            if (getHeight(avlTreeNode.rightChild) - getHeight(avlTreeNode.leftChild) &gt; 1)&#123;\n                &#x2F;&#x2F; 如果插入的值小于等于当前节点（即失衡节点）的右子节点的值，即插入的节点在失衡节点的右子节点的左边，则进行RL型旋转\n                if (val &lt; avlTreeNode.rightChild.data)&#123;\n                    System.out.println(&quot;RL型旋转&quot;);\n                    avlTreeNode &#x3D; RLRotate(avlTreeNode);\n                &#125; else &#123; &#x2F;&#x2F; 如果插入的值大于当前节点（即失衡节点）的右子节点的值，即插入的节点在失衡节点的右子节点的右边，则进行RR型旋转\n                    System.out.println(&quot;RR型旋转&quot;);\n                    avlTreeNode &#x3D; RRRotate(avlTreeNode);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 更新节点的高度，获取左子树与右子树的最大高度，叶子节点高度为0，再加1即为当前节点的高度\n        avlTreeNode.height &#x3D; Math.max(getHeight(avlTreeNode.leftChild), getHeight(avlTreeNode.rightChild)) + 1;\n        return avlTreeNode;\n    &#125;\n\n    &#x2F;**\n     * LL旋转,30为失衡点（左右子树高度差大于1），对失衡点的左子树，即对结点20进行左旋\n     *           30                        20\n     *          &#x2F;  \\                      &#x2F;  \\\n     *        20  40                   10   30\n     *       &#x2F;  \\      --LL旋转--       &#x2F;   &#x2F;  \\\n     *     10   25                   5   25   40\n     *    &#x2F;\n     *   56\n     *&#x2F;\n    private AVLTreeNode LLRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（30）的左子节点 20 作为新节点\n        AVLTreeNode newRoot &#x3D; avlTreeNode.leftChild;\n        &#x2F;&#x2F; 将新节点（20）的右子节点 25 作为失衡点（30）的左子节点\n        avlTreeNode.leftChild &#x3D; newRoot.rightChild;\n        &#x2F;&#x2F; 失衡点（30）作为新节点（20）的右子节点\n        newRoot.rightChild &#x3D; avlTreeNode;\n        &#x2F;&#x2F; 更新失衡点和新根节点的高度\n        avlTreeNode.height &#x3D; Math.max(getHeight(avlTreeNode.leftChild), getHeight(avlTreeNode.rightChild)) + 1;\n        newRoot.height &#x3D; Math.max(getHeight(newRoot.leftChild), getHeight(newRoot.rightChild)) + 1;\n        &#x2F;&#x2F; 新节点取代原失衡点\n        return newRoot;\n    &#125;\n\n    &#x2F;**\n     * RR旋转,20为失衡点（左右子树高度差大于1），对失衡点的右子树，即对结点30进行左旋\n     *      20                          30\n     *     &#x2F;  \\                        &#x2F;  \\\n     *    10  30                     20   40\n     *       &#x2F;  \\     --RR旋转--     &#x2F;  \\   \\\n     *      25  40                 10  25  50\n     *           \\\n     *           50\n     *&#x2F;\n    private AVLTreeNode RRRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（20）的右子节点 30 作为新节点\n        AVLTreeNode newRoot &#x3D; avlTreeNode.rightChild;\n        &#x2F;&#x2F; 将新节点（30）的左子节点 25 作为失衡点（20）的右子节点\n        avlTreeNode.rightChild &#x3D; newRoot.leftChild;\n        &#x2F;&#x2F; 失衡点（20）作为新节点（30）的左子节点\n        newRoot.leftChild &#x3D; avlTreeNode;\n        &#x2F;&#x2F; 更新失衡点和新根节点的高度\n        avlTreeNode.height &#x3D; Math.max(getHeight(avlTreeNode.leftChild), getHeight(avlTreeNode.rightChild)) + 1;\n        newRoot.height &#x3D; Math.max(getHeight(newRoot.leftChild), getHeight(newRoot.rightChild)) + 1;\n        &#x2F;&#x2F; 新节点取代原失衡点\n        return newRoot;\n    &#125;\n\n    &#x2F;**\n     * LR旋转，先将失衡点（30）的左子树（20）进行 RR 旋转，再将失衡点（30）进行 LL 旋转\n     *           30                         30                    25\n     *          &#x2F;  \\                       &#x2F;  \\                  &#x2F;  \\\n     *        20  40                     25   40                20  30\n     *       &#x2F;  \\      --先RR旋转--      &#x2F;  \\      --再LL旋转--   &#x2F;   &#x2F; \\\n     *     10   25                    20   28                 10  28  40\n     *            \\                  &#x2F;\n     *             28               10\n     *&#x2F;\n    private AVLTreeNode LRRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（30）的左子节点（20）进行 RR 旋转\n        avlTreeNode.leftChild &#x3D; RRRotate(avlTreeNode.leftChild);\n        &#x2F;&#x2F; 将失衡点（30）进行 LL 旋转，并返回新节点代替原失衡点\n        return LLRotate(avlTreeNode);\n    &#125;\n\n    &#x2F;**\n     * RL旋转，先将失衡点（20）的右子树（30）进行 LL 旋转，再将失衡点（20）进行 RR 旋转\n     *      20                          20                       25\n     *     &#x2F;  \\                        &#x2F;  \\                     &#x2F;  \\\n     *    10  30                     10   25                   20  30\n     *       &#x2F;  \\     --LL旋转--             \\    --RR旋转--    &#x2F;   &#x2F; \\\n     *      25  40                          30               10  28  40\n     *       \\                             &#x2F;  \\\n     *       28                           28  40\n     *&#x2F;\n    private AVLTreeNode RLRotate(AVLTreeNode avlTreeNode) &#123;\n        &#x2F;&#x2F; 将失衡点（20）的右子节点（30）进行 LL 旋转\n        avlTreeNode.rightChild &#x3D; LLRotate(avlTreeNode.rightChild);\n        &#x2F;&#x2F; 将失衡点（20）进行 RR 旋转，并返回新节点代替原失衡点\n        return RRRotate(avlTreeNode);\n    &#125;\n&#125;\n\n测试类\npublic class AVLTreeTest &#123;\n    public static void main(String[] args) &#123;\n        AVLTree avlTree &#x3D; new AVLTree();\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 20);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 10);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 30);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 25);\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 40);\n        avlTree.printTree(avlTree.root);\n        System.out.println();\n\n        avlTree.root &#x3D; avlTree.insert(avlTree.root, 28);\n        avlTree.printTree(avlTree.root);\n        System.out.println();\n\n        System.out.println(&quot;树的高度：&quot; + avlTree.getHeight(avlTree.root));\n        System.out.println(&quot;树的节点数：&quot; + avlTree.getSize());\n    &#125;\n&#125;\n\n\n4.6 红黑树4.6.1 概述\n节点非红即黑\n根节点是黑色的\n所有 Null 节点称为叶节点，且颜色为黑色\n所有红色节点的子结点都是黑色，即从每个叶子到根的所有路径上不能有两个连续的红色结点\n从任意节点到其叶节点的所有路径都包含相同数目的黑色节点\n\nAVL 所有节点的左右子树高度差的绝对值不超过1，由于红黑树每个红色节点都必须有两个黑色的子节点，并且从任一节点到叶子节点的所有路径都包含相同数目的黑色节点，则红黑树最差情况下高度比是2：1\n插入原则：假如插入节点的颜色为黑色的话，就破坏了红黑树的性质，所以每次插入的首先都是红节点。如果插入节点的父节点是黑色，能维持性质 。如果插入节点的父节点是红色，破坏了性质，需要通过重新着色或旋转，来维持性质\n\n为根节点根节点为空，则直接插入为根节点，颜色为黑色\n\n插入节点的父结点为黑色直接插入\n\n插入节点的父结点和叔父节点都是红色节点，先插入新节点(红色)，插入节点的父结点、叔父节点和祖父节点都要变色。假如祖父节点为根节点，则变为黑色，否则继续向上更新\n\n插入节点的父结点是红色，同时叔父节点是黑色，同时插入节点是其父结点的左子节点，而父结点是祖父节点的左子节点，这时要进行一次LL旋转调整插入节点和其父节点的角色（以父结点为轴）\n\n\n\n\n\n\n\n\n\n这里由于旋转后根节点是红色所以进行了一次变色，为了满足红黑树的性质，叔父节点也进行一次变色\n\n\n插入节点的父结点是红色，同时叔父节点都是黑色，同时插入节点是其父节点的右子节点，而父结点是祖父节点的右子节点，此时需要对祖父节点进行一次RR旋转(以父结点为轴)，变色情况同 4\n\n插入节点的父节点是红色，同时叔父节点都是黑色，同时插入节点是其父节点的右子节点，而父节点又是其父节点的左子节点（LR旋转）。先进行一次RR旋转调换新节点和其父节点的角色，旋转后发现节点符合情况 4，再进行一次LL旋转。变色情况同 4\n\n插入节点的父结点是红色，同时叔父节点是黑色，同时插入节点是其父节点的左子节点，而父节点是祖父节点的右子节点（RL），先进行一次LL旋转变成情况5，再进行一次RR旋转。变色情况同 4\n\n\n整体构建过程\n4.6.2 实现1、创建节点类\npublic class RBTreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;\n    boolean color; &#x2F;&#x2F; red or black\n    T key; &#x2F;&#x2F; 键\n    RBTreeNode leftChildren; &#x2F;&#x2F; 左子节点\n    RBTreeNode rightChildren; &#x2F;&#x2F; 右子节点\n    RBTreeNode parent; &#x2F;&#x2F; 父节点\n\n    public RBTreeNode(T key, boolean color) &#123;\n        this.key &#x3D; key;\n        this.color &#x3D; color;\n    &#125;\n&#125;\n\n2、实现类（待改善）\npublic class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123;\n    private RBTreeNode&lt;T&gt; mRoot;    &#x2F;&#x2F; 根结点\n\n    private static final boolean RED   &#x3D; false;\n    private static final boolean BLACK &#x3D; true;\n\n    public RBTree() &#123;\n        mRoot&#x3D;null;\n    &#125;\n\n    private boolean isRed(RBTreeNode&lt;T&gt; node) &#123;\n        return ((node!&#x3D;null)&amp;&amp;(node.color&#x3D;&#x3D;RED)) ? true : false;\n    &#125;\n    private boolean isBlack(RBTreeNode&lt;T&gt; node) &#123;\n        return !isRed(node);\n    &#125;\n\n    &#x2F;&#x2F; 前序遍历&quot;红黑树&quot;\n    private void preOrder(RBTreeNode&lt;T&gt; tree) &#123;\n        if(tree !&#x3D; null) &#123;\n            System.out.print(tree.key+&quot;-&quot; + tree.color + &quot; &quot;);\n            preOrder(tree.leftChildren);\n            preOrder(tree.rightChildren);\n        &#125;\n    &#125;\n\n    public void preOrder() &#123;\n        preOrder(mRoot);\n    &#125;\n\n    &#x2F;&#x2F; 中序遍历&quot;红黑树&quot;\n    private void inOrder(RBTreeNode&lt;T&gt; tree) &#123;\n        if(tree !&#x3D; null) &#123;\n            inOrder(tree.leftChildren);\n            System.out.print(tree.key+&quot; &quot;);\n            inOrder(tree.rightChildren);\n        &#125;\n    &#125;\n\n    public void inOrder() &#123;\n        inOrder(mRoot);\n    &#125;\n\n\n    &#x2F;&#x2F; 后序遍历&quot;红黑树&quot;\n    private void postOrder(RBTreeNode&lt;T&gt; tree) &#123;\n        if(tree !&#x3D; null)\n        &#123;\n            postOrder(tree.leftChildren);\n            postOrder(tree.rightChildren);\n            System.out.print(tree.key+&quot; &quot;);\n        &#125;\n    &#125;\n\n    public void postOrder() &#123;\n        postOrder(mRoot);\n    &#125;\n\n\n    &#x2F;&#x2F; (递归实现)查找&quot;红黑树x&quot;中键值为key的节点\n    private RBTreeNode&lt;T&gt; search(RBTreeNode&lt;T&gt; x, T key) &#123;\n        if (x&#x3D;&#x3D;null)\n            return x;\n\n        int cmp &#x3D; key.compareTo(x.key);\n        if (cmp &lt; 0)\n            return search(x.leftChildren, key);\n        else if (cmp &gt; 0)\n            return search(x.rightChildren, key);\n        else\n            return x;\n    &#125;\n\n    public RBTreeNode&lt;T&gt; search(T key) &#123;\n        return search(mRoot, key);\n    &#125;\n\n    &#x2F;&#x2F;  (非递归实现)查找&quot;红黑树x&quot;中键值为key的节点\n    private RBTreeNode&lt;T&gt; iterativeSearch(RBTreeNode&lt;T&gt; x, T key) &#123;\n        while (x!&#x3D;null) &#123;\n            int cmp &#x3D; key.compareTo(x.key);\n\n            if (cmp &lt; 0)\n                x &#x3D; x.leftChildren;\n            else if (cmp &gt; 0)\n                x &#x3D; x.rightChildren;\n            else\n                return x;\n        &#125;\n\n        return x;\n    &#125;\n\n    public RBTreeNode&lt;T&gt; iterativeSearch(T key) &#123;\n        return iterativeSearch(mRoot, key);\n    &#125;\n\n    &#x2F;&#x2F; 查找最小结点：返回tree为根结点的红黑树的最小结点。\n    private RBTreeNode&lt;T&gt; minimum(RBTreeNode&lt;T&gt; tree) &#123;\n        if (tree &#x3D;&#x3D; null)\n            return null;\n\n        while(tree.leftChildren !&#x3D; null)\n            tree &#x3D; tree.leftChildren;\n        return tree;\n    &#125;\n\n    public T minimum() &#123;\n        RBTreeNode&lt;T&gt; p &#x3D; minimum(mRoot);\n        if (p !&#x3D; null)\n            return p.key;\n\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 查找最大结点：返回tree为根结点的红黑树的最大结点。\n    private RBTreeNode&lt;T&gt; maximum(RBTreeNode&lt;T&gt; tree) &#123;\n        if (tree &#x3D;&#x3D; null)\n            return null;\n\n        while(tree.rightChildren !&#x3D; null)\n            tree &#x3D; tree.rightChildren;\n        return tree;\n    &#125;\n\n    public T maximum() &#123;\n        RBTreeNode&lt;T&gt; p &#x3D; maximum(mRoot);\n        if (p !&#x3D; null)\n            return p.key;\n\n        return null;\n    &#125;\n\n    &#x2F;&#x2F; 找结点(x)的后继结点。即，查找&quot;红黑树中数据值大于该结点&quot;的&quot;最小结点&quot;。\n    public RBTreeNode&lt;T&gt; successor(RBTreeNode&lt;T&gt; x) &#123;\n        &#x2F;&#x2F; 如果x存在右孩子，则&quot;x的后继结点&quot;为 &quot;以其右孩子为根的子树的最小结点&quot;。\n        if (x.rightChildren !&#x3D; null)\n            return minimum(x.rightChildren);\n\n        &#x2F;&#x2F; 如果x没有右孩子。则x有以下两种可能：\n        &#x2F;&#x2F; (01) x是&quot;一个左孩子&quot;，则&quot;x的后继结点&quot;为 &quot;它的父结点&quot;。\n        &#x2F;&#x2F; (02) x是&quot;一个右孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有左孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的后继结点&quot;。\n        RBTreeNode&lt;T&gt; y &#x3D; x.parent;\n        while ((y!&#x3D;null) &amp;&amp; (x&#x3D;&#x3D;y.rightChildren)) &#123;\n            x &#x3D; y;\n            y &#x3D; y.parent;\n        &#125;\n\n        return y;\n    &#125;\n\n    &#x2F;&#x2F; 找结点(x)的前驱结点。即，查找&quot;红黑树中数据值小于该结点&quot;的&quot;最大结点&quot;。\n    public RBTreeNode&lt;T&gt; predecessor(RBTreeNode&lt;T&gt; x) &#123;\n        &#x2F;&#x2F; 如果x存在左孩子，则&quot;x的前驱结点&quot;为 &quot;以其左孩子为根的子树的最大结点&quot;。\n        if (x.leftChildren !&#x3D; null)\n            return maximum(x.leftChildren);\n\n        &#x2F;&#x2F; 如果x没有左孩子。则x有以下两种可能：\n        &#x2F;&#x2F; (01) x是&quot;一个右孩子&quot;，则&quot;x的前驱结点&quot;为 &quot;它的父结点&quot;。\n        &#x2F;&#x2F; (01) x是&quot;一个左孩子&quot;，则查找&quot;x的最低的父结点，并且该父结点要具有右孩子&quot;，找到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;。\n        RBTreeNode&lt;T&gt; y &#x3D; x.parent;\n        while ((y!&#x3D;null) &amp;&amp; (x&#x3D;&#x3D;y.leftChildren)) &#123;\n            x &#x3D; y;\n            y &#x3D; y.parent;\n        &#125;\n\n        return y;\n    &#125;\n\n    &#x2F;*\n     * 对红黑树的节点(x)进行左旋转\n     *\n     * 左旋示意图(对节点x进行左旋)：\n     *      px                              px\n     *     &#x2F;                               &#x2F;\n     *    x                               y\n     *   &#x2F;  \\      --(左旋)-.             &#x2F; \\                #\n     *  lx   y                          x  ry\n     *     &#x2F;   \\                       &#x2F;  \\\n     *    ly   ry                     lx  ly\n     *\n     *\n     *&#x2F;\n    private void leftRotate(RBTreeNode&lt;T&gt; rbTreeNode) &#123;\n        &#x2F;&#x2F; 将当前节点的右子节点设为新节点\n        RBTreeNode&lt;T&gt; newRoot &#x3D; rbTreeNode.rightChildren;\n        &#x2F;&#x2F; 将新节点的左子节点设为当前节点的右子节点\n        rbTreeNode.rightChildren &#x3D; newRoot.leftChildren;\n\n        &#x2F;&#x2F; 将 “x的父亲” 设为 “y的父亲”\n        newRoot.parent &#x3D; rbTreeNode.parent;\n\n        if (rbTreeNode.parent &#x3D;&#x3D; null) &#123;\n            this.mRoot &#x3D; newRoot;            &#x2F;&#x2F; 如果 “x的父亲” 是空节点，则将y设为根节点\n        &#125; else &#123;\n            if (rbTreeNode.parent.leftChildren &#x3D;&#x3D; rbTreeNode)\n                rbTreeNode.parent.leftChildren &#x3D; newRoot;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”\n            else\n                rbTreeNode.parent.rightChildren &#x3D; newRoot;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”\n        &#125;\n\n        &#x2F;&#x2F; 将 “x” 设为 “y的左孩子”\n        newRoot.leftChildren &#x3D; rbTreeNode;\n    &#125;\n\n    &#x2F;*\n     * 对红黑树的节点(y)进行右旋转\n     *\n     * 右旋示意图(对节点y进行左旋)：\n     *            py                               py\n     *           &#x2F;                                &#x2F;\n     *          y                                x\n     *         &#x2F;  \\      --(右旋)-.            &#x2F;  \\                     #\n     *        x   ry                           lx   y\n     *       &#x2F; \\                                   &#x2F; \\                   #\n     *      lx  rx                                rx  ry\n     *\n     *&#x2F;\n    private void rightChildrenRotate(RBTreeNode&lt;T&gt; y) &#123;\n        &#x2F;&#x2F; 设置x是当前节点的左孩子。\n        RBTreeNode&lt;T&gt; x &#x3D; y.leftChildren;\n\n        &#x2F;&#x2F; 将 “x的右孩子” 设为 “y的左孩子”；\n        &#x2F;&#x2F; 如果&quot;x的右孩子&quot;不为空的话，将 “y” 设为 “x的右孩子的父亲”\n        y.leftChildren &#x3D; x.rightChildren;\n        if (x.rightChildren !&#x3D; null)\n            x.rightChildren.parent &#x3D; y;\n\n        &#x2F;&#x2F; 将 “y的父亲” 设为 “x的父亲”\n        x.parent &#x3D; y.parent;\n\n        if (y.parent &#x3D;&#x3D; null) &#123;\n            this.mRoot &#x3D; x;            &#x2F;&#x2F; 如果 “y的父亲” 是空节点，则将x设为根节点\n        &#125; else &#123;\n            if (y &#x3D;&#x3D; y.parent.rightChildren)\n                y.parent.rightChildren &#x3D; x;    &#x2F;&#x2F; 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”\n            else\n                y.parent.leftChildren &#x3D; x;    &#x2F;&#x2F; (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”\n        &#125;\n\n        &#x2F;&#x2F; 将 “y” 设为 “x的右孩子”\n        x.rightChildren &#x3D; y;\n\n        &#x2F;&#x2F; 将 “y的父节点” 设为 “x”\n        y.parent &#x3D; x;\n    &#125;\n\n    &#x2F;&#x2F; 插入节点\n    public void insert(T key) &#123;\n        insert(new RBTreeNode&lt;T&gt;(key, BLACK));\n    &#125;\n\n    &#x2F;&#x2F; 插入节点后，修正红黑树\n    private void insert(RBTreeNode&lt;T&gt; node) &#123;\n        int cmp;\n        RBTreeNode&lt;T&gt; y &#x3D; null;\n        RBTreeNode&lt;T&gt; x &#x3D; this.mRoot;\n\n        &#x2F;&#x2F; 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。\n        while (x !&#x3D; null) &#123;\n            y &#x3D; x;\n            cmp &#x3D; node.key.compareTo(x.key); &#x2F;&#x2F;当前key h和插入的key进行比较\n            if (cmp &lt; 0)\n                x &#x3D; x.leftChildren;\n            else\n                x &#x3D; x.rightChildren;\n        &#125;\n\n        node.parent &#x3D; y;\n        if (y!&#x3D;null) &#123;\n            cmp &#x3D; node.key.compareTo(y.key); &#x2F;&#x2F;判断插入到左边还是右边\n            if (cmp &lt; 0)\n                y.leftChildren &#x3D; node;\n            else\n                y.rightChildren &#x3D; node;\n        &#125; else &#123;\n            this.mRoot &#x3D; node;\n        &#125;\n\n        &#x2F;&#x2F; 2. 设置节点的颜色为红色\n        node.color &#x3D; RED;\n\n        &#x2F;&#x2F; 3. 将它重新修正为一颗二叉查找树\n        insertFixUp(node);\n    &#125;\n\n    &#x2F;*\n     * 红黑树插入修正函数\n     *\n     * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；\n     * 目的是将它重新塑造成一颗红黑树。\n     *1.Z是根节点（即Z插入前是一颗空树）\n     * 2.Z的叔节点是红色的\n     * 3.Z的叔节点是黑色的，并且局部呈现三角行（左右三角）\n     * 3.Z的叔节点是黑色的，并且局部呈现直线角行（左右直线）\n     *\n     * 参数说明：\n     *     node 插入的结点\n     *\n     *&#x2F;\n    private void insertFixUp(RBTreeNode&lt;T&gt; addNode) &#123;\n        RBTreeNode&lt;T&gt; parent, gparent;\n\n        &#x2F;&#x2F; 若“父节点存在，并且父节点的颜色是红色”\n        while (((parent &#x3D; addNode.parent)!&#x3D;null) &amp;&amp; isRed(parent)) &#123;\n            gparent &#x3D; parent.parent;\n\n            &#x2F;&#x2F;若“父节点”是“祖父节点的左孩子”\n            if (parent &#x3D;&#x3D; gparent.leftChildren) &#123;\n                &#x2F;&#x2F; Case 1条件：叔叔节点是红色\n                RBTreeNode&lt;T&gt; uncle &#x3D; gparent.rightChildren;\n                if ((uncle!&#x3D;null) &amp;&amp; isRed(uncle)) &#123;\n                    uncle.color &#x3D; BLACK;\n                    parent.color &#x3D; BLACK;\n                    gparent.color &#x3D; RED;\n                    addNode &#x3D; gparent;\n                    continue;\n                &#125;\n\n                &#x2F;&#x2F; Case 2条件：叔叔是黑色，且当前节点是右孩子\n                if (parent.rightChildren &#x3D;&#x3D; addNode) &#123;\n                    RBTreeNode&lt;T&gt; tmp;\n                    leftRotate(parent);\n                    tmp &#x3D; parent;\n                    parent &#x3D; addNode;\n                    addNode &#x3D; tmp;\n                &#125;\n\n                &#x2F;&#x2F; Case 3条件：叔叔是黑色，且当前节点是左孩子。\n                parent.color &#x3D; BLACK;\n                gparent.color &#x3D; RED;\n                rightChildrenRotate(gparent);\n            &#125; else &#123;    &#x2F;&#x2F;若“z的父节点”是“z的祖父节点的右孩子”\n                &#x2F;&#x2F; Case 1条件：叔叔节点是红色\n                RBTreeNode&lt;T&gt; uncle &#x3D; gparent.leftChildren;\n                if ((uncle!&#x3D;null) &amp;&amp; isRed(uncle)) &#123;\n                    uncle.color &#x3D; BLACK;\n                    parent.color &#x3D; BLACK;\n                    gparent.color &#x3D; RED;\n                    addNode &#x3D; gparent;\n                    continue;\n                &#125;\n\n                &#x2F;&#x2F; Case 2条件：叔叔是黑色，且当前节点是左孩子\n                if (parent.leftChildren &#x3D;&#x3D; addNode) &#123;\n                    RBTreeNode&lt;T&gt; tmp;\n                    rightChildrenRotate(parent);\n                    tmp &#x3D; parent;\n                    parent &#x3D; addNode;\n                    addNode &#x3D; tmp;\n                &#125;\n\n                &#x2F;&#x2F; Case 3条件：叔叔是黑色，且当前节点是右孩子。\n                parent.color &#x3D; BLACK;\n                gparent.color &#x3D; RED;\n                leftRotate(gparent);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 将根节点设为黑色\n        mRoot.color &#x3D; BLACK;\n    &#125;\n\n    &#x2F;*\n     * 红黑树删除修正函数\n     *\n     * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；\n     * 目的是将它重新塑造成一颗红黑树。\n     *\n     *\n     *\n     * 参数说明：\n     *     node 待修正的节点\n     *&#x2F;\n    private void removeFixUp(RBTreeNode&lt;T&gt; fixNode, RBTreeNode&lt;T&gt; parent) &#123;\n        RBTreeNode&lt;T&gt; other;\n\n        while ((fixNode&#x3D;&#x3D;null || isBlack(fixNode)) &amp;&amp; (fixNode !&#x3D; this.mRoot)) &#123;\n            if (parent.leftChildren &#x3D;&#x3D; fixNode) &#123;&#x2F;&#x2F;删除的节点是左节点\n                other &#x3D; parent.rightChildren;\n                if (isRed(other)) &#123;\n                    &#x2F;&#x2F; Case 1: x的兄弟w是红色的\n                    other.color &#x3D; BLACK;\n                    parent.color &#x3D; RED;\n                    leftRotate(parent);\n                    other &#x3D; parent.rightChildren;\n                &#125;\n\n                if ((other.leftChildren&#x3D;&#x3D;null || isBlack(other.leftChildren)) &amp;&amp;\n                        (other.rightChildren&#x3D;&#x3D;null || isBlack(other.rightChildren))) &#123;\n                    &#x2F;&#x2F; Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的\n                    other.color &#x3D; RED;\n                    fixNode &#x3D; parent;\n                    parent &#x3D; fixNode.parent;\n                &#125; else &#123;\n\n                    if (other.rightChildren&#x3D;&#x3D;null || isBlack(other.rightChildren)) &#123;\n                        &#x2F;&#x2F; Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。\n                        other.leftChildren.color &#x3D; BLACK;\n                        other.color &#x3D; RED;\n                        rightChildrenRotate(other);\n                        other &#x3D; parent.rightChildren;\n                    &#125;\n                    &#x2F;&#x2F; Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。\n                    other.color &#x3D; parent.color;\n                    parent.color &#x3D; BLACK;\n                    other.rightChildren.color &#x3D; BLACK;\n                    leftRotate(parent);\n                    fixNode &#x3D; this.mRoot;\n                    break;\n                &#125;\n            &#125; else &#123; &#x2F;&#x2F;删除的节点是右节点\n\n                other &#x3D; parent.leftChildren;\n                if (isRed(other)) &#123;\n                    &#x2F;&#x2F; Case 1: x的兄弟w是红色的\n                    other.color &#x3D; BLACK;\n                    parent.color &#x3D; RED;\n                    rightChildrenRotate(parent);\n                    other &#x3D; parent.leftChildren;\n                &#125;\n\n                if ((other.leftChildren&#x3D;&#x3D;null || isBlack(other.leftChildren)) &amp;&amp;\n                        (other.rightChildren&#x3D;&#x3D;null || isBlack(other.rightChildren))) &#123;\n                    &#x2F;&#x2F; Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的\n                    other.color &#x3D; RED;\n                    fixNode &#x3D; parent;\n                    parent &#x3D; fixNode.parent;\n                &#125; else &#123;\n\n                    if (other.leftChildren&#x3D;&#x3D;null || isBlack(other.leftChildren)) &#123;\n                        &#x2F;&#x2F; Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。\n                        other.rightChildren.color &#x3D; BLACK;\n                        other.color &#x3D; RED;\n                        leftRotate(other);\n                        other &#x3D; parent.leftChildren;\n                    &#125;\n\n                    &#x2F;&#x2F; Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。\n                    other.color &#x3D; parent.color;\n\n\n                    parent.color &#x3D; BLACK;\n                    other.leftChildren.color &#x3D; BLACK;\n                    rightChildrenRotate(parent);\n                    fixNode &#x3D; this.mRoot;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n\n        if (fixNode!&#x3D;null)\n            fixNode.color &#x3D; BLACK;\n    &#125;\n\n    &#x2F;&#x2F; 删除结点(delNode)，并返回被删除的结点\n    private void remove(RBTreeNode&lt;T&gt; delNode) &#123;\n        RBTreeNode&lt;T&gt; child, parent;\n        boolean color;\n\n        &#x2F;&#x2F; 被删除节点的&quot;左右孩子都不为空&quot;的情况。\n        if ( (delNode.leftChildren!&#x3D;null) &amp;&amp; (delNode.rightChildren!&#x3D;null) ) &#123;\n            &#x2F;&#x2F; 被删节点的后继节点。(称为&quot;取代节点&quot;)\n            &#x2F;&#x2F; 用它来取代&quot;被删节点&quot;的位置，然后再将&quot;被删节点&quot;去掉。\n            RBTreeNode&lt;T&gt; replace &#x3D; delNode;\n\n            &#x2F;&#x2F; 获取后继节点\n            replace &#x3D; replace.rightChildren;\n            while (replace.leftChildren !&#x3D; null)\n                replace &#x3D; replace.leftChildren;\n\n            &#x2F;&#x2F; &quot;node节点&quot;不是根节点(只有根节点不存在父节点)\n            if (delNode.parent!&#x3D;null) &#123;\n                if (delNode.parent.leftChildren &#x3D;&#x3D; delNode)\n                    delNode.parent.leftChildren &#x3D; replace;\n                else\n                    delNode.parent.rightChildren &#x3D; replace;\n            &#125; else &#123;\n                &#x2F;&#x2F; &quot;node节点&quot;是根节点，更新根节点。\n                this.mRoot &#x3D; replace;\n            &#125;\n\n            &#x2F;&#x2F; child是&quot;取代节点&quot;的右孩子，也是需要&quot;调整的节点&quot;。\n            &#x2F;&#x2F; &quot;取代节点&quot;肯定不存在左孩子！因为它是一个后继节点。\n            child &#x3D; replace.rightChildren;\n            parent &#x3D; replace.parent;\n            &#x2F;&#x2F; 保存&quot;取代节点&quot;的颜色\n            color &#x3D; replace.color;\n\n            &#x2F;&#x2F; &quot;被删除节点&quot;是&quot;它的后继节点的父节点&quot;\n            if (parent &#x3D;&#x3D; delNode) &#123;\n                parent &#x3D; replace;\n            &#125; else &#123;\n                &#x2F;&#x2F; child不为空\n                if (child!&#x3D;null)\n                    child.parent &#x3D; parent;\n                parent.leftChildren &#x3D; child;\n\n                replace.rightChildren &#x3D; delNode.rightChildren;\n                delNode.rightChildren.parent &#x3D; replace;\n            &#125;\n\n            replace.parent &#x3D; delNode.parent;\n            replace.color &#x3D; delNode.color;\n            replace.leftChildren &#x3D; delNode.leftChildren;\n            delNode.leftChildren.parent &#x3D; replace;\n\n            if (color &#x3D;&#x3D; BLACK) &#x2F;&#x2F;红色直接删除 黑色删除后维护\n                removeFixUp(child, parent);\n\n            delNode &#x3D; null;\n            return ;\n        &#125;\n\n        if (delNode.leftChildren !&#x3D;null) &#123;\n            child &#x3D; delNode.leftChildren;\n        &#125; else &#123;\n            child &#x3D; delNode.rightChildren;\n        &#125;\n\n        parent &#x3D; delNode.parent;\n        &#x2F;&#x2F; 保存&quot;取代节点&quot;的颜色\n        color &#x3D; delNode.color;\n\n        if (child!&#x3D;null)\n            child.parent &#x3D; parent;\n\n        &#x2F;&#x2F; &quot;node节点&quot;不是根节点\n        if (parent!&#x3D;null) &#123;\n            if (parent.leftChildren &#x3D;&#x3D; delNode)\n                parent.leftChildren &#x3D; child;\n            else\n                parent.rightChildren &#x3D; child;\n        &#125; else &#123;\n            this.mRoot &#x3D; child;\n        &#125;\n\n        if (color &#x3D;&#x3D; BLACK)\n            removeFixUp(child, parent);\n        delNode &#x3D; null;\n    &#125;\n\n    &#x2F;*\n     * 删除结点(z)，并返回被删除的结点\n     *\n     * 参数说明：\n     *     tree 红黑树的根结点\n     *     z 删除的结点\n     *&#x2F;\n    public void remove(T key) &#123;\n        RBTreeNode&lt;T&gt; node;\n\n        if ((node &#x3D; search(mRoot, key)) !&#x3D; null)\n            remove(node);\n    &#125;\n\n    &#x2F;*\n     * 销毁红黑树\n     *&#x2F;\n    private void destroy(RBTreeNode&lt;T&gt; tree) &#123;\n        if (tree&#x3D;&#x3D;null)\n            return ;\n\n        if (tree.leftChildren !&#x3D; null)\n            destroy(tree.leftChildren);\n        if (tree.rightChildren !&#x3D; null)\n            destroy(tree.rightChildren);\n\n        tree&#x3D;null;\n    &#125;\n\n    public void clear() &#123;\n        destroy(mRoot);\n        mRoot &#x3D; null;\n    &#125;\n\n    &#x2F;*\n     * 打印&quot;红黑树&quot;\n     *\n     * key        -- 节点的键值\n     * direction  --  0，表示该节点是根节点;\n     *               -1，表示该节点是它的父结点的左孩子;\n     *                1，表示该节点是它的父结点的右孩子。\n     *&#x2F;\n    private void print(RBTreeNode&lt;T&gt; tree, T key, int direction) &#123;\n\n        if(tree !&#x3D; null) &#123;\n\n            if(direction&#x3D;&#x3D;0)    &#x2F;&#x2F; tree是根节点\n                System.out.printf(&quot;%2d(B) is root\\n&quot;, tree.key);\n            else                &#x2F;&#x2F; tree是分支节点\n                System.out.printf(&quot;%2d(%s) is %2d&#39;s %6s child\\n&quot;, tree.key, isRed(tree)?&quot;R&quot;:&quot;B&quot;, key, direction&#x3D;&#x3D;1?&quot;rightChildren&quot; : &quot;leftChildren&quot;);\n\n            print(tree.leftChildren, tree.key, -1);\n            print(tree.rightChildren,tree.key,  1);\n        &#125;\n    &#125;\n\n    public void print() &#123;\n        if (mRoot !&#x3D; null)\n            print(mRoot, mRoot.key, 0);\n    &#125;\n&#125;\n\n3、测试类\npublic class RBTreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;\n    boolean color; &#x2F;&#x2F; red or black\n    T key; &#x2F;&#x2F; 键\n    RBTreeNode leftChildren; &#x2F;&#x2F; 左子节点\n    RBTreeNode rightChildren; &#x2F;&#x2F; 右子节点\n    RBTreeNode parent; &#x2F;&#x2F; 父节点\n\n    public RBTreeNode(T key, boolean color) &#123;\n        this.key &#x3D; key;\n        this.color &#x3D; color;\n    &#125;\n&#125;\n\n\n","slug":"BlogRepository/Java/Java 数据结构总结","date":"2022-08-05T07:14:42.000Z","categories_index":"Java","tags_index":"Java,数据结构","author_index":"凡"},{"id":"f01a8fc979d8be0c498f7adbc2e32f43","title":"记创建SpringBoot项目时连接超时，Cannot download \"https://start.spring.io\"","content":"1. 问题首先，在第一阶段，连接 start.spring.io 超时假如运气好第一阶段刷新成功，第二阶段创建，下载时报错超时，无法创建\n2. 解决将地址 https://start.spring.io/ 改为 https://start.springboot.io/ 即可成功创建\n","slug":"BlogRepository/问题记录/记创建SpringBoot项目时连接超时，Cannot download “https___start.spring.io“","date":"2022-07-25T17:19:20.000Z","categories_index":"问题记录","tags_index":"IDEA,SpringBoot","author_index":"凡"},{"id":"1b9f23e14da5dbec955e19baedd994be","title":"记 IDEA 启动 Command line is too long 解决","content":"1. IDEA 2021 及之前在项目的 .idea 文件中，找到 workspace.xml 文件打开，找到 &lt;component name=&quot;PropertiesComponent&quot;&gt; 标签，在里面加上一条&lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;\n2. IDEA 2022照样在项目的 .idea 文件中，找到 workspace.xml 文件，同样找到 &lt;component name=&quot;PropertiesComponent&quot;&gt; 标签，加上 &quot;dynamic.classpath&quot;: &quot;true&quot;,\n","slug":"BlogRepository/问题记录/记 IDEA 启动 Command line is too long 解决","date":"2022-07-01T07:24:03.000Z","categories_index":"问题记录","tags_index":"IDEA","author_index":"凡"},{"id":"63ad785272b1d320f5d35d75fc9f15a2","title":"IDEA 配置及插件","content":"1. 配置依次点击 File，Settings\n1.1 设置编译版本设置编译为版本 JDK 8，使用的是 JDK 8\n1.2 设置编码设置编码为 UTF-8\n1.3 自动导包\n1.4 自动编译\n1.5 设置主题\n1.6 设置字体字号\n1.7 滚轮修改字体大小\n1.8 控制台字体\n1.9 行号与方法分隔符\n1.10 忽略大小写字母\n1.11 多行显示\n1.12 设置 Maven设置自定义 Maven 路径与配置文件路径和仓库路径设置 JDK，设置下载依赖的时候的下载内容\n1.13 GitHub 账户\n1.14 配置 Git\n1.15 配置文件隐藏隐藏不希望看见的文件。File --&gt; Settings --&gt; Editor --&gt; File Types --&gt; Ingored Files And Folders，添加想要隐藏的文件或文件夹\n1.16 配置相同词背景色\n1.17 配置实现 Serializable 快速生成 serialVersionUID在 Settings 里依次找到 Editor –&gt; inspections –&gt; JVM languages，或者直接搜索，勾选下图选项在类上按下 Alt + Enter，或悬停，会提示创建 serialVersionUID\n1.18 创建类或接口和枚举模板&#x2F;**\n * $description\n * @author $&#123;USER&#125;\n*&#x2F;\n\n创建类时会提示输入 description创建完成自动添加注释或者也可以在 File Header 里配置\n1.19 自定义方法注释模板找到 Live Template，可以点击右边的 + 号创建一个模板组，再在该模板组下创建自定义的方法注释模板，Abbreviation 指缩写，这里用 * 表示注释模板 ，这样先输入 /* 后再输入 * 按下回车生成方法注释，刚好符合 Javadoc 规范**这里为具体的模板内容，可根据情况进行增减，Javadoc 地址**。这里在第一行的占位符前面加了一个空格，因为生成模板后直接写注释会导致 params 错位，可以先按一下删除这个空格再写注释，就不会有格式问题\n*\n *  $description$\n * @author $author$ $param$ $return$\n * @throws $throws$\n *&#x2F;\n\n给参数定义值。这里的 params 不使用 IDEA 的默认实现，不符合 Javadoc 规范，自己进行实现\ngroovyScript(&quot;if(\\&quot;$&#123;_1&#125;\\&quot;&#x3D;&#x3D;\\&quot;null\\&quot;||\\&quot;$&#123;_1&#125;\\&quot;.length() &#x3D;&#x3D; 2) &#123;return &#39;&#39;;&#125; else &#123;def result&#x3D;&#39;&#39;; def params&#x3D;\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#39;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList();for(i &#x3D; 0; i &lt; params.size(); i++) &#123;if(i&#x3D;&#x3D;0)&#123;result+&#x3D;&#39;\\\\n * @param &#39; + params[i]&#125;else&#123;result+&#x3D;&#39;\\\\n&#39; + &#39; * @param &#39; + params[i]&#125;&#125;; return result;&#125;&quot;, methodParameters());\n\nreturn 也采用自己的实现，加上 @link 标签，可以点击查看返回类型的信息\ngroovyScript(&quot;def returnType &#x3D; \\&quot;$&#123;_1&#125;\\&quot;; if (returnType &#x3D;&#x3D; \\&quot;void\\&quot; || returnType &#x3D;&#x3D; \\&quot;null\\&quot; || returnType &#x3D;&#x3D; null ) return \\&quot;\\&quot;; def result &#x3D; &#39;\\\\n * @return &#123;@link &#39; + returnType + &#39;&#125;&#39;; return result;&quot;, methodReturnType());\n\nthrows 暂时没有方式自动获取到异常信息最后选择应用场景和触发形式，选择回车触发先输入 /*，再输入 *，按下回车补全信息，最后预览如下\n2. 插件2.1 MyBatisX结合 MyBatis-Plus 使用\n2.2 lombok\n2.3 Background Image Plus +修改 IDEA 背景，可以设置为图片，轮播设置图片路径和轮播设置背景布局和透明度等\n2.4 Alibaba Java Coding Guidelines代码检查\n2.5 CodeGlance右侧代码预览\n2.6 Translation翻译插件\n2.7 Key promoter X快捷键提示\n2.8 Maven Helper查看 Maven 依赖\n2.8 FindBugs\n2.9 GitHub Copilot智能补全代码\n2.10 Jrebel热部署\n安装后激活\n**Service Address ：https://jrebel.qekang.com/{GUID}**（https 失效时换成 http）GUID 地址：\n\nhttps://www.guidgen.com\nhttp://www.ofmonkey.com/transfer/guid\nhttps://www.guidgenerator.com/online-guid-generator.aspx\n\n\n2.11 Rainbow Brackets多彩括号\n2.12 SequenceDiagram根据代码调用链路自动生成时序图\n2.13 Material Theme UI主题插件选择主题\n2.14 Atom Material Icons可以不安装 Material Theme UI，只使用主题图标，如上\n2.15 jclasslib Bytecode Viewer编译成字节码文件并展示\n2.15 MapStruct Support配合 MapStruct 使用\n\n3. 快捷键可根据个人习惯修改\n\nCtrl + F：查找\nCtrl + Shift + F：全局查找\nCtrl + R：替换\nCtrl + Y：删除光标所在行 或 删除选中的行\nCtrl + Shift + Z：回退撤销，回退 Ctrl + Z 的操作\nCtrl + D：复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面\nCtrl + P：方法参数提示显示\nCtrl + Q：光标所在的变量 &#x2F; 类名 &#x2F; 方法名等上面（也可以在提示补充的时候按），显示文档内容\nCtrl + H：显示当前类的层次结构\nCtrl + O：选择可重写的方法\nCtrl + I：选择可继承的方法\nCtrl + &#x2F;：注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号\nCtrl + Enter：智能分隔行\nCtrl + Space： 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改。改为 Alt + Enter\nAlt + Insert：代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等。改为 Alt + I\nAlt + Enter：IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同\nCtrl + Alt + L：格式化代码，可以对当前文件和整个包目录使用\nCtrl + Alt + 左方向键：退回到上一个操作的地方\nCtrl + Shift + &#x2F;：代码块注释\nCtrl + Shift + Space：智能代码提示，可以改为 Alt + &#x2F;\nCtrl + Alt + Space：类名或接口名提示\n连按两次Shift：弹出 Search Everywhere 弹出层\nCtrl + Alt + T：Surround with，快捷使用 if 或 try catch 等，可以改为 Alt + T\nCtrl + Shift + F10：运行，改为 Alt + 0\n新建类，添加快捷键，Alt + N\n清空控制台，添加快捷键，Alt + C\n\n","slug":"BlogRepository/开发工具及环境/IDEA 配置及插件和快捷键总结","date":"2022-07-01T02:12:53.000Z","categories_index":"开发工具及环境","tags_index":"Java,IDEA","author_index":"凡"},{"id":"648d078e3655921f437d23e88a3a35f2","title":"PyCharm 下载安装及配置使用详细图文教程","content":"1. 下载1、进入官网：https://www.jetbrains.com/pycharm，点击 Download，下载2、选择下载专业版（付费）或社区版（免费），这里选择下载专业版3、下载完成，得到安装程序\n2. 安装双击应用程序，进行安装，Next选择安装路径，Next根据需要选择，NextInstall，安装安装完成\n3. 使用不导入设置\n进入 PyCharm，点击 Start trial点击开始试用Continue创建项目输入项目名，选择路径，Create完成同为 Jetbrains 产品，使用与 IDEA 类似\n","slug":"BlogRepository/开发工具及环境/PyCharm 下载安装及配置使用详细图文教程","date":"2022-06-30T15:32:39.000Z","categories_index":"开发工具及环境","tags_index":"Python,PyCharm","author_index":"凡"},{"id":"2f6fa7c456d90ea78f2273a18fcc64b4","title":"Spring Boot 总结","content":"1. 概念1.1 Spring Boot 优点\n\n\n\n\n\n\n\n\nSpring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.\n能快速创建出生产级别的 Spring 应用\n\nCreate stand-alone Spring applications创建独立Spring应用\nEmbed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)内嵌 Web 服务器\nProvide opinionated ‘starter’ dependencies to simplify your build configuration自动 starter 依赖，简化构建配置\nAutomatically configure Spring and 3rd party libraries whenever possible自动配置 Spring 以及第三方功能\nProvide production-ready features such as metrics, health checks, and externalized configuration提供生产级别的监控、健康检查及外部化配置\nAbsolutely no code generation and no requirement for XML configuration无代码生成、无需编写 XML\n\nSpring Boot 是整合 Spring 技术栈的一站式框架，简化 Spring 技术栈的快速开发脚手架\n1.2 Spring Boot 缺点\n迭代快，需要时刻关注变化\n封装太深，内部原理复杂，不容易精通\n\n1.3 微服务概念James Lewis and Martin Fowler (2014)  提出微服务完整概念：https://martinfowler.com/microservices/\n\n\n\n\n\n\n\n\n\nIn short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.– James Lewis and Martin Fowler (2014)\n\n微服务是一种架构风格\n一个应用拆分为一组小型服务\n每个服务运行在自己的进程内，也就是可独立部署和升级\n服务之间使用轻量级 HTTP 交互\n服务围绕业务功能拆分\n可以由全自动部署机制独立部署\n去中心化，服务自治。服务可以使用不同的语言、不同的存储技术\n\n1.4 分布式困难：\n\n远程调用\n服务发现\n负载均衡\n服务容错\n配置管理\n服务监控\n链路追踪\n日志管理\n任务调度\n……\n\n解决：Spring Boot + Spring Cloud\n1.5 云原生（Cloud Native）原生应用如何上云。困难：\n\n服务自愈\n弹性伸缩\n服务隔离\n自动化部署\n灰度发布\n流量治理\n……\n\n2. 基础使用1.1 POM 依赖&lt;parent&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.6.2&lt;&#x2F;version&gt;\n\t&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;&#x2F;parent&gt;\n\n&lt;dependencies&gt;\n\t&lt;dependency&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n\t&lt;&#x2F;dependency&gt;\n\t&lt;dependency&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n\t\t&lt;scope&gt;test&lt;&#x2F;scope&gt;\n\t&lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n1.2 创建主程序@SpringBootApplication\npublic class SpringbootTestApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SpringbootTestApplication.class, args);\n    &#125;\n&#125;\n\n1.3 配置文件 application.ymlserver:\n  port: 8081\n\n1.4 控制器@Controller\npublic class TestController &#123;\n    @RequestMapping(&quot;&#x2F;index&quot;)\n    @ResponseBody\n    public String index()&#123;\n        return &quot;Hello SpringBoot&quot;;\n    &#125;\n&#125;\n\n1.6 启动直接运行 SpringbootTestApplication 主程序的 Main 方法\n1.7 简化部署&lt;build&gt;\n\t&lt;plugins&gt;\n\t\t&lt;plugin&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n\t\t\t&lt;configuration&gt;\n\t\t\t\t&lt;excludes&gt;\n\t\t\t\t\t&lt;exclude&gt;\n\t\t\t\t\t\t&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n\t\t\t\t\t\t&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n\t\t\t\t\t&lt;&#x2F;exclude&gt;\n\t\t\t\t&lt;&#x2F;excludes&gt;\n\t\t\t&lt;&#x2F;configuration&gt;\n\t\t&lt;&#x2F;plugin&gt;\n\t&lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n把项目打成jar包，直接在目标服务器执行即可。java -jar SpringbootTest-0.0.1-SNAPSHOT.jar\n2. 自动配置2.1 依赖管理父项目做依赖管理\n依赖管理  \n&lt;parent&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n它的父项目\n&lt;parent&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制\n2.2 开发导入 starter 场景启动器\n很多 spring-boot-starter-* ： * 就某种场景\n只要引入 starter，这个场景的所有常规需要的依赖都将自动引入\nSpring Boot 所有支持的场景https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter\n*-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器\n所有场景启动器最底层的依赖&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n\t&lt;scope&gt;compile&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n2.3 无需关注版本号，自动版本仲裁\n引入依赖默认都可以不写版本\n引入非版本仲裁的 jar，要写版本号\n可以修改默认版本号\n\n1、查看 spring-boot-dependencies 里面规定当前依赖的版本用的 key。\n2、在当前项目里面重写配置\n&lt;properties&gt;\n\t&lt;mysql.version&gt;8.0.19&lt;&#x2F;mysql.version&gt;\n&lt;&#x2F;properties&gt;\n\n2.4 自动配置\n自动配好 Tomcat\n\n引入 Tomcat 依赖\n配置 Tomcat\n\n&lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n      &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n自动配好 SpringMVC\n\n引入 SpringMVC 全套组件\n自动配好 SpringMVC 常用组件（功能）\n\n\n自动配好 Web 常见功能，如：字符编码问题\n\nSpring Boot 配置好了所有 Web 开发的常见场景\n\n\n默认的包结构\n\n主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来\n无需以前的包扫描配置\n想要改变扫描路径，@SpringBootApplication(scanBasePackages=&quot;fan&quot;) ，扩大层级，或者 @ComponentScan 指定扫描路径\n\n@SpringBootApplication\n等同于\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(&quot;fan.springboottest&quot;)\n各种配置拥有默认值\n\n默认配置最终都是映射到某个类上，如：MultipartProperties\n配置文件的值最终会绑定每个类上，这个类会在容器中创建对象\n\n\n按需加载所有自动配置项\n\n非常多的 starter\n引入了哪些场景这个场景的自动配置才会开启\nSpring Boot 所有的自动配置功能都在 spring-boot-autoconfigure 包里\n\n\n……\n\n\n2.5 自动配置原理2.5.1 引导加载自动配置类@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters &#x3D; &#123; @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),\n\t\t@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)\npublic @interface SpringBootApplication&#123;\n&#125;\n\n\n@SpringBootConfiguration@Configuration。代表当前是一个配置类\n\n@ComponentScan指定扫描哪些 Spring 注解\n\n@EnableAutoConfiguration\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration &#123;\n&#125;\n\n\n@AutoConfigurationPackage自动配置包，指定了默认的包规则@Import(AutoConfigurationPackages.Registrar.class)  &#x2F;&#x2F; 给容器中导入一个组件\npublic @interface AutoConfigurationPackage &#123;\n&#125;\n\n&#x2F;&#x2F; 利用 Registrar 给容器中导入一系列组件\n&#x2F;&#x2F; 将指定的一个包下的所有组件导入进来，MainApplication 所在包下\n@Import(AutoConfigurationImportSelector.class)\n利用 getAutoConfigurationEntry(annotationMetadata); 给容器中批量导入一些组件\n调用 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes) 获取到所有需要导入到容器中的配置类\n利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader); 得到所有的组件\n从 META-INF/spring.factories 位置来加载一个文件默认扫描当前系统里面所有 META-INF/spring.factories 位置的文件spring-boot-autoconfigure-2.6.4.jar 包里面也有 META-INF/spring.factories\n\n\n\n\n\n文件里面写死了 Spring Boot 一启动就要给容器中加载的所有配置类\nspring-boot-autoconfigure-2.3.4.RELEASE.jar&#x2F;META-INF&#x2F;spring.factories\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n\n2.5.2 按需开启自动配置虽然 127 个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration按照条件装配规则（@Conditional），最终会按需配置\n2.5.3 修改默认配置@Bean\n@ConditionalOnBean(MultipartResolver.class)  &#x2F;&#x2F; 容器中有这个类型组件\n@ConditionalOnMissingBean(name &#x3D; DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) &#x2F;&#x2F;容器中没有这个名字 multipartResolver 的组件\npublic MultipartResolver multipartResolver(MultipartResolver resolver) &#123;\n    &#x2F;&#x2F; 给 @Bean 标注的方法传入了对象参数，这个参数的值就会从容器中找\n    &#x2F;&#x2F; SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范\n    &#x2F;&#x2F; Detect if the user has created a MultipartResolver but named it incorrectly\n    return resolver;\n&#125;\n给容器中加入了文件上传解析器\n\nSpring Boot 默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先\n@Bean\n@ConditionalOnMissingBean\npublic CharacterEncodingFilter characterEncodingFilter() &#123;\n&#125;\n\n2.6 小结\nSpring Boot 先加载所有的自动配置类  xxxxxAutoConfiguration\n每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties 里面拿xxxProperties 和配置文件进行了绑定\n生效的配置类就会给容器中装配组件\n只要容器中有这些组件，相当于拥有对应的这些功能\n定制化配置\n用户直接自己 @Bean 替换底层的组件\n用户去看这个组件是获取的配置文件什么值就去修改\n\n\n\nxxxxxAutoConfiguration —&gt; 组件  —&gt; xxxxProperties 里面拿值  —-&gt; application.properties\n最佳实践\n\n引入场景依赖https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter\n查看自动配置了哪些（选做）\n自己分析，引入场景对应的自动配置一般都生效了\n配置文件中 debug&#x3D;true 开启自动配置报告。Negative（不生效）\\Positive（生效）\n\n\n是否需要修改\n参照文档修改配置项https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties分析 xxxxProperties 绑定了配置文件的哪些\n自定义加入或者替换组件@Bean、@Component…\n自定义器  XXXXXCustomizer\n…\n\n\n\n3. 注解与配置绑定3.1 @Configuration(proxyBeanMethods)告诉Spring Boot这是一个配置类 &#x3D;&#x3D; 配置文件，配置类本身也是组件。配置类里面使用 @Bean 标注在方法上给容器注册组件，默认是单实例的\nFull 模式与 Lite 模式\n\n配置类组件之间无依赖关系用 Lite 模式加速容器启动过程，减少判断\n配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用 Full 模式\n\nproxyBeanMethods：代理 bean 的方法：\n\nFull(proxyBeanMethods = true)【保证每个 @Bean 方法被调用多少次返回的组件都是单实例的，Spring Boot 总会检查这个组件是否在容器中有，获取的都是之前注册容器中的单实例对象】\nLite(proxyBeanMethods = false)  【每个 @Bean 方法被调用多少次返回的组件都是新创建的】\n\n组件依赖必须使用Full模式默认。其他默认是否Lite模式\n配置类\n@Configuration(proxyBeanMethods &#x3D; true &#x2F;*false*&#x2F;) &#x2F;&#x2F; 代理\npublic class MyConfig &#123;\n    @Bean\n    public User user01()&#123;\n        User user &#x3D; new User(&quot;张三&quot;, 17);\n        user.setPet(petCat());\n        return user;\n    &#125;\n    @Bean(&quot;cat&quot;)\n    public Pet petCat()&#123;\n        return new Pet(&quot;tom&quot;,78);\n    &#125;\n&#125;\n\nBean\npublic class User &#123;\n    private String username;\n    private int age;\n    private Pet pet;\n&#125;\n\n\n默认值为 true。为 false 时，每一次 new 出的对象都是不一样的。 在 User 类中嵌入 Pet 类，使用 User 类获取到的 Pet 类与直接获取 Pet 类不相等，而且使用两次 new 获取 Pet 类，值也不相等，即每次获取的不是同一个\n为 true 时，无论怎么样获取Pet类，无论获取多少次，都是相等的，即每次获取都是同一个。单实例\n\n@SpringBootApplication\npublic class SpringinitApplication &#123;\n\n    public static void main(String[] args) &#123;\n        ConfigurableApplicationContext run &#x3D; SpringApplication.run(SpringbootTestApplication.class, args);\n  \n        User user01 &#x3D; (User) run.getBean(&quot;user01&quot;, User.class);\n        System.out.println(user01);\n        System.out.println(&quot;用户的宠物：&quot; + user01.getPet());\n\n        Pet pet &#x3D; (Pet) run.getBean(&quot;cat&quot;,Pet.class);\n        System.out.println(pet);\n\n        System.out.println(user01.getPet() &#x3D;&#x3D; pet);\n    &#125;\n&#125;\n\n3.2 @Conditional条件注解，需要某些 Bean 满足某种条件才加载\n@Configuration(proxyBeanMethods &#x3D; true) &#x2F;&#x2F; 告诉SpringBoot这是一个配置类 &#x3D;&#x3D; 配置文件\n&#x2F;&#x2F; @ConditionalOnBean(name &#x3D; &quot;tom&quot;) 存在名称为 tom 的 Bean 才去做某些事情\n@ConditionalOnMissingBean(name &#x3D; &quot;tom&quot;)\npublic class MyConfig &#123;\n    &#x2F;**\n     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象\n     * @return\n     *&#x2F;\n    @Bean &#x2F;&#x2F; 给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例\n    public User user01()&#123;\n        User zhangsan &#x3D; new User(&quot;zhangsan&quot;, 18);\n        &#x2F;&#x2F;user组件依赖了Pet组件\n        zhangsan.setPet(tomcatPet());\n        return zhangsan;\n    &#125;\n    @Bean(&quot;tom22&quot;)\n    public Pet tomcatPet()&#123;\n        return new Pet(&quot;tomcat&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n注解\n作用\n\n\n\n@ConditionalOnProperty\napplication.properties 或 application.yml 中是否有满足条件的配置\n\n\n@ConditionalOnBean\nBean 已经存在应用上下文时才会加载\n\n\n@ConditionalOnMissingBean\nBean 不存在应用上下文时才会加载\n\n\n@ConditionalOnClass\n某个类存在于 classpath 中才加载\n\n\n@ConditionalOnMissingClass\n某个类不存在于 classpath 中才加载\n\n\n@ConditionalOnExpression\n当条件为 true 时才加载\n\n\n@ConditionalOnSingleCandidate\n只有指定类已存在于 BeanFactory 中，并且可以确定单个\n\n\n@ConditionalOnResource\n加载的 bean 依赖指定资源存在于 classpath\n\n\n@ConditionalOnJndi\n只有指定的资源通过 JNDI 加载后才加载 bean\n\n\n@ConditionalOnJava\n只有运行指定版本的 Java 才会加载 Bean\n\n\n@ConditionalOnWebApplication\n只有运行在 web 应用里才会加载这个 bean\n\n\n@ConditionalOnNotWebApplication\n只有运行在非 web 应用里才会加载这个 bean\n\n\n@ConditionalOnCloudPlatform\n只有运行在指定的云平台上才加载指定的 bean，CloudPlatform 是 org.springframework.boot.cloud 下一个 enum 类型的类\n\n\n例：\n@ConditionalOnProperty：application.properties 或 application.yml 中是否有满足条件的配置\n配置文件：\nfan.property&#x3D;true\n\n使用：\n&#x2F;&#x2F; @ConditionalOnProperty(prefix &#x3D; &quot;fan&quot;, name &#x3D; &quot;property&quot;, havingValue &#x3D; &quot;true&quot;)\n@ConditionalOnProperty(value &#x3D; &quot;fan.property&quot;, havingValue &#x3D; &quot;true&quot;)\n\n3.2 @Import、@ImportResource@Import：\n&#x2F;&#x2F; 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名\n@Import(&#123;User.class, DBHelper.class&#125;)\n\n@SpringBootApplication\npublic class SpringbootTestApplication &#123;\n    public static void main(String[] args) &#123;\n        ConfigurableApplicationContext run &#x3D; SpringApplication.run(SpringbootTestApplication.class, args);\n        String[] users &#x3D; run.getBeanNamesForType(User.class);\n        for (String user : users) &#123;\n            System.out.println(user);\n        &#125;\n    &#125;\n&#125;\n\n@ImportResource：引入自定义配置文件\n@ImportResource(&quot;classpath:beans.xml&quot;)\n\n3.3 @Bean设置 Bean，给容器中添加组件，以方法名作为组件的 id，返回类型就是组件类型，返回值就是组件的容器中的实例。配置类里面使用 @Bean 标注在方法上给容器注册组件，默认是单实例的\n@Bean\npublic User user01()&#123;\n\tUser user &#x3D; new User(&quot;张三&quot;, 17);\n\tuser.setPet(petCat());\n\treturn user;\n&#125;\n\n@Bean(&quot;cat&quot;)\npublic Pet petCat()&#123;\n\treturn new Pet(&quot;tom&quot;,78);\n&#125;\n\n@SpringBootApplication\npublic class SpringbootTestApplication &#123;\n    public static void main(String[] args) &#123;\n        ConfigurableApplicationContext run &#x3D; SpringApplication.run(SpringbootTestApplication.class, args);\n        String[] beanDefinitionNames &#x3D; run.getBeanDefinitionNames();\n        for (String beanDefinitionName : beanDefinitionNames) &#123;\n            System.out.println(beanDefinitionName); &#x2F;&#x2F; 打印输出所有组件名\n        &#125;\n    &#125;\n&#125;\n\n3.4 配置绑定如何使用Java读取到配置文件properties或yml中的内容，并且把它封装到JavaBean中，以供随时使用\n@Component + @ConfigurationProperties\n&#x2F;**\n * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能\n *&#x2F;\n@Data\n@Component &#x2F;&#x2F; 注入容器\n@ConfigurationProperties(prefix &#x3D; &quot;user&quot;)\npublic class User &#123;\n    private Integer id;\n    private String name;\n    private String gender;\n    private String[] hobby;\n&#125;\n\nuser:\n  id: 1\n  name: 张三\n  hobby: [篮球, 游泳]\n\n@Controller\npublic class TestController &#123;\n    @Autowired\n    private User user;\n\n    @RequestMapping(&quot;&#x2F;index&quot;)\n    @ResponseBody\n    public User index()&#123;\n        return user;\n    &#125;\n&#125;\n\n@EnableConfigurationProperties + @ConfigurationProperties\n@Data\n@ConfigurationProperties(prefix &#x3D; &quot;user&quot;)\npublic class User &#123;\n    private Integer id;\n    private String name;\n    private String gender;\n    private String[] hobby;\n&#125;\n\n@Configuration\n@EnableConfigurationProperties(User.class)\n&#x2F;&#x2F; 1、开启Car配置绑定功能\n&#x2F;&#x2F; 2、把这个Car这个组件自动注册到容器中\npublic class MyConfig &#123;\n&#125;\n\n3.5 配置绑定提示自定义的类和配置文件绑定一般没有提示\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n    &lt;optional&gt;true&lt;&#x2F;optional&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;excludes&gt;\n                        &lt;exclude&gt;\n                            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                            &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n                        &lt;&#x2F;exclude&gt;\n                    &lt;&#x2F;excludes&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n3.6 @Value 与 @ ConfigurationProperties 对比@Value 和 @ConfigurationProperties 注解都能读取配置文件中的属性值并绑定到 JavaBean 中。当我们只需要读取配置文件中的某一个配置时，可以通过 @Value 注解获取\n\n使用位置不同@ConfigurationProperties：标注在 JavaBean 的类名上@Value：标注在 JavaBean 的属性上\n\n功能不同@ConfigurationProperties：用于批量绑定配置文件中的配置@Value：只能一个一个的指定需要绑定的配置\n\n松散绑定支持不同@ConfigurationProperties：支持松散绑定（松散语法），例如实体类 Person 中有一个属性为 lastName，那么配置文件中的属性名支持以下写法：\n\nperson.firstName\nperson.first-name\nperson.first_name\nPERSON_FIRST_NAME\n\n@Vaule：不支持松散绑定\n\n应用场景不同@Value 和 @ConfigurationProperties 两个注解之间，并没有明显的优劣之分，它们只是适合的应用场景不同而已。\n\n若只是获取配置文件中的某项值，则推荐使用 @Value 注解\n若专门编写了一个 JavaBean 来和配置文件进行映射，则建议使用 @ConfigurationProperties 注解\n\n\n\n3.7 @PropertySource如果将所有的配置都集中到 application.properties 或 application.yml 中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 Spring Boot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件\n@PropertySource(value &#x3D; &quot;classpath:person.properties&quot;) &#x2F;&#x2F;指向对应的配置文件\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\npublic class Person &#123;\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n    private Date birth;\n    private Map&lt;String, Object&gt; maps;\n    private List&lt;Object&gt; lists;\n    private Dog dog;\n&#125;\n\n4. 基本配置4.1 SpringMVC 的自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置)\nThe auto-configuration adds the following features on top of Spring’s defaults（添加如下功能）：\n\nInclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.内容协商视图解析器和 BeanName 视图解析器\nSupport for serving static resources, including support for WebJars (covered later in this document)).静态资源（包括webjars）\nAutomatic registration of Converter, GenericConverter, and Formatter beans.自动注册 Converter，GenericConverter，Formatter\nSupport for HttpMessageConverters (covered later in this document).支持 HttpMessageConverters （配合内容协商理解原理）\nAutomatic registration of MessageCodesResolver (covered later in this document).自动注册 MessageCodesResolver （国际化用）\nStatic index.html support.静态 index.html 页支持\nCustom Favicon support (covered later in this document).自定义 Favicon\nAutomatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).自动使用 ConfigurableWebBindingInitializer ，（DataBinder 负责将请求数据绑定到JavaBean上）\n\n\n\n\n\n\n\n\n\n\nIf you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.不用 @EnableWebMvc 注解。使用 @Configuration + WebMvcConfigurer 自定义规则\n\n\n\n\n\n\n\n\n\nIf you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components.声明 WebMvcRegistrations 改变默认底层组件\n\n\n\n\n\n\n\n\n\nIf you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc.使用 @EnableWebMvc + @Configuration + DelegatingWebMvcConfiguration 全面接管 SpringMVC\n4.2 设置端口http://localhost:xxx/aaa.png\nserver:\n  port: xxxx     &#x2F;&#x2F; 端口号\n\n4.3 静态资源访问只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources\n它们的优先级顺序为：classpath:/META-INF/resources/ &gt; classpath:/resources/ &gt; classpath:/static/ &gt; classpath:/public/\n访问 ： 当前项目根路径&#x2F; + 静态资源名。原理： 静态映射&#x2F;\n请求进来，先去找 Controller 看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应 404 页\n4.3.1 改变默认的静态资源路径改变默认的静态资源路径后，原先的默认路径就失效了\nspring:\n  web:\n    resources:\n      static-locations: [classpath:&#x2F;aaa&#x2F;]\n#      static-locations: classpath:&#x2F;aaa&#x2F; classpath之后的不能加空格\n\n4.3.2 静态资源访问前缀设置后在访问的静态资源路径前必须加上 &#x2F;xxx。http://localhost:8080/xxx/aaa.png\nspring:\n  mvc:\n    static-path-pattern: &#x2F;xxx&#x2F;**         &#x2F;&#x2F; 路径 http:&#x2F;&#x2F;localhost:8080&#x2F;xxx&#x2F;**\n\n4.3.3 webjar自动映射 &#x2F;webjars&#x2F;。https://www.webjars.org/\n&lt;dependency&gt;\n    &lt;groupId&gt;org.webjars&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jquery&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.5.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n访问地址：http://localhost:8081/webjars/jquery/3.5.1/jquery.js   后面地址要按照依赖里面的包路径\n4.4 浏览器访问路径设置后浏览器访问的路径前必须加上 /xxx 。http://localhost:8080/world/res/aaa.png/访问路径/静态资源路径\nserver:\n  servlet:\n    context-path: &#x2F;xxx                   &#x2F;&#x2F; 路径 http:&#x2F;&#x2F;localhost:8080&#x2F;xxx&#x2F;\n\n4.5 欢迎页支持\n静态资源路径下  index.html\n\n可以配置静态资源路径\n但是不可以配置静态资源的访问前缀。否则导致 index.html 不能被默认访问\n\nspring:\n#  mvc:\n#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致welcome page功能失效\n\n  resources:\n    static-locations: [classpath:&#x2F;haha&#x2F;]\nController 能处理 &#x2F;index\n\n\n4.6 自定义 Faviconfavicon.ico 放在静态资源目录下即可\nspring:\n#  mvc:\n#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致 Favicon 功能失效\n\n4.7 静态资源配置原理\nSpring Boot 启动默认加载  xxxAutoConfiguration 类（自动配置类）\nSpringMVC 功能的自动配置类 WebMvcAutoConfiguration，生效@Configuration(proxyBeanMethods &#x3D; false)\n@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)\n@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\n@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\n\t\tValidationAutoConfiguration.class &#125;)\npublic class WebMvcAutoConfiguration &#123;&#125;\n给容器中配了什么@Configuration(proxyBeanMethods &#x3D; false)\n@Import(EnableWebMvcConfiguration.class)\n@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)\n@Order(0)\npublic static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;&#125;\n配置文件的相关属性和 xxx 进行了绑定。WebMvcProperties==spring.mvc、ResourceProperties==spring.resources\n\n4.7.1 配置类只有一个有参构造器&#x2F;&#x2F; 有参构造器所有参数的值都会从容器中确定\n&#x2F;&#x2F; ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象\n&#x2F;&#x2F; WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象\n&#x2F;&#x2F; ListableBeanFactory beanFactory Spring的beanFactory\n&#x2F;&#x2F; HttpMessageConverters 找到所有的HttpMessageConverters\n&#x2F;&#x2F; ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; DispatcherServletPath  \n&#x2F;&#x2F; ServletRegistrationBean   给应用注册Servlet、Filter....\npublic WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties,\n\t\t\tListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,\n\t\t\tObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,\n\t\t\tObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,\n\t\t\tObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123;\n\t\tthis.resourceProperties &#x3D; resourceProperties;\n\t\tthis.mvcProperties &#x3D; mvcProperties;\n\t\tthis.beanFactory &#x3D; beanFactory;\n\t\tthis.messageConvertersProvider &#x3D; messageConvertersProvider;\n\t\tthis.resourceHandlerRegistrationCustomizer &#x3D; resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n\t\tthis.dispatcherServletPath &#x3D; dispatcherServletPath;\n\t\tthis.servletRegistrations &#x3D; servletRegistrations;\n&#125;\n\n4.7.2 资源处理的默认规则@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n\tif (!this.resourceProperties.isAddMappings()) &#123;\n\t\tlogger.debug(&quot;Default resource handling disabled&quot;);\n\t\treturn;\n\t&#125;\n\tDuration cachePeriod &#x3D; this.resourceProperties.getCache().getPeriod();\n\tCacheControl cacheControl &#x3D; this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n\t&#x2F;&#x2F; webjars的规则\n\tif (!registry.hasMappingForPattern(&quot;&#x2F;webjars&#x2F;**&quot;)) &#123;\n\t\tcustomizeResourceHandlerRegistration(registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)\n\t\t\t\t.addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;)\n\t\t\t\t.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n\t&#125;\n    \n\t&#x2F;&#x2F;\n\tString staticPathPattern &#x3D; this.mvcProperties.getStaticPathPattern();\n\tif (!registry.hasMappingForPattern(staticPathPattern)) &#123;\n\t\tcustomizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n\t\t\t\t.addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n\t\t\t\t.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n\t&#125;\n&#125;\n\n禁用所有静态资源规则spring:\n#  mvc:\n#    static-path-pattern: &#x2F;res&#x2F;**\n\n  resources:\n    add-mappings: false   禁用所有静态资源规则\n\n@ConfigurationProperties(prefix &#x3D; &quot;spring.resources&quot;, ignoreUnknownFields &#x3D; false)\npublic class ResourceProperties &#123;\n\n\tprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS &#x3D; &#123; &quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;,\n\t\t\t&quot;classpath:&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &#125;;\n\n\t&#x2F;**\n\t * Locations of static resources. Defaults to classpath:[&#x2F;META-INF&#x2F;resources&#x2F;,\n\t * &#x2F;resources&#x2F;, &#x2F;static&#x2F;, &#x2F;public&#x2F;].\n\t *&#x2F;\n\tprivate String[] staticLocations &#x3D; CLASSPATH_RESOURCE_LOCATIONS;\n\n4.7.3 欢迎页的处理规则HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。\n\n@Bean\npublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,\n\t\tFormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123;\n\tWelcomePageHandlerMapping welcomePageHandlerMapping &#x3D; new WelcomePageHandlerMapping(\n\t\tnew TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),\n\t\tthis.mvcProperties.getStaticPathPattern());\n\twelcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n\twelcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());\n\treturn welcomePageHandlerMapping;\n&#125;\n\nWelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,\n\t\tApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;\n\tif (welcomePage.isPresent() &amp;&amp; &quot;&#x2F;**&quot;.equals(staticPathPattern)) &#123;\n\t\t&#x2F;&#x2F; 要用欢迎页功能，必须是 &#x2F;**\n\t\tlogger.info(&quot;Adding welcome page: &quot; + welcomePage.get());\n\t\tsetRootViewName(&quot;forward:index.html&quot;);\n\t&#125; else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;\n\t\t&#x2F;&#x2F; 调用Controller  &#x2F;index\n\t\tlogger.info(&quot;Adding welcome page template: index&quot;);\n\t\tsetRootViewName(&quot;index&quot;);\n\t&#125;\n&#125;\n\n4.8 设置 Rest 响应方式4.8.1 激活 Rest 响应方式激活，设置为true\nspring:\n  mvc:\n    hiddenmethod:\n      filter:\n        enabled: true\n\n4.8.2 设置配置类，自定义值@Bean\npublic HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;\n\tHiddenHttpMethodFilter hiddenHttpMethodFilter &#x3D; new HiddenHttpMethodFilter();\n\thiddenHttpMethodFilter.setMethodParam(&quot;xxx&quot;);   &#x2F;&#x2F; 自定义值\n\treturn hiddenHttpMethodFilter;\n&#125;\n\n4.8.3 HTML 设置表单提交响应方式，正常 GET 和 POST 提交不改变&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;\n&lt;!--    &lt;input name&#x3D;&quot;_method&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;DELETE&quot;&gt;--&gt;   &#x2F;&#x2F; 默认值为_method\n    &lt;input name&#x3D;&quot;xxx&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;DELETE&quot;&gt;              &#x2F;&#x2F; 设置后自定义值xxx\n    &lt;input value&#x3D;&quot;reset_delete&quot; type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;form action&#x3D;&quot;&#x2F;user&quot; method&#x3D;&quot;post&quot;&gt;\n&lt;!--    &lt;input name&#x3D;&quot;_method&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;PUT&quot;&gt;--&gt;      &#x2F;&#x2F; 默认值为_method\n    &lt;input name&#x3D;&quot;xxx&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;PUT&quot;&gt;                 &#x2F;&#x2F; 设置后自定义值xxx\n    &lt;input value&#x3D;&quot;reset_put&quot; type&#x3D;&quot;submit&quot;&gt;\n\n4.8.4 RestController 类@RestController\npublic class Rest_Controller &#123;\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.GET)\n    @GetMapping(&quot;&#x2F;user&quot;)\n    public String getUser()&#123;\n        return &quot;GET-张三&quot;;\n    &#125;\n\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.POST)\n    @PostMapping(&quot;&#x2F;user&quot;)\n    public String saveUser()&#123;\n        return &quot;POST-张三&quot;;\n    &#125;\n\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.PUT)\n    @PutMapping(&quot;&#x2F;user&quot;)\n    public String putUser()&#123;\n        return &quot;PUT-张三&quot;;\n    &#125;\n\n&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.DELETE)\n    @DeleteMapping(&quot;&#x2F;user&quot;)\n    public String deleteUser()&#123;\n        return &quot;DELETE-张三&quot;;\n    &#125;\n&#125;\n\n4.9 设置 Bean 的值YAML 文件，双引号 “张三” 和单引号 ‘张三’ 与直接写 张三 一样，但是 \\n 在单引号中会作为字符串输出，在双引号中会作为换行输出，双引号不会转义，单引号会转义\nperson:\n  user-name: 张三\n  boss: true\n  birth: 2001&#x2F;12&#x2F;5\n  age: 15\n#  String[]\n  interests: #  intersts: [篮球,足球]\n    - 篮球\n    - 足球\n    - 17\n  \n#  List&lt;String&gt;\n  animal: [猫,狗]\n  \n#  score:\n#    english: 80\n#    math: 70\n#  Map&lt;String, Object&gt;\n  score: &#123;math:79,english:80&#125;\n  \n#  Set&lt;Integer&gt;\n  salarys:\n    - 8888\n    - 5555\n  \n  pet:\n    name: 猫\n    weight: 99\n  \n# Map&lt;String, List&lt;Pet&gt;&gt;\n  allPets:\n    sick:\n      - &#123;name: 狗, weight: 88.4&#125;\n      - name: 猫\n        weight: 54.3\n    health: [&#123;name: 乌龟, weight: 55.3&#125;, &#123;name: 鱼, weight: 44.2&#125;]\n\n配置Bean（1）\nBean\n@Component   &#x2F;&#x2F; 需要加容器\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\npublic class Person &#123;\n    private String userName;\n    private Boolean boss;\n    private Date birth;\n    private Integer age;\n    private Pet pet;\n    private String[] interests;\n    private List&lt;String&gt; animal;\n    private Map&lt;String, Object&gt; score;\n    private Set&lt;Integer&gt; salarys;\n    private Map&lt;String, List&lt;Pet&gt;&gt; allPets;\n&#125;\n\n配置类和Bean（2）\n配置类\n@Configuration\n@EnableConfigurationProperties(Car.class) &#x2F;&#x2F; 设置了Bean的class，则不需要加容器\npublic class MyConfig &#123;\n&#125;\n\nBean\n&#x2F;&#x2F;@Component\n@ConfigurationProperties(prefix &#x3D; &quot;mycar&quot;)\npublic class Car &#123;\n    private String brand;\n&#125;\n\n@Controller\npublic class TestController &#123;\n    @Autowired\n    private User user;\n\n    @RequestMapping(&quot;&#x2F;index&quot;)\n    @ResponseBody\n    public User index()&#123;\n        return user;\n    &#125;\n&#125;\n\n5. 请求参数处理、数据响应与内容协商5.1 请求映射5.1.1 REST 使用与原理\n@xxxMapping\n\nREST 风格支持（使用 HTTP 请求方式动词来表示对资源的操作）\n\n以前：&#x2F;getUser   获取用户     &#x2F;deleteUser 删除用户    &#x2F;editUser  修改用户       &#x2F;saveUser 保存用户\n现在： &#x2F;user    GET-获取用户    DELETE-删除用户     PUT-修改用户      POST-保存用户\n核心Filter；HiddenHttpMethodFilter\n用法： 表单 method&#x3D;post，隐藏域  _method&#x3D;put\nSpring Boot 中手动开启\n\n\n扩展：如何自定义 _method 这个名字\n\n@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.GET)\npublic String getUser()&#123;\n\treturn &quot;GET-张三&quot;;\n&#125;\n\n@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.POST)\npublic String saveUser()&#123;\n\treturn &quot;POST-张三&quot;;\n&#125;\n\n\n@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.PUT)\npublic String putUser()&#123;\n\treturn &quot;PUT-张三&quot;;\n&#125;\n\n@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;,method &#x3D; RequestMethod.DELETE)\npublic String deleteUser()&#123;\n\treturn &quot;DELETE-张三&quot;;\n&#125;\n\n@Bean\n@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)\n@ConditionalOnProperty(prefix &#x3D; &quot;spring.mvc.hiddenmethod.filter&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; false)\npublic OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;\n\treturn new OrderedHiddenHttpMethodFilter();\n&#125;\n\n\n&#x2F;&#x2F; 自定义filter\n@Bean\npublic HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;\n\tHiddenHttpMethodFilter methodFilter &#x3D; new HiddenHttpMethodFilter();\n\tmethodFilter.setMethodParam(&quot;_m&quot;); &#x2F;&#x2F; 将_method属性自定义为_m\n\treturn methodFilter;\n&#125;\nREST 原理（表单提交要使用 REST 的时候）\n\n表单提交会带上 _method&#x3D;PUT\n请求过来被 HiddenHttpMethodFilter 拦截\n请求是否正常，并且是 POST\n获取到 _method 的值\n兼容以下请求：PUT.DELETE.PATCH\n原生request（post），包装模式 requesWrapper 重写了 getMethod 方法，返回的是传入的值\n过滤器链放行的时候用 wrapper。以后的方法调用 getMethod 是调用 requesWrapper 的\n\n\n\n\n\n\nREST 使用客户端工具如 Postman 直接发送 Put、DELETE 等方式请求，无需 Filter\n\n\nspring:\n  mvc:\n    hiddenmethod:\n      filter:\n        enabled: true   #开启页面表单的Rest功能\n\n5.1.2 请求映射原理SpringMVC 功能分析都从 org.springframework.web.servlet.DispatcherServlet-》doDispatch ()\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n\t\tHttpServletRequest processedRequest &#x3D; request;\n\t\tHandlerExecutionChain mappedHandler &#x3D; null;\n\t\tboolean multipartRequestParsed &#x3D; false;\n\n\t\tWebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry &#123;\n\t\t\tModelAndView mv &#x3D; null;\n\t\t\tException dispatchException &#x3D; null;\n\n\t\t\ttry &#123;\n\t\t\t\tprocessedRequest &#x3D; checkMultipart(request);\n\t\t\t\tmultipartRequestParsed &#x3D; (processedRequest !&#x3D; request);\n\n\t\t\t\t&#x2F;&#x2F; 找到当前请求使用哪个Handler（Controller的方法）处理\n\t\t\t\tmappedHandler &#x3D; getHandler(processedRequest);\n        \n                &#x2F;&#x2F; HandlerMapping：处理器映射。&#x2F;xxx-&gt;&gt;xxxx\n\nRequestMappingHandlerMapping：保存了所有 @RequestMapping 和 handler 的映射规则所有的请求映射都在 HandlerMapping 中\n\nSpring Boot 自动配置欢迎页的 WelcomePageHandlerMapping 。访问 &#x2F;能访问到 index.html；\nSpring Boot 自动配置了默认 的 RequestMappingHandlerMapping\n请求进来，挨个尝试所有的 HandlerMapping 看是否有请求信息。\n如果有就找到这个请求对应的 handler\n如果没有就是下一个 HandlerMapping\n\n\n需要一些自定义的映射处理，我们也可以自己给容器中放 HandlerMapping。自定义 HandlerMapping\n\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;\n\tif (this.handlerMappings !&#x3D; null) &#123;\n\t\tfor (HandlerMapping mapping : this.handlerMappings) &#123;\n\t\t\tHandlerExecutionChain handler &#x3D; mapping.getHandler(request);\n\t\t\tif (handler !&#x3D; null) &#123;\n\t\t\t\treturn handler;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn null;\n&#125;\n\n5.2 获取请求参数 Param 的值5.2.1 @PathVariable获取路径中 &#123;xxx&#125; 的值。http://localhost:8080/car/111/owner/zhangsan\n@RequestMapping(&quot;car&#x2F;&#123;id&#125;&#x2F;owner&#x2F;&#123;username&#125;&quot;)\npublic void getCar(@PathVariable(&quot;id&quot;) int id,\n                   @PathVariable(&quot;username&quot;) String username,\n                   @PathVariable Map&lt;String,String&gt; pv)\n\n5.2.2 @RequestHeader获取请求头的值\n@RequestMapping(&quot;car&#x2F;&#123;id&#125;&#x2F;owner&#x2F;&#123;username&#125;&quot;)\npublic void get(@RequestHeader(&quot;User-Agent&quot;) String userAgent,\n                @RequestHeader Map&lt;String,String&gt; header）&#123;\n\tMap&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n\tmap.put(&quot;userAgent&quot;,userAgent);\n\tmap.put(&quot;headers&quot;,header);\n\treturn map;\n&#125;\n\n5.2.3 @CookieValue获取 Cookie 的值\n@RequestMapping(&quot;car&#x2F;&#123;id&#125;&#x2F;owner&#x2F;&#123;username&#125;&quot;)\npublic void get(@CookieValue(&quot;xxx&quot;) String cookie1, &#x2F;&#x2F; xxx为cookie名\n                @CookieValue(&quot;xxx&quot;) Cookie cookie）&#123;\n\tString s &#x3D; cookie.getName() + cookie.getValue()\n&#125;\n\n5.2.4 @RequestParam获取传递参数的值。http://localhost:8080/car/111/owner/zhangsan?age=18&amp;inters=sing&amp;inters=play\n@RequestMapping(&quot;car&#x2F;&#123;id&#125;&#x2F;owner&#x2F;&#123;username&#125;&quot;)\npublic void get(@RequestParam(&quot;age&quot;) int age,\n                @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters,\n                @RequestParam Map&lt;String,String&gt; param）&#123;\n&#125;\n\n5.3 获取 Request 域中的值5.3.1 跳转 forward:&#x2F;xxx@RequestMapping(&quot;&#x2F;goto&quot;)\npublic String gotoPage(HttpServletRequest request)&#123;\n    request.setAttribute(&quot;code&quot;,200);\n    return &quot;forward:&#x2F;success&quot;;\n&#125;\n\n@ResponseBody\n@RequestMapping(&quot;&#x2F;success&quot;)\npublic Map success(@RequestAttribute(value &#x3D; &quot;msg&quot;,required &#x3D; false) String msg,\n                   @RequestAttribute(&quot;code&quot;) int code)&#123;\n  \n&#125;\n\n5.3.2 @RequestAttribute获取 request 请求域的值，也可通过 HttpServletRequest 直接获取 request，然后通过 request 获取值。设置 required &#x3D; false，获取的值为非必须，即请求域中可以不存在该值\n@RequestMapping(&quot;&#x2F;success&quot;)\npublic Map success(@RequestAttribute(value &#x3D; &quot;msg&quot;,required &#x3D; false) String msg,\n                   @RequestAttribute(&quot;code&quot;) int code,\n                   HttpServletRequest request)&#123;\n  \n    Object msg1 &#x3D; request.getAttribute(&quot;msg&quot;);\n    Object code1 &#x3D; request.getAttribute(&quot;code&quot;);\n&#125;\n\n5.3.3 request 请求域对象在 request 请求域中，可以传递 Map、Model 和 request、response 对象，同时 Map 和 Model 对象都可以直接通过 request 在请求域中获取到。传递的 Map 和 Model 底层其实是一个对象\n@RequestMapping(&quot;&#x2F;goto&quot;)\npublic String gotoPage(HttpServletRequest request,\n                       Map&lt;String,Object&gt; map,\n                       Model model,\n                       HttpServletResponse response)&#123;\n    map.put(&quot;map&quot;,&quot;map&quot;);\n    model.addAttribute(&quot;model&quot;,&quot;model&quot;);\n    request.setAttribute(&quot;code&quot;,200);\n\n    Cookie cookie &#x3D; new Cookie(&quot;c1&quot;,&quot;v1&quot;);\n    response.addCookie(cookie);\n\n    return &quot;forward:&#x2F;success&quot;;\n&#125;\n\n@ResponseBody\n@RequestMapping(&quot;&#x2F;success&quot;)\npublic Map success(HttpServletRequest request,\n                  @CookieValue(&quot;c1&quot;) String c1)&#123;\n    Object map &#x3D; request.getAttribute(&quot;map&quot;);\n    Object model &#x3D; request.getAttribute(&quot;model&quot;);\n    Object code &#x3D; request.getAttribute(&quot;code&quot;);\n&#125;\n\n5.4 矩阵变量\n语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd\nSpring Boot 默认是禁用了矩阵变量的功能手动开启：原理。对于路径的处理，UrlPathHelper 进行解析。removeSemicolonContent（移除分号内容） 支持矩阵变量的\n矩阵变量必须有 URL 路径变量才能被解析\n\n假如 Cookie 被禁用了，Session 里的内容怎么使用session.set(a,b)   —&gt; jsessionid   —&gt; cookie   —&gt; 每次发送请求携带\nurl 重写：/abc;jsessionid=xxx   把 Cookie 的值使用矩阵变量进行传递\n5.4.1 配置类开启矩阵变量默认移除 url 地址中的 ; 符号，设置值为 false 则开启矩阵变量\n\n实现 WebMvcConfigurer 接口，注入 Bean@Configuration\npublic class MyConfig implements WebMvcConfigurer&#123;\n    @Bean\n\tpublic WebMvcConfigurer webMvcConfigurer()&#123;\n\t\treturn new WebMvcConfigurer() &#123;\n\t\t\t@Override\n\t\t\tpublic void configurePathMatch(PathMatchConfigurer configurer) &#123;\n\t\t\t\tUrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();\n\t\t\t\turlPathHelper.setRemoveSemicolonContent(false);\n\t\t\t\tconfigurer.setUrlPathHelper(urlPathHelper);\n\t\t\t&#125;\n\t\t&#125;;\n\t&#125;\n&#125;\n实现 WebMvcConfigurer 接口，重写 configurePathMatch 方法@Configuration\npublic class MyConfig implements WebMvcConfigurer&#123;\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) &#123;\n        UrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();\n        urlPathHelper.setRemoveSemicolonContent(false);\n        configurer.setUrlPathHelper(urlPathHelper);\n    &#125;\n&#125;\n\n5.4.2  获取矩阵变量http://localhost:8080/cars/sell;low=34;brand=byd,audi,ydhttp://localhost:8080/cars/sell;low=34;brand=byd;brand=audi;brand=yd\n@RequestMapping(&quot;&#x2F;cars&#x2F;&#123;path&#125;&quot;) &#x2F;&#x2F; 包括后面的分号内容也算路径\npublic Map&lt;String,Object&gt; carsSell(@MatrixVariable(&quot;low&quot;) Integer low,\n                                   @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand,\n                                   @PathVariable(&quot;path&quot;) String path)&#123;\n  \n&#125;\n\nhttp://localhost:8080/boss/1;age=10/2;age=20\n@RequestMapping(&quot;&#x2F;boss&#x2F;&#123;bossId&#125;&#x2F;&#123;empId&#125;&quot;)\npublic Map&lt;String,Object&gt; boss(@MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;bossId&quot;) int bossAge,\n                               @MatrixVariable(value &#x3D; &quot;age&quot;,pathVar &#x3D; &quot;empId&quot;) int empAge)&#123;\n   \n&#125;\n\n5.5 Servlet APIWebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId\nServletRequestMethodArgumentResolver  以上的部分参数：\n@Override\npublic boolean supportsParameter(MethodParameter parameter) &#123;\n\t\tClass&lt;?&gt; paramType &#x3D; parameter.getParameterType();\n\t\treturn (WebRequest.class.isAssignableFrom(paramType) ||\n\t\t\t\tServletRequest.class.isAssignableFrom(paramType) ||\n\t\t\t\tMultipartRequest.class.isAssignableFrom(paramType) ||\n\t\t\t\tHttpSession.class.isAssignableFrom(paramType) ||\n\t\t\t\t(pushBuilder !&#x3D; null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||\n\t\t\t\tPrincipal.class.isAssignableFrom(paramType) ||\n\t\t\t\tInputStream.class.isAssignableFrom(paramType) ||\n\t\t\t\tReader.class.isAssignableFrom(paramType) ||\n\t\t\t\tHttpMethod.class &#x3D;&#x3D; paramType ||\n\t\t\t\tLocale.class &#x3D;&#x3D; paramType ||\n\t\t\t\tTimeZone.class &#x3D;&#x3D; paramType ||\n\t\t\t\tZoneId.class &#x3D;&#x3D; paramType);\n&#125;\n\n5.6 复杂参数Map、Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、Errors&#x2F;BindingResult、RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder\nMap&lt;String,Object&gt; map,  Model model, HttpServletRequest request 都是可以给request域中放数据，\nrequest.getAttribute();\n\nMap、Model类型的参数，会返回 mavContainer.getModel（）；—&gt; BindingAwareModelMap 是 Model 也是 Map\nmavContainer.getModel(); 获取到值的\n5.6 POJO 数据绑定可以自动类型转换与格式化，可以级联封装，ServletModelAttributeMethodProcessor\n5.6.1 普通数据绑定HTML 页面，提交后可自动绑定到 Person 类\n&lt;form action&#x3D;&quot;&#x2F;saveUser&quot; method&#x3D;&quot;post&quot;&gt;\n    姓名：&lt;input name&#x3D;&quot;username&quot; value&#x3D;&quot;zhangsan&quot; &#x2F;&gt; &lt;br&gt;\n    年龄：&lt;input name&#x3D;&quot;age&quot; value&#x3D;&quot;16&quot;&gt;&lt;br&gt;\n&lt;!--    宠物姓名：&lt;input name&#x3D;&quot;pet.name&quot; value&#x3D;&quot;猫&quot;&gt;&lt;br&gt;--&gt;\n&lt;!--    宠物年龄：&lt;input name&#x3D;&quot;pet.age&quot; value&#x3D;&quot;18&quot;&gt;--&gt;\n    &lt;input name&#x3D;&quot;pet&quot; value&#x3D;&quot;狗,3&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n\nController 类\nBean\npublic class Person &#123;\n    private String username;\n    private int age;\n    private Pet pet;\n&#125;\n\nController\n@ResponseBody\n@RequestMapping(&quot;&#x2F;saveUser&quot;)\npublic Person saveUser(Person person)&#123;\n    return person;\n&#125;\n\n5.6.2 自定义数据绑定&lt;input name=&quot;pet&quot; value=&quot;狗,3&quot;&gt;，配置类设置 convert，将传进来的值以 ， 进行分割，第一个为姓名，第二个为年龄\n@Bean\npublic WebMvcConfigurer webMvcConfigurer()&#123;\n    return new WebMvcConfigurer() &#123;\n\t\t@Override\n\t\tpublic void addFormatters(FormatterRegistry registry) &#123;\n\t\t\tregistry.addConverter(new Converter&lt;String, Pet&gt;() &#123;\n\t\t\t\t@Override\n\t\t\t\tpublic Pet convert(String s) &#123;\n\t\t\t\t\tif (!s.isEmpty())&#123;\n\t\t\t\t\t\tPet pet &#x3D; new Pet();\n\t\t\t\t\t\tString[] split &#x3D; s.split(&quot;,&quot;);\n\t\t\t\t\t\tpet.setName(split[0]);\n\t\t\t\t\t\tpet.setAge(Integer.parseInt(split[1]));\n\t\t\t\t\t\treturn pet;\n\t\t\t\t\t&#125;\n\t\t\t\t\treturn null;\n\t\t\t\t&#125;\n\t\t\t&#125;);\n\t\t&#125;\n\t&#125;;\n&#125;\n\n5.7 参数处理原理\nHandlerMapping 中找到能处理请求的 Handler（Controller.method()）\n为当前 Handler 找一个适配器 HandlerAdapter； RequestMappingHandlerAdapter\n适配器执行目标方法并确定方法参数的每一个值\n\n5.7.1 HandlerAdapter0 - 支持方法上标注 @RequestMapping1 - 支持函数式编程的xxxxxx\n5.7.2 执行目标方法&#x2F;&#x2F; Actually invoke the handler.\n&#x2F;&#x2F;DispatcherServlet -- doDispatch\nmv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n\nmav &#x3D; invokeHandlerMethod(request, response, handlerMethod); &#x2F;&#x2F;执行目标方法\n\n&#x2F;&#x2F;ServletInvocableHandlerMethod\nObject returnValue &#x3D; invokeForRequest(webRequest, mavContainer, providedArgs);\n&#x2F;&#x2F;获取方法的参数值\nObject[] args &#x3D; getMethodArgumentValues(request, mavContainer, providedArgs);\n\n5.7.3 参数解析器 HandlerMethodArgumentResolver\n确定将要执行的目标方法的每一个参数的值是什么\nSpringMVC 目标方法能写多少种参数类型。取决于参数解析器\n\n\n\n当前解析器是否支持解析这种参数\n支持就调用 resolveArgument\n\n5.6.4 返回值处理器\n5.6.5 如何确定目标方法每一个参数的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;InvocableHandlerMethod&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception &#123;\n\n\t\tMethodParameter[] parameters &#x3D; getMethodParameters();\n\t\tif (ObjectUtils.isEmpty(parameters)) &#123;\n\t\t\treturn EMPTY_ARGS;\n\t\t&#125;\n\n\t\tObject[] args &#x3D; new Object[parameters.length];\n\t\tfor (int i &#x3D; 0; i &lt; parameters.length; i++) &#123;\n\t\t\tMethodParameter parameter &#x3D; parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\targs[i] &#x3D; findProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] !&#x3D; null) &#123;\n\t\t\t\tcontinue;\n\t\t\t&#125;\n\t\t\tif (!this.resolvers.supportsParameter(parameter)) &#123;\n\t\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));\n\t\t\t&#125;\n\t\t\ttry &#123;\n\t\t\t\targs[i] &#x3D; this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t\t\t&#125;\n\t\t\tcatch (Exception ex) &#123;\n\t\t\t\t&#x2F;&#x2F; Leave stack trace for later, exception may actually be resolved and handled...\n\t\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\t\tString exMsg &#x3D; ex.getMessage();\n\t\t\t\t\tif (exMsg !&#x3D; null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;\n\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tthrow ex;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn args;\n&#125;\n\n5.6.5.1 挨个判断所有参数解析器那个支持解析这个参数@Nullable\nprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;\n\tHandlerMethodArgumentResolver result &#x3D; this.argumentResolverCache.get(parameter);\n\tif (result &#x3D;&#x3D; null) &#123;\n\t\tfor (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123;\n\t\t\tif (resolver.supportsParameter(parameter)) &#123;\n\t\t\t\tresult &#x3D; resolver;\n\t\t\t\tthis.argumentResolverCache.put(parameter, result);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn result;\n&#125;\n\n5.6.5.2 解析这个参数的值调用各自 HandlerMethodArgumentResolver 的 resolveArgument 方法即可\n5.6.5.3 自定义类型参数 封装 POJOServletModelAttributeMethodProcessor  这个参数处理器支持是否为简单类型\npublic static boolean isSimpleValueType(Class&lt;?&gt; type) &#123;\n\t\treturn (Void.class !&#x3D; type &amp;&amp; void.class !&#x3D; type &amp;&amp;\n\t\t\t\t(ClassUtils.isPrimitiveOrWrapper(type) ||\n\t\t\t\tEnum.class.isAssignableFrom(type) ||\n\t\t\t\tCharSequence.class.isAssignableFrom(type) ||\n\t\t\t\tNumber.class.isAssignableFrom(type) ||\n\t\t\t\tDate.class.isAssignableFrom(type) ||\n\t\t\t\tTemporal.class.isAssignableFrom(type) ||\n\t\t\t\tURI.class &#x3D;&#x3D; type ||\n\t\t\t\tURL.class &#x3D;&#x3D; type ||\n\t\t\t\tLocale.class &#x3D;&#x3D; type ||\n\t\t\t\tClass.class &#x3D;&#x3D; type));\n&#125;\n\n@Override\n@Nullable\npublic final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;\n\n\t\tAssert.state(mavContainer !&#x3D; null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;);\n\t\tAssert.state(binderFactory !&#x3D; null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;);\n\n\t\tString name &#x3D; ModelFactory.getNameForParameter(parameter);\n\t\tModelAttribute ann &#x3D; parameter.getParameterAnnotation(ModelAttribute.class);\n\t\tif (ann !&#x3D; null) &#123;\n\t\t\tmavContainer.setBinding(name, ann.binding());\n\t\t&#125;\n\n\t\tObject attribute &#x3D; null;\n\t\tBindingResult bindingResult &#x3D; null;\n\n\t\tif (mavContainer.containsAttribute(name)) &#123;\n\t\t\tattribute &#x3D; mavContainer.getModel().get(name);\n\t\t&#125;\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F; Create attribute instance\n\t\t\ttry &#123;\n\t\t\t\tattribute &#x3D; createAttribute(name, parameter, binderFactory, webRequest);\n\t\t\t&#125;\n\t\t\tcatch (BindException ex) &#123;\n\t\t\t\tif (isBindExceptionRequired(parameter)) &#123;\n\t\t\t\t\t&#x2F;&#x2F; No BindingResult parameter -&gt; fail with BindException\n\t\t\t\t\tthrow ex;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; Otherwise, expose null&#x2F;empty value and associated BindingResult\n\t\t\t\tif (parameter.getParameterType() &#x3D;&#x3D; Optional.class) &#123;\n\t\t\t\t\tattribute &#x3D; Optional.empty();\n\t\t\t\t&#125;\n\t\t\t\tbindingResult &#x3D; ex.getBindingResult();\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (bindingResult &#x3D;&#x3D; null) &#123;\n\t\t\t&#x2F;&#x2F; Bean property binding and validation;\n\t\t\t&#x2F;&#x2F; skipped in case of binding failure on construction.\n\t\t\tWebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, attribute, name);\n\t\t\tif (binder.getTarget() !&#x3D; null) &#123;\n\t\t\t\tif (!mavContainer.isBindingDisabled(name)) &#123;\n\t\t\t\t\tbindRequestParameters(binder, webRequest);\n\t\t\t\t&#125;\n\t\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\t\tif (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;\n\t\t\t\t\tthrow new BindException(binder.getBindingResult());\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\t&#x2F;&#x2F; Value type adaptation, also covering java.util.Optional\n\t\t\tif (!parameter.getParameterType().isInstance(attribute)) &#123;\n\t\t\t\tattribute &#x3D; binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);\n\t\t\t&#125;\n\t\t\tbindingResult &#x3D; binder.getBindingResult();\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Add resolved attribute and BindingResult at the end of the model\n\t\tMap&lt;String, Object&gt; bindingResultModel &#x3D; bindingResult.getModel();\n\t\tmavContainer.removeAttributes(bindingResultModel);\n\t\tmavContainer.addAllAttributes(bindingResultModel);\n\n\t\treturn attribute;\n&#125;\n\n\nWebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, attribute, name);\nWebDataBinder：Web 数据绑定器，将请求参数的值绑定到指定的 JavaBean 里面\nWebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到 JavaBean 中\n\nGenericConversionService：在设置每一个值的时候，找它里面的所有 converter 哪个可以将这个数据类型（request 带来参数的字符串）转换到指定的类型（JavaBean – Integer）byte – &gt; file\n@FunctionalInterfacepublic interface Converter&lt;S, T&gt;可以给 WebDataBinder 里面自定义 Converter。private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt;\n自定义 Converter\n&#x2F;&#x2F; 1、WebMvcConfigurer定制化SpringMVC的功能\n@Bean\npublic WebMvcConfigurer webMvcConfigurer()&#123;\n        return new WebMvcConfigurer() &#123;\n            @Override\n            public void configurePathMatch(PathMatchConfigurer configurer) &#123;\n                UrlPathHelper urlPathHelper &#x3D; new UrlPathHelper();\n                &#x2F;&#x2F; 不移除；后面的内容。矩阵变量功能就可以生效\n                urlPathHelper.setRemoveSemicolonContent(false);\n                configurer.setUrlPathHelper(urlPathHelper);\n            &#125;\n\n            @Override\n            public void addFormatters(FormatterRegistry registry) &#123;\n                registry.addConverter(new Converter&lt;String, Pet&gt;() &#123;\n\n                    @Override\n                    public Pet convert(String source) &#123;\n                        &#x2F;&#x2F; 啊猫,3\n                        if(!StringUtils.isEmpty(source))&#123;\n                            Pet pet &#x3D; new Pet();\n                            String[] split &#x3D; source.split(&quot;,&quot;);\n                            pet.setName(split[0]);\n                            pet.setAge(Integer.parseInt(split[1]));\n                            return pet;\n                        &#125;\n                        return null;\n                    &#125;\n                &#125;);\n            &#125;\n        &#125;;\n&#125;\n\n5.6.6 目标方法执行完成将所有的数据都放在 ModelAndViewContainer；包含要去的页面地址 View。还包含 Model 数据\n5.6.7 处理派发结果processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\nrenderMergedOutputModel(mergedModel, getRequestToExpose(request), response);\nInternalResourceView：\n@Override\nprotected void renderMergedOutputModel(\n\t\t\tMap&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n\n\t\t&#x2F;&#x2F; Expose the model object as request attributes.\n\t\texposeModelAsRequestAttributes(model, request);\n\n\t\t&#x2F;&#x2F; Expose helpers as request attributes, if any.\n\t\texposeHelpers(request);\n\n\t\t&#x2F;&#x2F; Determine the path for the request dispatcher.\n\t\tString dispatcherPath &#x3D; prepareForRendering(request, response);\n\n\t\t&#x2F;&#x2F; Obtain a RequestDispatcher for the target resource (typically a JSP).\n\t\tRequestDispatcher rd &#x3D; getRequestDispatcher(request, dispatcherPath);\n\t\tif (rd &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +\n\t\t\t\t\t&quot;]: Check that the corresponding file exists within your web application archive!&quot;);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; If already included or response already committed, perform include, else forward.\n\t\tif (useInclude(request, response)) &#123;\n\t\t\tresponse.setContentType(getContentType());\n\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\tlogger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;);\n\t\t\t&#125;\n\t\t\trd.include(request, response);\n\t\t&#125;\n\n\t\telse &#123;\n\t\t\t&#x2F;&#x2F; Note: The forwarded resource is supposed to determine the content type itself.\n\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\tlogger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;);\n\t\t\t&#125;\n\t\t\trd.forward(request, response);\n\t\t&#125;\n&#125;\n\n暴露模型作为请求域属性\n&#x2F;&#x2F; Expose the model object as request attributes.\nexposeModelAsRequestAttributes(model, request);\n\nprotected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model,\n\t\t\tHttpServletRequest request) throws Exception &#123;\n\n    &#x2F;&#x2F;model中的所有数据遍历挨个放在请求域中\n\t\tmodel.forEach((name, value) -&gt; &#123;\n\t\t\tif (value !&#x3D; null) &#123;\n\t\t\t\trequest.setAttribute(name, value);\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\trequest.removeAttribute(name);\n\t\t\t&#125;\n\t\t&#125;);\n&#125;\n\n5.8 响应处理5.8.1 响应 JSONjackson.jar + @ResponseBody，给前端自动返回 JSON 数据\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\nweb 场景自动引入了 json 场景\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-json&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n    &lt;scope&gt;compile&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n5.8.1.1 返回值解析器\ntry &#123;\n\tthis.returnValueHandlers.handleReturnValue(\n\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n&#125;\n\n@Override\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;\n\n\t\tHandlerMethodReturnValueHandler handler &#x3D; selectHandler(returnValue, returnType);\n\t\tif (handler &#x3D;&#x3D; null) &#123;\n\t\t\tthrow new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());\n\t\t&#125;\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n&#125;\n\nRequestResponseBodyMethodProcessor  \n@Override\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;\n\n\t\tmavContainer.setRequestHandled(true);\n\t\tServletServerHttpRequest inputMessage &#x3D; createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage &#x3D; createOutputMessage(webRequest);\n\n\t\t&#x2F;&#x2F; Try even with null return value. ResponseBodyAdvice could get involved.\n        &#x2F;&#x2F; 使用消息转换器进行写出操作\n\t\twriteWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n&#125;\n\n5.8.1.2 返回值解析器原理\n\n返回值处理器判断是否支持这种类型返回值 supportsReturnType\n返回值处理器调用 handleReturnValue 进行处理\nRequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的\n利用 MessageConverters 进行处理 将数据写为 JSON\n内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）\n服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据\nSpringMVC 会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理\n得到 MappingJackson2HttpMessageConverter 可以将对象写为 JSON\n利用 MappingJackson2HttpMessageConverter 将对象转为 JSON 再写出去\n\n\n\n\n\n\n\n\n5.8.1.3 SpringMVC 支持哪些返回值ModelAndView\nModel\nView\nResponseEntity \nResponseBodyEmitter\nStreamingResponseBody\nHttpEntity\nHttpHeaders\nCallable\nDeferredResult\nListenableFuture\nCompletionStage\nWebAsyncTask\n有 @ModelAttribute 且为对象类型的\n@ResponseBody 注解 ---&gt; RequestResponseBodyMethodProcessor；\n\n5.8.1.4 HTTPMessageConverter 原理\nMessageConverter 规范HttpMessageConverter：看是否支持将 此 Class 类型的对象，转为 MediaType 类型的数据例：Person 对象转为 JSON。或者 JSON 转为 Person\n默认的 MessageConverter0 - 只支持 Byte 类型的1 - String2 - String3 - Resource4 - ResourceRegion5 - DOMSource.class \\ SAXSource.class) \\ StAXSource.class \\StreamSource.class \\Source.class6 - MultiValueMap7 - true8 - true9 - 支持注解方式 XML 处理的最终 MappingJackson2HttpMessageConverter  把对象转为JSON（利用底层的 jackson 的 objectMapper 转换的）\n\n5.8.2 内容协商\n浏览器发送请求，在请求头中，Accept 传递可支持什么格式的返回内容，q 代表权重，优先级。*/* 表示所有格式都支持返回Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n服务器接收到数据后，判断浏览器要什么格式的返回内容，然后自己能够提供什么的格式返回内容。最优匹配。由 Accept 参数可知：xhtml 和 xml 优先级大于其他的返回格式，这个在请求头内。我们需要某种返回格式时需要指定参数，请求参数。可以使用 format 指定传递所需要的返回格式\n开启基于请求参数的内容协商功能http://localhost:8080/test/person?format=json\n\nspring:\n    contentnegotiation:\n      favor-parameter: true\n\n&lt;!-- 引入 xml 依赖 --&gt; \n&lt;dependency&gt;\n\t&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;jackson-dataformat-xml&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n5.8.3 内容协商原理\n判断当前响应头中是否已经有确定的媒体类型。MediaType\n\n获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端 Accept请求头字段）【application&#x2F;xml】\n\ncontentNegotiationManager 内容协商管理器 默认使用基于请求头的策略\n\n**HeaderContentNegotiationStrategy  确定客户端可以接收的内容类型 **\n\n\n\n遍历循环所有当前系统的 MessageConverter，看谁支持操作这个对象（Person）\n\n找到支持操作 Person 的 converter，把 converter 支持的媒体类型统计出来\n\n客户端需要【application&#x2F;xml】。服务端能力【10种、json、xml】\n\n进行内容协商的最佳匹配媒体类型\n\n用支持将对象转为最佳匹配媒体类型的 converter。调用它进行转化\n\n\n导入了 jackson 处理 xml 的包，xml 的 converter 就会自动进来\nWebMvcConfigurationSupport\njackson2XmlPresent &#x3D; ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);\n\nif (jackson2XmlPresent) &#123;\n\t\t\tJackson2ObjectMapperBuilder builder &#x3D; Jackson2ObjectMapperBuilder.xml();\n\t\t\tif (this.applicationContext !&#x3D; null) &#123;\n\t\t\t\tbuilder.applicationContext(this.applicationContext);\n\t\t\t&#125;\n\t\t\tmessageConverters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));\n&#125;\n\n5.8.4 自定义数据格式5.8.4.1 先定义一个 Converter，设置自定义格式public class XMessageConverter implements HttpMessageConverter&lt;Person&gt; &#123;  &#x2F;&#x2F; 返回Person格式\n    @Override\n    public boolean canRead(Class aClass, MediaType mediaType) &#123;\n        return false;\n    &#125;\n\n    @Override\n    public boolean canWrite(Class aClass, MediaType mediaType) &#123;  &#x2F;&#x2F; 返回\n        return aClass.isAssignableFrom(Person.class);\n    &#125;\n\n    @Override\n    public List&lt;MediaType&gt; getSupportedMediaTypes() &#123;\n        return MediaType.parseMediaTypes(&quot;application&#x2F;x&quot;);   &#x2F;&#x2F; 设置支持为x格式 即 ?format&#x3D;x\n    &#125;\n\n    @Override\n    public Person read(Class&lt;? extends Person&gt; aClass, HttpInputMessage httpInputMessage) throws IOException, HttpMessageNotReadableException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public void write(Person person, MediaType mediaType, HttpOutputMessage httpOutputMessage) throws IOException, HttpMessageNotWritableException &#123;\n        String data &#x3D; person.getUsername() + &quot;;&quot; + person.getAge();\n        OutputStream body &#x3D; httpOutputMessage.getBody();\n        body.write(data.getBytes());                           &#x2F;&#x2F; 定义返回数据\n    &#125;\n&#125;\n\n5.8.4.2 在配置类的 WebMvcConfigurer 中配置一个额外的MessageConverterspublic class MyConfig &#123;\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer()&#123;\n        return new WebMvcConfigurer() &#123;\n            @Override\n            public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n                converters.add(new XMessageConverter());\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n5.8.4.3 设置请求参数策略将可传递的格式添加进 Map 集合里，添加了 json、xml 和自定义 x 格式，请求参数 json、xml和 x 格式则可正常返回。此时设置的是基于参数的策略 ParameterContentNegotiationStrategyhttp://localhost:8080/test/person?format=x\npublic class MyConfig &#123;\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer()&#123;\n        return new WebMvcConfigurer() &#123;\n            @Override\n            public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n                converters.add(new XMessageConverter());\n            &#125;\n    \n            @Override\n            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;\n                Map&lt;String, MediaType&gt; mediaTypes &#x3D; new HashMap&lt;&gt;();\n                mediaTypes.put(&quot;json&quot;,MediaType.APPLICATION_JSON);\n                mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML);\n                mediaTypes.put(&quot;x&quot;,MediaType.parseMediaType(&quot;application&#x2F;x&quot;));\n\n                ParameterContentNegotiationStrategy strategy &#x3D; new ParameterContentNegotiationStrategy(mediaTypes);\n                configurer.strategies(Arrays.asList(strategy));\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n5.8.4.4 添加请求头策略由于没有添加基于请求头的策略，这样设置会覆盖请求头策略，请求头的返回格式会失效。此时直接请求，不加 format 设置请求参数，无论请求头是什么返回格式都为添加进 Map 集合的第一个元素格式，即为 json 格式。优先级。假如想要请求头生效，需要再加一个基于请求头的策略 HeaderContentNegotiationStrategy。同样的，还可以添加更多的策略。http://localhost:8080/test/person\npublic class MyConfig &#123;\n    @Bean\n    public WebMvcConfigurer webMvcConfigurer()&#123;\n        return new WebMvcConfigurer() &#123;\n            @Override\n            public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n                converters.add(new XMessageConverter());\n            &#125;\n    \n            @Override\n            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;\n                Map&lt;String, MediaType&gt; mediaTypes &#x3D; new HashMap&lt;&gt;();\n                mediaTypes.put(&quot;json&quot;,MediaType.APPLICATION_JSON);\n                mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML);\n                mediaTypes.put(&quot;x&quot;,MediaType.parseMediaType(&quot;application&#x2F;x&quot;));\n\n                ParameterContentNegotiationStrategy strategy &#x3D; new ParameterContentNegotiationStrategy(mediaTypes);\n                HeaderContentNegotiationStrategy headerStrategy &#x3D; new HeaderContentNegotiationStrategy();\n                configurer.strategies(Arrays.asList(strategy,headerStrategy));\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n6. Thymeleaf 模板引擎https://www.thymeleaf.org/documentation.html\n6.1 引入6.1.1 引入 Starter&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n6.1.2 已自动配置public static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;\n\npublic static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;   &#x2F;&#x2F;xxx.html\n\n6.1.3 在 HTML 页面引入 Thymeleaf&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt; &lt;&#x2F;head&gt;\n&lt;body&gt; &lt;&#x2F;body&gt;\n\n6.2 使用语法6.2.1 条件运算&lt;a href&#x3D;&quot;comments.html&quot;\nth:href&#x3D;&quot;@&#123;&#x2F;product&#x2F;comments(prodId&#x3D;$&#123;prod.id&#125;)&#125;&quot;\nth:if&#x3D;&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;&gt;view&lt;&#x2F;a&gt; \n\n&lt;div th:switch&#x3D;&quot;$&#123;user.role&#125;&quot;&gt;\n  &lt;p th:case&#x3D;&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;&#x2F;p&gt;\n  &lt;p th:case&#x3D;&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;&#x2F;p&gt;\n  &lt;p th:case&#x3D;&quot;*&quot;&gt;User is some other thing&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n6.2.2 迭代&lt;tr th:each&#x3D;&quot;prod,status : $&#123;prods&#125;&quot;&gt;\n  \t\t\t&lt;td th:text&#x3D;&quot;$&#123;status.count&#125;&quot;&gt;id&lt;&#x2F;td&gt;   &#x2F;&#x2F; 计数\n        &lt;td th:text&#x3D;&quot;$&#123;prod.name&#125;&quot;&gt;name&lt;&#x2F;td&gt;\n        &lt;td th:text&#x3D;&quot;$&#123;prod.price&#125;&quot;&gt;price&lt;&#x2F;td&gt;\n        &lt;td th:text&#x3D;&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;isStock&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n\n6.2.3 链接 @前面加 &#x2F; ，会自动将访问路径添加进来，只需要写后面的资源路径就行\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;xxx&#125;&quot;&gt; &lt;&#x2F;a&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;xxx&#125;&quot;&gt; &lt;&#x2F;form&gt;\n\n携带参数在路径后面加上括号，如：@&#123;/xxx(id = xxx)&#125;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;xxx(id &#x3D; $&#123;user.id&#125;)&#125;&quot;&gt; &lt;&#x2F;a&gt;\n\n7. 拦截器7.1 创建拦截器，实现 HandlerInter 接口public class LoginInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        &#x2F;&#x2F;登录检查逻辑\n        HttpSession session &#x3D; request.getSession();\n        Object loginUser &#x3D; session.getAttribute(&quot;loginUser&quot;);\n        if(loginUser !&#x3D; null)&#123;\n            return true;\n        &#125;\n        &#x2F;&#x2F;拦截住。未登录。跳转到登录页\n        request.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);\n&#x2F;&#x2F;        re.sendRedirect(&quot;&#x2F;&quot;);\n        request.getRequestDispatcher(&quot;&#x2F;&quot;).forward(request,response);\n        return false;\n    &#125;\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n    &#125;\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n    &#125;\n&#125;\n\n7.2 配置拦截器同样的在 WebMvcConfigurer 里进行拦截器配置\n@Configuration\npublic class AdminWebConfig implements WebMvcConfigurer &#123;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(&quot;&#x2F;**&quot;)  &#x2F;&#x2F; 所有请求都被拦截包括静态资源\n\t\t \t\t.excludePathPatterns(&quot;&#x2F;&quot;,&quot;&#x2F;login&quot;,&quot;&#x2F;css&#x2F;**&quot;,&quot;&#x2F;fonts&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;,&quot;&#x2F;js&#x2F;**&quot;); &#x2F;&#x2F; 放行的请求\n    &#125;\n&#125;\n\n7.3 过滤器 Filter 和拦截器 Inteceptor 详解及使用场景7.3.1 过滤器和拦截器的区别\n\n过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入 Servlet 之前进行预处理的。 请求结束返回也是，是在 Servlet 处理完后，返回给前端之前\n拦截器可以获取 IOC 容器中的各个 bean，而过滤器就不行，因为拦截器是 Spring 提供并管理的，Spring 的功能可以被拦截器使用，在拦截器里注入一个Service，可以调用业务逻辑。而过滤器是 JavaEE 标准，只需依赖 Servlet API，不需要依赖 Spring\n过滤器的实现基于回调函数。而拦截器（代理模式）的实现基于反射\nFilter 是依赖于Servlet 容器，属于 Servlet 规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用\nFilter 的执行由 Servlet 容器回调完成，而拦截器通常通过动态代理（反射）的方式来执行\nFilter 的生命周期由 Servlet 容器管理，而拦截器则可以通过 IOC 容器来管理，因此可以通过注入等方式来获取其他 Bean 的实例，因此使用会更方便\n\n过滤器和拦截器非常相似，但是它们有很大的区别\n\n最简单明了的区别就是过滤器可以修改 request，而拦截器不能\n过滤器需要在 Servlet 容器中实现，拦截器可以适用于 JavaEE，JavaSE 等各种环境\n拦截器可以调用 IOC 容器中的各种依赖，而过滤器不能\n过滤器只能在请求的前后使用，而拦截器可以详细到每个方法\n\n\n\n过滤器（Filter） ：可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息\n拦截器（Interceptor）：可以拿到你请求的控制器和方法，却拿不到请求方法的参数\n切片（Aspect）: 可以拿到方法的参数，但是却拿不到 HTTP 请求和响应的对象\n\n7.3.2 应用场景拦截器是在 DispatcherServlet 这个 Servlet 中执行的，因此所有的请求最先进入 Filter，最后离开 Filter。其顺序如下：Filter -&gt; Interceptor.preHandle -&gt; Handler -&gt; Interceptor.postHandle -&gt; Interceptor.afterCompletion -&gt; Filter\n拦截器应用场景拦截器本质上是面向切面编程（AOP），符合横切关注点的功能都可以放在拦截器中来实现， 主要的应用场景包括：\n\n登录验证，判断用户是否登录。\n权限验证，判断用户是否有权限访问资源，如校验token\n日志记录，记录请求操作日志（用户ip，访问时间等），以便统计请求访问量。\n处理cookie、本地化、国际化、主题等。\n性能监控，监控请求处理时长等。\n通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现）\n\n过滤器应用场景\n过滤敏感词汇（防止sql注入）\n设置字符编码\nURL级别的权限访问控制\n压缩响应信息\n\n\n8. 文件上传8.1 HTML 页面设置 type 为 file，多文件上传需要设置 multiple 属性，表单提交方式需要为 post ，并且需要加 enctype 属性\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;upload&#125;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n  &lt;div class&#x3D;&quot;form-group&quot;&gt;\n\t\t&lt;label for&#x3D;&quot;exampleInputFile&quot;&gt;单文件上传&lt;&#x2F;label&gt;\n\t\t&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;headerImg&quot; id&#x3D;&quot;exampleInputFile&quot;&gt;\n\t\t&lt;p class&#x3D;&quot;help-block&quot;&gt;Example block-level help text here.&lt;&#x2F;p&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;div class&#x3D;&quot;form-group&quot;&gt;\n\t\t&lt;label for&#x3D;&quot;exampleInputFile&quot;&gt;多文件上传&lt;&#x2F;label&gt;\n\t\t&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;photos&quot; multiple&gt;\n\t\t&lt;p class&#x3D;&quot;help-block&quot;&gt;Example block-level help text here.&lt;&#x2F;p&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;form&gt;\n\n8.2 设置文件大小限制spring:\n  servlet:\n    multipart:\n      max-file-size: 10MB       &#x2F;&#x2F; 单个文件的最大大小\n      max-request-size: 50MB    &#x2F;&#x2F; 请求的总文件最大大小\n\n8.3 Controller 类使用 @RequestPart 接收文件，使用 transferTo 写出文件\n@Controller\npublic class FormTestController &#123;\n    @PostMapping(&quot;&#x2F;upload&quot;)\n    public String upload(@RequestParam(&quot;email&quot;) String email,  &#x2F;&#x2F; 参数值\n                         @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg, &#x2F;&#x2F; 文件上传接收\n                         @RequestPart(&quot;photos&quot;) MultipartFile[] photos)&#123; &#x2F;&#x2F; 多文件则数组接收\n        if (!headerImg.isEmpty())&#123;\n            String originalFilename &#x3D; headerImg.getOriginalFilename();  &#x2F;&#x2F; 获取文件原始名\n            try &#123;\n                headerImg.transferTo(new File(&quot;E:\\\\&quot; + originalFilename)); &#x2F;&#x2F; 服务器创建文件\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        if (photos.length &gt; 0)&#123;\n            for (MultipartFile photo : photos) &#123;\n                String originalFilename &#x3D; photo.getOriginalFilename();\n                try &#123;\n                    photo.transferTo(new File(&quot;E:\\\\&quot; + originalFilename));\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n        return &quot;main&quot;;\n    &#125;\n&#125;\n\n9. 异常处理默认规则\n\n默认情况下，Spring Boot 提供 &#x2F;error 处理所有错误的映射\n对于机器客户端，它将生成 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器客户端，响应一个 “whitelabel” 错误视图，以 HTML 格式呈现相同的数据\n要对其进行自定义，添加 View 解析为 error\n要完全替换默认行为，可以实现 ErrorController 并注册该类型的 Bean 定义，或添加 ErrorAttributes 类型的组件以使用现有机制但替换其内容\nerror&#x2F; 下的 4xx，5xx 页面会被自动解析\n\n9.1 自定义异常页面\n自定义错误页error&#x2F;404.html、error&#x2F;5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页\n@ControllerAdvice + @ExceptionHandler 处理全局异常；底层是 ExceptionHandlerExceptionResolver 支持的\n@ResponseStatus + 自定义异常 ；底层是 ResponseStatusExceptionResolver ，把 @ResponseStatus 注解的信息底层调用 response.sendError(statusCode, resolvedReason);Tomcat 发送的 &#x2F;error\nSpring 底层的异常，如 参数类型转换异常；DefaultHandlerExceptionResolver 处理框架底层的异常response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());\n\n可以通过以下 3 种方式定制 Spring Boot 错误页面：\n\n自定义 error.html\n自定义动态错误页面\n自定义静态错误页面\n\n9.2 界面优先级在 templates 文件夹或静态资源文件夹下，创建一个 error 文件夹，存放错误界面，会自动解析，跳转到自定义的错误界面可以直接在模板引擎文件夹（/resources/templates）下创建 error.html ，覆盖 Spring Boot 默认的错误视图页面（Whitelabel Error Page）上述 5 种方式均可以定制 Spring Boot 错误页面，且它们的优先级顺序为：\n\n自定义动态错误页面目录（精确匹配404.html）\n自定义静态错误页面目录（精确匹配404.html）\n自定义动态错误页面目录（模糊匹配4xx.html）\n自定义静态错误页面目录（模糊匹配404.html）\n自定义 error.html\n\n9.3 页面错误信息\nmessage：异常信息\nstatus：状态码\nerror：错误名称\npath：错误路径\ntimestamp：时间戳\n\n9.4 自定义全局异常处理创建一个全局异常处理类，加上 @ControllerAdvice 注解，增强。同时加上 @ExceptionHandler 注解。会跳转到返回的页面，返回异常属性要放入请求域中\nint num &#x3D; 1&#x2F;0;  &#x2F;&#x2F; 空指针\n\n&#x2F;&#x2F; 处理整个web controller 的异常\n@ControllerAdvice\npublic class GlobalExceptionHandler &#123;\n    @ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;) &#x2F;&#x2F; 处理全局异常\n    public String handleArithExcepyion()&#123;\n        return &quot;login&quot;; &#x2F;&#x2F; 视图地址\n    &#125;\n&#125;\n\n9.5 自定义异常类加上 @ResponseStatus 注解，继承 RuntimeException ，运行时异常。手动抛出异常\nif (list.size() &gt; 3)&#123;   &#x2F;&#x2F; 越界\n\tthrow new UserTooManyException();\n&#125;\n\n@ResponseStatus(value &#x3D; HttpStatus.FORBIDDEN,reason &#x3D; &quot;用户数量太多&quot;)\npublic class UserTooManyException extends RuntimeException&#123;    &#x2F;&#x2F; 越界异常\n    public UserTooManyException()&#123;\n    &#125;\n    public UserTooManyException(String message)&#123;\n        super(message);\n    &#125;\n&#125;\n\n会跳转到 &#x2F;error 目录下的异常页面，然后输出异常信息\n&lt;h1 th:text&#x3D;&quot;$&#123;message&#125;&quot;&gt;&lt;&#x2F;h1&gt;\n&lt;h1 th:text&#x3D;&quot;$&#123;error&#125;&quot;&gt;&lt;&#x2F;h1&gt;\n&lt;h1 th:text&#x3D;&quot;$&#123;status&#125;&quot;&gt;&lt;&#x2F;h1&gt;\n\n9.6 自定义异常解析器设置最高优先级后，所有的异常全部都会被自定义的异常解析器解析，所有的异常都会变成自定义异常解析器的异常。相当于全局异常处理规则。上面定义的所有异常都失效，全成为自定义异常解析器定义的异常。\n@Order(value &#x3D; Ordered.HIGHEST_PRECEDENCE)  &#x2F;&#x2F; 设置最高优先级\n@Component\npublic class CustomerHandleException implements HandlerExceptionResolver &#123;\n    @Override\n    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,\n                                         Object handler, Exception ex) &#123;\n        try &#123;\n            response.sendError(511,&quot;自定义错误&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return new ModelAndView();\n    &#125;\n&#125;\n\n9.7 定制错误数据自定义错误属性处理工具\n@Component\npublic class MyErrorAttributes extends DefaultErrorAttributes &#123;\n    @Override\n    public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) &#123;\n        Map&lt;String, Object&gt; errorAttributes &#x3D; super.getErrorAttributes(webRequest, options);\n        &#x2F;&#x2F; 添加自定义的错误数据\n        errorAttributes.put(&quot;company&quot;, &quot;www.biancheng.net&quot;);\n        &#x2F;&#x2F; 获取 MyExceptionHandler 传入 request 域中的错误数据\n        Map ext &#x3D; (Map) webRequest.getAttribute(&quot;ext&quot;, 0);\n        errorAttributes.put(&quot;ext&quot;, ext);\n        return errorAttributes;\n    &#125;\n&#125;\n\n10. Web 原生组件注入10.1 原生 API10.1.1 Servlet创建 Servlet ，在启动类加上 @ServletComponentScan 注解，配置包扫描\n@ServletComponentScan(basePackages &#x3D; &quot;fan&quot;)\n@SpringBootApplication\npublic class AdminmanagerApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(AdminmanagerApplication.class, args);\n    &#125;\n&#125;\n\n直接访问即可响应，http://localhost:8081/MyServlet\n@WebServlet(name &#x3D; &quot;MyServlet&quot;, value &#x3D; &quot;&#x2F;MyServlet&quot;)\n&#x2F;&#x2F; @WebServlet(urlPatterns &#x3D; &quot;&#x2F;my&quot;)\npublic class MyServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doPost(request,response);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        response.getWriter().write(&quot;6666&quot;);\n    &#125;\n&#125;\n\n10.1.2 Filter 和 Listener直接创建原生组件即可使用\n\n@ServletComponentScan(basePackages = &quot;com.atguigu.admin&quot;) ：指定原生Servlet组件都放在那里\n@WebServlet(urlPatterns = &quot;/my&quot;)：效果：直接响应，没有经过 Spring 的拦截器\n\n\n\n@WebFilter(urlPatterns=&#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;)\n@WebListener\n\n@WebFilter(filterName &#x3D; &quot;MyFilter&quot;, urlPatterns &#x3D; &quot;&#x2F;images&#x2F;*&quot;)\npublic class MyFilter implements Filter &#123;\n    @Override\n    public void init(FilterConfig config) throws ServletException &#123;\n        System.out.println(&quot;MyFilter初始化完成&quot;);\n    &#125;\n    @Override\n    public void destroy() &#123;\n        System.out.println(&quot;MyFilter销毁&quot;);\n    &#125;\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;\n        System.out.println(&quot;MyFilter工作&quot;);\n        chain.doFilter(request, response);\n    &#125;\n&#125;\n\n@WebListener\npublic class MyListener implements ServletContextListener, HttpSessionListener, HttpSessionAttributeListener &#123;\n    public MyListener() &#123;\n    &#125;\n    @Override\n    public void contextInitialized(ServletContextEvent sce) &#123;\n        &#x2F;* This method is called when the servlet context is initialized(when the Web application is deployed). *&#x2F;\n    &#125;\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) &#123;\n        &#x2F;* This method is called when the servlet Context is undeployed or Application Server shuts down. *&#x2F;\n    &#125;\n&#125;\n\n10.2 Spring Boot 的 RegistrationBean创建一个配置类，注入 RegistrationBean 的 Bean。不使用 @WebServlet 等注解，在 RegistrationBean 里注入\n10.2.1 Servlet@Configuration\npublic class MyRegisterConfig &#123;\n    @Bean\n    public ServletRegistrationBean myServlet()&#123;\n        MyServlet myServlet &#x3D; new MyServlet();      &#x2F;&#x2F; 创建的Servlet\n        return new ServletRegistrationBean(myServlet,&quot;&#x2F;myServlet&quot;,&quot;&#x2F;my&quot;);  &#x2F;&#x2F; servlet多路径\n    &#125;\n&#125;\n\n10.2.2 Filter@Configuration\npublic class MyRegisterConfig &#123;\n     @Bean\n    public ServletRegistrationBean myServlet()&#123;\n        MyServlet myServlet &#x3D; new MyServlet();      &#x2F;&#x2F; 创建的Servlet\n        return new ServletRegistrationBean(myServlet,&quot;&#x2F;myServlet&quot;,&quot;&#x2F;my&quot;);  &#x2F;&#x2F; servlet多路径\n    &#125;\n    @Bean\n    public FilterRegistrationBean myFilter()&#123;\n        MyFilter myFilter &#x3D; new MyFilter();         &#x2F;&#x2F; 创建的Filter\n&#x2F;&#x2F;        return new FilterRegistrationBean(myFilter,myServlet());  &#x2F;&#x2F; 直接配置过滤servlet\n        FilterRegistrationBean filterRegistrationBean &#x3D; new FilterRegistrationBean(myFilter);\n        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;&#x2F;my&quot;,&quot;&#x2F;css&#x2F;*&quot;)); &#x2F;&#x2F; 配置自定义路径\n        return filterRegistrationBean;\n    &#125;\n&#125;\n\n10.2.3 Listener@Configuration\npublic class MyRegisterConfig &#123;\n    @Bean\n    public ServletListenerRegistrationBean myListener()&#123;\n        MyListener myListener &#x3D; new MyListener();   &#x2F;&#x2F; 创建的Listener\n        return new ServletListenerRegistrationBean(myListener);\n    &#125;\n&#125;\n\n10.3 切换 Web 服务器\n排除 Web 的 Tomcat 服务器&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n引入其他服务器&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n10.4 定制 Servlet 容器\n实现  WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;把配置文件的值和 ServletWebServerFactory 进行绑定xxxxxCustomizer：定制化器，可以改变 xxxx 的默认规则@Component\npublic class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123;\n    @Override\n    public void customize(ConfigurableServletWebServerFactory server) &#123;\n        server.setPort(9000);\n    &#125;\n\n&#125;\n修改配置文件 server.xxx\n直接自定义 ConfigurableServletWebServerFactory\n\n10.5 定制化原理\n修改配置文件\nxxxxxCustomizer\n编写自定义的配置类   xxxConfiguration；+ @Bean 替换、增加容器中默认组件；视图解析器\nWeb应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；+ @Bean给容器中再扩展一些组件\n@EnableWebMvc + WebMvcConfigurer —— @Bean  可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能原理：\nWebMvcAutoConfiguration  默认的 SpringMVC 的自动配置功能类。静态资源、欢迎页…..\n一旦使用 @EnableWebMvc 。会 @Import(DelegatingWebMvcConfiguration.class)\nDelegatingWebMvcConfiguration 的 作用，只保证 SpringMVC 最基本的使用\n把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer  合起来一起生效\n自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport\n\n\nWebMvcAutoConfiguration 里面的配置要能生效 必须  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\n@EnableWebMvc  导致了 WebMvcAutoConfiguration  没有生效\n\n\n\n场景 starter - xxxxAutoConfiguration - 导入 xxx 组件 - 绑定 xxxProperties – 绑定配置文件项\n11. JDBC 导入与 Druid 数据源11.1 JDBC 导入11.1.1 导入 Starter&lt;dependency&gt;\n  \t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n数据源的自动配置-HikariDataSource自动配置的类：\n\nDataSourceAutoConfiguration ： 数据源的自动配置\n\n修改数据源相关的配置：spring.datasource\n数据库连接池的配置，是自己容器中没有 DataSource 才自动配置的\n底层配置好的连接池是：HikariDataSource\n\n@Configuration(proxyBeanMethods &#x3D; false)\n@Conditional(PooledDataSourceCondition.class)\n@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)\n@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,\n\t\t\tDataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,\n\t\t\tDataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;)\nprotected static class PooledDataSourceConfiguration\nDataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置\n\nJdbcTemplateAutoConfiguration： JdbcTemplate 的自动配置，可以来对数据库进行crud\n\n可以修改这个配置项 @ConfigurationProperties(prefix = &quot;spring.jdbc&quot;) 来修改JdbcTemplate\n@Bean @Primary    JdbcTemplate；容器中有这个组件\n\n\nJndiDataSourceAutoConfiguration： jndi 的自动配置\n\nXADataSourceAutoConfiguration： 分布式事务相关的\n\n\n11.1.2 导入数据库驱动Spring Boot自带版本仲裁，因此可以不用写版本信息，目前默认版本为 8.0.26 。同时 MySQL 驱动高版本兼容低版本。即使电脑版本为 MySQL 5 也可使用 MySQL 8 的驱动。修改版本直接加版本信息即可\n&lt;dependency&gt;\n\t\t&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n&lt;!--\t&lt;version&gt;5.1.49&lt;&#x2F;version&gt;\t\t--&gt;\n&lt;&#x2F;dependency&gt;\n\n修改配置项，url 、username 、 password 、driver-class-name 属性\nspring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;&#x2F;xxx\n    username: root\n    password: xxx\n    driver-class-name: com.mysql.jdbc.Driver # 会自动适配高版本写法\n#    driver-class-name: com.mysql.cj.jdbc.Driver    &#x2F;&#x2F; 高版本写法\n\n11.2 JdbcTemplate\n可修改配置项spring:\n  jdbc:\n    template:\n      query-timeout: 3    &#x2F;&#x2F; 单位为秒\n自动配置已经自动配置好 JdbcTemplate ，自动注入使用即可@Autowired\nJdbcTemplate jdbcTemplate;\n\n@ResponseBody\n@GetMapping(&quot;&#x2F;sql&quot;)\npublic String sql()&#123;\n\tString sql &#x3D; &quot;select count(*) from user&quot;;\n\tInteger integer &#x3D; jdbcTemplate.queryForObject(sql, Integer.class);\n\treturn integer.toString();\n&#125;\n\n11.3 Druid 数据源https://github.com/alibaba/druid/wiki/常见问题\n11.3.1 自定义方式11.3.1.1 引入 Druid 依赖&lt;dependency&gt;\n\t&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;1.1.14&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n11.3.1.2 创建配置类@Configuration\npublic class MyDataSourceConfig &#123;\n    @Bean\n    public DataSource dataSource() throws SQLException &#123;\n        DruidDataSource druidDataSource &#x3D; new DruidDataSource();\n        druidDataSource.setUrl();\n        druidDataSource.setUsername();\n        druidDataSource.setPassword();\n        return druidDataSource;\n    &#125;\n&#125;\n\n需要设置 url、username、password 等属性，可以使用配置文件来进行配置，由于与 JDBC 配置属性相同，可以使用 @ConfigurationProperties 注解引入 JDBC 的配置信息\n@Configuration\npublic class MyDataSourceConfig &#123;\n    @ConfigurationProperties(&quot;spring.datasource&quot;)\n    @Bean\n    public DataSource dataSource() throws SQLException &#123;\n        DruidDataSource druidDataSource &#x3D; new DruidDataSource();\n        return druidDataSource;\n    &#125;\n&#125;\n\n可使用 XML 配置文件方式\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;\n\t\tdestroy-method&#x3D;&quot;close&quot;&gt;\n\t\t&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;20&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;initialSize&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;maxWait&quot; value&#x3D;&quot;60000&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;minIdle&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;timeBetweenEvictionRunsMillis&quot; value&#x3D;&quot;60000&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;minEvictableIdleTimeMillis&quot; value&#x3D;&quot;300000&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;testWhileIdle&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;testOnBorrow&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;testOnReturn&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;poolPreparedStatements&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n\t\t&lt;property name&#x3D;&quot;maxOpenPreparedStatements&quot; value&#x3D;&quot;20&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n11.3.1.3 监控统计功能http://localhost:8080/druid\n\n开启监控统计和防火墙\n@Configuration\npublic class MyDataSourceConfig &#123;\n    @ConfigurationProperties(&quot;spring.datasource&quot;)\n    @Bean\n    public DataSource dataSource() throws SQLException &#123;\n        DruidDataSource druidDataSource &#x3D; new DruidDataSource();\n&#x2F;&#x2F;        druidDataSource.setFilters(&quot;stat,wall&quot;);    &#x2F;&#x2F; 开启监控统计、防火墙\n        return druidDataSource;\n    &#125;\n&#125;\n同样可在配置文件中配置 filters 属性\nspring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;&#x2F;db1\n    username: root\n    password: fan223\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n    filters: stat,wall   &#x2F;&#x2F; 配置监控统计、防火墙\nStatViewServlet提供监控信息展示的 HTML 页面、提供监控信息的 JSON API可以在 StatViewServlet 中设置登录用户名和密码，设置后输入用户名和密码才可以进行监控\n@Configuration\npublic class MyDataSourceConfig &#123;\n    @Bean\n    public ServletRegistrationBean statViewServlet()&#123;\n        StatViewServlet statViewServlet &#x3D; new StatViewServlet();\n        ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean &#x3D; new ServletRegistrationBean&lt;&gt;(statViewServlet,&quot;&#x2F;druid&#x2F;*&quot;);\n        registrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;admin&quot;);  &#x2F;&#x2F; 登录用户名\n        registrationBean.addInitParameter(&quot;loginPassword&quot;,&quot;123&quot;);\t &#x2F;&#x2F; 登录密码\n        return registrationBean;\n    &#125;\n&#125;\n\n&lt;servlet&gt;\n\t&lt;servlet-name&gt;DruidStatView&lt;&#x2F;servlet-name&gt;\n\t&lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n&lt;servlet-mapping&gt;\n\t&lt;servlet-name&gt;DruidStatView&lt;&#x2F;servlet-name&gt;\n\t&lt;url-pattern&gt;&#x2F;druid&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\nStatFilter用于统计监控信息，如 SQL 监控、URL 监控\n@Configuration\npublic class MyDataSourceConfig &#123;\n    @Bean\n    public FilterRegistrationBean webStatFilter()&#123;\n        WebStatFilter webStatFilter &#x3D; new WebStatFilter();\n        FilterRegistrationBean&lt;WebStatFilter&gt; webStatFilterFilterRegistrationBean &#x3D; new FilterRegistrationBean&lt;&gt;(webStatFilter);\n        webStatFilterFilterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;&#x2F;*&quot;));    &#x2F;&#x2F; 拦截路径\n        webStatFilterFilterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&quot;); &#x2F;&#x2F; 释放路径\n        return webStatFilterFilterRegistrationBean;\n    &#125;\n&#125;\n\n需要给数据源中配置如下属性；可以允许多个filter，多个用，分割；如：\n\n&lt;property name&#x3D;&quot;filters&quot; value&#x3D;&quot;stat,slf4j&quot; &#x2F;&gt;\n系统中所有 Filter：| 别名          | Filter类名                                              || ————- | ——————————————————- || default       | com.alibaba.druid.filter.stat.StatFilter                || stat          | com.alibaba.druid.filter.stat.StatFilter                || mergeStat     | com.alibaba.druid.filter.stat.MergeStatFilter           || encoding      | com.alibaba.druid.filter.encoding.EncodingConvertFilter || log4j         | com.alibaba.druid.filter.logging.Log4jFilter            || log4j2        | com.alibaba.druid.filter.logging.Log4j2Filter           || slf4j         | com.alibaba.druid.filter.logging.Slf4jLogFilter         || commonlogging | com.alibaba.druid.filter.logging.CommonsLogFilter       |\n\n慢 SQL 记录配置：\n&lt;bean id&#x3D;&quot;stat-filter&quot; class&#x3D;&quot;com.alibaba.druid.filter.stat.StatFilter&quot;&gt;\n    &lt;property name&#x3D;&quot;slowSqlMillis&quot; value&#x3D;&quot;10000&quot; &#x2F;&gt;\n    &lt;property name&#x3D;&quot;logSlowSql&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n使用 slowSqlMillis 定义慢SQL的时长\n\n11.3.2 使用官方 starter 方式11.3.2.1 引入 druid-starter&lt;dependency&gt;\n\t&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;1.1.14&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n11.3.2.2 自动配置\n扩展配置项 spring.datasource.druid\nDruidSpringAopConfiguration.class,   监控SpringBean的；配置项：\tspring.datasource.druid.aop-patterns\nDruidStatViewServletConfiguration.class, 监控页的配置：\tspring.datasource.druid.stat-view-servlet；默认开启\nDruidWebStatFilterConfiguration.class, web监控配置；\tspring.datasource.druid.web-stat-filter；默认开启\nDruidFilterConfiguration.class}) 所有 Druid 自己 filter 的配置\n\nprivate static final String FILTER_STAT_PREFIX &#x3D; &quot;spring.datasource.druid.filter.stat&quot;;\nprivate static final String FILTER_CONFIG_PREFIX &#x3D; &quot;spring.datasource.druid.filter.config&quot;;\nprivate static final String FILTER_ENCODING_PREFIX &#x3D; &quot;spring.datasource.druid.filter.encoding&quot;;\nprivate static final String FILTER_SLF4J_PREFIX &#x3D; &quot;spring.datasource.druid.filter.slf4j&quot;;\nprivate static final String FILTER_LOG4J_PREFIX &#x3D; &quot;spring.datasource.druid.filter.log4j&quot;;\nprivate static final String FILTER_LOG4J2_PREFIX &#x3D; &quot;spring.datasource.druid.filter.log4j2&quot;;\nprivate static final String FILTER_COMMONS_LOG_PREFIX &#x3D; &quot;spring.datasource.druid.filter.commons-log&quot;;\nprivate static final String FILTER_WALL_PREFIX &#x3D; &quot;spring.datasource.druid.filter.wall&quot;;\n\n11.3.2.3 配置项spring:\n  datasource:\n    druid:\n      aop-patterns: fan.*  #监控SpringBean，包\n      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）\n\n      stat-view-servlet:   # 配置监控页功能\n        enabled: true      &#x2F;&#x2F; 开启\n        login-username: admin\n        login-password: xxx\n        resetEnable: false\n\n      web-stat-filter:  # 监控web\n        enabled: true\n        urlPattern: &#x2F;*\n        exclusions: &#39;*.js,*.gif,*.jpg,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&#39;\n\n      filter:\n        stat:    # 对上面filters里面的stat的详细配置\n          slow-sql-millis: 1000\n          logSlowSql: true\n          enabled: true\n        wall:    # 对上面filters里面的wall的详细配置\n          enabled: true\n          config:\n            drop-table-allow: false\n\n12. 整合 Mybatis 和 Mybatis-Plus12.1 整合 Mybatis最佳实战：\n\n引入 mybatis-starter\n配置 application.yaml 中，指定 mapper-location 位置即可\n编写 Mapper 接口并标注 @Mapper 注解 ，或在启动类指定 MapperSacn 包扫描\n简单方法直接注解方式\n复杂方法编写mapper.xml进行绑定映射\n@MapperScan(&quot;fan.mapper&quot;) 简化，其他的接口就可以不用标注 @Mapper 注解\n\n12.1.1 引入 Starterhttps://github.com/mybatis引入 Mybatis 的时候其实已经引了 JDBC 核心包，之前的 JDBC 核心包就不用引了\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.1.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n12.1.2 配置模式\n全局配置文件\nSqlSessionFactory：自动配置好了\nSqlSession：自动配置了 SqlSessionTemplate 组合了SqlSession\n@Import(AutoConfiguredMapperScannerRegistrar.class）\nMapper： 只要我们写的操作 MyBatis 的接口标准了 @Mapper 就会被自动扫描进来\n\n12.1.3 配置项\n可创建 Mybatis 映射文件 Mapper.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;fan.UserMapper&quot;&gt;\n    &lt;select id&#x3D;&quot;getUser&quot; resultType&#x3D;&quot;fan.User&quot;&gt;\n        select * from  user where  id&#x3D;#&#123;id&#125;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\nYaml 配置可以不写全局配置文件，所有全局配置文件的配置都放在 configuration 配置项中即可，就是相当于改 mybatis 全局配置文件中的值，因此两者不能共存mybatis:\n#  config-location: classpath:mybatis&#x2F;mybatis-config.xml      #全局配置文件位置\n  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml            #sql映射文件位置\n  configuration:\n    map-underscore-to-camel-case: true\n注解模式无需编写 Mapper.xml 文件public interface TestMapper extends BaseMapper &#123;\n    @Select(&quot;select * from test where id &#x3D; #&#123;id&#125;&quot;)\n    public Test getTest(int id);\n\n    @Insert(&quot;insert into test values(null,#&#123;name&#125;,#&#123;age&#125;,#&#123;gender&#125;)&quot;)\n    @Options(useGeneratedKeys &#x3D; true,keyProperty &#x3D; &quot;id&quot;)\n    public void insert(User user);\n&#125;\n\n12.2 整合 Mybatis-Plus12.2.1 引入 Starter引入 Mybatis-Plus 的同时已经引入了 Mybatis 和JDBC 的核心包，因此之前的两个核心包可以不用引入\n&lt;dependency&gt;\n\t&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n12.2.2 自动配置\nMybatisPlusAutoConfiguration 配置类，MybatisPlusProperties 配置项绑定。mybatis-plus：xxx 就是对 mybatis-plus 的定制\nSqlSessionFactory 自动配置好。底层是容器中默认的数据源\nmapperLocations 自动配置好的。有默认值。classpath*:&#x2F;mapper&#x2F;**&#x2F;*.xml；任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。  建议以后sql映射文件，放在 mapper下\n容器中也自动配置好了 SqlSessionTemplate\n@Mapper 标注的接口也会被自动扫描；建议直接 @MapperScan(&quot;fan.mapper&quot;) 批量扫描就行\n\n优点：只需要我们的 Mapper 继承 BaseMapper 就可以拥有 CRUD 能力，无需编写 Mapper.xml 文件\n12.3 整合 Mybatis-Plus 的 CRUD\n创建Bean一般来说 Bean 的名字与数据库表名对应，假如数据库表名修改了，可以使用 @TableName 标注数据库表名\n&#x2F;&#x2F; @TableName(&quot;xxx&quot;) &#x2F;&#x2F; 对应数据库表名\npublic class User &#123;\n    private int id;\n    private String name;\n    private int age;\n    private String gender;\n&#125;\n创建 Mapper 接口继承 BaseMapper，标注 Bean\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;\n&#125;\n创建 Service继承 ServiceImpl ，标注 Mapper 接口 和 Bean\npublic interface UserService extends IService&lt;User&gt; &#123;\n\n&#125;\n\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;\n\n&#125;\n创建 Controller可直接使用 UserService 接口，调用 Mybatis-Plus 自带的 SQL 方法，进行 CRUD 操作list() 方法，返回 List 集合，查询到的所有数据page() 方法，返回分页数据\n\nrecords：数据集合\ntotal：数据条数\npages：总页数\ncurrent：当前页码\n\n@Autowired\nUserService userService;\n\n@GetMapping(&quot;&#x2F;editable_table&quot;)\npublic String editable_table(@RequestParam(value &#x3D; &quot;currentPage&quot;,defaultValue &#x3D; &quot;1&quot;) int currentPage, Model model)&#123;\n        List&lt;User&gt; list &#x3D; UserService.list();\n&#x2F;&#x2F;        model.addAttribute(&quot;users&quot;,list);\n\n        Page&lt;User&gt; userPage &#x3D; new Page&lt;&gt;(currentPage,5);    &#x2F;&#x2F; 创建一个 BeanPage 对象，传入当前页码和每页显示数据数\n        Page&lt;User&gt; page &#x3D; userService.page(userPage, null); &#x2F;&#x2F; 调用 page 方法，传入 BeanPage 对象和条件\n        if (currentPage &lt; 1)&#123;\n            userPage.setCurrent(1);\n        &#125;else if (currentPage &gt; page.getPages())&#123;\n            userPage.setCurrent(page.getPages());\n        &#125;\n        page &#x3D; userService.page(userPage,null);\n        model.addAttribute(&quot;page&quot;,page);\n        return &quot;table&#x2F;editable_table&quot;;\n&#125;\nHTML 页面\n&lt;tr class&#x3D;&quot;&quot; th:each&#x3D;&quot;user,stats : $&#123;page.records&#125;&quot;&gt;\n\t\t&lt;td th:text&#x3D;&quot;$&#123;stats.count&#125;&quot;&gt;Jonathan&lt;&#x2F;td&gt;    &#x2F;&#x2F; 可以 .属性名\n\t\t&lt;td th:text&#x3D;&quot;$&#123;user.id&#125;&quot;&gt;Jonathan&lt;&#x2F;td&gt;\n\t\t&lt;td th:text&#x3D;&quot;$&#123;user.getName()&#125;&quot;&gt;Smith&lt;&#x2F;td&gt;\t\t&#x2F;&#x2F; 也可以 get()方法\n\t\t&lt;td&gt;[[$&#123;user.getAge&#125;]]&lt;&#x2F;td&gt;\n\t\t&lt;td&gt;[[$&#123;user.gender&#125;]]&lt;&#x2F;td&gt;\n\t\t&lt;td&gt;\n\t\t\t\t&lt;a th:href&#x3D;&quot;@&#123;&#x2F;userDel&#x2F;&#123;id&#125;(id &#x3D; $&#123;user.id&#125;,currentPage &#x3D; $&#123;page.current&#125;)&#125;&quot; class&#x3D;&quot;btn btn-danger btn-sm&quot;&gt;删除&lt;&#x2F;a&gt;\n\t\t&lt;&#x2F;td&gt;\n&lt;&#x2F;tr&gt;\n\n&lt;ul&gt;\n\t\t&lt;li class&#x3D;&quot;prev&quot;&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;editable_table(currentPage &#x3D; $&#123;page.current&#125; - 1)&#125;&quot;&gt;← Prev&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n\t\t&lt;li th:class&#x3D;&quot;$&#123;num &#x3D;&#x3D; page.current&#125; ? &#39;active&#39; : &#39;&#39;&quot; th:each&#x3D;&quot;num : $&#123;#numbers.sequence(1,page.pages)&#125;&quot;&gt;\n\t\t\t\t&lt;a th:href&#x3D;&quot;@&#123;&#x2F;editable_table(currentPage &#x3D; $&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;&#x2F;a&gt;\n\t\t&lt;&#x2F;li&gt;\n\t\t&lt;li class&#x3D;&quot;next&quot;&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;editable_table(currentPage &#x3D; $&#123;page.current&#125; + 1)&#125;&quot;&gt;Next → &lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n13. 整合 NoSQL（Redis）13.1 引入 Starter&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n13.2 自动配置\nRedisAutoConfiguration 自动配置类。RedisProperties 属性类 –&gt; spring.redis.xxx 是对 Redis 的配置\n连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration\n自动注入了 RedisTemplate&lt;Object, Object&gt; ： xxxTemplate\n自动注入了 StringRedisTemplate；k：v 都是 String\n只要使用 RedisTemplate，就可以操作 Redis\n\n13.3 配置项spring:\n  redis:\n    host: 124.222.118.90 # Redis服务器地址\n    port: 6379 # Redis服务器连接端口\n    client-type: lettuce # 可以选择客户端类型，默认为 lettuce\n    lettuce:\n      pool:\n        max-active: 10 # 连接池最大连接数（使用负值表示没有限制）\n        max-wait: -1 # 最大阻塞等待时间(负数表示没限制)\n        max-idle: 5 # 连接池中的最大空闲连接\n        min-idle: 0 # 连接池中的最小空闲连接\n    jedis:\n      pool:\n        max-active: 10\n        max-wait: 10\n    password: xxx # 密码\n    database: 0 # Redis数据库索引（默认为0）\n    connect-timeout: 1800000 # 连接超时时间（毫秒）\n\n13.4 切换至 Jedis默认使用的是 Lettuce\n\n导入 Jedis 依赖&lt;dependency&gt;\n\t&lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n更改 Client-type 属性为 Jedisspring:\n  redis:\n    port: 6379                  &#x2F;&#x2F; 端口号\n    host: localhost\t\t\t\t\t\t\t&#x2F;&#x2F; 主机\n    client-type: jedis\t\t\t\t&#x2F;&#x2F; 客户端类型，Lettuce和Jedis\n\n13.5 Controller首先注入 RedisTemplate，然后使用 redisTemplate 的 opsForValue() 方法得到一个对象。使用该对象来对Redis 进行操纵使用该对象的 increment(xxx) 方法，表示 xxx 的值自动加 1\n@Controller\npublic class IndexController &#123;\n    @Autowired\n    StringRedisTemplate stringRedisTemplate;\n\n    @GetMapping(&quot;&#x2F;index.html&quot;)\n    public String index(Model model)&#123;\n        ValueOperations&lt;String, String&gt; operations &#x3D; stringRedisTemplate.opsForValue();\n        operations.set(&quot;name&quot;,&quot;张三&quot;);\n        String name &#x3D; operations.get(&quot;name&quot;);\n        System.out.println(name);\n        return &quot;index&quot;;\n    &#125;\n&#125;\n\n14. Junit5 单元测试14.1 引入 Starter&lt;dependency&gt;\n\t  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t  &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n\t  &lt;scope&gt;test&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n14.2 选择引入 JUnit Vintage 测试引擎SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容 Junit4 需要自行引入（不能使用 Junit4 的功能 @Test）。 JUnit 5’s Vintage Engine Removed from spring-boot-starter-test，如果需要继续兼容 Junit4 需要自行引入vintage\n&lt;dependency&gt;\n    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;\n    &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.hamcrest&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;hamcrest-core&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n14.3 JUnit5 常用注解https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations\n\n@Test：表示方法是测试方法。但是与 JUnit4 的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由 Jupiter 提供额外测试\n@ParameterizedTest：表示方法是参数化测试\n@RepeatedTest：表示方法可重复执行\n@DisplayName：为测试类或者测试方法设置展示名称\n@BeforeEach：表示在每个单元测试之前执行\n@AfterEach：表示在每个单元测试之后执行\n@BeforeAll :表示在所有单元测试之前执行\n@AfterAll：表示在所有单元测试之后执行\n@Tag：表示单元测试类别，类似于 JUnit4 中的 @Categories\n@Disabled：表示测试类或测试方法不执行，类似于 JUnit4 中的 @Ignore\n@Timeout：表示测试方法运行如果超过了指定时间将会返回错误\n@ExtendWith：为测试类或测试方法提供扩展类引用\n\n14.4 断言（assertions）断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。 这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别：\n\n检查业务逻辑返回的数据是否合理\n所有的测试运行结束以后，会有一个详细的测试报告\n\n14.1.1 简单断言\n\n\n方法\n说明\n\n\n\nassertEquals\n判断两个对象或两个原始类型是否相等\n\n\nassertNotEquals\n判断两个对象或两个原始类型是否不相等\n\n\nassertSame\n判断两个对象引用是否指向同一个对象\n\n\nassertNotSame\n判断两个对象引用是否指向不同的对象\n\n\nassertTrue\n判断给定的布尔值是否为 True\n\n\nassertFalse\n判断给定的布尔值是否为 False\n\n\nassertNull\n判断给定的对象引用是否为 NULL\n\n\nassertNotNull\n判断给定的对象引用是否不为 NULL\n\n\n@Test\n@DisplayName(&quot;simple assertion&quot;)\npublic void simple() &#123;\n     assertEquals(3, 1 + 2, &quot;simple math&quot;);\n     assertNotEquals(3, 1 + 1);\n\n     assertNotSame(new Object(), new Object());\n     Object obj &#x3D; new Object();\n     assertSame(obj, obj);\n\n     assertFalse(1 &gt; 2);\n     assertTrue(1 &lt; 2);\n\n     assertNull(null);\n     assertNotNull(new Object());\n&#125;\n\n14.1.2 数组断言@Test\n@DisplayName(&quot;array assertion&quot;)\npublic void array() &#123;\n    assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);\n&#125;\n\n14.1.3 组合断言@Test\n@DisplayName(&quot;assert all&quot;)\npublic void all() &#123;\n\tassertAll(&quot;Math&quot;,\n\t\t() -&gt; assertEquals(2, 1 + 1,&quot;number&quot;),\n\t\t() -&gt; assertTrue(1 &gt; 0)\n\t);\n&#125;\n\n14.1.4 异常断言@Test\n@DisplayName(&quot;异常测试&quot;)\npublic void exceptionTest() &#123;\n    ArithmeticException exception &#x3D; Assertions.assertThrows(\n\t\t&#x2F;&#x2F;扔出断言异常\n\t\tArithmeticException.class, () -&gt; System.out.println(1 % 0));\n&#125;\n\n14.1.5 超时断言@Timeout(value &#x3D; 500,unit &#x3D; TimeUnit.MICROSECONDS)\n@Test\n@DisplayName(&quot;超时测试&quot;)\npublic void timeoutTest() &#123;\n\t&#x2F;&#x2F;如果测试方法时间超过1s将会异常\n    &#x2F;&#x2F;Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));\n    Thread.sleep(600);\n&#125;\n\n14.1.5 快速失败通过 Fail 方法直接使得测试失败\n@Test\n@DisplayName(&quot;fail&quot;)\npublic void shouldFail() &#123;\n    if(1 &#x3D;&#x3D; 1)&#123;\n\t\tfail(&quot;This should fail&quot;);\n    &#125;\n&#125;\n\n14.5 前置条件（assumptions）JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。 前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。\n@DisplayName(&quot;前置条件&quot;)\npublic class AssumptionsTest &#123;\n\tprivate final String environment &#x3D; &quot;DEV&quot;;\n \n\t@Test\n\t@DisplayName(&quot;simple&quot;)\n \tpublic void simpleAssume() &#123;\n\t\tassumeTrue(Objects.equals(this.environment, &quot;DEV&quot;));\n\t\tassumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;));\n\t&#125;\n\n\t@Test\n\t@DisplayName(&quot;assume then do&quot;)\n\tpublic void assumeThenDo() &#123;\n  \t  assumingThat(\n   \t    Objects.equals(this.environment, &quot;DEV&quot;),\n\t\t\t() -&gt; System.out.println(&quot;In DEV&quot;)\n\t\t);\n\t&#125;\n&#125;\n\nassumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止\n14.6 嵌套测试JUnit 5 可以通过 Java 中的内部类和 @Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用 @BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制\n@DisplayName(&quot;A stack&quot;)\nclass TestingAStackDemo &#123;\n    Stack&lt;Object&gt; stack;\n\n    @Test\n    @DisplayName(&quot;is instantiated with new Stack()&quot;)\n    void isInstantiatedWithNew() &#123;\n        new Stack&lt;&gt;();\n    &#125;\n    @Nested\n    @DisplayName(&quot;when new&quot;)\n    class WhenNew &#123;\n        @BeforeEach\n        void createNewStack() &#123;\n            stack &#x3D; new Stack&lt;&gt;();\n        &#125;\n        @Test\n        @DisplayName(&quot;is empty&quot;)\n        void isEmpty() &#123;\n            assertTrue(stack.isEmpty());\n        &#125;\n        @Test\n        @DisplayName(&quot;throws EmptyStackException when popped&quot;)\n        void throwsExceptionWhenPopped() &#123;\n            assertThrows(EmptyStackException.class, stack::pop);\n        &#125;\n        @Test\n        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)\n        void throwsExceptionWhenPeeked() &#123;\n            assertThrows(EmptyStackException.class, stack::peek);\n        &#125;\n        @Nested\n        @DisplayName(&quot;after pushing an element&quot;)\n        class AfterPushing &#123;\n            String anElement &#x3D; &quot;an element&quot;;\n\n            @BeforeEach\n            void pushAnElement() &#123;\n                stack.push(anElement);\n            &#125;\n            @Test\n            @DisplayName(&quot;it is no longer empty&quot;)\n            void isNotEmpty() &#123;\n                assertFalse(stack.isEmpty());\n            &#125;\n            @Test\n            @DisplayName(&quot;returns the element when popped and is empty&quot;)\n            void returnElementWhenPopped() &#123;\n                assertEquals(anElement, stack.pop());\n                assertTrue(stack.isEmpty());\n            &#125;\n            @Test\n            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)\n            void returnElementWhenPeeked() &#123;\n                assertEquals(anElement, stack.peek());\n                assertFalse(stack.isEmpty());\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n14.7 参数化测试参数化测试是 JUnit5 很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。标注 @ParameterizedTest 注解指定这是一参数化测试类，利用 @ValueSource 等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。\n\n@ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型\n@NullSource: 表示为参数化测试提供一个 NULL 的入参\n@EnumSource: 表示为参数化测试提供一个枚举入参\n@CsvFileSource：表示读取指定 CSV 文件内容作为参数化测试入参\n@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)\n\n@ParameterizedTest\n@ValueSource(strings &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)\n@DisplayName(&quot;参数化测试1&quot;)\npublic void parameterizedTest1(String string) &#123;\n    System.out.println(string);\n    Assertions.assertTrue(StringUtils.isNotBlank(string));\n&#125;\n\n@ParameterizedTest\n@MethodSource(&quot;method&quot;)    &#x2F;&#x2F;指定方法名\n@DisplayName(&quot;方法来源参数&quot;)\npublic void testWithExplicitLocalMethodSource(String name) &#123;\n    System.out.println(name);\n    Assertions.assertNotNull(name);\n&#125;\n\nstatic Stream&lt;String&gt; method() &#123;\n    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);\n&#125;\n\n15. 指标监控15.1 SpringBoot Actuator未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能\n15.1.1 引入 Starter&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n15.1.2 配置项暴露规则支持的暴露方式：\n\nHTTP：默认只暴露 health 和 info Endpoint\nJMX：默认暴露所有 Endpoint\n除过 health 和 info，剩下的 Endpoint 都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则\n\n\n开启方式默认所有的 Endpoint 除了 shutdown 都是开启的。需要开启或者禁用某个 Endpoint。配置模式为 management.endpoint.&lt;endpointName&gt;.enabled = true\nmanagement:\n  endpoints:\n    enabled-by-default: true #暴露所有端点信息\n    web:\n      exposure:\n        include: &#39;*&#39;  #以web方式暴露\n\n或者禁用所有的 Endpoint 然后手动开启指定的 Endpoint ，设置相关端点属性\nmanagement:\n  endpoints:\n    enabled-by-default: false\n    web:\n      exposure:\n        include: &#39;*&#39;\n  endpoint:\n    health:\n      show-details: always  #总是显示详细信息。可显示每个模块的状态信息\n      enabled: true\n    info:\n      enabled: true\n    beans:\n      enabled: true\n    metrics:\n      enabled: true\n\n15.1.3 访问http://localhost:8080/actuator/**\n\nhttp://localhost:8080/actuator/beans\nhttp://localhost:8080/actuator/configprops\nhttp://localhost:8080/actuator/metrics\nhttp://localhost:8080/actuator/metrics/jvm.gc.pause\nhttp://localhost:8080/actuator/endpointName/detailPath\n。。。。。。\n\n15.2 Actuator Endpoint常用 Endpoint：\n\nHealth：监控状况\nMetrics：运行时指标\nLoggers：日志记录\n\n如果应用程序是Web应用程序（Spring MVC，Spring WebFlux 或 Jersey），则可以使用以下附加端点：\n15.2.1 Health Endpoint健康检查端点，一般用于在云平台，平台会定时的检查应用的健康状况，就需要 Health Endpoint，可以为平台返回当前应用的一系列组件健康状况的集合\n\nhealth endpoint 返回的结果，应该是一系列健康检查后的一个汇总报告\n很多的健康检查默认已经自动配置好了，比如：数据库、Redis 等\n可以很容易的添加自定义的健康检查机制\n\n定制 Health\n\n继承抽象类@Component\npublic class MyComHealthIndicator extends AbstractHealthIndicator &#123;\n    @Override\n    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;\n        Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();\n\n        if (1 &#x3D;&#x3D; 1)&#123;\n            builder.up();\n            map.put(&quot;count&quot;,1);\n            map.put(&quot;ms&quot;,1000);\n        &#125;else &#123;\n            builder.status(Status.OUT_OF_SERVICE);\n            map.put(&quot;err&quot;,&quot;连接超时&quot;);\n        &#125;\n        builder.withDetail(&quot;code&quot;,100)\n            \t.withDetails(map);\n    &#125;\n&#125;\n实现接口@Component\npublic class MyHealthIndicator implements HealthIndicator &#123;\n    @Override\n    public Health health() &#123;\n        int errorCode &#x3D; check(); &#x2F;&#x2F; perform some specific health check\n        if (errorCode !&#x3D; 0) &#123;\n            return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();\n        &#125;\n        return Health.up().build();\n    &#125;\n&#125;\n&#x2F;&#x2F; 构建Health\nHealth build &#x3D; Health.down()\n                .withDetail(&quot;msg&quot;, &quot;error service&quot;)\n                .withDetail(&quot;code&quot;, &quot;500&quot;)\n                .withException(new RuntimeException())\n                .build();\n\n15.2.2 Metrics Endpoint提供详细的、层级的、空间指标信息，这些信息可以被 pull（主动推送）或者push（被动获取）方式得到\n\n通过Metrics对接多种监控系统\n简化核心Metrics开发\n添加自定义 Metrics 或者扩展已有 Metrics\n\n定制Metrics：\nclass MyService&#123;\n    Counter counter;\n    public MyService(MeterRegistry meterRegistry)&#123;\n         counter &#x3D; meterRegistry.counter(&quot;myservice.method.running.counter&quot;);\n    &#125;\n    public void hello() &#123;\n        counter.increment();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;也可以使用下面的方式\n@Bean\nMeterBinder queueSize(Queue queue) &#123;\n    return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);\n&#125;\n\n15.2.3 定制 info 信息\n编写配置文件info:\n  appName: boot-admin\n  version: 2.0.1\n  mavenProjectName: @project.artifactId@  #使用@@可以获取maven的pom文件值\n  mavenProjectVersion: @project.version@\n编写 InfoContributor@Component\npublic class ExampleInfoContributor implements InfoContributor &#123;\n    @Override\n    public void contribute(Info.Builder builder) &#123;\n        builder.withDetail(&quot;ms&quot;,&quot;你好&quot;)\n                .withDetails(Collections.singletonMap(&quot;world&quot;,&quot;world&quot;));\n    &#125;\n&#125;\n\n15.2.4 定制 Endpoint@Component\n@Endpoint(id &#x3D; &quot;myService&quot;)\npublic class MyServiceEndpoint &#123;\n    @ReadOperation\n    public Map getDockerInfo()&#123;\n        return Collections.singletonMap(&quot;dockerInto&quot;,&quot;dockerInfo start&quot;);\n    &#125;\n    @WriteOperation\n    public void stopDockerInfo()&#123;\n        System.out.println(&quot;docker stopped&quot;);\n    &#125;\n&#125;\n\n15.3 可视化https://github.com/codecentric/spring-boot-admin创建一个 springboot server 项目，用作服务器指标监控 springboot client 客户端\n15.3.1 Server\n引入 Starter&lt;dependency&gt;\n\t&lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-admin-starter-server&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n添加 @EnableAdminServer 注解@EnableAdminServer\n@SpringBootApplication\npublic class AdminserverApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(AdminserverApplication.class, args);\n    &#125;\n&#125;\n设置端口server:\n\tport: 8888\n\n15.3.2 Clientspring:\n  boot:\n    admin:\n      client:\n        url: http:&#x2F;&#x2F;localhost:8888  &#x2F;&#x2F; 使用主机名注册\n        instance:\n          prefer-ip: true  # 使用ip注册进来\n\tapplication:\n\t\tname: adminmanager\n\n16. 外部化配置和默认配置文件16.1 外部化配置文件除了默认配置文件，Spring Boot 还可以加载一些位于项目外部的配置文件。可以通过如下 2 个参数，指定外部配置文件的路径：\n\nspring.config.location可以先将 Spring Boot 项目打包成 JAR 文件，然后在命令行启动命令中，使用命令行参数 –spring.config.location，指定外部配置文件的路径。java -jar &#123;JAR&#125; --spring.config.location=&#123;外部配置文件全路径&#125;使用该参数指定配置文件后，会使项目默认配置文件（application.properties 或 application.yml ）失效，Spring Boot 将只加载指定的外部配置文件\nspring.config.additional-locationjava -jar &#123;JAR&#125; --spring.config.additional-location=&#123;外部配置文件全路径&#125;与 --spring.config.location 不同，--spring.config.additional-location 不会使项目默认的配置文件失效，使用该命令行参数添加的外部配置文件会与项目默认的配置文件共同生效，形成互补配置，且其优先级是最高的，比所有默认配置文件的优先级都高\n\n16.1.1 配置外部配置文件的优先级Maven 对项目进行打包时，位于项目根目录下的配置文件是无法被打包进项目的 JAR 包的，因此位于根目录下的默认配置文件无法在 JAR 中生效， 即该项目将只加载指定的外部配置文件和项目类路径（classpath）下的默认配置文件，它们的加载优先级顺序为：\n\nspring.config.additional-location 指定的外部配置文件 my-application.yml\nclasspath:&#x2F;config&#x2F;application.yml\nclasspath:&#x2F;application.yml\n\n16.1.2 配置虚拟机参数将 Spring Boot 项目打包后，然后在命令行启动命令中添加 spring.config.additional-location 参数指定外部配置文件，会导致项目根目录下的配置文件无法被加载，可以通过以下 3 种方式解决这个问题：\n\n在 IDEA 的运行配置（Run&#x2F;Debug Configuration）中，添加虚拟机参数 -Dspring.config.additional-location=D:\\myConfig\\my-application.yml，指定外部配置文件\n在 IDEA 的运行配置（Run&#x2F;Debug Configuration）中，添加程序运行参数 --spring.config.additional-location=D:\\myConfig\\my-application.yml，指定外部配置文件；\n在主启动类中调用 System.setProperty（）方法添加系统属性 spring.config.additional-location，指定外部配置文件\n\n16.1.3 外部配置源常用：Java属性文件、YAML文件、环境变量、命令行参数\n@Controller\npublic class HelloController &#123;\n    @Value(&quot;$&#123;MAVEN_HOME&#125;&quot;)\n    private String msg;\n  \n    @Value(&quot;os.name&quot;)\n    private String osName;\n&#125;\n\n16.2 默认配置文件16.2.1 Spring Boot 配置加载顺序以下是常用的 Spring Boot 配置形式及其加载顺序（优先级由高到低）：\n\n命令行参数Spring Boot 中的所有配置，都可以通过命令行参数进行指定，其配置形式如下:java -jar &#123;Jar文件名&#125; --&#123;参数1&#125;=&#123;参数值1&#125; --&#123;参数2&#125;=&#123;参数值2&#125;java -jar springbootdemo-0.0.1-SNAPSHOT.jar --server.port=8081 --server.servlet.context-path=/bcb\n--server.port：指定服务器端口号\n--server.servlet.context-path：指定上下文路径（项目的访问路径）\n\n\n来自 java:comp&#x2F;env 的 JNDI 属性\nJava 系统属性（System.getProperties()）\n操作系统环境变量\nRandomValuePropertySource 配置的 random. 属性值*\n配置文件（YAML 文件、Properties 文件）\n@Configuration 注解类上的 @PropertySource 指定的配置文件\n通过 SpringApplication.setDefaultProperties 指定的默认属性\n\n以上所有形式的配置都会被加载，当存在相同配置内容时，高优先级的配置会覆盖低优先级的配置；存在不同的配置内容时，高优先级和低优先级的配置内容取并集，共同生效，形成互补配置\n16.2.2 配置文件查找位置\nclasspath 根路径\nclasspath 根路径下config目录\njar包当前目录\njar包当前目录的config目录\n&#x2F;config子目录的直接子目录\n\n16.3 配置文件加载顺序根目录 config 目录下的子文件夹 &gt; 根目录 config 目录下 &gt; 根目录下 &gt; classpath 目录下的 config 目录下 &gt; classpath 目录下\n\n当前 jar 包内部的 application.properties 和 application.yml\n当前 jar 包内部的application-{profile}.properties 和 application-{profile}.yml\n引用的外部 jar 包的 application.properties 和 application.yml\n引用的外部 jar 包的 application-{profile}.properties 和 application-{profile}.yml\n\n指定环境优先，外部优先，后面的可以覆盖前面的同名配置项，同一位置下，Properties 文件优先级高于 YAML 文件\n\n&#x2F;myBoot：表示 JAR 包所在目录，目录名称自定义\n&#x2F;childDir：表示 JAR 包所在目录下 config 目录的子目录，目录名自定义\nJAR：表示 Spring Boot 项目打包生成的 JAR\n其余带有 “&#x2F;” 标识的目录的目录名称均不能修改\n红色数字：表示该配置文件的优先级，数字越小优先级越高\n\n这些配置文件的优先级顺序，遵循以下规则：\n\n先加载 JAR 包外的配置文件，再加载 JAR 包内的配置文件\n先加载 config 目录内的配置文件，再加载 config 目录外的配置文件\n先加载 config 子目录下的配置文件，再加载 config 目录下的配置文件4。 先加载 appliction-{profile}.properties&#x2F;yml，再加载 application.properties&#x2F;yml\n先加载 .properties 文件，再加载 .yml 文件\n\n17. 自定义 Starter功能：传入姓名 ，自动配置前缀和后缀\n17.1 创建一个 Starter 项目创建一个空项目，加入一个 Maven 模块，作为 Starter ，再加入一个 Springboot 模块，作为 Starter-autoconfigure\n17.2 Starter-Autoconfigure\nPOM 配置将其他所有依赖和插件删掉，只留下 web-starter&lt;properties&gt;\n\t&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n&lt;&#x2F;properties&gt;\n&lt;dependencies&gt;\n\t&lt;dependency&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\nBean@ConfigurationProperties(&quot;fan&quot;)\npublic class HelloProperties &#123;\n    private String prefix;\n    private String suffix;\n&#125;\nService无需添加进容器，即不需要 @Service 注解，注入 Beanpublic class HelloService &#123;\n    @Autowired\n    HelloProperties helloProperties;\n    public String sayHello(String name)&#123;\n        return helloProperties.getPrefix() + &quot;: &quot; + name + &quot;》&quot; + helloProperties.getSuffix();\n    &#125;\n&#125;\n自动配置类 AutoConfiguration@Configuration\n@EnableConfigurationProperties(HelloProperties.class)\npublic class HelloAutoConfiguration &#123;\n    @ConditionalOnMissingBean(HelloService.class)\n    @Bean\n    public HelloService helloService()&#123;\n        HelloService helloService &#x3D; new HelloService();\n        return helloService;\n    &#125;\n&#125;\n创建 META-INF 下的 spring.factories加入自动配置类# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\\nfan.auto.HelloAutoConfiguraion\t\t\t&#x2F;&#x2F; 自动配置类\n\n17.3 Starter\n引入编写好的 AutoConfiguration&lt;dependency&gt;\n\t&lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;fan-spring-boot-starter-autoconfigure&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n设置编码格式&lt;properties&gt;\n\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;\n&lt;&#x2F;properties&gt;\n\n17.4 加载进本地仓库先将 Starter-autoconfigure 执行 clean ，然后 install ，然后再将 Starter 执行 clean ，install，加载进本地仓库\n17.5 使用自定义 Starter17.5.1 引入自定义 Starter&lt;dependency&gt;\n\t\t&lt;groupId&gt;fan&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;fan-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t\t&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n17.5.2 Controller将自定义 Starter 中的 Service 注入进来，调用 Starter 的方法\n@Controller\npublic class TestStarterController &#123;\n    @Autowired\n    HelloService helloService;\n    @ResponseBody\n    @GetMapping(&quot;&#x2F;teststart&quot;)\n    public String sayHello()&#123;\n        String sayHello &#x3D; helloService.sayHello(&quot;张三&quot;);\n        return sayHello;\n    &#125;\n&#125;\n\n17.5.3 配置项使用 Starter-Autoconfiguration 自动配置的属性\nfan:\n  prefix: fan\n  suffix: auto\n\n17.5.4 成功返回\n17.5.5 自定义 Config将会使用我们自定义的 Config 来进行装配\n@Configuration\npublic class MyHelloConfig &#123;\n    @Bean\n    public HelloService helloService()&#123;\n        HelloService helloService &#x3D; new HelloService();\n        return helloService;\n    &#125;\n&#125;\n\n18. Profile 功能18.1 application-profile 功能在 src&#x2F;main&#x2F;resources 下添加 4 个配置文件：\n\napplication.yml：主配置文件\napplication-dev.yml：开发环境配置文件\napplication-test.yml：测试环境配置文件\napplication-prod.yml：生产环境配置文件\n\n默认配置文件  application.yml；任何时候都会加载，指定环境配置文件  application-prod.yml &#x2F; application-test.yml &#x2F; application-dev.yml激活指定环境：\n\n配置文件激活spring:\n  profiles:\n    active: prod\n#    active: test\n命令行激活：(打包成JAR文件后，通过命令行激活）java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha修改配置文件的任意值，命令行优先\n虚拟机参数激活（打包成JAR文件后，通过虚拟机参数来激活）java -Dspring.profiles.active=prod -jar xxx.jar\n\n默认配置与环境配置同时生效，同名配置项，profile 配置优先\n18.2 @Profile 条件装配功能指定仅在某个 profile 下执行\n@Configuration(proxyBeanMethods &#x3D; false)\n@Profile(&quot;prod&quot;)\npublic class ProductionConfiguration &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n@Configuration(proxyBeanMethods &#x3D; false)\n@Profile(&quot;test&quot;)\npublic class ProductionConfiguration &#123;\n    &#x2F;&#x2F; ...\n&#125;\n\n18.3 Profile 分组指定 profile 分组，同时加载多个 profile ，可以分别指定值，如：一个指定 name，一个指定 age ，然后同时加载进来\nspring:\n\tprofiles:\n  \tactive: production\n\t\tgroup:\n    \tproduction[0]: prodname\n    \tproduction[1]: prodage\n\n18.4 多 Profile 文档块模式#默认配置\nserver:\n  port: 8080\n#切换配置\nspring:\n  profiles:\n    active: test\n---\n#开发环境\nserver:\n  port: 8081\nspring:\n  config:\n    activate:\n      on-profile: dev\n---\n#测试环境\nserver:\n  port: 8082\nspring:\n  config:\n    activate:\n      on-profile: test\n---\n#生产环境\nserver:\n  port: 8083\nspring:\n  config:\n    activate:\n      on-profile: prod\n","slug":"BlogRepository/Spring/Spring Boot 总结","date":"2022-06-13T18:56:36.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"凡"},{"id":"153deb9c806beaeb0b25c611326c4f25","title":"SpringMVC 总结","content":"1. 配置1.1 MVC 概念MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分\n\nM：Model，模型层，指工程中的 JavaBean，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）JavaBean 分为两类：\n一类称为实体类 Bean：专门存储业务数据的，如 Student、User 等\n一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问\n\n\nV：View，视图层，指工程中的 HTML 或 JSP 等页面，负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能\nC：Controller，控制层，指工程中的 Servlet，负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端\n\nMVC 的工作流程：\n\n用户通过视图层发送请求到服务器，在服务器中请求被 Controller 接收\nController 调用相应的 Model 层处理请求，处理完毕将结果返回到 Controller\nController 再根据请求处理的结果找到相应的 View 视图，渲染数据后最终响应给浏览器\n\n1.2 SpringMVC 概念\nSpringMVC是Spring的一个后续产品，是 Spring 的一个子项目\nSpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC 作为 Java EE 项目表述层开发的首选方案\n\n注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 Servlet\n1.3 SpringMVC的特点\nSpring 家族原生产品，与 IOC 容器等基础设施无缝对接\n基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理\n表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案\n代码清新简洁，大幅度提升开发效率\n内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可\n性能卓著，尤其适合现代大型、超大型互联网项目要求\n\n1.4 配置 web.xml\n默认配置方式此配置作用下，SpringMVC 的配置文件默认位于 WEB-INF 下，默认名称为 &lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应 SpringMVC 的配置文件位于 WEB-INF 下，文件名为 springMVC-servlet.xml&lt;web-app&gt;\n  &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;\n  &lt;!-- 配置 SpringMVC 的前端控制器，对浏览器发送的请求统一进行处理 --&gt;\n\t&lt;servlet&gt;\n\t\t&lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n\t\t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet\u0002class&gt;\n\t&lt;&#x2F;servlet&gt;\n\n\t&lt;servlet-mapping&gt;\n\t\t&lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n\t\t&lt;!--\n\t\t\t设置 springMVC 的核心控制器所能处理的请求的请求路径\n\t\t\t&#x2F; 所匹配的请求可以是 &#x2F;login 或 .html 或 .js 或 .css 方式的请求路径\n\t\t\t但是 &#x2F; 不能匹配 .jsp 请求路径的请求\n\t\t--&gt;\n\t\t&lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n\t&lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;\n扩展配置方式可通过 init-param 标签设置 SpringMVC 配置文件的位置和名称，通过 load-on-startup 标签设置 SpringMVC 前端控制器 DispatcherServlet 的初始化时间&lt;!-- 配置 SpringMVC 的前端控制器，对浏览器发送的请求统一进行处理 --&gt;\n&lt;servlet&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;!-- 通过初始化参数指定 SpringMVC 配置文件的位置和名称 --&gt;\n    &lt;init-param&gt;\n        &lt;!-- contextConfigLocation 为固定值 --&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n        &lt;!-- 使用 classpath: 表示从类路径查找配置文件，例如 Maven 工程中的src&#x2F;main&#x2F;resources --&gt;\n        &lt;param-value&gt;classpath:springMVC.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n&lt;&#x2F;servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n\n&lt;url-pattern&gt; 标签中使用 / 和 /* 的区别：* / 所匹配的请求可以是 &#x2F;login 或 .html 或 .js 或 .css 方式的请求路径，但是 &#x2F; 不能匹配 .jsp 请求路径的请求。因此就可以避免在访问 JSP 页面时，该请求被 DispatcherServlet 处理，从而找不到相应的页面\n/* 则能够匹配所有请求，在使用过滤器时，若需要对所有请求进行过滤，就需要使用 &#x2F;* 的写法\n\n\n完整配置：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app version&#x3D;&quot;3.0&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee\n\thttp:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;&gt;\n\n  &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;\n\n   &lt;!-- 配置统一编码格式 --&gt;\n  &lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;forceResponseEncoding&lt;&#x2F;param-name&gt;\n      &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n  &lt;&#x2F;filter&gt;\n  &lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;filter-mapping&gt;\n\n\t&lt;!-- 配置 HiddenHttpMethodFilter，实现 RestFul --&gt;\n  &lt;filter&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;&#x2F;filter-class&gt;\n  &lt;&#x2F;filter&gt;\n  &lt;filter-mapping&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;filter-mapping&gt;\n\n  &lt;!-- 配置 SpringMVC 的前端控制器，对浏览器发送的请求统一进行处理 --&gt;\n  &lt;servlet&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;!-- 通过初始化参数指定 SpringMVC 配置文件的位置和名称 --&gt;\n    &lt;init-param&gt;\n      &lt;!-- contextConfigLocation 为固定值 --&gt;\n      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n      &lt;!-- 使用 classpath: 表示从类路径查找配置文件，例如 Maven 工程中的src&#x2F;main&#x2F;resources --&gt;\n      &lt;param-value&gt;classpath:springmvc-config.xml&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;!--\n        作为框架的核心组件，在启动过程中有大量的初始化操作要做\n        而这些操作放在第一次请求时才执行会严重影响访问速度\n        因此需要通过此标签将启动控制 DispatcherServlet 的初始化时间提前到服务器启动时\n    --&gt;\n    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;\n  &lt;&#x2F;servlet&gt;\n  &lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springMVC&lt;&#x2F;servlet-name&gt;\n    &lt;!--\n        设置 springMVC 的核心控制器所能处理的请求的请求路径\n        &#x2F; 所匹配的请求可以是 &#x2F;login 或 .html 或 .js 或 .css 方式的请求路径\n        但是 &#x2F; 不能匹配 .jsp 请求路径的请求\n   --&gt;\n    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;\n\n1.5 配置 springmvc-config.xml&lt;!-- 开启注解扫描，自动扫描包 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;fan&quot; &#x2F;&gt;\n\n&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;\n\t&lt;property name&#x3D;&quot;order&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n\t&lt;property name&#x3D;&quot;characterEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n\t&lt;property name&#x3D;&quot;templateEngine&quot;&gt;\n\t\t&lt;bean class&#x3D;&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;\n\t\t\t&lt;property name&#x3D;&quot;templateResolver&quot;&gt;\n\t\t\t\t&lt;bean class&#x3D;&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;\n\t\t\t\t\t&lt;!-- 视图前缀 --&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;templates&#x2F;&quot;&#x2F;&gt;\n\t\t\t\t\t&lt;!-- 视图后缀 --&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.html&quot;&#x2F;&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;templateMode&quot; value&#x3D;&quot;HTML5&quot;&#x2F;&gt;\n\t\t\t\t\t&lt;property name&#x3D;&quot;characterEncoding&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\t\t\t\t&lt;&#x2F;bean&gt;\n\t\t\t&lt;&#x2F;property&gt;\n\t\t&lt;&#x2F;bean&gt;\n\t&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 处理静态资源，例如 html、js、css、jpg\n  若只设置该标签，则只能访问静态资源，其他请求则无法访问\n  此时必须设置&lt;mvc:annotation-driven&#x2F;&gt;解决问题 --&gt;\n&lt;mvc:default-servlet-handler&#x2F;&gt;\n&lt;!-- 开启 mvc 注解驱动 --&gt;\n&lt;mvc:annotation-driven&gt;\n\t&lt;mvc:message-converters&gt;\n\t\t&lt;!-- 处理响应中文内容乱码 --&gt;\n\t\t&lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;\n\t\t\t&lt;property name&#x3D;&quot;defaultCharset&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\t\t\t&lt;property name&#x3D;&quot;supportedMediaTypes&quot;&gt;\n\t\t\t\t&lt;list&gt;\n\t\t\t\t\t&lt;value&gt;text&#x2F;html&lt;&#x2F;value&gt;\n\t\t\t\t\t&lt;value&gt;application&#x2F;json&lt;&#x2F;value&gt;\n\t\t\t\t&lt;&#x2F;list&gt;\n\t\t\t&lt;&#x2F;property&gt;\n\t\t&lt;&#x2F;bean&gt;\n\t&lt;&#x2F;mvc:message-converters&gt;\n&lt;&#x2F;mvc:annotation-driven&gt;\n\n1.6 控制器@Controller\npublic class TestController &#123;\n    @RequestMapping(&quot;&#x2F;index&quot;)\n    public String index()&#123;\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(&quot;&#x2F;target&quot;)\n    public String toTarget()&#123;\n        return &quot;target&quot;;\n    &#125;\n&#125;\n\n1.7 Thymeleaf 页面&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t首页\n\t&lt;a th:href&#x3D;&quot;@&#123;&#x2F;target&#125;&quot;&gt;hello&lt;&#x2F;a&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n1.8 工作流程小结浏览器发送请求，若请求地址符合前端控制器的 url-pattern，该请求就会被前端控制器 DispatcherServlet处理。前端控制器会读取 SpringMVC 的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中 @RequestMapping 注解的 value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过 Thymeleaf 对视图进行渲染，最终转发到视图所对应页面。\n2. 视图解析器 ViewResolver视图解析器（ViewResolver）是 Spring MVC 的重要组成部分，负责将逻辑视图名解析为具体的视图对象。 Spring MVC 提供了很多视图解析类，其中每一项都对应 Java Web 应用中特定的某些视图技术。常用的视图解析类如下\n2.1 URLBasedViewResolver\nUrlBasedViewResolver 是对 ViewResolver 的一种简单实现，主要提供了一种拼接 URL 的方式来解析视图\n通过 prefix 属性指定前缀，suffix 属性指定后缀。当 ModelAndView 对象返回具体的 View 名称时，它会将前缀 prefix 和后缀 suffix 与具体的视图名称拼接，得到一个视图资源文件的具体加载路径，从而加载真正的视图文件并反馈给用户\n使用 UrlBasedViewResolver 除了要配置前缀和后缀属性之外，还需要配置“viewClass”，表示解析成哪种视图。 示例代码如下：\n\n&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt;          \n  &lt;!--不能省略--&gt;  \n  &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&#x2F;&gt; \n    &lt;!--前缀--&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n    &lt;!--后缀--&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;  \n&lt;&#x2F;bean&gt;\n\n2.2 InternalResourceViewResolver\nInternalResourceViewResolver 为“内部资源视图解析器”，是日常开发中最常用的视图解析器类型。它是 URLBasedViewResolver 的子类，拥有 URLBasedViewResolver 的一切特性\nInternalResourceViewResolver 能自动将返回的视图名称解析为 InternalResourceView 类型的对象。InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL\n也就是说，使用 InternalResourceViewResolver 视图解析时，无需再单独指定 viewClass 属性。 示例代码如下：\n\n&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n  &lt;!--可以省略--&gt;  \n  &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&#x2F;&gt;\n    &lt;!--前缀--&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;\n    &lt;!--后缀--&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;  \n&lt;&#x2F;bean&gt;\n\n2.3 FreeMarkerViewResolver\nFreeMarkerViewResolver 是 UrlBasedViewResolver 的子类，可以通过 prefix 属性指定前缀，通过 suffix 属性指定后缀\nFreeMarkerViewResolver 最终会解析逻辑视图配置，返回 freemarker 模板。不需要指定 viewClass 属性&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;fm_&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.ftl&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n下面指定 FreeMarkerView 类型最终生成的实体视图（模板文件）的路径以及其他配置。需要给 FreeMarkerViewResolver 设置一个 FreeMarkerConfig 的 bean 对象来定义 FreeMarker 的配置信息&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;\n    &lt;property name&#x3D;&quot;templateLoaderPath&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;ftl&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n定义了 templateLoaderPath 属性后，Spring 可以通过该属性找到 FreeMarker 模板文件的具体位置。当有模板位于不同的路径时，可以配置 templateLoaderPath 属性，来指定多个资源路径\n然后定义一个 Controller，让其返回 ModelAndView，同时定义一些返回参数和视图信息：@Controller\n@RequestMapping(&quot;viewtest&quot;)\npublic class ViewController &#123;\n    @RequestMapping(&quot;freemarker&quot;)\n    public ModelAndView freemarker() &#123;\n        ModelAndView mv &#x3D; new ModelAndView();\n        mv.addObject(&quot;username&quot;, &quot;BianChengBang&quot;);\n        mv.setViewName(&quot;freemarker&quot;);\n        return mv;\n    &#125;\n&#125;\n当 FreeMarkerViewResolver 解析逻辑视图信息时，会生成一个 URL 为“前缀+视图名+后缀”（这里即“fm_freemarker.ftl”）的 FreeMarkerView 对象，然后通过 FreeMarkerConfigurer 的配置找到 templateLoaderPath 对应文本文件的路径，在该路径下找到该文本文件，从而 FreeMarkerView 就可以利用该模板文件进行视图的渲染，并将 model 数据封装到即将要显示的页面上，最终展示给用户\n在 &#x2F;WEB-INF&#x2F;ftl 文件夹下创建 fm_freemarker.ftl，代码如下：&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;FreeMarker&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;b&gt;Welcome!&lt;&#x2F;b&gt;\n    &lt;i&gt;$&#123;username &#125;&lt;&#x2F;i&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3.Spring MVC 执行流程SpringMVC 的执行流程如下：\n\n用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）\n由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）\nDispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）\nHandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）\nHandler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；\nHandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet\nDispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析\nViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet\nDispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）\n视图负责将结果显示到浏览器（客户端）\n\n3.1 Spring MVC 常用组件Spring MVC 涉及到的组件有 DispatcherServlet（前端控制器）、HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、Handler（处理器）、ViewResolver（视图解析器）和 View（视图）\n3.1.1 前端控制器 DispatcherServletSpring MVC 的所有请求都要经过 DispatcherServlet 来统一分发DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。\n3.1.2 处理器映射器 HandlerMapping根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息\n3.1.3 处理器适配器 HandlerAdapter根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）\n3.1.4 处理器 Handler与 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中\n3.1.5 视图解析器 View Resolver进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）\n3.1.6 视图 View本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）\n以上组件中，需要开发人员进行开发的是处理器（Handler，常称Controller）和视图（View）。通俗的说，要开发处理该请求的具体代码逻辑，以及最终展示给用户的界面。\n3.2 DispatcherServlet 初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\n\na&gt;初始化WebApplicationContext所在类：org.springframework.web.servlet.Frameworkprotected WebApplicationContext initWebApplicationContext() &#123;\n    WebApplicationContext rootContext &#x3D;\n\n WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n    WebApplicationContext wac &#x3D; null;\n     if (this.webApplicationContext !&#x3D; null) &#123;\n        &#x2F;&#x2F; A context instance was injected at construction time -&gt; use it\n        wac &#x3D; this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) &#123;\n            ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) wac;\n            if (!cwac.isActive()) &#123;\n                &#x2F;&#x2F; The context has not yet been refreshed -&gt; provide services such as\n                &#x2F;&#x2F; setting the parent context, setting the application context id, etc\n                if (cwac.getParent() &#x3D;&#x3D; null) &#123;\n                    &#x2F;&#x2F; The context instance was injected without an explicit parent -&gt; set\n                    &#x2F;&#x2F; the root application context (if any; may be null) as the parent\n                    cwac.setParent(rootContext);\n                &#125;\n                configureAndRefreshWebApplicationContext(cwac);\n            &#125;\n        &#125;\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; No context instance was injected at construction time -&gt; see if one\n        &#x2F;&#x2F; has been registered in the servlet context. If one exists, it is assumed\n        &#x2F;&#x2F; that the parent context (if any) has already been set and that the\n        &#x2F;&#x2F; user has performed any initialization such as setting the context id\n        wac &#x3D; findWebApplicationContext();\n    &#125;\n    if (wac &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; No context instance is defined for this servlet -&gt; create a local one\n        &#x2F;&#x2F; 创建WebApplicationContext\n        wac &#x3D; createWebApplicationContext(rootContext);\n    &#125;\n    if (!this.refreshEventReceived) &#123;\n        &#x2F;&#x2F; Either the context is not a ConfigurableApplicationContext with \nrefresh\n        &#x2F;&#x2F; support or the context injected at construction time had already been\n        &#x2F;&#x2F; refreshed -&gt; trigger initial onRefresh manually here.\n        synchronized (this.onRefreshMonitor) &#123;\n            &#x2F;&#x2F; 刷新WebApplicationContext\n            onRefresh(wac);\n        &#125;\n    &#125;\n    if (this.publishContext) &#123;\n        &#x2F;&#x2F; Publish the context as a servlet context attribute.\n        &#x2F;&#x2F; 将IOC容器在应用域共享\n        String attrName &#x3D; getServletContextAttributeName();\n        getServletContext().setAttribute(attrName, wac);\n    &#125;\n    return wac;\n&#125;\n创建WebApplicationContextext所在类：org.springframework.web.servlet.FrameworkServletprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123;\n    Class&lt;?&gt; contextClass &#x3D; getContextClass();\n    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;\n        throw new ApplicationContextException(\n            &quot;Fatal initialization error in servlet with name &#39;&quot; + getServletName() +\n            &quot;&#39;: custom WebApplicationContext class [&quot; + contextClass.getName() +\n            &quot;] is not of type ConfigurableWebApplicationContext&quot;);\n    &#125;\n    &#x2F;&#x2F; 通过反射创建 IOC 容器对象\n    ConfigurableWebApplicationContext wac &#x3D; (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n    wac.setEnvironment(getEnvironment());\n    &#x2F;&#x2F; 设置父容器\n    wac.setParent(parent);\n    String configLocation &#x3D; getContextConfigLocation();\n    if (configLocation !&#x3D; null) &#123;\n        wac.setConfigLocation(configLocation);\n    &#125;\n    configureAndRefreshWebApplicationContext(wac);\n    return wac;\n&#125;\nDispatcherServlet初始化策略FrameworkServlet 创建 WebApplicationContext 后，刷新容器，调用 onRefresh(wac)，此方法在 DispatcherServlet 中进行了重写，调用了 initStrategies(context) 方法，初始化策略，即初始化 DispatcherServlet 的各个组件所在类：org.springframework.web.servlet.DispatcherServletprotected void initStrategies(ApplicationContext context) &#123;\n   initMultipartResolver(context);\n   initLocaleResolver(context);\n   initThemeResolver(context);\n   initHandlerMappings(context);\n   initHandlerAdapters(context);\n   initHandlerExceptionResolvers(context);\n   initRequestToViewNameTranslator(context);\n   initViewResolvers(context);\n   initFlashMapManager(context);\n&#125;\n\n3.3 SpringMVC 的执行流程\n用户向服务器发送请求，请求被 SpringMVC 前端控制器 DispatcherServlet 捕获\nDispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI），判断请求 URI 对应的映射：\n不存在\n再判断是否配置了 mvc:default-servlet-handler\n如果没配置，则控制台报映射查找不到，客户端展示 404 错误\n如果有配置，则访问目标资源（一般为静态资源，如：JS, CSS, HTML），找不到客户端也会展示 404 错误\n\n\n存在则执行下面的流程\n\n\n根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 执行链对象的形式返回\nDispatcherServlet 根据获得的 Handler，选择一个合适的 HandlerAdapter\n如果成功获得 HandlerAdapter，此时将开始执行拦截器的 preHandler(…) 方法【正向】\n提取 Request 中的模型数据，填充 Handler 入参，开始执行 Handler（Controller) 方法，处理请求。在填充 Handler 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：\nHttpMessageConveter： 将请求消息（如 Json、XML 等数据）转换成一个对象，将对象转换为指定的响应信息\n数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等\n数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\n数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中\n\n\nHandler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象\n此时将开始执行拦截器的 postHandle(…) 方法【逆向】\n根据返回的 ModelAndView（此时会判断是否存在异常：如果存在异常，则执行 HandlerExceptionResolver 进行异常处理）选择一个适合的 ViewResolver 进行视图解析，根据 Model 和 View，来渲染视图\n渲染视图完毕执行拦截器的 afterCompletion(…) 方法【逆向】\n将渲染结果返回给客户\n\n4. RequestMapping 注解4.1 @RequestMapping 注解的功能将请求和处理请求的控制器方法关联起来，建立映射关系。SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n4.2 @RequestMapping 注解的位置\n@RequestMapping 标识一个类：设置映射请求的请求路径的初始信息\n@RequestMapping标识一个方法：设置映射请求请求路径的具体信息\n\n@Controller\n@RequestMapping(&quot;&#x2F;test&quot;)\npublic class RequestMappingController &#123;\n    &#x2F;&#x2F; 此时请求映射所映射的请求的请求路径为：&#x2F;test&#x2F;testRequestMapping\n    @RequestMapping(&quot;&#x2F;testRequestMapping&quot;)\n    public String testRequestMapping()&#123;\n        return &quot;success&quot;;\n    &#125;\n&#125;\n\n4.3 value 属性\n通过请求的请求地址匹配请求映射，注解的 value 属性必须设置，至少通过请求地址匹配请求映射\nvalue 属性是 @RequestMapping 注解的默认属性，因此如果只有 value 属性时，可以省略该属性名，如果有其它属性，则必须写上 value 属性名称\n@RequestMapping 注解的 value 属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求\nvalue 属性支持通配符匹配，如 @RequestMapping(value=&quot;toUser/*&quot;) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问\n\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;&#x2F;testRequestMapping&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;&#x2F;test&lt;&#x2F;a&gt;&lt;br&gt;\n\n@RequestMapping(value &#x3D; &#123;&quot;&#x2F;testRequestMapping&quot;, &quot;&#x2F;test&quot;&#125;)\n&#x2F;&#x2F; @RequestMapping(&quot;&#x2F;test&quot;)\npublic String testRequestMapping()&#123;\n    return &quot;success&quot;;\n&#125;\n\n4.4 path 属性\npath 属性和 value 属性都用来作为映射使用。即 @RequestMapping(value=&quot;toUser&quot;) 和 @RequestMapping(path=&quot;toUser&quot;) 都能访问 toUser() 方法\npath 属性支持通配符匹配，如 @RequestMapping(path=&quot;toUser/*&quot;) 表示 http://localhost:8080/toUser/1 或 http://localhost:8080/toUser/hahaha 都能够正常访问\n\n4.5 name 属性name 属性相当于方法的注释，使方法更易理解。如 @RequestMapping(value =&quot;toUser&quot;, name = &quot;获取用户信息&quot;)\n4.6 method 属性\nmethod 属性用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求\n@RequestMapping 注解的 method 属性通过请求的请求方式（get 或 post）匹配请求映射\n@RequestMapping 注解的 method 属性是一个 RequestMethod 类型的数组，表示该请求映射能够匹配多种请求方式的请求\n\n若当前请求的请求地址满足请求映射的 value 属性，但是请求方式不满足 method 属性，则浏览器报错 405：Request method &#39;POST&#39; not supported\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;&#x2F;test&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;test&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n\n@RequestMapping(\n\tvalue &#x3D; &#123;&quot;&#x2F;testRequestMapping&quot;, &quot;&#x2F;test&quot;&#125;,\n\tmethod &#x3D; &#123;RequestMethod.GET, RequestMethod.POST&#125;\n)\npublic String testRequestMapping()&#123;\n\treturn &quot;success&quot;;\n&#125;\n\n对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解\n\n处理 GET 请求的映射，查询 –&gt; @GetMapping\n处理 POST 请求的映射，新增 –&gt; @PostMapping\n处理 PUT 请求的映射，修改 –&gt; @PutMapping\n处理 DELETE请求的映射，删除 –&gt; @DeleteMapping\n\n常用的请求方式有 GET，POST，PUT，DELETE。但是目前浏览器只支持 GET 和 POST，若在 Form 表单提交时，为 method 设置了其他请求方式的字符串（PUT 或 DELETE），则按照默认的请求方式 GET 处理，若要发送 PUT 和 DELETE 请求，则需要通过 Spring 提供的过滤器 HiddenHttpMethodFilter\n4.7 params 属性@RequestMapping 注解的 params 属性通过请求的请求参数匹配请求映射@RequestMapping 注解的 params 属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系：\n\n&quot;param&quot;：要求请求映射所匹配的请求必须携带 param 请求参数\n&quot;!param&quot;：要求请求映射所匹配的请求必须不能携带 param 请求参数\n&quot;param=value&quot;：要求请求映射所匹配的请求必须携带 param 请求参数且param&#x3D;value\n&quot;param!=value&quot;：要求请求映射所匹配的请求必须携带 param 请求参数但param!&#x3D;value\n\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;test(username&#x3D;&#39;admin&#39;,password&#x3D;123456)&quot;&gt;测试@RequestMapping的params属性--&gt;&#x2F;test&lt;&#x2F;a&gt;&lt;br&gt;\n\n@RequestMapping(\n        value &#x3D; &#123;&quot;&#x2F;testRequestMapping&quot;, &quot;&#x2F;test&quot;&#125;\n        ,method &#x3D; &#123;RequestMethod.GET, RequestMethod.POST&#125;\n        ,params &#x3D; &#123;&quot;username&quot;,&quot;password!&#x3D;123456&quot;&#125;\n)\npublic String testRequestMapping()&#123;\n    return &quot;success&quot;;\n&#125;\n\n若当前请求满足 @RequestMapping 注解的 value 和 method 属性，但是不满足 params 属性，此时页面会报错400：Parameter conditions &quot;username, password!=123456&quot; not met for actual request parameters: username=&#123;admin&#125;, password=&#123;123456&#125;\n4.8 headers 属性@RequestMapping 注解的 headers 属性通过请求的请求头信息匹配请求映射@RequestMapping 注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系：\n\n&quot;header&quot;：要求请求映射所匹配的请求必须携带header请求头信息\n&quot;!header&quot;：要求请求映射所匹配的请求必须不能携带header请求头信息\n&quot;header=value&quot;：要求请求映射所匹配的请求必须携带header请求头信息且header&#x3D;value\n&quot;header!=value&quot;：要求请求映射所匹配的请求必须携带header请求头信息且header!&#x3D;value\n\n若当前请求满足 @RequestMapping 注解的 value 和 method 属性，但是不满足 headers 属性，此时页面显示404错误，即资源未找到。\n4.9 consumers 属性consumers 属性用于指定处理请求的提交内容类型（Content-Type），例如 application/json、text/html如: @RequestMapping(value = &quot;toUser&quot;,consumes = &quot;application/json&quot;)\n4.10 produces 属性produces 属性用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型。 如：@RequestMapping(value = &quot;toUser&quot;, produces = &quot;application/json&quot;)除此之外，produces 属性还可以指定返回值的编码。 如： @RequestMapping(value = &quot;toUser&quot;, produces = &quot;application/json, charset=utf-8&quot;)，表示返回 UTF-8 编码。\n4.11 SpringMVC支持ant风格的路径\n？：表示任意的单个字符，?，&#x2F; 两个特殊字符不行\n*：表示任意的 0 个或多个字符\n**：表示任意的一层或多层目录\n\n注：在使用 ** 时，只能使用 /**/xxx 的方式\n@RequestMapping(&quot;&#x2F;a?a&#x2F;target&quot;)\n&#x2F;&#x2F; @RequestMapping(&quot;&#x2F;**&#x2F;target&quot;)\npublic String toTarget()&#123;\n\treturn &quot;target&quot;;\n&#125;\n\n4.12 SpringMVC 支持路径中的占位符\n原始方式：/deleteUser?id=1\nREST 方式：/deleteUser/1\n\nSpringMVC 路径中的占位符常用于 RESTful 风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的 @RequestMapping 注解的 value 属性中通过占位符 &#123;xxx&#125; 表示传输的数据，再通过 @PathVariable 注解，将占位符所表示的数据赋值给控制器方法的形参\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;testRest&#x2F;1&#x2F;admin&#125;&quot;&gt;测试路径中的占位符--&gt;&#x2F;testRest&lt;&#x2F;a&gt;&lt;br&gt;\n\n@RequestMapping(&quot;&#x2F;testRest&#x2F;&#123;id&#125;&#x2F;&#123;username&#125;&quot;)\npublic String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) \nString username)&#123;\n    System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username);\n    return &quot;success&quot;;\n&#125;\n&#x2F;&#x2F; 最终输出的内容为--&gt;id:1,username:adm\n\n5. SpringMVC 获取请求参数5.1 原生 ServletAPI 获取将 HttpServletRequest 作为控制器方法的形参，此时 HttpServletRequest 类型的参数表示封装了当前请求的请求报文的对象\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;param(username &#x3D; &#39;张三&#39;, password &#x3D; 123)&#125;&quot;&gt;111&lt;&#x2F;a&gt;\n\n@RequestMapping(&quot;&#x2F;param&quot;)\npublic String param(HttpServletRequest request)&#123;\n\tString username &#x3D; request.getParameter(&quot;username&quot;);\n\tString password &#x3D; request.getParameter(&quot;password&quot;);\n\tSystem.out.println(&quot;username:&quot; + username + &quot;password:&quot; + password);\n\treturn &quot;param&quot;;\n&#125;\n\n5.2 通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在 DispatcherServlet 中就会将请求参数赋值给相应的形参\n&lt;a th:href&#x3D;&quot;@&#123;&#x2F;testParam(username&#x3D;&#39;admin&#39;,password&#x3D;123456)&#125;&quot;&gt;测试获取请求参数--&gt;&#x2F;testParam&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;testParam&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; placeholder&#x3D;&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;password&quot;&gt;&lt;br&gt;\n    爱好：&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;a&quot;&gt;a\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;b&quot;&gt;b\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;c&quot;&gt;c&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n\n@RequestMapping(&quot;&#x2F;testParam&quot;)\npublic String param(String username, String password, String[] hobby)&#123;\n\tSystem.out.println(&quot;username:&quot; + username + &quot;,password:&quot; + password + &quot;,hobby&quot; + Arrays.toString(hobby));\n\treturn &quot;success&quot;;\n&#125;\n\n\n若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数\n若使用字符串数组类型的形参，此参数的数组中包含了每一个数据\n若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n\n5.3 @RequestParam@RequestParam 是将请求参数和控制器方法的形参创建映射关系，一共有三个属性：\n\nvalue：指定为形参赋值的请求参数的参数名\nrequired：设置是否必须传输此请求参数，默认值为 true若设置为 true 时，则当前请求必须传 value 所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue 属性，则页面报错400：Required String parameter &#39;xxx&#39; is not present若设置为 false，则当前请求不是必须传 value 所指定的请求参数，若没有传输，则注解所标识的形参的值为 null\ndefaultValue：不管 required 属性值为 true 或 false，当 value 所指定的请求参数没有传输或传输的值为 “” 时，则使用默认值为形参赋值\n\n@RequestMapping(&quot;&#x2F;testParam&quot;)\npublic String param(@RequestParam(value &#x3D; &quot;username&quot;, required &#x3D; false, defaultValue &#x3D; &quot;hehe&quot;) String username, \n                    @RequestParam(&quot;password&quot;) String password, \n                    @RequestParam(&quot;hobby&quot;) String[] hobby)&#123;\n\tSystem.out.println(&quot;username:&quot; + username + &quot;,password:&quot; + password + &quot;,hobby&quot; + Arrays.toString(hobby));\n\treturn &quot;success&quot;;\n&#125;\n\n5.4 @RequestHeader@RequestHeader 是将请求头信息和控制器方法的形参创建映射关系@RequestHeader 注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n5.5 @CookieValue@CookieValue 是将 Cookie 数据和控制器方法的形参创建映射关系@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n5.6 通过 POJO 获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值\n@RequestMapping(&quot;&#x2F;testParam&quot;)\npublic String testParam(User user)&#123;\n\tSystem.out.println(user);\n\treturn &quot;success&quot;;\n&#125;\n\n5.7 @ModelAttribute\n@ModelAttribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用\n而 “通过实体 Bean 接收请求参数” 中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据）\n\n通过 @ModelAttribute 注解接收请求参数适用于 GET 和 POST 提交请求方式，示例代码如下：\n@RequestMapping(&quot;&#x2F;login&quot;)\npublic String login(@ModelAttribute(&quot;user&quot;) User user, Model model) &#123;\n   \n    if (&quot;bianchengbang&quot;.equals(name)\n            &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123;\n     \n        model.addAttribute(&quot;message&quot;, &quot;登录成功&quot;);\n        return &quot;main&quot;; &#x2F;&#x2F; 登录成功，跳转到 main.jsp\n    &#125; else &#123;\n        model.addAttribute(&quot;message&quot;, &quot;用户名或密码错误&quot;);\n        return &quot;login&quot;;\n    &#125;\n&#125;\n\n因为模型对象要先于 Controller 方法之前创建，所以被 @ModelAttribute 注解的方法会在 Controller 每个方法执行之前都执行。因此一个 Controller 映射多个 URL 时，要谨慎使用。\n5.8 获取请求参数乱码问题解决获取请求参数的乱码问题，可以使用 SpringMVC 提供的编码过滤器CharacterEncodingFilter，但是必须在 web.xml 中进行注册\n&lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &#x2F;&#x2F; 设置请求编码\n      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;forceResponseEncoding&lt;&#x2F;param-name&gt; &#x2F;&#x2F; 设置响应编码\n      &lt;param-value&gt;true&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncoding&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n\n6. 域共享数据6.1 使用 ServletAPI 向 request 域对象共享数据请求域（request scope），仅限于当前请求过程，包括转发（forward）或被包含（include）的情况\n@RequestMapping(&quot;&#x2F;testServletAPI&quot;)\npublic String testServletAPI(HttpServletRequest request)&#123;\n    request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;);\n    return &quot;success&quot;;\n&#125;\n\n6.2 使用 ModelAndView 向 request 域对象共享数据@RequestMapping(&quot;&#x2F;testModelAndView&quot;)\npublic ModelAndView testModelAndView()&#123;\n    &#x2F;**\n     * ModelAndView有Model和View的功能\n     * Model主要用于向请求域共享数据\n     * View主要用于设置视图，实现页面跳转\n     *&#x2F;\n    ModelAndView mav &#x3D; new ModelAndView();\n    &#x2F;&#x2F;向请求域共享数据\n    mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;);\n    &#x2F;&#x2F;设置视图，实现页面跳转\n    mav.setViewName(&quot;success&quot;);\n    return mav;\n&#125;\n\n6.3 使用 Model 向 request 域对象共享数据@RequestMapping(&quot;&#x2F;testModel&quot;)\npublic String testModel(Model model)&#123;\n    model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;);\n    return &quot;success&quot;;\n&#125;\n\n6.4 使用 map 向 request 域对象共享数据@RequestMapping(&quot;&#x2F;testMap&quot;)\npublic String testMap(Map&lt;String, Object&gt; map)&#123;\n    map.put(&quot;testScope&quot;, &quot;hello,Map&quot;);\n    return &quot;success&quot;;\n&#125;\n\n6.5 使用 ModelMap 向 request 域对象共享数据@RequestMapping(&quot;&#x2F;testModelMap&quot;)\npublic String testModelMap(ModelMap modelMap)&#123;\n    modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;);\n    return &quot;success&quot;;\n&#125;\n\n6.6 Model、ModelMap、Map 的关系Model、ModelMap、Map 类型的参数其实本质上都是 BindingAwareModelMap 类型的\npublic interface Model&#123;&#125;\npublic class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;\npublic class ExtendedModelMap extends ModelMap implements Model &#123;&#125;\npublic class BindingAwareModelMap extends ExtendedModelMapP &#123;&#125;\n\n6.7 向 session 域共享数据会话域（session scope），限于当前会话，即当前服务器与客户端连接期间，当关闭浏览器或者退出浏览器时，当前会话则失效\n@RequestMapping(&quot;&#x2F;testSession&quot;)\npublic String testSession(HttpSession session)&#123;\n    session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;);\n    return &quot;success&quot;;\n&#125;\n\n6.8 向 application（应用）域共享数据应用域（application scope），有效于整个服务器启动期间，关闭浏览器或退出都不会失效，在服务器关闭时失效\n@RequestMapping(&quot;&#x2F;testApplication&quot;)\npublic String testApplication(HttpSession session)&#123;\n    ServletContext application &#x3D; session.getServletContext();\n    application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;);\n    return &quot;success&quot;;\n&#125;\n\n7. 视图（转发与重定向）\nSpringMVC 中的视图是 View 接口，视图的作用渲染数据，将模型 Model 中的数据展示给用户\nSpringMVC 视图的种类很多，默认有转发视图（forward:）和重定向视图（redirect:）\n当工程引入 jstl 的依赖，转发视图会自动转换为 JstlView\n若使用的视图技术为 Thymeleaf，在 SpringMVC 的配置文件中配置了 Thymeleaf 的视图解析器，由此视图解析器解析之后所得到的是 ThymeleafView\n\n7.1 ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC 配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。控制器类中处理方法的 return 语句默认就是转发实现，只不过实现的是转发到视图。\n@RequestMapping(&quot;&#x2F;testHello&quot;)\npublic String testHello()&#123;\n    return &quot;hello&quot;;\n&#125;\n\n处理当前结果：渲染视图：获取当前视图：\n7.2 转发视图SpringMVC中默认的转发视图是InternalResourceView\n\n转发过程：客户浏览器发送 HTTP 请求，Web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户。在这里转发的路径必须是同一个 Web 容器下的 URL，其不能转向到其他的 Web 路径上，中间传递的是自己的容器内的 request\nSpringMVC 中创建转发视图的情况：当控制器方法中所设置的视图名称以 &quot;forward:&quot; 为前缀时，创建InternalResourceView 视图，此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 &quot;forward:&quot; 去掉，剩余部分作为最终路径通过转发的方式实现跳转\n浏览器发送一次请求，地址不变，发生在服务器内部，不能跨域\n\n例如：&quot;forward:/&quot;，&quot;forward:/employe\n@RequestMapping(&quot;test&quot;)\npublic String test()&#123;\n\treturn &quot;forward:toSuccess&quot;;\n&#125;\n@RequestMapping(&quot;toSuccess&quot;)\npublic String toSuccess(Model model)&#123;\n\tmodel.addAttribute(&quot;test&quot;,&quot;testModel&quot;);\n\treturn &quot;success&quot;;\n&#125;\n\n7.3 重定向视图SpringMVC中默认的重定向视图是RedirectView\n\n重定向过程：客户浏览器发送 HTTP 请求，Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 HTTP 请求，请求 URL 是新的 location 地址，服务器根据此请求寻找资源并发送给客户\nSpringMVC 中创建重定向视图的情况：当控制器方法中所设置的视图名称以 &quot;redirect:&quot; 为前缀时，创建 RedirectView 视图，此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 &quot;redirect:&quot; 去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n浏览器发送两次请求，地址改变，WEB-INF目录下内容不能被重定向，具有安全性，可以跨域\n\n例如：&quot;redirect:/&quot;，&quot;redirect:/employee&quot;\n@RequestMapping(&quot;test&quot;)\npublic String test()&#123;\n\treturn &quot;redirect:toSuccess&quot;;\n&#125;\n@RequestMapping(&quot;toSuccess&quot;)\npublic String toSuccess(Model model)&#123;\n\tmodel.addAttribute(&quot;test&quot;,&quot;testModel&quot;);\n\treturn &quot;success&quot;;\n&#125;\n\n\n7.4 视图控制器当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用 view-controller 标签进行表示。\n当 SpringMVC 中设置任何一个 view-controller 时，其他控制器中的请求映射将全部失效，此时需要在 SpringMVC 的核心配置文件中设置开启 MVC 注解驱动的标签：&lt;mvc:annotation-driven /&gt;\n&lt;!--\n    path：设置处理的请求地址\n    view-name：设置请求地址所对应的视图名称\n--&gt;\n&lt;mvc:view-controller path&#x3D;&quot;&#x2F;index&quot; view-name&#x3D;&quot;index&quot; &#x2F;&gt;\n&lt;mvc:annotation-driven &#x2F;&gt;\n\n在 Spring MVC 框架中，不管是重定向或转发，都需要符合视图解析器的配置，如果直接转发到一个不需要 DispatcherServlet 的资源，则需要配置静态资源路径\n8. RESTful8.1 RESTful 简介REST：Representational State Transfer，表现层资源状态转移\n\n资源****资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词一个资源可以由一个或多个 URI 来标识。URI 既是资源的名称，也是资源在 Web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 与其进行交互\n资源的表述****资源的表述是一段对于资源在某个特定时刻的状态的描述，可以在客户端-服务器端之间转移（交换）资源的表述可以有多种格式，例如 HTML&#x2F;XML&#x2F;JSON&#x2F;纯文本&#x2F;图片&#x2F;视频&#x2F;音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式\n状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的\n\n8.2 RESTful 的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE用来删除资源\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性\n8.3 HiddenHttpMethodFilter由于浏览器只支持发送 GET 和 POST 方式的请求，SpringMVC 提供了 HiddenHttpMethodFilter 将 POST 请求转换为 DELETE 或 PUT 请求\nHiddenHttpMethodFilter 处理 PUT 和 DELETE 请求的条件：\n\n当前请求的请求方式必须为 POST\n当前请求必须传输请求参数 _method\n\n满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数 _method 的值，因此请求参数 _method 的值才是最终的请求方式\n在 web.xml 中注册 HiddenHttpMethodFilte\n&lt;filter&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\n\n@RequestMapping(value &#x3D; &quot;&#x2F;user&quot;, method &#x3D; RequestMethod.PUT)\npublic String user(String username, String password)&#123;\n    System.out.println(&quot;username&quot; + username + &quot;,password&quot; + password);\n    return &quot;success&quot;;\n&#125;\n\n&lt;form method&#x3D;&quot;post&quot;&gt; &#x2F;&#x2F; post 请求\n    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;_method&quot; value&#x3D;&quot;put&quot;&gt; &#x2F;&#x2F; 设置_method\n \t  email:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot;&gt;&lt;br&gt;\n    gender:&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;1&quot;&gt;male\n    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;0&quot;&gt;female&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;add&quot;&gt;&lt;br&gt;\n&lt;&#x2F;form&gt;\n\n目前为止，SpringMVC 中提供了两个过滤器：CharacterEncodingFilter 和 HiddenHttpMethodFilter\n在 web.xml 中注册时，必须先注册 CharacterEncodingFilter，再注册 HiddenHttpMethodFilter\n在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集。request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作，而 HiddenHttpMethodFilter 恰恰有一个获取请求参数的操作 String paramValue = request.getParameter(this.methodParam);\n9. HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文\nHttpMessageConverter 提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity\n9.1 @RequestBody@RequestBody 可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody 进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n&lt;form th:action&#x3D;&quot;@&#123;&#x2F;testRequestBody&#125;&quot; method&#x3D;&quot;post&quot;&gt;\n    用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n\n@RequestMapping(&quot;&#x2F;testRequestBody&quot;)\npublic String testRequestBody(@RequestBody String requestBody)&#123;\n    System.out.println(&quot;requestBody:&quot;+requestBody);\n    return &quot;success&quot;;\n&#125;\n输出：requestBody:username&#x3D;admin&amp;password&#x3D;1234\n\n9.2 RequestEntityRequestEntity 封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过 getHeaders() 获取请求头信息，通过 getBody() 获取请求体信息\n@RequestMapping(&quot;&#x2F;testRequestEntity&quot;)\npublic String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123;\n    System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders());\n    System.out.println(&quot;requestBody:&quot;+requestEntity.getBody());\n    return &quot;success&quot;;\n&#125;\n\n9.3 @ResponseBody@ResponseBody 用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n@RequestMapping(&quot;&#x2F;testResponseBody&quot;)\n@ResponseBody\npublic String testResponseBody()&#123;\n    return &quot;success&quot;;\n&#125;\n&#x2F;&#x2F; 浏览器页面显示 success\n\n9.4 SpringMVC 处理 JSON9.4.1 JSON 概述与 XML 一样，JSON 也是基于纯文本的数据格式。它有对象结构和数组结构两种数据结构\n\n对象结构对象结构以 &#123;开始、以&#125; 结束，中间部分由 0 个或多个以英文,分隔的 key&#x2F;value 对构成，key 和 value 之间以英文:分隔。 对象结构的语法结构如下：\n&#123;\n    key1:value1,\n    key2:value2,\n    ...\n&#125;\n\n其中，key 必须为 String 类型，value 可以是 String、Number、Object、Array 等数据类型。例如，一个 person 对象包含姓名、密码、年龄等信息，使用 JSON 的表示形式如下：\n&#123;\n    &quot;pname&quot;:&quot;张三&quot;,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;page&quot;:40\n&#125;\n数组结构数组结构以 [开始、以] 结束，中间部分由 0 个或多个以英文,分隔的值的列表组成。 数组结构的语法结构如下：\n[\n    value1,\n    value2,\n    ...\n]\n\n上述两种（对象、数组）数据结构也可以分别组合构成更加复杂的数据结构。例如，一个 student 对象包含 sno、sname、hobby 和 college 对象，其 JSON 的表示形式如下：\n&#123;\n    &quot;sno&quot;:&quot;201802228888&quot;,\n    &quot;sname&quot;:&quot;张三&quot;,\n    &quot;hobby&quot;:[&quot;篮球&quot;,&quot;足球&quot;]，\n    &quot;college&quot;:&#123;\n        &quot;cname&quot;:&quot;清华大学&quot;,\n        &quot;city&quot;:&quot;北京&quot;\n    &#125;\n&#125;\n\n9.4.2 @ResponseBody 处理 JSON 的步骤\n导入 jackson 的依赖&lt;!-- 开源的jackson，Spring MVC 内置的 JSON 转换工具 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- fastjson，用 Java 语言编写的高性能 JSON 处理器，由阿里巴巴公司开发。不需要依赖其它的 jar 文件，\n就能直接在 JDK 上运行。FastJson 在复杂类型的 Bean 转换 JSON 上会出现一些问题，可能会出现引用的类型，\n导致 JSON 转换出错，需要制定引用。--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.62&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n在SpringMVC的核心配置文件中开启 MVC 的注解驱动，此时在 HandlerAdaptor 中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的 Java 对象转换为 JSON 格式的字符串&lt;mvc:annotation-driven &#x2F;&gt;\n在处理器方法上使用@ResponseBody注解进行标识\n将 Java 对象直接作为控制器方法的返回值返回，就会自动转换为 JSON 格式的字符串\n\n@RequestMapping(&quot;&#x2F;testResponseUser&quot;)\n@ResponseBody\npublic User testResponseUser()&#123;\n    return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);\n&#125;\n&#x2F;&#x2F; &#123;&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;&#125;\n\n9.5 SpringMVC 处理 ajax\n请求超链接：&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;a th:href&#x3D;&quot;@&#123;&#x2F;testAjax&#125;&quot; @click&#x3D;&quot;testAjax&quot;&gt;testAjax&lt;&#x2F;a&gt;&lt;br&gt;\n&lt;&#x2F;div&gt;\n通过 Vue 和 Axios 处理点击事件：&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;js&#x2F;vue.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;js&#x2F;axios.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    var vue &#x3D; new Vue(&#123;\n        el:&quot;#app&quot;,\n        methods:&#123;\n            testAjax:function (event) &#123;\n                axios(&#123;\n                    method:&quot;post&quot;,\n                    url:event.target.href,\n                    params:&#123;\n                        username:&quot;admin&quot;,\n                        password:&quot;123456&quot;\n                    &#125;\n                &#125;).then(function (response) &#123;\n                    alert(response.data);\n                &#125;);\n                event.preventDefault();\n            &#125;\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n控制器方法：@RequestMapping(&quot;&#x2F;testAjax&quot;)\n@ResponseBody\npublic String testAjax(String username, String password)&#123;\n    System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password);\n    return &quot;hello,ajax&quot;;\n&#125;\n\n9.6 @RestController 注解@RestController 注解是 SpringMVC 提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 @Controller 注解，并且为其中的每个方法添加了 @ResponseBody 注解\n9.7 ResponseEntityResponseEntity 用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n9.8 ResponseEntity 和 ResponseBody 的区别\nResponseEntity 的优先级高于 @ResponseBody在不是 ResponseEntity 的情况下才去检查有没有 @ResponseBody 注解。如果响应类型是 ResponseEntity 可以不写 @ResponseBody 注解，写了也没有关系。@ResponseBody 可以直接返回 JSON 结果，\nResponseEntity 表示整个 HTTP 响应：状态代码，标题和正文。因此，可以使用它来完全配置 HTTP 响应，它是一个对象。@ResponseEntity 不仅可以返回 JSON 结果，还可以定义返回的 HttpHeaders 和 HttpStatus\n\n10. 文件上传和下载10.1 文件下载使用 ResponseEntity 实现下载文件的功能：\n@RequestMapping(&quot;&#x2F;testDown&quot;)\npublic ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123;\n    &#x2F;&#x2F;获取ServletContext对象\n    ServletContext servletContext &#x3D; session.getServletContext();\n    &#x2F;&#x2F;获取服务器中文件的真实路径\n    String realPath &#x3D; servletContext.getRealPath(&quot;&#x2F;static&#x2F;img&#x2F;1.jpg&quot;);\n    &#x2F;&#x2F;创建输入流\n    InputStream is &#x3D; new FileInputStream(realPath);\n    &#x2F;&#x2F;创建字节数组\n    byte[] bytes &#x3D; new byte[is.available()];\n    &#x2F;&#x2F;将流读到字节数组中\n    is.read(bytes);\n    &#x2F;&#x2F;创建HttpHeaders对象设置响应头信息\n    MultiValueMap&lt;String, String&gt; headers &#x3D; new HttpHeaders();\n    &#x2F;&#x2F;设置要下载方式以及下载文件的名字\n    headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;1.jpg&quot;);\n    &#x2F;&#x2F;设置响应状态码\n    HttpStatus statusCode &#x3D; HttpStatus.OK;\n    &#x2F;&#x2F;创建ResponseEntity对象\n    ResponseEntity&lt;byte[]&gt; responseEntity &#x3D; new ResponseEntity&lt;&gt;(bytes, headers, statusCode);\n    &#x2F;&#x2F;关闭输入流\n    is.close();\n    return responseEntity;\n&#125;\n\n10.2 文件上传文件上传要求 Form 表单的请求方式必须为 POST，并且添加属 enctype=&quot;multipart/form-data&quot;，SpringMVC 中将上传的文件封装到 MultipartFile 对象中，通过此对象可以获取文件相关信息\n\n添加依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.3.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n在 SpringMVC 的配置文件中添加配置，文件上传解析器，根据 id 获取，固定值\n&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\n\t\t&lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;5000000&quot; &#x2F;&gt;\n    &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n控制器方法：\n@RequestMapping(&quot;&#x2F;testUp&quot;)\npublic String testUp(MultipartFile photo, HttpSession session) throws IOException &#123;\n    &#x2F;&#x2F;获取上传的文件的文件名\n    String fileName &#x3D; photo.getOriginalFilename();\n    &#x2F;&#x2F;处理文件重名问题\n    String hzName &#x3D; fileName.substring(fileName.lastIndexOf(&quot;.&quot;));\n     fileName &#x3D; UUID.randomUUID().toString() + hzName;\n    &#x2F;&#x2F;获取服务器中photo目录的路径\n    ServletContext servletContext &#x3D; session.getServletContext();\n    String photoPath &#x3D; servletContext.getRealPath(&quot;photo&quot;);\n    File file &#x3D; new File(photoPath);\n    if(!file.exists())&#123;\n        file.mkdir();\n    &#125;\n    String finalPath &#x3D; photoPath + File.separator + fileName;\n    &#x2F;&#x2F;实现上传功能\n    photo.transferTo(new File(finalPath));\n    return &quot;success&quot;;\n&#125;\n页面：负责文件上传表单的编码类型必须是 “multipart/form-data” 类型，表单的 enctype 属性指定的是表单数据的编码方式，该属性有以下 3 个值：\n\napplication/x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的 value 属性值\nmultipart/form-data：该编码方式以二进制流的方式来处理表单数据，并将文件域指定文件的内容封装到请求参数里\ntext/plain：该编码方式只有当表单的 action 属性为 “mailto：”URL 的形式时才使用，主要适用于直接通过表单发送邮件的方式\n\n&lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath &#125;&#x2F;fileupload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n        选择文件：&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;myfile&quot;&gt;&lt;br&gt; \n        文件描述：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;description&quot;&gt;&lt;br&gt; \n        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n11. 拦截器、异常处理器11.1 拦截器的配置\nSpringMVC 中的拦截器用于拦截控制器方法的执行\nSpringMVC 中的拦截器需要实现 HandlerInterceptor\n通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类（例如 HandlerInterceptorAdapter）来定义\n通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口的实现类来定义\n\n\nSpringMVC 的拦截器必须在 SpringMVC 的配置文件中进行配置&lt;mvc:interceptors&gt;\n\t&lt;bean class&#x3D;&quot;fan.FirstInterceptor&quot;&gt;&lt;&#x2F;bean&gt;\n\t&lt;ref bean&#x3D;&quot;firstInterceptor&quot;&gt;&lt;&#x2F;ref&gt;\n&lt;!-- 以上两种配置方式都是对 DispatcherServlet 所处理的所有的请求进行拦截 --&gt;\n    &lt;mvc:interceptor&gt;\n    \t&lt;!-- 配置拦截器作用的路径 &#x2F;* 表示一层目录，&#x2F;** 表示拦截所有请求 --&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;\n        &lt;!-- 配置不需要拦截作用的路径 --&gt;\n        &lt;mvc:exclude-mapping path&#x3D;&quot;&#x2F;testRequestEntity&quot;&#x2F;&gt;\n        &lt;!-- 定义 &lt;mvc:interceptor&gt; 元素中，表示匹配指定路径的请求才进行拦截 --&gt;\n        &lt;ref bean&#x3D;&quot;firstInterceptor&quot;&gt;&lt;&#x2F;ref&gt;\n    &lt;&#x2F;mvc:interceptor&gt;\n&lt;&#x2F;mvc:interceptors&gt;\n&lt;!-- \n    以上配置方式可以通过 ref 或 bean 标签设置拦截器，通过 mvc:mapping 设置需要拦截的请求，\n    通过 mvc:exclude-mapping 设置需要排除的请求，即不需要拦截的请求\n--&gt;\n\n&lt;mvc:interceptor&gt; 元素的子元素必须按照 &lt;mvc:mapping.../&gt;、&lt;mvc:exclude-mapping.../&gt;、&lt;bean.../&gt; 的顺序配置\n11.2 拦截器的三个抽象方法SpringMVC 中的拦截器有三个抽象方法：\n\npreHandle： 控制器方法执行之前执行 preHandle()，其 boolean 类型的返回值表示是否拦截或放行，返回 true 为放行，即调用控制器方法；返回 false 表示拦截，即不调用控制器方法\npostHandle： 控制器方法执行之后执行 postHandle()\nafterComplation： 处理完视图和模型数据，渲染视图完毕之后执行 afterComplation()\n\n\npublic class FirstInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;preHandle...&quot;);\n        return true;\n    &#125;\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;postHandle...&quot;);\n    &#125;\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;afterCompletion...&quot;);\n    &#125;\n&#125;\n\n11.3 多个拦截器的执行顺序\n若每个拦截器的 preHandle() 都返回 true此时多个拦截器的执行顺序和拦截器在 SpringMVC 的配置文件的配置顺序有关：preHandle() 会按照配置的顺序执行，而 postHandle() 和 afterComplation() 会按照配置的反序执行\n若某个拦截器的 preHandle() 返回了 falsepreHandle() 返回 false 和它之前的拦截器的 preHandle() 都会执行，postHandle() 都不执行，返回 false 的拦截器之前的拦截器的 afterComplation() 会执行\n\n\n11.4 基于配置的异常处理\nSpringMVC 提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver\nHandlerExceptionResolver 接口的实现类有：DefaultHandlerExceptionResolver 默认异常处理器和 SimpleMappingExceptionResolver 简单异常处理器\nSpringMVC 提供了自定义的异常处理器 SimpleMappingExceptionResolver\n\n&lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;\n    &lt;property name&#x3D;&quot;exceptionMappings&quot;&gt;\n        &lt;props&gt;\n            &lt;!--\n                properties的键表示处理器方法执行过程中出现的异常\n                properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面\n            --&gt;\n            &lt;prop key&#x3D;&quot;java.lang.ArithmeticException&quot;&gt;error&lt;&#x2F;prop&gt;\n        &lt;&#x2F;props&gt;\n    &lt;&#x2F;property&gt;\n    &lt;!--\n        exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享\n    --&gt;\n    &lt;property name&#x3D;&quot;exceptionAttribute&quot; value&#x3D;&quot;ex&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n11.5 基于注解的异常处理&#x2F;&#x2F;@ControllerAdvice将当前类标识为异常处理的组件\n@ControllerAdvice\npublic class ExceptionController &#123;\n    &#x2F;&#x2F;@ExceptionHandler用于设置所标识方法处理的异常\n    @ExceptionHandler(value &#x3D; &#123;ArithmeticException.class, NullPointerException.class&#125;)\n    &#x2F;&#x2F;ex表示当前请求处理中出现的异常对象\n    public String testException(Exception ex, Model model)&#123;\n        model.addAttribute(&quot;ex&quot;, ex);\n        return &quot;error&quot;;\n    &#125;\n&#125;\n\n12. 注解配置 SpringMVC使用配置类和注解代替 web.xml 和 SpringMVC 配置文件的功能\n12.1 创建初始化类，代替 web.xml在 Servlet3.0 环境中，容器会在类路径中查找实现 javax.servlet.ServletContainerInitializer 接口的类，如果找到的话就用它来配置 Servlet 容器。 Spring 提供了这个接口的实现，名为 SpringServletContainerInitializer，这个类反过来又会查找实现 WebApplicationInitializer 的类并将配置的任务交给它们来完成\nSpring3.2 引入了一个便利的 WebApplicationInitializer 基础实现，名为 AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了 AbstractAnnotationConfigDispatcherServletInitializer 并将其部署到 Servlet3.0 容器的时候，容器会自动发现它，并用它来配置 Servlet 上下文\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    &#x2F;**\n     * 指定spring的配置类\n     * @return\n     *&#x2F;\n    @Override\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[]&#123;SpringConfig.class&#125;;\n    &#125;\n    &#x2F;**\n     * 指定SpringMVC的配置类\n     * @return\n     *&#x2F;\n    @Override\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[]&#123;WebConfig.class&#125;;\n    &#125;\n    &#x2F;**\n     * 指定DispatcherServlet的映射规则，即url-pattern\n     * @return\n     *&#x2F;\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n    &#x2F;**\n     * 添加过滤器\n     * @return\n     *&#x2F;\n    @Override\n    protected Filter[] getServletFilters() &#123;\n        CharacterEncodingFilter encodingFilter &#x3D; new CharacterEncodingFilter();\n        encodingFilter.setEncoding(&quot;UTF-8&quot;);\n        encodingFilter.setForceRequestEncoding(true);\n        HiddenHttpMethodFilter hiddenHttpMethodFilter &#x3D; new HiddenHttpMethodFilter();\n        return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;\n    &#125;\n&#125;\n\n10.2 创建 SpringConfig 配置类，代替 Spring 的配置文件@Configuration\npublic class SpringConfig &#123;\n    &#x2F;&#x2F; ssm整合之后，Spring 的配置信息写在此类中\n&#125;\n\n10.3 创建 WebConfig 配置类，代替 SpringMVC 的配置文件@Configuration\n&#x2F;&#x2F;扫描组件\n@ComponentScan(&quot;fan.com.controller&quot;)\n&#x2F;&#x2F;开启MVC注解驱动\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F;使用默认的servlet处理静态资源\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;\n        configurer.enable();\n    &#125;\n    &#x2F;&#x2F;配置文件上传解析器\n    @Bean\n    public CommonsMultipartResolver multipartResolver()&#123;\n        return new CommonsMultipartResolver();\n    &#125;\n    &#x2F;&#x2F;配置拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        FirstInterceptor firstInterceptor &#x3D; new FirstInterceptor();\n        registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;&#x2F;**&quot;);\n    &#125;\n  \n    &#x2F;&#x2F;配置视图控制\n  \n    &#x2F;*@Override\n    public void addViewControllers(ViewControllerRegistry registry) &#123;\n        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;index&quot;);\n    &#125;*&#x2F;\n  \n    &#x2F;&#x2F;配置异常映射\n    &#x2F;*@Override\n    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;\n        SimpleMappingExceptionResolver exceptionResolver &#x3D; new SimpleMappingExceptionResolver();\n        Properties prop &#x3D; new Properties();\n        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);\n        &#x2F;&#x2F;设置异常映射\n        exceptionResolver.setExceptionMappings(prop);\n        &#x2F;&#x2F;设置共享异常信息的键\n        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);\n        resolvers.add(exceptionResolver);\n    &#125;*&#x2F;\n    &#x2F;&#x2F;配置生成模板解析器\n    @Bean\n    public ITemplateResolver templateResolver() &#123;\n        WebApplicationContext webApplicationContext &#x3D; ContextLoader.getCurrentWebApplicationContext();\n        &#x2F;&#x2F; ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得\n        ServletContextTemplateResolver templateResolver &#x3D; new ServletContextTemplateResolver(webApplicationContext.getServletContext());\n        templateResolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;templates&#x2F;&quot;);\n        templateResolver.setSuffix(&quot;.html&quot;);\n        templateResolver.setCharacterEncoding(&quot;UTF-8&quot;);\n        templateResolver.setTemplateMode(TemplateMode.HTML);\n        return templateResolver;\n    &#125;\n    &#x2F;&#x2F;生成模板引擎并为模板引擎注入模板解析器\n    @Bean\n    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123;\n        SpringTemplateEngine templateEngine &#x3D; new SpringTemplateEngine();\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    &#125;\n    &#x2F;&#x2F;生成视图解析器并未解析器注入模板引擎\n    @Bean\n    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123;\n        ThymeleafViewResolver viewResolver &#x3D; new ThymeleafViewResolver();\n        viewResolver.setCharacterEncoding(&quot;UTF-8&quot;);\n        viewResolver.setTemplateEngine(templateEngine);\n        return viewResolver;\n    &#125;\n&#125;\n","slug":"BlogRepository/Spring/SpringMVC 总结","date":"2022-06-10T18:22:45.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"凡"},{"id":"3b3f88b9af43070e80fc66fe9324e787","title":"Spring5 总结","content":"1. IOC1.1 概念\n控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理\n好处：降低耦合度\n\n1.2 IOC 底层原理XML解析、工厂模式、反射\n1.3 IOC（接口）\nIOC思想基于IOC容器完成，IOC容器底层就是对象工厂\nSpring 提供IOC容器两种实现方式：（两个接口）\nBeanFactory： IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用加载配置文件时不会创建对象，在获取对象（使用）才去创建对象\nApplicationContext： BeanFactory接口的子接口，提供更多强大的功能，一般由开发人员进行使用加载配置文件时就会把在配置文件对象进行创建\nApplicationContext接口实现类FileSystemXMLApplicationContext：电脑盘符路径ClassPathXMLApplicationContext：src下类路径\n\n\n\n\n1.4 IOC 操作 Bean 管理\nBean 管理指的是两个操作：\n创建对象\n注入属性\n\n\nBean 管理操作有两种方式：\n基于 XML 配置文件方式实现\n基于注解方式实现\n\n\n\n1.4.1 基于 XML 方式1.4.1.1 基于 XML 方式创建对象&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;&lt;&#x2F;bean&gt;\n\n\n在 Spring 配置文件里，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建\n在 bean 标签有很多属性：\nid 属性：唯一标识，可以不使用 id，只留全类名，此时类名作为唯一标识\nclass 属性：类全路径（包类路径）\n创建对象时，默认是执行无参构造方法完成对象创建\n\n\n\n1.4.1.2 基于 xml 方式注入属性DI：依赖注入，就是注入属性\n\n第一种注入方式：使用 set 方法注入\npublic class User &#123;\n    private Integer id;\n\tprivate String name;\n\n    public void setId(Integer id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;property&gt;\n\t&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n第二种注入方式：使用有参构造注入\npublic class User &#123;\n    private Integer id;\n    private String name;\n\n    public void printValue()&#123;\n        System.out.println(id + &quot;:&quot; + name);\n    &#125;\n    public User(Integer id, String name) &#123;\n        this.id &#x3D; id;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;constructor-arg name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;constructor-arg&gt;\n\t&lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;constructor-arg&gt;\n&lt;&#x2F;bean&gt;\np名称空间注入（需要依赖于 set 方法）\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; &#x2F;&#x2F; 名称空间注入\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n\t\t&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot; p:id&#x3D;&quot;1&quot; p:name&#x3D;&quot;张三&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n1.4.1.3 基于 XML 方式注入属性（其他类型属性）\n字面量（前面注入的属性都是字面量）\\\n\nnull 值&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;property name&#x3D;&quot;name&quot;&gt;\n        &lt;null&gt;&lt;&#x2F;null&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n特殊符号 &lt;&gt;&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;property&gt;\n\t&lt;property name&#x3D;&quot;name&quot;&gt;\n\t\t&lt;value&gt; &lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt; &lt;&#x2F;value&gt;\n\t\t&lt;!-- &lt;&lt;南京&gt;&gt;，也可使用转义字符 &gt;⁢ --&gt;\n\t&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n注入属性-外部 bean（ref）创建两个类 service 和 dao，在 service 里调用 dao 的方法\npublic class UserService &#123;\n    private UserDao userDao;\n\n    public void setUserDao(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n    public void printValue()&#123;\n        System.out.println(&quot;service add...&quot;);\n        userDao.update();\n    &#125;\n&#125;\npublic class UserDao &#123;\n    public void update() &#123;\n        System.out.println(&quot;userDao update...&quot;);\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;fan.com.service.UserService&quot;&gt;\n\t&lt;!-- 使用ref --&gt;\n    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&gt;&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;fan.com.dao.UserDao&quot;&gt;&lt;&#x2F;bean&gt;\n注入属性-内部 bean\npublic class Dept &#123;\n    private String dname;\n\n    public void setDname(String dname) &#123;\n        this.dname &#x3D; dname;\n    &#125;\n&#125;\npublic class Emp &#123;\n    private Integer id;\n    private String name;\n    private Dept dept;\n\n    public void setId(Integer id) &#123;\n        this.id &#x3D; id;\n    &#125;\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    public void setDept(Dept dept) &#123;\n        this.dept &#x3D; dept;\n    &#125;\n    public void printValue()&#123;\n        System.out.println(id + &quot;:&quot; + name + &quot;:&quot; + dept);\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;fan.com.domain.Emp&quot;&gt;\n    &lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n\n    &lt;property name&#x3D;&quot;dept&quot;&gt;\n        &lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;fan.com.domain.Dept&quot;&gt;\n            &lt;property name&#x3D;&quot;dname&quot; value&#x3D;&quot;安保部&quot; &#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n注入属性-级联赋值\n&lt;!-- 第一种方法 --&gt;\n&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;fan.com.domain.Emp&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;dept&quot; ref&#x3D;&quot;dept&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;fan.com.domain.Dept&quot;&gt;\n\t&lt;property name&#x3D;&quot;dname&quot; value&#x3D;&quot;安保部&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 第二种方法 --&gt;\n&lt;bean id&#x3D;&quot;emp&quot; class&#x3D;&quot;fan.com.domain.Emp&quot;&gt;\n\t&lt;property name&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;dept&quot; ref&#x3D;&quot;dept&quot; &#x2F;&gt;\n\t&lt;property name&#x3D;&quot;dept.dname&quot; value&#x3D;&quot;财务部&quot; &#x2F;&gt;  &#x2F;&#x2F; 需要 get 方法，获取到dept对象\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;dept&quot; class&#x3D;&quot;fan.com.domain.Dept&quot; &#x2F;&gt;\n注入属性-数组、集合、map、set\npublic class User &#123;\n    private int[] arrays;\n    private List&lt;String&gt; lists;\n    private Map&lt;Integer,String&gt; maps;\n    private Set&lt;String&gt; sets;\n\n    public void setArrays(int[] arrays) &#123;\n        this.arrays &#x3D; arrays;\n    &#125;\n    public void setLists(List&lt;String&gt; lists) &#123;\n        this.lists &#x3D; lists;\n    &#125;\n    public void setMaps(Map&lt;Integer, String&gt; maps) &#123;\n        this.maps &#x3D; maps;\n    &#125;\n    public void setSets(Set&lt;String&gt; sets) &#123;\n        this.sets &#x3D; sets;\n    &#125;\n\n    public void printValue()&#123;\n        System.out.println(Arrays.toString(arrays)); System.out.println(lists);\n        System.out.println(maps); System.out.println(sets);\n    &#125;\n&#125;\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n    &lt;property name&#x3D;&quot;arrays&quot;&gt;\n        &lt;array&gt;\n            &lt;value&gt;1&lt;&#x2F;value&gt;\n            &lt;value&gt;2&lt;&#x2F;value&gt;\n        &lt;&#x2F;array&gt;\n    &lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;lists&quot;&gt;\n        &lt;list&gt;\n            &lt;value&gt;张三&lt;&#x2F;value&gt;\n            &lt;value&gt;小张&lt;&#x2F;value&gt;\n        &lt;&#x2F;list&gt;\n    &lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;maps&quot;&gt;\n        &lt;map&gt;\n            &lt;entry key&#x3D;&quot;1&quot; value&#x3D;&quot;Map1&quot; &#x2F;&gt;\n            &lt;entry key&#x3D;&quot;2&quot; value&#x3D;&quot;Map2&quot; &#x2F;&gt;\n        &lt;&#x2F;map&gt;\n    &lt;&#x2F;property&gt;\n    &lt;property name&#x3D;&quot;sets&quot;&gt;\n        &lt;set&gt;\n            &lt;value&gt;MySQL&lt;&#x2F;value&gt;\n            &lt;value&gt;Redis&lt;&#x2F;value&gt;\n        &lt;&#x2F;set&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n注入多个对象属性\npublic class User &#123;\n    private List&lt;Course&gt; courseList;\n\n    public void setCourseList(List&lt;Course&gt; courseList) &#123;\n        this.courseList &#x3D; courseList;\n    &#125;\n    public void printValue()&#123;\n        System.out.println(courseList.toString());\n    &#125;\n&#125;\n\n&lt;bean&gt;\n\t&lt;property name&#x3D;&quot;courseList&quot;&gt;\n\t\t&lt;list&gt;\n\t\t\t&lt;ref bean&#x3D;&quot;course1&quot; &#x2F;&gt;\n\t\t\t&lt;ref bean&#x3D;&quot;course2&quot; &#x2F;&gt;\n\t\t&lt;&#x2F;list&gt;\n\t&lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;course1&quot; class&#x3D;&quot;fan.com.domain.Course&quot;&gt;\n    &lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;Spring&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;course2&quot; class&#x3D;&quot;fan.com.domain.Course&quot;&gt;\n    &lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;Spring5&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n提取集合公共部分\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot; &#x2F;&#x2F; 定义util名称空间\n       xsi:schemaLocation&#x3D;\n        \t&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd&quot;&gt;\n\t &lt;util:list id&#x3D;&quot;nameList&quot;&gt;\n        &lt;value&gt;张三&lt;&#x2F;value&gt;\n        &lt;value&gt;李四&lt;&#x2F;value&gt;\n        &lt;value&gt;王五&lt;&#x2F;value&gt;\n    &lt;&#x2F;util:list&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot;&gt;\n        &lt;property name&#x3D;&quot;lists&quot; ref&#x3D;&quot;nameList&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n1.4.1.4 工厂 Bean（FactoryBean）\nSpring 有两种类型 bean，一种普通 bean，另外一种工厂 bean (FactoryBean)\n普通 bean：在配置文件中定义 bean 类型就是返回类型\n工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样\n第一步创建类，让这个类作为工厂 bean，实现接口 FactoryBean\n第二步实现接口里面的方法，在实现的方法中定义返回的 bean 类型\n\n\n\n&lt;!-- 创建 bean --&gt;\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot; &#x2F;&gt; &#x2F;&#x2F; 创建 bean（user）\n\npublic class User implements FactoryBean&lt;Course&gt; &#123;\n    @Override\n    public Course getObject() throws Exception &#123;\n        Course course &#x3D; new Course();\n        course.setCname(&quot;abc&quot;);\n        return course;\n    &#125;\n    @Override\n    public Class&lt;?&gt; getObjectType() &#123;\n        return null;\n    &#125;\n    @Override\n    public boolean isSingleton() &#123;\n        return FactoryBean.super.isSingleton();\n    &#125;\n&#125;\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n        Course course &#x3D; context.getBean(&quot;user&quot;, Course.class); &#x2F;&#x2F; 改成返回的 bean 类型（Course）\n        System.out.println(course); &#x2F;&#x2F; Course&#123;cname&#x3D;&#39;abc&#39;&#125;\n    &#125;\n&#125;\n\n1.4.2 bean 作用域\n在 Spring 里，默认情况下， bean 是单实例对象。安全的public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n        Course course &#x3D; context.getBean(&quot;course&quot;, Course.class);\n        Course course1 &#x3D; context.getBean(&quot;course&quot;, Course.class);\n        System.out.println(course);\n        System.out.println(course1);\n    &#125;\n&#125;\n\n\n设置为单实例还是多实例（scope）\n在 spring 配置文件 bean 标签里面有属性（scope），用于设置单实例还是多实例\nscope 属性值（singleton、prototype、request、session、websocket、application）\n第一个值默认值，singleton，表示是单实例对象，加载 spring 配置文件时就会创建单实例对象\n第二个值 prototype，表示是多实例对象，不是在加载 spring 配置文件时创建对象，而是在 getBean 方法时创建多实例对象\n\n\n\n\n\n1.4.3 bean 生命周期\n通过构造器创建 bean 实例(无参数构造)\n为 bean 的属性设置值和对其他bean引用(调用set方法)\n把 bean 实例传递给 bean 后置处理器的方法（postProcessBeforeInitialization）\n调用 bean 的初始化的方法(需要进行配置初始化的方法)\n把 bean 实例传递给 bean 后置处理器的方法（postProcessAfterInitialization）\nbean 可以使用了(对象获取到了)\n当容器关闭时候，调用 bean 的销毁的方法(需要进行配置销毁的方法)\n\npublic class Course &#123;\n    private String cname;\n\n    public Course() &#123;\n        System.out.println(&quot;第一步：执行构造器方法&quot;);\n    &#125;\n    public void setCname(String cname) &#123;\n        this.cname &#x3D; cname;\n        System.out.println(&quot;第二步：调用set方法&quot;);\n    &#125;\n    &#x2F;&#x2F; @PostConstruct\n    public void initMethod()&#123;\n        System.out.println(&quot;第三步：执行初始化方法&quot;);\n    &#125;\n    &#x2F;&#x2F; @PreDestory\n    public void destroyMethod()&#123;\n        System.out.println(&quot;第五步：执行销毁方法&quot;);\n    &#125;\n\n&#125;\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n        Course course &#x3D; context.getBean(&quot;course&quot;, Course.class);\n        System.out.println(&quot;第四步：获取创建 bean 实例对象&quot;);\n        System.out.println(course);\n        ((ClassPathXmlApplicationContext)context).close(); &#x2F;&#x2F; 调用销毁方法\n    &#125;\n&#125;\n\n&lt;!-- 配置初始化方法和销毁方法 --&gt;\n&lt;bean id&#x3D;&quot;course&quot; class&#x3D;&quot;fan.com.domain.Course&quot; init-method&#x3D;&quot;initMethod&quot; destroy-method&#x3D;&quot;destroyMethod&quot;&gt;\n\t&lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n1.4.4 后置处理器 BeanPostProcessor\npostProcessBeforeInitialization 在 Bean 实例化、依赖注入后，初始化前调用\npostProcessAfterInitialization 在 Bean 实例化、依赖注入、初始化都完成后调用当需要添加多个后置处理器实现类时，默认情况下 Spring 容器会根据后置处理器的定义顺序来依次调用。也可以通过实现 Ordered 接口的 getOrder 方法指定后置处理器的执行顺序。该方法返回值为整数，默认值为 0，值越大优先级越低\n\n&lt;!-- 创建 bean --&gt;\n&lt;bean id&#x3D;&quot;coursePost&quot; class&#x3D;&quot;fan.com.domain.CoursePost&quot; &#x2F;&gt;\n\n实现 BeanPostProcessor 接口\npublic class CoursePost implements BeanPostProcessor, Ordered &#123;\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;在初始化之前执行的方法&quot;);\n        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);\n    &#125;\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;在初始化之后执行的方法&quot;);\n        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);\n    &#125;\n  \n    @Override\n    public int getOrder() &#123;\n        return 5;\n    &#125;\n&#125;\n\n\n1.4.5 XML 自动装配根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入。autorire 属性常用两个值：\n\nbyName，根据属性名称注入，注入值 bean 的id值和类属性名称一样\nbyType，根据属性类型注入，假如有两个同样的 bean 报错\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;fan.com.domain.User&quot; autowire&#x3D;&quot;byName&quot; &#x2F;&gt;\n&lt;bean id&#x3D;&quot;course&quot; class&#x3D;&quot;fan.com.domain.Course&quot;&gt;\n        &lt;property name&#x3D;&quot;cname&quot; value&#x3D;&quot;张三&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n1.4.6 XML（引入外部属性文件）&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;\n       \t\t&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n\t\t\t\t\t http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot; &#x2F;&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n            &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;driverClass&#125;&quot; &#x2F;&gt;\n            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot; &#x2F;&gt;\n            &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;userName&#125;&quot; &#x2F;&gt;\n            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n1.5 基于注解方式\n注解是代码特殊标记，格式: @注解名称(属性名称&#x3D;属性值,属性名称&#x3D;属性..\n使用注解，注解作用在类上面，方法上面，属性上面\n使用注解目的：简化 XML 配置\n\n1.5.1 Spring 针对 Bean 管理中创建对象提供注解\n@Component，可以使用此注解描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。 使用时只需将该注解标注在相应类上即可。\n@Service，通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n@Controller，通常作用在控制层（如 Struts2 的 Action、SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n@Repository，用于将数据访问层（DAO层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同\n\n上面四个注解功能是一样的，都可以用来创建 bean 实例\n\n@Bean，通常是我们在标有该注解的方法中定义产生这个 bean 的逻辑，告诉 Spring 这个方法将会返回一个对象，这个对象要注册为 Spring 应用上下文中的 bean。@Bean 注解比 @Component 注解的自定义性更强\n\n1.5.2 基于注解方式创建对象\n开启组件扫描，扫描多个包\n&lt;!-- 扫描上层目录 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n&lt;!-- 逗号隔开 --&gt;\n&lt;context:component-scan base-package&#x3D;&quot;fan.com.dao, fan.com.service&quot; &#x2F;&gt;\n创建类，在类上面添加创建对象注解\n&#x2F;&#x2F; value 可以省略不写，默认值是类名称，首字母小写\n@Service(value &#x3D; &quot;userService&quot;)\npublic class UserService &#123;\n\n&#125;\n组件扫描细节配置\n\nuse-default-filters=&quot;false&quot; 表示不适用默认 filter，自己配 filter\ncontext:include-filter 设置需要扫描哪些内容\ncontext:exclude-filter 设置哪些内容不需要扫描\n\n&lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; use-default-filters&#x3D;&quot;false&quot;&gt;\n\t&lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;\n\t&lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Service&quot;&#x2F;&gt;\n&lt;&#x2F;context:component-scan&gt;\n\n1.5.3 基于注解方式实现属性注入\n@Autowired：根据属性类型进行自动装配。Spring 推荐使用@Service(value &#x3D; &quot;userService&quot;)\npublic class UserService &#123;\n    @Autowired\n    private UserDao userDao;\n\n    public void add()&#123;\n        System.out.println(&quot;service add..&quot;);\n        userDao.update();\n    &#125;\n&#125;\n@Qualifier：根据属性名称进行注入，配合 @Autowired 进行使用，当有多个实现类时，需要根据名称注入@Autowired\n@Qualifier(value &#x3D; &quot;userDaoImpl1&quot;)\nprivate UserDao userDao;\n@Resource：可以根据类型注入、可以根据名称注入，位于 javax.annotation 包下。Spring 不推荐使用，JavaEE 推荐使用@Resource &#x2F;&#x2F; 根据类型注入\n&#x2F;&#x2F; @Resource(name &#x3D; &quot;userDaoImpl1&quot;) 根据名称注入\nprivate UserDao userDao;\n@Value：注入普通类型属性@Value(&quot;张三&quot;)\nprivate String name;\n\n1.5.4 完全注解开发（配置类）@Configuration\n@ComponentScan(basePackages &#x3D; &#123;&quot;fan.com&quot;&#125;)\npublic class SpringConfig &#123;\n&#125;\n\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);\n        UserService userService &#x3D; context.getBean(&quot;userService&quot;, UserService.class);\n        userService.add();\n    &#125;\n&#125;\n\n2. AOP2.1 概念\n面向切面（方面）编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率\n通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n\n\n2.2 AOP 底层原理2.2.1 AOP 底层使用动态代理有两种情况动态代理：\n\n第一种：有接口情况，使用 JDK 动态代理（创建接口实现类代理对象，增强类的方法）\n第二种：没有接口情况，使用 CGLIB 动态代理（创建当前类子类代理对象，增强类的方法）\n\n2.2.2 AOP（JDK 动态代理）使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象， 调用 newProxyInstance 方法，三个参数\n\n第一参数，类加载器\n第二参数，增强方法所在的类，这个类实现的接口，支持多个接口\n第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的方法\n\npublic interface UserDao &#123;\n    public int add(int a, int b);\n    public String update(String id);\n&#125;\npublic class UserDaoImpl implements UserDao &#123;\n    @Override\n    public String update(String id) &#123;\n        return id;\n    &#125;\n    @Override\n    public int add(int a, int b) &#123;\n        return a + b;\n    &#125;\n&#125;\n\npublic class JDKProxy &#123;\n    public static void main(String[] args) &#123;\n        Class[] interfaces &#x3D; &#123;UserDao.class&#125;; &#x2F;&#x2F; 类实现接口\n        UserDaoImpl userDaoImpl &#x3D; new UserDaoImpl();\n        UserDao userDao &#x3D; (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDaoImpl));\n        int result &#x3D; userDao.add(1,2);\n        &#x2F;&#x2F; 代理对象UserDaoProxy返回的结果，add方法，返回为3，假如为update方法，返回null\n        System.out.println(result);\n    &#125;\n&#125;\nclass UserDaoProxy implements InvocationHandler&#123;\n    private Object obj;\n\n    public UserDaoProxy(Object obj) &#123;\n        this.obj &#x3D; obj;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        if (&quot;add&quot;.equals(method.getName()))&#123; &#x2F;&#x2F; 判断是哪个方法才执行\n            System.out.println(&quot;方法之前执行...&quot; + method.getName() + &quot;传递的参数：&quot; + Arrays.toString(args));\n            Object result &#x3D; method.invoke(obj,args); &#x2F;&#x2F; 方法执行，传入对象和参数\n            System.out.println(&quot;方法之后执行&quot; + obj);\n            return result;\n        &#125;else &#123;\n            return null;\n        &#125;\n\n    &#125;\n&#125;\n\n\n2.3 AOP 术语\nJoinpoint 连接点：那些被拦截到的点，类里面哪些方法可以被拦截到被增强，这些方法称为连接点\nPointcut 切入点：指要对哪些 Joinpoint 进行拦截，即被拦截的连接点，实际被真正增强的方法，称为切入点\nAdvice 通知（增强）：实际增强的逻辑部分称为通知（增强）\n前置通知 @Before：方法执行之前执行\n后置&#x2F;返回通知 @AfterReturning：方法返回结果之后执行\n环绕通知 @Around：方法之前和之后都执行\n异常通知 @AfterThrowing：异常时执行\n最终通知：@After（finally）：方法执行之后执行\n\n\nAspect 切面：一个动作，把通知应用到切入点的过程\nTarget 目标：指代理的目标对象\nWeaving 织入：指把增强代码应用到目标上，生成代理对象的过程\nProxy 代理：指生成的代理对象\n\n\n2.4 AOP 操作\nSpring 框架一般都是基于 AspectJ 实现 AOP 操作AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spring 框架一起使用， 进行 AOP 操作\n基于 AspectJ 实现 AOP 操作\n基于 XML 配置文件实现\n基于注解方式实现（实用）\n\n\n切入点表达式\n作用：知道对哪个类里面的哪个方法进行增强\n语法结构：execution（[权限修饰符] [返回类型（可省略）] [类全路径] [方法名称] ([参数列表])）\n举例 1：对 fan.com.dao.BookDao 类里面的 add 进行增强execution(*  fan.com.dao.BookDao.add(..))   // 修饰符 包名.类名.方法名(参数..)\n举例 2：对 fan.com.dao.BookDao 类里面的所有的方法进行增强execution(*  fan.com.dao.BookDao.* (..))\n举例 3：对 fan.com.dao 包里面所有类，类里面所有方法进行增强execution(*  fan.com.dao.*.* (..))\n\n\n\n\n\n2.4.1 基于注解方式（抽取公共切入点）\n开启注解扫描和生成代理对象：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n    &lt;aop:aspectj-autoproxy &#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n使用完全注解开发\n@Configuration\n@ComponentScan(basePackages &#x3D; &#123;&quot;fan.com&quot;&#125;)\n@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true) &#x2F;&#x2F; 开启代理对象\npublic class SpringConfig &#123;\n&#125;\n类和增强类：\n@Component\npublic class User &#123;\n    public void add()&#123;\n        System.out.println(&quot;user add...&quot;);\n    &#125;\n&#125;\n\n@Component\n@Aspect\npublic class UserProxy &#123;\n    @Pointcut(value &#x3D; &quot;execution(* fan.com.domain.User.add(..))&quot;) &#x2F;&#x2F; 抽取公共切入点\n    public void pointDemo()&#123;\n\n    &#125;\n    @Before(value &#x3D; &quot;pointDemo()&quot;)\n    public void before() &#123;\n        System.out.println(&quot;前置通知before.........&quot;);\n    &#125;\n    @After(value &#x3D; &quot;pointDemo())&quot;)\n    public void after() &#123;\n        System.out.println(&quot;最终通知after.........&quot;);\n    &#125;\n    @AfterThrowing(value &#x3D; &quot;pointDemo()&quot;)\n    public void afterThrowing() &#123;\n        System.out.println(&quot;异常通知afterThrowing.........&quot;);\n    &#125;\n    @AfterReturning(value &#x3D; &quot;pointDemo()&quot;)\n    public void afterReturning() &#123;\n        System.out.println(&quot;后置通知afterReturning.........&quot;);\n    &#125;\n    @Around(value &#x3D; &quot;pointDemo()&quot;)\n    public void around(ProceedingJoinPoint joinPoint) throws Throwable&#123;\n        try &#123;\n            System.out.println(&quot;环绕前置通知&quot;); &#x2F;&#x2F;前置通知@Before\n            joinPoint.proceed(); &#x2F;&#x2F;目标方法执行\n            System.out.println(&quot;环绕返回通知&quot;); &#x2F;&#x2F;环绕返回通知@AfterReturning\n        &#125; catch (Throwable throwable) &#123;\n            System.out.println(&quot;环绕异常通知&quot;); &#x2F;&#x2F;环绕异常通知@AfterThrowing\n            throw new RuntimeException(throwable);\n        &#125; finally &#123;\n            System.out.println(&quot;环绕最终通知&quot;); &#x2F;&#x2F;最终通知@After\n        &#125;\n    &#125;\n&#125;\n\n执行顺序：* 正常情况：环绕前置 &#x3D;&#x3D; @Before &#x3D;&#x3D; 目标方法执行 &#x3D;&#x3D;@AfterReturning &#x3D;&#x3D; @After &#x3D;&#x3D; 环绕返回 &#x3D;&#x3D;环绕最终\n\n异常情况：环绕前置&#x3D;&#x3D; @Before &#x3D;&#x3D; 目标方法执行 &#x3D;&#x3D; @AfterThrowing &#x3D;&#x3D; @After &#x3D;&#x3D; 环绕异常 &#x3D;&#x3D; 环绕最终\n\n\n多个增强类对同一个方法进行增强，设置增强类优先级在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高\n@Component\n@Aspect\n@Order(1) &#x2F;&#x2F; 设置优先级\npublic class PersonProxy &#123;\n    @Pointcut(value &#x3D; &quot;execution(* fan.com.domain.User.add(..))&quot;)\n    public void pointDemo()&#123;\n    &#125;\n\n    @Before(value &#x3D; &quot;pointDemo()&quot;)\n    public void before() &#123;\n        System.out.println(&quot;person before.........&quot;);\n    &#125;\n&#125;\n\n\n\n测试类\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F; ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);\n        ApplicationContext ac &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);\n        User user &#x3D; ac.getBean(&quot;user&quot;, User.class);\n        user.add();\n    &#125;\n&#125;\n\n2.4.2 AspectJ 配置文件&lt;bean id&#x3D;&quot;book&quot; class&#x3D;&quot;fan.com.Book&quot;&gt;&lt;&#x2F;bean&gt; \n&lt;bean id&#x3D;&quot;bookProxy&quot; class&#x3D;&quot;fan.com.BookProxy&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;aop:config&gt; \n    &lt;!--切入点--&gt; \n    &lt;aop:pointcut id&#x3D;&quot;p&quot; expression&#x3D;&quot;execution(* fan.com.Book.buy(..))&quot;&#x2F;&gt; \n    &lt;!--配置切面 aop:aspect 大多用于面向切面编程，aop:advisor 大多用于事务管理--&gt; \n    &lt;aop:aspect ref&#x3D;&quot;bookProxy&quot;&gt; \n        &lt;!--增强作用在具体的方法上--&gt; \n        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;p&quot;&#x2F;&gt; \n    &lt;&#x2F;aop:aspect&gt; \n&lt;&#x2F;aop:config&gt;\n\n\n定义切面 &lt;aop:aspect&gt;\n\n该元素可以将定义好的 Bean 转换为切面 Bean，所以使用 &lt;aop:aspect&gt; 之前需要先定义一个普通的 Spring Bean\nid 用来定义该切面的唯一表示名称，ref 用于引用普通的 Spring Bean\n\n&lt;aop:config&gt;\n    &lt;aop:aspect id&#x3D;&quot;myAspect&quot; ref&#x3D;&quot;aBean&quot;&gt;\n        ...\n    &lt;&#x2F;aop:aspect&gt;\n&lt;&#x2F;aop:config&gt;\n定义切入点 &lt;aop:pointcut&gt;\n\n当 &lt;aop:pointcut&gt;元素作为 &lt;aop:config&gt; 元素的子元素定义时，表示该切入点是全局切入点，它可被多个切面所共享\n当 &lt;aop:pointcut&gt; 元素作为 &lt;aop:aspect&gt; 元素的子元素时，表示该切入点只对当前切面有效\nid 用于指定切入点的唯一标识名称，execution 用于指定切入点关联的切入点表达式\n\n&lt;aop:config&gt;\n    &lt;aop:pointcut id&#x3D;&quot;myPointCut&quot; expression&#x3D;&quot;execution(* net.biancheng.service.*.*(..))&quot;&#x2F;&gt;\n&lt;&#x2F;aop:config&gt;\n定义通知\n&lt;aop:aspect id&#x3D;&quot;myAspect&quot; ref&#x3D;&quot;aBean&quot;&gt;\n    &lt;!-- 前置通知 --&gt;\n    &lt;aop:before pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 后置通知 --&gt;\n    &lt;aop:after-returning pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 环绕通知 --&gt;\n    &lt;aop:around pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 异常通知 --&gt;\n    &lt;aop:after-throwing pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;!-- 最终通知 --&gt;\n    &lt;aop:after pointcut-ref&#x3D;&quot;myPointCut&quot; method&#x3D;&quot;...&quot;&#x2F;&gt;\n    .... \n&lt;&#x2F;aop:aspect&gt;\n\n3. JdbcTemplate3.1 配置连接属性&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd &quot;&gt;\n\t&lt;!-- 注解扫描 --&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n    &lt;!-- 引入外部属性文件 --&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot; &#x2F;&gt; \n    &lt;!-- 配置数据库连接池 Druid --&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;driverClassName&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;user&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!-- 配置 JdbcTemplate 对象，注入 DataSource --&gt;\n    &lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n3.2 Dao层public interface UserDao &#123;\n    User selectUser(int id); &#x2F;&#x2F; 按id 查询\n    List&lt;User&gt; selectAll(); &#x2F;&#x2F; 查询所有\n    int selectTotalCount(); &#x2F;&#x2F; 查询总记录条数\n    int updateUser(User user); &#x2F;&#x2F; 按id 修改\n    int insertUser(User user); &#x2F;&#x2F; 插入\n    int deleteUser(int id); &#x2F;&#x2F; 按id 删除\n    int[] batchAdd(List&lt;Object[]&gt; users); &#x2F;&#x2F; 批量插入\n&#125;\n@Component\npublic class UserDaoImpl implements UserDao &#123;\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override &#x2F;&#x2F; 按id 查询\n    public User selectUser(int id) &#123;\n        String sql &#x3D; &quot;select * from user where id &#x3D; ? &quot;;\n        User user &#x3D; jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), id);\n        return user;\n    &#125;\n    @Override &#x2F;&#x2F; 查询所有\n    public List&lt;User&gt; selectAll() &#123;\n        String sql &#x3D; &quot;select * from user&quot;;\n        List&lt;User&gt; maps &#x3D; jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class));\n        return maps;\n    &#125;\n    @Override &#x2F;&#x2F; 查询总记录条数\n    public int selectTotalCount() &#123;\n        String sql &#x3D; &quot;select count(*) from user&quot;;\n        int i &#x3D; jdbcTemplate.queryForObject(sql, Integer.class);\n        return i;\n    &#125;\n\n    @Override &#x2F;&#x2F; 按id 修改\n    public int updateUser(User user) &#123;\n        String sql &#x3D; &quot;update user set name &#x3D; ?, age &#x3D; ? where id &#x3D; ?&quot;;\n        Object[] args &#x3D; &#123;user.getName(),user.getAge(),user.getId()&#125;;\n        int update &#x3D; jdbcTemplate.update(sql, args);\n        return update;\n    &#125;\n\n    @Override &#x2F;&#x2F; 插入\n    public int insertUser(User user) &#123;\n        Object[] args &#x3D; &#123;user.getId(),user.getName(),user.getAge()&#125;;\n        String sql &#x3D; &quot;insert into user value(?,?,?)&quot;;\n        int update &#x3D; jdbcTemplate.update(sql, args);\n        return update;\n    &#125;\n    @Override &#x2F;&#x2F; 批量插入\n    public int[] batchAdd(List&lt;Object[]&gt; users) &#123;\n        String sql &#x3D; &quot;insert into user value(?,?,?)&quot;;\n        int[] ints &#x3D; jdbcTemplate.batchUpdate(sql, users);\n        return ints;\n    &#125;\n\n    @Override &#x2F;&#x2F; 按id 删除\n    public int deleteUser(int id) &#123;\n        String sql &#x3D; &quot;delete from user where id &#x3D; ?&quot;;\n        int update &#x3D; jdbcTemplate.update(sql, id);\n        return update;\n    &#125;\n&#125;\n\n3.3 Service 层@Service(value &#x3D; &quot;userService&quot;)\npublic class UserService &#123;\n    @Autowired\n    private UserDao userDao;\n\n    public User selectUser(int id)&#123;\n        User user &#x3D; userDao.selectUser(id);\n        return user;\n    &#125;\n    public List&lt;User&gt; selectAll() &#123;\n        List&lt;User&gt; users &#x3D; userDao.selectAll();\n        return users;\n    &#125;\n    public int selectTotalCount() &#123;\n        int i &#x3D; userDao.selectTotalCount();\n        return i;\n    &#125;\n\n    public int updateUser(User user)&#123;\n        int i &#x3D; userDao.updateUser(user);\n        return i;\n    &#125;\n\n    public int insertUser(User user)&#123;\n        int i &#x3D; userDao.insertUser(user);\n        return i;\n    &#125;\n    public int[] batchAdd(List&lt;Object[]&gt; users) &#123;\n        int[] ints &#x3D; userDao.batchAdd(users);\n        return ints;\n    &#125;\n\n    public int deleteUser(int id)&#123;\n        int i &#x3D; userDao.deleteUser(id);\n        return i;\n    &#125;\n&#125;\n\n3.4 测试类public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);\n        UserService userService &#x3D; ac.getBean(&quot;userService&quot;, UserService.class);\n      \n        User user &#x3D; new User(2,&quot;ff&quot;,18);\n        int i &#x3D; userService.updateUser(user);\n        System.out.println(i); &#x2F;&#x2F; 1\n        List&lt;User&gt; users &#x3D; userService.selectAll();\n        System.out.println(users);\n      \n        List&lt;Object[]&gt; users &#x3D; new ArrayList&lt;&gt;();\n        Object[] user1 &#x3D; &#123;6, &quot;6&quot;, 6&#125;;\n        Object[] user2 &#x3D; &#123;7,&quot;7&quot;,8&#125;;\n        Object[] user3 &#x3D; &#123;8, &quot;7&quot;, 8&#125;;\n        users.add(user1);\n        users.add(user2);\n        users.add(user3);\n        int[] ints &#x3D; userService.batchAdd(users);\n    &#125;\n&#125;\n\n4. 事务操作4.1 概念事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。典型场景：银行转账\n\nlucy 转账 100 元 给 mary\nlucy 少 100，mary 多 100\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;fan.com&quot; &#x2F;&gt;\n    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot; &#x2F;&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;driverClassName&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;user&#125;&quot;&gt;&lt;&#x2F;property&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\nDao 层\npublic interface PriceDao &#123;\n    public void reduce();\n    public void add();\n&#125;\n@Component\npublic class PriceDaoImpl implements PriceDao &#123;\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public void reduce() &#123;\n        String sql &#x3D; &quot;update price set price &#x3D; price - ? where name &#x3D; ?&quot;;\n        jdbcTemplate.update(sql,100,&quot;张三&quot;);\n    &#125;\n    @Override\n    public void add() &#123;\n        String sql &#x3D; &quot;update price set price &#x3D; price + ? where name &#x3D; ?&quot;;\n        jdbcTemplate.update(sql,100,&quot;李四&quot;);\n    &#125;\n&#125;\n\nService 层\n@Service\npublic class PriceService &#123;\n    @Autowired\n    private PriceDao priceDao;\n\n    public void account()&#123;\n        priceDao.reduce();\n        int a &#x3D; 10 &#x2F; 0;\n        priceDao.add();\n    &#125;\n&#125;\n\n4.2 接口PlatformTransactionManager、TransactionDefinition 和 TransactionStatus 是事务的 3 个核心接口\n4.2.1 PlatformTransactionManager 接口PlatformTransactionManager 接口用于管理事务，接口定义如下：\npublic interface PlatformTransactionManager &#123;\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n    void commit(TransactionStatus status) throws TransactionException;\n    void rollback(TransactionStatus status) throws TransactionException;\n&#125;\n\n\n4.2.2 TransactionDefinition 接口TransactionDefinition 接口提供了获取事务相关信息的方法，接口定义如下\npublic interface TransactionDefinition &#123;\n    int getPropagationBehavior();\n    int getIsolationLevel();\n    String getName();\n    int getTimeout();\n    boolean isReadOnly();\n&#125;\n\n\n4.2.3 TransactionStatus 接口TransactionStatus 接口提供了一些简单的方法来控制事务的执行和查询事务的状态，接口定义如下：\npublic interface TransactionStatus extends SavepointManager &#123;\n    boolean isNewTransaction();\n    boolean hasSavepoint();\n    void setRollbackOnly();\n    boolean isRollbackOnly();\n    boolean isCompleted();\n&#125;\n\n\n4.3 Spring 事务管理介绍\n事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）\n在 Spring 进行事务管理操作有两种方式：编程式事务管理和声明式事务管理（实用）\n声明式事务管理\n基于注解方式（实用）\n基于 xml 配置文件方式\n\n\n在 Spring 进行声明式事务管理，底层使用 AOP 原理\nSpring 事务管理 API提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类\n\n\n4.4 注解声明式事务管理\n配置事务管理器&lt;!-- 创建事务管理器 --&gt;\n&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n\t&lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt; &#x2F;&#x2F; 注入数据源\n&lt;&#x2F;bean&gt;\n开启事务注解&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; &#x2F;&#x2F; 引入名称空间 tx\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd &quot;&gt;\n\t&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n\t&lt;&#x2F;bean&gt;\n\t&lt;!-- 开启事务注解 --&gt;\n\t&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; &#x2F;&gt;\n&lt;&#x2F;beans&gt;\n在 service 类上面（或者 service 类里面方法上面）添加事务注解\n@Transactional，这个注解添加到类上面，也可以添加方法上面\n如果把这个注解添加类上面，这个类里面所有的方法都添加事务\n如果把这个注解添加方法上面，为这个方法添加事务\n\n\n\n4.5 声明式事务管理参数配置\n\npropagation：事务传播行为：多事务方法直接进行调用，这个过程中事务 是如何进行管理\nioslation：事务隔离级别\ntimeout：超时时间\n事务需要在一定时间内进行提交，如果不提交进行回滚\n默认值是 -1 ，设置时间以秒单位进行计算\n\n\nreadOnly：是否只读\n读：查询操作，写：添加修改删除操作\nreadOnly 默认值 false，表示可以查询，可以添加修改删除操作\n设置 readOnly 值是 true，设置成 true 之后，只能查询\n\n\nrollbackFor：回滚设置出现哪些异常进行事务回滚\nnoRollbackFor：不回滚设置出现哪些异常不进行事务回滚\n\n4.6 XML 声明式事务管理&lt;!--1 创建事务管理器--&gt; \n&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; \n    &lt;!--注入数据源--&gt; \n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt; \n&lt;&#x2F;bean&gt; \n \n&lt;!--2 配置通知--&gt; \n&lt;tx:advice id&#x3D;&quot;txadvice&quot;&gt; \n    &lt;!--配置事务参数--&gt; \n    &lt;tx:attributes&gt;\n        &lt;!--指定哪种规则的方法上面添加事务--&gt; \n        &lt;tx:method name&#x3D;&quot;account&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt; \n        &lt;!--&lt;tx:method name&#x3D;&quot;account*&quot;&#x2F;&gt;--&gt; \n    &lt;&#x2F;tx:attributes&gt; \n&lt;&#x2F;tx:advice&gt; \n \n&lt;!--3 配置切入点和切面--&gt; \n&lt;aop:config&gt; \n    &lt;!--配置切入点--&gt; \n    &lt;aop:pointcut id&#x3D;&quot;pt&quot; expression&#x3D;&quot;execution(* fan.com.service.PriceService.*(..))&quot;&#x2F;&gt; \n    &lt;!--配置切面 aop:advisor 大多用于事务管理，aop:aspect 大多用于面向切面编程--&gt;\n    &lt;aop:advisor advice-ref&#x3D;&quot;txadvice&quot; pointcut-ref&#x3D;&quot;pt&quot;&#x2F;&gt; \n&lt;&#x2F;aop:config&gt;\n\n4.7 完全注解开发声明式事务管理@Configuration &#x2F;&#x2F;配置类 \n@ComponentScan(basePackages &#x3D; &quot;com.atguigu&quot;) &#x2F;&#x2F;组件扫描 \n@EnableTransactionManagement &#x2F;&#x2F;开启事务 \npublic class TxConfig &#123; \n    &#x2F;&#x2F;创建数据库连接池 \n    @Bean \n    public DruidDataSource getDruidDataSource() &#123; \n        DruidDataSource dataSource &#x3D; new DruidDataSource(); \n        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); \n        dataSource.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;user_db&quot;); \n        dataSource.setUsername(&quot;root&quot;); \n        dataSource.setPassword(&quot;root&quot;); \n        return dataSource; \n    &#125; \n    &#x2F;&#x2F;创建 JdbcTemplate 对象 \n    @Bean \n    public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123; \n        &#x2F;&#x2F;到 ioc 容器中根据类型找到 dataSource \n        JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(); \n        &#x2F;&#x2F;注入 dataSource \n        jdbcTemplate.setDataSource(dataSource); \n        return jdbcTemplate; \n    &#125; \n    &#x2F;&#x2F;创建事务管理器 \n    @Bean \n    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) &#123; \n        DataSourceTransactionManager transactionManager &#x3D; new DataSourceTransactionManager(); \n        transactionManager.setDataSource(dataSource); \n        return transactionManager; \n    &#125; \n&#125; \n\n4.8 事务失效的原因（重要）4.8.1 数据库引擎不支持以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。 从 MySQL 5.5.5 开始的默认存储引擎是 InnoDB，之前默认的都是 MyISAM。所以这点需要注意，底层引擎不支持事务，再怎么操作事务都无效。\n4.8.2 没有被 Spring 管理&#x2F;&#x2F; @Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;\n\n如果此时把 @Service 注解注释掉，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。\n4.8.3 方法不是 public 的@Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。\n4.8.4 自身调用问题@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    public void update(Order order) &#123;\n        updateOrder(order);\n    &#125;\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;\n\n上面的 update 方法上面没有加 @Transactional 注解，调用有 @Transactional 注解的 updateOrder 方法，updateOrder 方法上的事务不管用。\n@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void update(Order order) &#123;\n        updateOrder(order);\n    &#125;\n    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;\n\n上面这次在 update 方法上加了 @Transactional，而 updateOrder 加了 REQUIRES_NEW 新开启一个事务，那么新开的事务不管用。\n因为它们发生了自身调用，调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效。\n解决方案：\n&lt;!-- 在Spring配置中添加标签 --&gt;\n&lt;aop:aspectj-autoproxy expose-proxy&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;!-- &lt;aop:config expose-proxy&#x3D;&quot;true&quot;&gt; --&gt;\n\n&#x2F;&#x2F; 在代码的调用中要求使用代理对象去调用即可：\n((ServiceA ) AopContext.currentProxy()).insert();\n\n4.8.5 数据源没有配置事务管理器@Bean\npublic PlatformTransactionManager transactionManager(DataSource dataSource) &#123;\n    return new DataSourceTransactionManager(dataSource);\n&#125;\n\n4.8.6 不支持事务@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void update(Order order) &#123;\n        updateOrder(order);\n    &#125;\n    @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)\n    public void updateOrder(Order order) &#123;\n        &#x2F;&#x2F; update order\n    &#125;\n&#125;\n\nPropagation.NOT_SUPPORTED： 表示不以事务运行，当前若存在事务则挂起\n4.8.7 异常被 catch@Service\npublic class OrderServiceImpl implements OrderService &#123;\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        try &#123;\n            &#x2F;&#x2F; update order\n        &#125; catch &#123;\n\t\t\t&#x2F;&#x2F; 异常被 catch，但又不抛出来\n        &#125;\n    &#125;\n&#125;\n\n4.8.8 异常类型错误@Service\npublic class OrderServiceImpl implements OrderService &#123;\n\n    @Transactional\n    public void updateOrder(Order order) &#123;\n        try &#123;\n            &#x2F;&#x2F; update order\n        &#125; catch &#123;\n            throw new Exception(&quot;更新错误&quot;);\n        &#125;\n    &#125;\n\n&#125;\n\n这样事务也是不生效的，因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如：\n@Transactional(rollbackFor &#x3D; Exception.class)\n\n这个配置仅限于 Throwable 异常类及其子类\n5. Spring5 新特性整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的和方法在代码库中删除\n5.1 自带的通用日志封装 log4j2\nSpring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2\nSpring5 框架整合 Log4j2\n\n5.1.1 引入依赖&lt;dependency&gt;\n      &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;log4j-api&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.13.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n      &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.13.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- 使用slf4j日志门面 --&gt;\n&lt;dependency&gt;\n      &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;log4j-slf4j-impl&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.13.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n5.1.2 配置文件 log4j2.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration status&#x3D;&quot;INFO&quot;&gt;\n    &lt;!--定义所有的appender --&gt;\n    &lt;appenders&gt;\n        &lt;!--这个输出控制台的配置 --&gt;\n        &lt;console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt;\n            &lt;!--输出日志的格式 --&gt;\n            &lt;PatternLayout pattern&#x3D;&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;&#x2F;&gt;\n        &lt;&#x2F;console&gt;\n    &lt;&#x2F;appenders&gt;\n    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;\n    &lt;loggers&gt;\n        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息 --&gt;\n        &lt;logger name&#x3D;&quot;org.springframework&quot; level&#x3D;&quot;INFO&quot;&gt;&lt;&#x2F;logger&gt;\n        &lt;logger name&#x3D;&quot;org.mybatis&quot; level&#x3D;&quot;INFO&quot;&gt;&lt;&#x2F;logger&gt;\n        &lt;root level&#x3D;&quot;info&quot;&gt;\n            &lt;appender-ref ref&#x3D;&quot;Console&quot; &#x2F;&gt;\n        &lt;&#x2F;root&gt;\n    &lt;&#x2F;loggers&gt;\n&lt;&#x2F;configuration&gt;\n\n5.1.3 手动打印日志public class UserLog &#123;\n    public static final  Logger log &#x3D; LoggerFactory.getLogger(UserLog.class);\n    public static void main(String[] args) &#123;\n        log.info(&quot;hello log4j2&quot;);\n        log.warn(&quot;hello log4j2&quot;);\n    &#125;\n&#125;\n\n5.2 Spring5 核心容器支持 @Nullable 注解@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空\n\n注解用在方法上面，方法返回值可以为空\n注解使用在方法参数里面，方法参数可以为空\n注解使用在属性上面，属性值可以为空\n\n5.3 Spring5 核心容器支持函数式风格 GenericApplicationContext&#x2F;&#x2F;函数式风格创建对象，交给 spring 进行管理\npublic void testGenericApplicationContext() &#123;\n\t&#x2F;&#x2F;1 创建 GenericApplicationContext 对象 \n\tGenericApplicationContext context &#x3D; new GenericApplicationContext();\n\t&#x2F;&#x2F;2 调用 context 的方法对象注册 \n\tcontext.refresh();\n\tcontext.registerBean(&quot;user1&quot;,User.class,() -&gt; new User());\n\t&#x2F;&#x2F;3 获取在 spring 注册的对象 \n\t&#x2F;&#x2F; User user &#x3D; (User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;); \n\tUser user &#x3D; (User)context.getBean(&quot;user1&quot;);\n\tSystem.out.println(user);\n&#125;\n\n5.4 Spring5 支持整合 JUnit55.4.1 整合 JUnit4@RunWith(SpringJUnit4ClassRunner.class) &#x2F;&#x2F; 单元测试框架 \n@ContextConfiguration(&quot;classpath:bean.xml&quot;) &#x2F;&#x2F; 加载配置文件 \npublic class JTest4 &#123; \n    @Autowired \n    private UserService userService; \n    @Test \n    public void test1() &#123; \n        userService.accountMoney(); \n    &#125; \n&#125; \n\n5.4.2 Spring5 整合 JUnit5&#x2F;&#x2F; @ExtendWith(SpringExtension.class) \n&#x2F;&#x2F; @ContextConfiguration(&quot;classpath:bean1.xml&quot;)\n@SpringJUnitConfig(locations &#x3D; &quot;classpath:bean1.xml&quot;)\npublic class JTest5 &#123; \n    @Autowired \n    private UserService userService; \n    @Test \n    public void test1() &#123; \n        userService.accountMoney(); \n    &#125; \n&#125;\n\n6. WebfluxSpring5 新添加的模块，用于 Web 开发。功能和 SpringMVC 类似，Webflux 使用响应式编程出现的框架。传统 Web 框架，比如 SpringMVC，这些基于 Servlet 容器，Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现的。\n6.1 异步非阻塞（NIO）异步与非阻塞都是针对对象不一样\n\n异步和同步针对调用者调用者发送请求，如果等着对方回应之后才去做其他事情就是同步；如果发送请求之后不等着对方回应就去做其他事情就是异步\n阻塞和非阻塞针对被调用者被调用者受到请求之后，做完请求任务之后才给出反馈就是阻塞；受到请求之后马上给出反馈然后再去做事情就是非阻塞\n\n6.2 SpringMVC 与 Webflux 对比Webflux\n\n非阻塞式： 在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程\n函数式编程： Spring5 框架基于 Java8，Webflux 使用 Java8 函数式编程方式实现路由请求\n\n\n\n两个框架都可以使用注解方式，都运行在 Tomcat 等容器中\nSpringMVC 采用命令式编程，Webflux 采用异步响应式编程\n\n6.3 响应式编程（Java 实现）6.3.1 概念响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。\n例： 电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似 &quot;=B1+C1&quot; 的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。\n6.3.2 Java8 及其之前版本提供的观察者模式两个类 Observer 和 Observable\npublic class ObserverDemo extends Observable &#123;\n    public static void main(String[] args) &#123;\n        ObserverDemo observerDemo &#x3D; new ObserverDemo();\n\n        observerDemo.addObserver((o, arg) -&gt; &#123;\n            System.out.println(&quot;发生变化&quot;);\n        &#125;);\n        observerDemo.addObserver((o, arg) -&gt; &#123;\n            System.out.println(&quot;手动被观察者通知，准备改变&quot;);\n        &#125;);\n\n        observerDemo.setChanged();\n        observerDemo.notifyObservers();\n    &#125;\n&#125;\n\n\n6.3.3 Java9 及其之后版本使用 Flow 这个 API，Flow 是 JDK 对 Reactive Stream (响应式流&#x2F;反应流) 的实现，Reactive Stream 是一套基于发布&#x2F;订阅模式的数据处理规范。\n响应式流从 2013 年开始，作为提供非阻塞背压的异步流处理标准的倡议。 它旨在解决处理元素流的问题——如何将元素流从发布者传递到订阅者，而不需要发布者阻塞，或订阅者需要有无限制的缓冲区或丢弃。更确切地说，Reactive 流目的是“找到最小的一组接口，方法和协议，用来描述必要的操作和实体以实现这样的目标：以非阻塞背压方式实现数据的异步流”。\n响应式流 (Reactive Stream) 规范诞生，定义了如下四个接口：\n\nSubscription：接口定义了连接发布者和订阅者的方法\nPublisher：接口定义了发布者的方法\nSubscriber：接口定义了订阅者的方法\nProcessor&lt;T,R&gt;：接口定义了处理器\n\n6.4 响应式编程（Reactor 实现）\nReactor 是满足 Reactive 规范的框架\nReactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作符Flux 对象实现发布者，返回 N 个元素；Mono 实现发布者，返回 0 或者 1 个元素\nFlux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：元素值，错误信号，完成信号错误信号和完成信号都代表终止信号，用于告诉订阅者数据流结束了；错误信号终止数据流同时把错误信息传递给订阅者\n\n6.4.1 引入 POM 依赖&lt;dependency&gt;\n\t&lt;groupId&gt;io.projectreactor&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;reactor-core&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.4.15&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n6.4.2 实现public class ReactorDemo &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; just 方法直接声明\n        Flux&lt;Integer&gt; flux &#x3D; Flux.just(1, 2, 3, 4);\n        flux.subscribe(System.out::println);\n      \n        Mono&lt;Integer&gt; mono &#x3D; Mono.just(1);\n        mono.subscribe(System.out::print);\n\n        &#x2F;&#x2F; 其他方法\n        Integer[] integers &#x3D; &#123;1, 2, 3, 4&#125;;\n        Flux.fromArray(integers);\n\n        List&lt;Integer&gt; list &#x3D; Arrays.asList(integers);\n        Flux.fromIterable(list);\n\n        Stream&lt;Integer&gt; stream &#x3D; list.stream();\n        Flux.fromStream(stream);\n    &#125;\n&#125;\n\n\n\n错误信号和完成信号都是终止信号，不能共存\n如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流\n如果没有错误信号，没有完成信号，表示是无限数据流\n\n调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生\n6.4.3 操作符对数据流进行一道道操作，称为操作符\n\nmap：元素映射为新元素\nflatMap：元素映射为流。把每个元素转换成流，再把转换后的多个流合并成大的流\n\n6.4.4 Spring Webflux 执行流程和核心 APISpring Webflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO （异步非阻塞）的框架\n\nBIO\nNIO。通过 Channel（通道），在 Selector（选择器）里进行注册。实现多路复用，对每个通道选择不同的状态\nSpring Webflux 执行过程和 SpringMVC 相似Spring Webflux 核心控制器 DispatchHandler，实现接口 WebHandler，其中有一个 handle 方法public Mono&lt;Void&gt; handle(ServerWebExchange exchange) &#123; &#x2F;&#x2F; http 请求响应信息\n\tif (this.handlerMappings &#x3D;&#x3D; null) &#123;\n\t\treturn createNotFoundError();\n\t&#125;\n\tif (CorsUtils.isPreFlightRequest(exchange.getRequest())) &#123;\n\t\treturn handlePreFlight(exchange);\n\t&#125;\n\treturn Flux.fromIterable(this.handlerMappings)\n\t\t\t.concatMap(mapping -&gt; mapping.getHandler(exchange))\n\t\t\t.next()\n\t\t\t.switchIfEmpty(createNotFoundError())\n\t\t\t.flatMap(handler -&gt; invokeHandler(exchange, handler))\n\t\t\t.flatMap(result -&gt; handleResult(exchange, result));\n&#125;\nSpring Webflux 里面 DispatcherHandler，负责请求的处理\nHandlerMapping：请求查询到处理的方法\nHandlerAdapter：真正负责请求处理\nHandlerResultHandler：响应结果处理\n\n\nSpring Webflux 实现函数式编程，两个接口：RouterFunction（路由处理）和 HandlerFunction（处理函数）\n\n6.5 Spring Webflux（基于注解编程模型）SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型。使用注解编程模型方式，和 SpringMVC 使用相似，只需要把相关依赖配置到项目中，SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器\n6.5.1  引入 POM 依赖&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-webflux&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n6.5.2 Controller@RestController\npublic class UserController &#123;\n\n\t@Resource\n\tprivate UserService userService;\n\n\t@GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)\n\tpublic Mono&lt;User&gt; getUserById(@PathVariable int id)&#123;\n\t\treturn userService.getUserById(id);\n\t&#125;\n\n\t@GetMapping(&quot;&#x2F;user&quot;)\n\tpublic Flux&lt;User&gt; getAllUser()&#123;\n\t\treturn userService.getAllUser();\n\t&#125;\n\n\t@PostMapping(&quot;&#x2F;addUser&quot;)\n\tpublic Mono&lt;Void&gt; addUser(@RequestBody User user)&#123;\n\t\treturn userService.addUser(Mono.just(user));\n\t&#125;\n&#125;\n\n6.5.3 Entity 和 Service@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private String id;\n    private String name;\n    private String gender;\n&#125;\n\npublic interface UserService &#123;\n\tMono&lt;User&gt; getUserById(int id);\n\n\tFlux&lt;User&gt; getAllUser();\n\n\tMono&lt;Void&gt; addUser(Mono&lt;User&gt; userMono);\n&#125;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n\tpublic static final Map&lt;Integer, User&gt; MAP &#x3D; new HashMap&lt;&gt;();\n\n\tpublic UserServiceImpl() &#123;\n\t\tMAP.put(1, new User(&quot;user1&quot;, &quot;张三&quot;, &quot;男&quot;));\n\t\tMAP.put(2, new User(&quot;user2&quot;, &quot;李四&quot;, &quot;女&quot;));\n\t\tMAP.put(3, new User(&quot;user3&quot;, &quot;王五&quot;, &quot;男&quot;));\n\t&#125;\n\n\t@Override\n\tpublic Mono&lt;User&gt; getUserById(int id) &#123;\n\t\treturn Mono.justOrEmpty(MAP.get(id));\n\t&#125;\n\n\t@Override\n\tpublic Flux&lt;User&gt; getAllUser() &#123;\n\t\treturn Flux.fromIterable(MAP.values());\n\t&#125;\n\n\t@Override\n\tpublic Mono&lt;Void&gt; addUser(Mono&lt;User&gt; userMono) &#123;\n\t\treturn userMono.doOnNext(user -&gt; &#123;\n\t\t\tMAP.put(MAP.size() + 1, user);\n\t\t&#125;).thenEmpty(Mono.empty());\n\t&#125;\n&#125;\n\n\n\nSpringMVC 方式实现，同步阻塞的方式，基于 SpringMVC + Servlet + Tomcat\nSpring Webflux 方式实现，异步非阻塞方式，基于 Spring Webflux + Reactor + Netty\n\n6.6 Spring Webflux（基于函数式编程模型）\n在使用函数式编程模型操作时候，需要自己初始化服务器\n基于函数式编程模型时候，有两个核心接口：RouterFunction（实现路由功能，请求转发给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）核心任务定义两个函数式接口的实现并且启动需要的服务器\nSpring Webflux 请求和响应不再是 ServletRequest 和 ServletResponse ，而是 ServerRequest 和 ServerResponse\n\n6.6.1 Entity 和 Service与 6.5.3 同\n6.6.2 handler创建 Handler（具体实现方法）\npublic class UserHandler &#123;\n\n    private final UserService userService;\n\n    public UserHandler(UserService userService) &#123;\n        this.userService &#x3D; userService;\n    &#125;\n\n    public Mono&lt;ServerResponse&gt; getUserById(ServerRequest serverRequest) &#123;\n        &#x2F;&#x2F; 获取 Id 值\n        Integer id &#x3D; Integer.valueOf(serverRequest.pathVariable(&quot;id&quot;));\n        &#x2F;&#x2F; 空值处理\n        Mono&lt;ServerResponse&gt; notFound &#x3D; ServerResponse.notFound().build();\n        &#x2F;&#x2F; 调用 service 方法得到数据\n        Mono&lt;User&gt; userMono &#x3D; userService.getUserById(id);\n        &#x2F;&#x2F; 把 userMono 进行转换返回\n        return userMono.flatMap(user -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)\n                .body(BodyInserters.fromObject(user))).switchIfEmpty(notFound);\n    &#125;\n\n    public Mono&lt;ServerResponse&gt; getAllUser(ServerRequest serverRequest) &#123;\n        Flux&lt;User&gt; allUser &#x3D; userService.getAllUser();\n\n        return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)\n                .body(userMono, User.class);\n&#x2F;&#x2F;        return userMono.flatMap(user -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)\n&#x2F;&#x2F;                .body(BodyInserters.fromObject(user))).switchIfEmpty(notFound);\n    &#125;\n\n    public Mono&lt;ServerResponse&gt; addUser(ServerRequest serverRequest)&#123;\n        &#x2F;&#x2F; 得到 user 对象\n        Mono&lt;User&gt; userMono &#x3D; serverRequest.bodyToMono(User.class);\n\n        return ServerResponse.ok().build(userService.addUser(userMono));\n    &#125;\n&#125;\n\n6.6.3 Server先创建 Router 路由，再创建服务器完成适配，最后进行调用。\npublic class Server &#123;\n\n\t&#x2F;&#x2F; 3. 调用\n    public static void main(String[] args) throws IOException &#123;\n        Server server &#x3D; new Server();\n        server.createReactorServer();\n        System.in.read();\n    &#125;\n\n    &#x2F;&#x2F; 1. 创建 Router 路由\n    public RouterFunction&lt;ServerResponse&gt; routerFunction() &#123;\n        UserServiceImpl userService &#x3D; new UserServiceImpl();\n        UserHandler userHandler &#x3D; new UserHandler(userService);\n\n        return RouterFunctions.route(RequestPredicates.GET(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;)\n                        .and(RequestPredicates.accept(MediaType.APPLICATION_JSON)), userHandler::getUserById)\n                .andRoute(RequestPredicates.GET(&quot;&#x2F;users&quot;)\n                        .and(RequestPredicates.accept(MediaType.APPLICATION_JSON)), userHandler::getAllUser);\n    &#125;\n\n    &#x2F;&#x2F; 2. 创建服务器完成适配\n    public void createReactorServer()&#123;\n        &#x2F;&#x2F; 路由和 handler 适配\n        RouterFunction&lt;ServerResponse&gt; routerFunction &#x3D; routerFunction();\n        HttpHandler httpHandler &#x3D; RouterFunctions.toHttpHandler(routerFunction);\n        ReactorHttpHandlerAdapter handlerAdapter &#x3D; new ReactorHttpHandlerAdapter(httpHandler);\n\n        &#x2F;&#x2F; 创建服务器\n        HttpServer httpServer &#x3D; HttpServer.create();\n        httpServer.handle(handlerAdapter).bindNow();\n    &#125;\n&#125;\n\n6.6.4 Client使用 WebClient 调用\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 调用服务器地址\n        WebClient webClient &#x3D; WebClient.create(&quot;http:&#x2F;&#x2F;localhost:1289&quot;);\n\n        &#x2F;&#x2F; 根据 Id 查询\n        String id &#x3D; &quot;1&quot;;\n        User block &#x3D; webClient.get().uri(&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)\n                .retrieve().bodyToMono(User.class).doOnNext(System.out::println).block();\n        System.out.println(block);\n\n        &#x2F;&#x2F; 查询所有\n        webClient.get().uri(&quot;&#x2F;users&quot;).accept(MediaType.APPLICATION_JSON)\n                .retrieve().bodyToFlux(User.class).doOnNext(System.out::println).blockLast();\n    &#125;\n&#125;\n\n\n","slug":"BlogRepository/Spring/Spring5 总结","date":"2022-06-08T18:01:17.000Z","categories_index":"Spring","tags_index":"Spring","author_index":"凡"},{"id":"7879396660455873787f556f0fa69f30","title":"记 Vue + Element-UI 上传组件上传图片到 https 图床接口（sm:ms）","content":"1. 上传组件action 表示上传的地址，这里使用 http-request 覆盖默认的上传行为，自定义上传的实现\n&lt;el-upload\n\taction&#x3D;&quot;&quot;\n\tclass&#x3D;&quot;alignContainer&quot;\n\t:http-request&#x3D;&quot;upload&quot;\n\t:show-file-list&#x3D;&quot;false&quot;\n\t:before-upload&#x3D;&quot;beforeAvatarUpload&quot;\n&gt;\n\t&lt;div class&#x3D;&quot;avatar-update&quot;&gt;修改头像&lt;&#x2F;div&gt;\n&lt;&#x2F;el-upload&gt;\n\n2. 上传实现创建一个 formData 对象，然后将 组件传进来的文件 file 传进去。这里的参数名 smfile 是图床接口所需要的参数，类型为 file\nupload(file) &#123;\n      const formData &#x3D; new FormData()\n      formData.append(&#39;smfile&#39;, file.file)\n\n      axios.post(&#39;&#x2F;api&#x2F;v2&#x2F;upload&#39;, formData, &#123;\n        headers: &#123;\n          &#39;Content-Type&#39;: &#39;multipart&#x2F;form-data&#39;,\n          &#39;Authorization&#39;: &#39;xxx&#39;\n        &#125;\n      &#125;, &#123; timeout: 30000 &#125;).then(res &#x3D;&gt; &#123;\n        if (res.data.code &#x3D;&#x3D;&#x3D; &#39;image_repeated&#39;) &#123;\n          this.userInfo.avatar &#x3D; res.data.images;\n        &#125; else &#123;\n          this.userInfo.avatar &#x3D; res.data.data.url;\n        &#125;\n\n        this.$axios.put(&#39;&#x2F;hrms&#x2F;employee&#x2F;updateEmployee&#39;, this.userInfo).then(() &#x3D;&gt; &#123;\n          this.$message.success(&#39;修改头像成功&#39;);\n          this.$bus.$emit(&#39;refreshNavHeader&#39;);\n        &#125;)\n      &#125;)\n&#125;\n\n3. https 代理设置secure 表示安全证书校验，设为 false。然后设置 Referer，表示请求来源（重要）\nconst &#123; defineConfig &#125; &#x3D; require(&#39;@vue&#x2F;cli-service&#39;)\nmodule.exports &#x3D; defineConfig(&#123;\n  transpileDependencies: true,\n  lintOnSave: false,\n  devServer: &#123;\n    port: 8080,\n    proxy: &#123;\n      &#39;&#x2F;hrms&#39;: &#123;\n        target: &#39;http:&#x2F;&#x2F;localhost:8888&#39;,\n        ws: true,\n        changeOrigin: true\n      &#125;,\n      &quot;&#x2F;api&quot;: &#123;\n        target: &#39;https:&#x2F;&#x2F;sm.ms&#39;,\n        changeOrigin: true, \n        secure: false,\n        headers: &#123;                \n          Referer: &#39;https:&#x2F;&#x2F;sm.ms&#39;\n        &#125;\n      &#125;,\n    &#125;\n  &#125;\n&#125;)\n\n注： 重点是 https 设置，其次是文件类型，一般浏览器会默认转为 multipart&#x2F;form-data，使用 FormData 来进行传输\n","slug":"BlogRepository/问题记录/记 Vue + Element-UI 上传组件上传图片到 https 图床接口（sm_ms）","date":"2022-05-21T02:10:12.000Z","categories_index":"问题记录","tags_index":"Vue","author_index":"凡"},{"id":"d525d12dddb4f5a1f4b9cd14617eb49e","title":"Spring Security + Vue2 + Element-UI 总结","content":"Vue 基础部分见：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;123573568Vue 开发部分见：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;123789272\n1. Vue UI 创建项目Vue UI 是 @vue&#x2F;cli3.0 增加的一个可视化项目管理工具，可以运行项目、打包项目，检查等操作\n1、在命令行输入 vue ui，运行2、进入可视化界面3、选择项目路径，新建项目4、输入项目名，下一步5、可以选择预设或者自定义，默认预设即可。这里选择手动，下一步6、选择功能，加上 Router 和 Vuex7、选择 Vue 的版本和路由的模式，这里选择 Vue2 与 不使用 History 模式8、不保存预设9、创建完成10、启动项目，选择 任务 –&gt; serve –&gt; 运行，后续进入项目可通过命令行启动11、启动成功12、访问 localhost:8080，初始界面，因没有选择 History 路由模式，地址会带上 # 号13、项目初始结构\n2. Vue 项目搭建2.1 引入 Element-UI、Axios、Mockjs、QS2.1.1 引入 Element-UI\n安装：npm install element-ui -S\n完整引入： 在 main.js 引入&#x2F;&#x2F; 引入 Element UI 组件库\nimport ElementUI from &#39;element-ui&#39;;\n&#x2F;&#x2F; 引入 Element UI 全部样式\nimport &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;;\n&#x2F;&#x2F; 应用 Element UI\nVue.use(ElementUI);\n按需引入：\n安装：npm install babel-plugin-component -D ，-D 表示开发依赖\n将 babel.config.js 修改为：module.exports &#x3D; &#123;\n  presets: [ &#x2F;&#x2F; 预设\n    &#39;@vue&#x2F;cli-plugin-babel&#x2F;preset&#39;, &#x2F;&#x2F; vue-cli 原有的\n    [&#39;@babel&#x2F;preset-env&#39;, &#123; modules: false &#125;] &#x2F;&#x2F; 在原有的后面添加\n  ],\n  plugins: [\n    [\n      &quot;component&quot;,\n      &#123;\n        &quot;libraryName&quot;: &quot;element-ui&quot;,\n        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;\n      &#125;\n    ]\n  ]\n&#125;\n在 main.js 引入需要的部分组件：&#x2F;&#x2F; 引入 Button、Select 和 Option，按钮、选择器和选项\nimport &#123; Button, Select, Option &#125; from &#39;element-ui&#39;;\n&#x2F;&#x2F; Button.name 即使用时标签的默认名字 &lt;el-button&gt;&lt;&#x2F;el-button&gt;，el-xxx\nVue.component(Button.name, Button);\n&#x2F;&#x2F; 可以简写为：Vue.use(Button)\nVue.component(Select.name, Select);\n&#x2F;&#x2F; 可以自定义标签名字，则使用时标签也为自定义的标签名字而不是默认的 el-xxx\nVue.component(&#39;fan-option&#39;, Option)\n\n\n\n2.1.2 引入 Axios、Mockjs安装 axios：npm install axios --save安装 mockjs：npm install mockjs在 src 目录下 新建 mock&#x2F;index.js在 main.js 里引入。这里引入了 Mockjs，所有的请求都会被拦截。与后端接口对接时，需要在 main.js 中去掉 Mockjs 的引入，这样前端就可以访问后端的接口而不被 Mock 拦截\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\n&#x2F;&#x2F; 引入 store\nimport store from &#39;.&#x2F;store&#39;\n&#x2F;&#x2F; 引入 VueRouter\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 引入路由器\nimport router from &#39;.&#x2F;router&#x2F;index.js&#39;\n&#x2F;&#x2F; 引入 Axios\nimport axios from &#39;axios&#39;\n&#x2F;&#x2F; 引入 Element UI 组件库\nimport ElementUI from &#39;element-ui&#39;;\n&#x2F;&#x2F; 引入 Element UI 全部样式\nimport &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;;\n\nVue.config.productionTip &#x3D; false\n&#x2F;&#x2F; 全局应用 Axios\nVue.prototype.$axios &#x3D; axios\n&#x2F;&#x2F; 应用 VueRouter 插件\nVue.use(VueRouter)\n&#x2F;&#x2F; 应用 Element UI\nVue.use(ElementUI);\n&#x2F;&#x2F; 引入mock数据\nrequire(&#39;.&#x2F;mock&#x2F;index.js&#39;)\n\nnew Vue(&#123;\n  store,\n  router,\n  render: h &#x3D;&gt; h(App),\n&#125;).$mount(&#39;#app&#39;)\n\n2.1.3 引入 QS安装 qs：npm install qs在 main.js 文件中引入\n&#x2F;&#x2F; 引入 qs\nimport qs from &#39;qs&#39;\n&#x2F;&#x2F; 配置全局 qs 属性\nVue.prototype.$qs &#x3D; qs\n\n2.2 登录页\n2.2.1 新建登录组件在 views 目录下，将原来的默认组件删掉，新建一个 Login 组件1、使用 Element-UI 的 Layout 布局，加上表单验证\n\n:model 表示表单数据对象\n:rules 表示表单验证规则\n:status-icon 表示输入框中校验结果反馈图标\n:hide-required-asterisk 表示表单验证必填项的 * 号\nlabel 表示标签名字\nlabel-width 表示标签宽度\nref 给元素注册引用信息\n\n&lt;template&gt;\n  &lt;el-row&gt;\n    &lt;el-col :span&#x3D;&quot;24&quot;&gt;\n\n      &lt;el-form\n        :model&#x3D;&quot;loginForm&quot;\n        ref&#x3D;&quot;loginForm&quot;\n        :rules&#x3D;&quot;rules&quot;\n        :status-icon&#x3D;&quot;true&quot;\n        :hide-required-asterisk&#x3D;&quot;true&quot;\n        @keyup.enter.native&#x3D;&quot;login&quot;\n      &gt;\n        &lt;el-form-item&gt;\n          &lt;div class&#x3D;&quot;el-form-login-title&quot;&gt;系统登录&lt;&#x2F;div&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item\n          prop&#x3D;&quot;username&quot;\n          label&#x3D;&quot;用户名&quot;\n          label-width&#x3D;&quot;80px&quot;\n        &gt;\n          &lt;el-input\n            type&#x3D;&quot;input&quot;\n            v-model&#x3D;&quot;loginForm.username&quot;\n            autocomplete&#x3D;&quot;off&quot;\n            placeholder&#x3D;&quot;请输入用户名&quot;\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item\n          prop&#x3D;&quot;password&quot;\n          label&#x3D;&quot;密码&quot;\n          label-width&#x3D;&quot;80px&quot;\n        &gt;\n          &lt;el-input\n            type&#x3D;&quot;password&quot;\n            v-model&#x3D;&quot;loginForm.password&quot;\n            autocomplete&#x3D;&quot;off&quot;\n            placeholder&#x3D;&quot;请输入密码&quot;\n          &gt;&lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item\n          prop&#x3D;&quot;captcha&quot;\n          label&#x3D;&quot;验证码&quot;\n          label-width&#x3D;&quot;80px&quot;\n        &gt;\n          &lt;el-input\n            type&#x3D;&quot;input&quot;\n            v-model&#x3D;&quot;loginForm.captcha&quot;\n            autocomplete&#x3D;&quot;off&quot;\n            placeholder&#x3D;&quot;请输入验证码&quot;\n            style&#x3D;&quot;width: 380px; float: left;&quot;\n          &gt;&lt;&#x2F;el-input&gt;\n          &lt;el-image\n            :src&#x3D;&quot;captchaImg&quot;\n            @click&#x3D;&quot;getCaptcha&quot;\n            style&#x3D;&quot;margin-left: 15px; border-radius: 5px;&quot;\n          &gt;&lt;&#x2F;el-image&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item class&#x3D;&quot;el-form-login-submit&quot;&gt;\n          &lt;el-button\n            type&#x3D;&quot;primary&quot;\n            @click&#x3D;&quot;login&quot;\n          &gt;登 录&lt;&#x2F;el-button&gt;\n          &lt;el-button\n            type&#x3D;&quot;primary&quot;\n            @click&#x3D;&quot;() &#x3D;&gt; this.$refs.loginForm.resetFields()&quot;\n          &gt;重 置&lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-form-item&gt;\n      &lt;&#x2F;el-form&gt;\n    &lt;&#x2F;el-col&gt;\n  &lt;&#x2F;el-row&gt;\n&lt;&#x2F;template&gt;\n\n2、required 表示是否必填，message 表示提示信息，trigger 表示触发方式\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Login&#39;,\n  data() &#123;\n    return &#123;\n      &#x2F;&#x2F; 表单数据对象\n      loginForm: &#123;\n        username: &#39;&#39;,\n        password: &#39;&#39;,\n        captcha: &#39;&#39;,\n        token: &#39;&#39;,\n      &#125;,\n      &#x2F;&#x2F; 表单验证规则\n      rules: &#123;\n        username: [\n          &#x2F;&#x2F; required 表示是否必填，message 表示提示信息，trigger 表示触发方式\n          &#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;,\n        ],\n        password: [\n          &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;,\n        ],\n        captcha: [\n          &#123; required: true, message: &#39;请输入验证码&#39;, trigger: &#39;blur&#39; &#125;,\n        ],\n      &#125;,\n      captchaImg: &#39;&#39;,\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n3、修改表单验证提示语样式\n&lt;style scoped&gt;\n::v-deep .el-form-item__error &#123;\n  font-size: 14px;\n&#125;\n&lt;&#x2F;style&gt;\n\n4、修改表单标签样式\n&lt;style scoped&gt;\n::v-deep .el-form-item__label &#123;\n  color: #fff;\n  font-weight: bold;\n&#125;\n&lt;&#x2F;style&gt;\n\n5、重置表单this.$refs[&#39;loginForm&#39;]表示获取表单，或者写为 this.$refs.loginForm，resetFields() 用于对整个表单进行重置，将所有字段值重置为初始值并移除校验结果。@click=&quot;() =&gt; this.$refs.loginForm.resetFields()&quot;\n&lt;el-form :model&#x3D;&quot;loginForm&quot; ref&#x3D;&quot;loginForm&quot; :rules&#x3D;&quot;rules&quot;&gt;\n  &lt;el-form-item&gt;\n        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;login&quot;&gt;登录&lt;&#x2F;el-button&gt;\n        &lt;!-- 重置表单 --&gt;\n        &lt;el-button type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;() &#x3D;&gt; this.$refs.loginForm.resetFields()&quot;&gt;重置&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;el-form-item&gt;\n&lt;&#x2F;el-form&gt;\n\n6、表单按下回车提交@keyup.enter.native 表示按下回车触发事件\n&lt;el-form :model&#x3D;&quot;formLogin&quot; ref&#x3D;&quot;formLogin&quot; :rules&#x3D;&quot;rules&quot;\n\t@keyup.enter.native&#x3D;&quot;login&quot;&gt;\n&lt;&#x2F;el-form&gt;\n\n7、表单提交校验this.$refs[&#39;loginForm&#39;]获取表单，validate()表示对整个表单进行校验的方法，参数为一个回调函数。该回调函数会在校验结束后被调用，并传入两个参数：是否校验成功和未通过校验的字段。若不传入回调函数，则会返回一个 promise\n&lt;script&gt;\nexport default &#123;\n  methods: &#123;\n    login() &#123;\n      this.$refs[&#39;loginForm&#39;].validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          alert(&#39;submit!&#39;);\n        &#125; else &#123;\n          return false;\n        &#125;\n      &#125;);\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n2.2.2 添加路由在 src&#x2F;router&#x2F;index.js 文件里添加 &#x2F;login 的路由，并且绑定到上面的 Login 组件\n&#x2F;&#x2F; 引入VueRouter\nimport VueRouter from &#39;vue-router&#39;\n\n&#x2F;&#x2F; 创建 router 实例对象（路由器），去管理一组一组的路由规则，并暴露出去\nexport default new VueRouter(&#123;\n  &#x2F;&#x2F; 路由配置\n  routes: [\n    &#123;\n      path: &#39;&#x2F;login&#39;,\n      name: &#39;Login&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Login.vue&#39;),\n    &#125;,\n  ]\n&#125;)\n\n2.2.3 App.vue在 App.vue 里添加 &lt;router-view&gt;&lt;/router-view&gt; 标签，并且将边距设为 0\n&lt;template&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\nbody,\nhtml &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n&lt;&#x2F;style&gt;\n\n2.2.4 访问登录页面访问路径 localhost:8080&#x2F;#&#x2F;login 即可访问登录页面\n2.3 登录校验2.3.1 图片验证码1、Login 组件里给图片验证码加上 src 属性，图片源。在 data 里定义该图片源\n&lt;el-image\n\t:src&#x3D;&quot;captchaImg&quot;\n\tstyle&#x3D;&quot;margin-left: 20px; border-radius: 5px;&quot;\n&gt;&lt;&#x2F;el-image&gt;\n\n2、Login 组件里定义 getCaptcha 方法，获取验证码信息以及 token，同时组件加载时加载验证码\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Login&#39;,\n  data() &#123;\n    return &#123;\n      &#x2F;&#x2F; 验证码图片\n      captchaImg: &#39;&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    getCaptcha() &#123;\n      this.$axios.get(&#39;&#x2F;hrms&#x2F;api&#x2F;getCaptcha&#39;).then((res) &#x3D;&gt; &#123;\n        this.captchaImg &#x3D; res.data.data.captchaImg;\n        this.loginForm.token &#x3D; res.data.data.token;\n        this.loginForm.captcha &#x3D; &#39;&#39;;\n      &#125;)\n    &#125;,\n  &#125;,\n  mounted() &#123;\n    this.getCaptcha()\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3、未与后端接口对接时，可以先使用 Mockjs 模拟接口发送数据，在 src&#x2F;mock&#x2F;inde.js 文件中模拟发送数据（验证码和 token）。后续未对接的接口都可以在此模拟接口数据\nconst Mock &#x3D; require(&#39;mockjs&#39;)\nconst Random &#x3D; Mock.Random\n\nlet Result &#x3D; &#123;\n  code: 200,\n  msg: &#39;成功&#39;,\n  data: &#123;&#125;\n&#125;\n\nMock.mock(&#39;&#x2F;hrms&#x2F;api&#x2F;getCaptcha&#39;, &#39;get&#39;, () &#x3D;&gt; &#123;\n  Result.data &#x3D; &#123;\n    token: Random.string(32),\n    captchaImg: Random.dataImage(&#39;120x40&#39;, &#39;4A7BF7&#39;)\n  &#125;\n  return Result;\n&#125;)\n\n4、成功显示验证码\n2.3.2 登录验证1、Login 组件里定义 login 方法，发送登录请求，将登录表单的数据传过去，假如登录成功，获取并调用处理 jwt 方法，然后进行跳转\n&lt;script&gt;\nexport default &#123;\n  methods: &#123;\n  \tlogin() &#123;\n      this.$refs.loginForm.validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          this.$axios.post(&#39;&#x2F;hrms&#x2F;login?&#39; + this.$qs.stringify(this.loginForm)).then((res) &#x3D;&gt; &#123;\n            this.$message.success(&#39;登录成功&#39;)\n            &#x2F;&#x2F; eslint-disable-next-line no-unused-vars\n            const jwt &#x3D; res.headers.authorization\n            this.$store.commit(&#39;SET_JWT&#39;, jwt)\n            this.$router.push(&#39;&#x2F;home&#39;).catch(() &#x3D;&gt; &#123; &#125;)\n          &#125;)\n        &#125; else &#123;\n          return false;\n        &#125;\n      &#125;);\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n2、在 src&#x2F;store&#x2F;index.js 文件中接收并存储 jwt\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 Vuex\nimport Vuex from &#39;vuex&#39;\n&#x2F;&#x2F; 应用 Vuex 插件\nVue.use(Vuex)\n\n&#x2F;&#x2F; 准备 actions——用于响应组件中的动作\nconst actions &#x3D; &#123;&#125;\n&#x2F;&#x2F; 准备 mutations——用于操作数据（state）\nconst mutations &#x3D; &#123;\n  SET_JWT(state, jwt) &#123;\n    state.jwt &#x3D; jwt;\n    localStorage.setItem(&#39;jwt&#39;, jwt);\n  &#125;\n&#125;\n&#x2F;&#x2F; 准备state——用于存储数据\nconst state &#x3D; &#123;\n  jwt: &#39;&#39;,\n&#125;\n&#x2F;&#x2F; 准备getters——用于将state中的数据进行加工\nconst getters &#x3D; &#123;&#125;\n\n&#x2F;&#x2F;创建并暴露 store\nexport default new Vuex.Store(&#123;\n  &#x2F;&#x2F;actions: actions,\n  actions,\n  mutations,\n  state,\n  getters\n&#125;)\n\n\n2.3.3 全局 Axios 拦截器1、在 src 目录下新建 axios.js 文件，拦截所有请求，对于 200 状态码的请求放行，对其他状态码请求进行处理\nimport axios from &quot;axios&quot;;\nimport ElementUI from &quot;element-ui&quot;;\nimport router from &quot;.&#x2F;router&quot;;\n\nconst request &#x3D; axios.create(&#123;\n  timeout: 5000,\n  headers: &#123;\n    &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,\n  &#125;,\n&#125;);\n\nrequest.interceptors.request.use(config &#x3D;&gt; &#123;\n  if (localStorage.getItem(&quot;token&quot;)) &#123;\n  \t&#x2F;&#x2F; 请求头带上 token\n    config.headers.Authorization &#x3D; localStorage.getItem(&quot;jwt&quot;);\n  &#125;\n  return config;\n&#125;);\n\nrequest.interceptors.response.use(response &#x3D;&gt; &#123;\n  let res &#x3D; response.data;\n\n  if (res.code &#x3D;&#x3D;&#x3D; 200) &#123;\n    return response;\n  &#125;else &#123;\n    ElementUI.Message.error(res.message ? res.message : &#39;系统异常&#39;);\n    return Promise.reject(res.message);\n  &#125;\n&#125;, error &#x3D;&gt; &#123;\n  if (error.response) &#123;\n    switch (error.response.status) &#123;\n      case 401:\n        router.push(&quot;&#x2F;login&quot;);\n        break;\n      case 403:\n        ElementUI.Message.error(&quot;拒绝访问&quot;);\n        break;\n      case 404:\n        ElementUI.Message.error(&quot;请求错误,未找到该资源&quot;);\n        break;\n      case 500:\n        ElementUI.Message.error(&quot;服务器出错&quot;);\n        break;\n      default:\n        ElementUI.Message.error(&quot;未知错误&quot;);\n    &#125;\n  &#125;\n  return Promise.reject(error);\n&#125;);\n\nexport default request\n\n2、在 main.js 里修改 axios 的引入路径\n&#x2F;&#x2F; 引入 src&#x2F;axios.js 请求拦截器\nimport request from &#39;.&#x2F;axios&#39;\n&#x2F;&#x2F; 全局应用 axios 请求拦截器\nVue.prototype.$axios &#x3D; request\n\n\n2.4 整体布局在 src 目录下创建 layout 文件夹，并且分别创建三个布局组件。使用 Element-UI 的 Container 布局容器\n2.4.1 主容器 Main.vue包括左侧菜单栏和顶部菜单栏，以及主体部分，后续组件都使用嵌套路由套在该容器下，继承左侧菜单栏和顶部菜单栏\n&lt;template&gt;\n  &lt;el-container&gt;\n    &lt;el-aside width&#x3D;&quot;&#123;asideWidth: &#39;200px&#39;&#125;&quot;&gt;\n      &lt;NavAside&gt;&lt;&#x2F;NavAside&gt;\n    &lt;&#x2F;el-aside&gt;\n    &lt;el-container&gt;\n      &lt;el-header&gt;\n        &lt;NavHeader&gt;&lt;&#x2F;NavHeader&gt;\n      &lt;&#x2F;el-header&gt;\n      &lt;el-main&gt;\n        &lt;router-view style&#x3D;&quot;padding: 0 20px 0 20px&quot;&gt;&lt;&#x2F;router-view&gt;\n      &lt;&#x2F;el-main&gt;\n    &lt;&#x2F;el-container&gt;\n  &lt;&#x2F;el-container&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport NavAside from &#39;@&#x2F;layout&#x2F;NavAside.vue&#39;\nimport NavHeader from &#39;@&#x2F;layout&#x2F;NavHeader.vue&#39;\nimport Tabs from &#39;@&#x2F;layout&#x2F;Tabs.vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Main&#39;,\n  components: &#123;\n    NavAside,\n    NavHeader\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.el-header &#123;\n  background-color: #333;\n  color: #fff;\n&#125;\n.el-aside &#123;\n  background-color: #545c64;\n&#125;\n.el-main &#123;\n  background-color: #f3f3f4;\n  padding: 0;\n&#125;\n&lt;&#x2F;style&gt;\n\n2.4.2 左侧菜单栏 NavAside.vuecollapse 属性表示是否收缩，使用 router-link 进行路由跳转。同时更改 a 链接的样式去掉 router-link 的下划线\n&lt;template&gt;\n  &lt;el-menu\n    class&#x3D;&quot;el-menu-vertical-demo&quot;\n    :collapse&#x3D;&quot;$store.state.isCollapse&quot;\n    background-color&#x3D;&quot;#545c64&quot;\n    text-color&#x3D;&quot;#fff&quot;\n    active-text-color&#x3D;&quot;#ffd04b&quot;\n    :default-active&#x3D;&quot;this.$store.state.menu.editableTabsValue&quot;\n  &gt;\n    &lt;el-menu-item\n      index&#x3D;&quot;title&quot;\n      @click&#x3D;&quot;$router.go(0)&quot;\n    &gt;\n      &lt;span\n        slot&#x3D;&quot;title&quot;\n        style&#x3D;&quot;margin-left: 8px&quot;\n      &gt; &lt;b&gt;企业人力资源管理系统&lt;&#x2F;b&gt; &lt;&#x2F;span&gt;\n      &lt;i\n        class&#x3D;&quot;el-icon-menu&quot;\n        v-show&#x3D;&quot;$store.state.isCollapse&quot;\n      &gt;&lt;&#x2F;i&gt;\n    &lt;&#x2F;el-menu-item&gt;\n\n    &lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;\n      &lt;el-menu-item index&#x3D;&quot;Home&quot;&gt;\n        &lt;i class&#x3D;&#39;el-icon-s-home&#39;&gt;&lt;&#x2F;i&gt;\n        &lt;span slot&#x3D;&quot;title&quot;&gt; 首页 &lt;&#x2F;span&gt;\n      &lt;&#x2F;el-menu-item&gt;\n    &lt;&#x2F;router-link&gt;\n\n    &lt;template v-for&#x3D;&quot;menu in menuList&quot;&gt;\n      &lt;el-submenu\n        v-if&#x3D;&quot;menu.children &amp;&amp; menu.children.length &gt; 0&quot;\n        :key&#x3D;&quot;menu.name&quot;\n        :index&#x3D;&quot;menu.name&quot;\n      &gt;\n        &lt;template slot&#x3D;&quot;title&quot;&gt;\n          &lt;i :class&#x3D;menu.icon&gt;&lt;&#x2F;i&gt;\n          &lt;span slot&#x3D;&quot;title&quot;&gt; &#123;&#123; menu.title &#125;&#125; &lt;&#x2F;span&gt;\n        &lt;&#x2F;template&gt;\n        &lt;template v-for&#x3D;&quot;child in menu.children&quot;&gt;\n          &lt;router-link\n            :to&#x3D;&quot;child.path&quot;\n            :key&#x3D;&quot;child.name&quot;\n          &gt;\n            &lt;el-menu-item\n              :index&#x3D;&quot;child.name&quot;\n              @click&#x3D;&quot;addTab(child)&quot;\n            &gt;\n              &lt;i :class&#x3D;child.icon&gt;&lt;&#x2F;i&gt;\n              &lt;span slot&#x3D;&quot;title&quot;&gt; &#123;&#123; child.title &#125;&#125; &lt;&#x2F;span&gt;\n            &lt;&#x2F;el-menu-item&gt;\n          &lt;&#x2F;router-link&gt;\n        &lt;&#x2F;template&gt;\n\n      &lt;&#x2F;el-submenu&gt;\n\n      &lt;router-link\n        v-else\n        :to&#x3D;&quot;menu.path&quot;\n        :key&#x3D;&quot;menu.name&quot;\n      &gt;\n        &lt;el-menu-item\n          :index&#x3D;&quot;menu.name&quot;\n          @click&#x3D;&quot;addTab(menu)&quot;\n        &gt;\n          &lt;i :class&#x3D;menu.icon&gt;&lt;&#x2F;i&gt;\n          &lt;span slot&#x3D;&quot;title&quot;&gt; &#123;&#123; menu.title &#125;&#125; &lt;&#x2F;span&gt;\n        &lt;&#x2F;el-menu-item&gt;\n      &lt;&#x2F;router-link&gt;\n    &lt;&#x2F;template&gt;\n  &lt;&#x2F;el-menu&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;NavAside&#39;,\n  computed: &#123;\n    menuList() &#123;\n      return this.$store.state.menu.menuList\n    &#125;\n  &#125;,\n  methods: &#123;\n    addTab(menu) &#123;\n      this.$store.commit(&#39;ADD_TAB&#39;, menu)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.el-menu-vertical-demo:not(.el-menu--collapse) &#123;\n  width: 200px;\n&#125;\n.el-menu &#123;\n  height: 100vh;\n  background-color: #545c64;\n  color: #fff;\n&#125;\na &#123;\n  text-decoration: none;\n&#125;\n&lt;&#x2F;style&gt;\n\n2.4.3 顶部菜单栏 NavHeader.vue&lt;template&gt;\n  &lt;el-row&gt;\n    &lt;el-col :span&#x3D;&quot;24&quot;&gt;\n      &lt;el-button\n        size&#x3D;&quot;mini&quot;\n        v-show&#x3D;&quot;!$store.state.isCollapse&quot;\n        @click&#x3D;&quot;handleCollapse&quot;\n        icon&#x3D;&quot;el-icon-s-fold&quot;\n      &gt;&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        size&#x3D;&quot;mini&quot;\n        v-show&#x3D;&quot;$store.state.isCollapse&quot;\n        @click&#x3D;&quot;handleCollapse&quot;\n        icon&#x3D;&quot;el-icon-s-unfold&quot;\n      &gt;&lt;&#x2F;el-button&gt;\n\n      &lt;el-dropdown&gt;\n        &lt;el-avatar\n          class&#x3D;&quot;el-avatar&quot;\n          shape&#x3D;&quot;circle&quot;\n          :size&#x3D;&quot;45&quot;\n          :src&#x3D;&quot;userInfo.avatar&quot;\n        &gt;&lt;&#x2F;el-avatar&gt;\n        &lt;span style&#x3D;&quot;color: #ddd; margin-left: 10px;&quot;&gt;\n          &#123;&#123;userInfo.empName&#125;&#125;&lt;i class&#x3D;&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;&#x2F;span&gt;\n        &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;\n          &lt;router-link to&#x3D;&quot;&#x2F;userCenter&quot;&gt;\n            &lt;el-dropdown-item&gt;个人中心&lt;&#x2F;el-dropdown-item&gt;\n          &lt;&#x2F;router-link&gt;\n          &lt;el-dropdown-item @click.native&#x3D;&quot;logout&quot;&gt;退出&lt;&#x2F;el-dropdown-item&gt;\n        &lt;&#x2F;el-dropdown-menu&gt;\n      &lt;&#x2F;el-dropdown&gt;\n    &lt;&#x2F;el-col&gt;\n  &lt;&#x2F;el-row&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;NavHeader&#39;,\n  data() &#123;\n    return &#123;\n      userInfo: &#123;&#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    handleCollapse() &#123;\n      this.$store.commit(&#39;HANDLE_COLLAPSE&#39;);\n    &#125;,\n    logout() &#123;\n      this.$axios.post(&#39;&#x2F;hrms&#x2F;logout&#39;).then(() &#x3D;&gt; &#123;\n        this.$store.commit(&#39;LOGOUT&#39;);\n        this.$router.push(&#39;&#x2F;login&#39;);\n      &#125;);\n    &#125;,\n    getUserInfo() &#123;\n      this.$axios.get(&quot;&#x2F;hrms&#x2F;employee&#x2F;getUserInfo&quot;).then(res &#x3D;&gt; &#123;\n        this.userInfo &#x3D; res.data.data;\n      &#125;)\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.getUserInfo();\n\n    this.$bus.$on(&#39;refreshNavHeader&#39;, () &#x3D;&gt; &#123;\n      this.getUserInfo();\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.el-col &#123;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  line-height: 60px;\n&#125;\n.el-button &#123;\n  margin-left: -5px;\n&#125;\n.el-avatar &#123;\n  vertical-align: middle;\n&#125;\na &#123;\n  text-decoration: none;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n2.4.4 展开&#x2F;收缩侧边栏在 src&#x2F;store&#x2F;index.js 文件中添加 isCollapse 属性来决定是否收缩，使用 HANDLE_COLLAPSE 方法来进行控制\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 Vuex\nimport Vuex from &#39;vuex&#39;\n&#x2F;&#x2F; 应用 Vuex 插件\nVue.use(Vuex)\n\n&#x2F;&#x2F; 准备 actions——用于响应组件中的动作\nconst actions &#x3D; &#123;&#125;\n&#x2F;&#x2F; 准备 mutations——用于操作数据（state）\nconst mutations &#x3D; &#123;\n  SET_JWT(state, jwt) &#123;\n    state.jwt &#x3D; jwt;\n    localStorage.setItem(&#39;jwt&#39;, jwt);\n  &#125;,\n  HANDLE_COLLAPSE(state) &#123;\n    state.isCollapse &#x3D; !state.isCollapse\n  &#125;,\n&#125;\n&#x2F;&#x2F; 准备state——用于存储数据\nconst state &#x3D; &#123;\n  jwt: &#39;&#39;,\n  isCollapse: false,\n&#125;\n&#x2F;&#x2F; 准备getters——用于将state中的数据进行加工\nconst getters &#x3D; &#123;&#125;\n\n&#x2F;&#x2F;创建并暴露 store\nexport default new Vuex.Store(&#123;\n  actions,\n  mutations,\n  state,\n  getters\n&#125;)\n\n\n2.5 退出与动态导航路由、动态标签页绑定2.5.1 退出1、在顶部菜单栏，NavHeader.vue 组件中，给退出下拉框添加点击事件，一个退出的方法\n&lt;template&gt;\n  &lt;el-row&gt;\n    &lt;el-col :span&#x3D;&quot;24&quot;&gt;\n      &lt;el-dropdown&gt;\n        &lt;el-avatar\n          class&#x3D;&quot;el-avatar&quot;\n          shape&#x3D;&quot;circle&quot;\n          :size&#x3D;&quot;45&quot;\n          :src&#x3D;&quot;userInfo.avatar&quot;\n        &gt;&lt;&#x2F;el-avatar&gt;\n        &lt;span style&#x3D;&quot;color: #ddd; margin-left: 10px;&quot;&gt;\n          &#123;&#123;userInfo.empName&#125;&#125;&lt;i class&#x3D;&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;&#x2F;i&gt;\n        &lt;&#x2F;span&gt;\n  \n        &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;\n          &lt;router-link to&#x3D;&quot;&#x2F;userCenter&quot;&gt;\n            &lt;el-dropdown-item&gt;个人中心&lt;&#x2F;el-dropdown-item&gt;\n          &lt;&#x2F;router-link&gt;\n          &lt;el-dropdown-item @click.native&#x3D;&quot;logout&quot;&gt;退出&lt;&#x2F;el-dropdown-item&gt;\n        &lt;&#x2F;el-dropdown-menu&gt;\n      &lt;&#x2F;el-dropdown&gt;\n    &lt;&#x2F;el-col&gt;\n  &lt;&#x2F;el-row&gt;\n&lt;&#x2F;template&gt;\n\n2、发送退出请求，调用处理退出的方法，然后路由到登录页面\n&lt;script&gt;\nexport default &#123;\n  name: &#39;NavHeader&#39;,\n  methods: &#123;\n    handleCollapse() &#123;\n      this.$store.commit(&#39;HANDLE_COLLAPSE&#39;);\n    &#125;,\n    logout() &#123;\n      this.$axios.post(&#39;&#x2F;hrms&#x2F;logout&#39;).then(() &#x3D;&gt; &#123;\n        this.$store.commit(&#39;LOGOUT&#39;);\n        this.$router.push(&#39;&#x2F;login&#39;);\n      &#125;);\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3、在 src&#x2F;store&#x2F;index.js 文件里处理退出，清除缓存信息\nconst mutations &#x3D; &#123;\n  LOGOUT(state) &#123;\n    localStorage.removeItem(&#39;jwt&#39;);\n    state.jwt &#x3D; &#39;&#39;;\n    &#x2F;&#x2F; localStorage.clear();\n    &#x2F;&#x2F; state.menu.menuList &#x3D; [];\n    &#x2F;&#x2F; state.menu.permissions &#x3D; [];\n    &#x2F;&#x2F; state.menu.hasRoute &#x3D; false;\n    state.menu.editableTabsValue &#x3D; &#39;Home&#39;;\n    state.menu.editableTabs &#x3D; [&#123;\n      title: &#39;首页&#39;,\n      name: &#39;Home&#39;,\n    &#125;];\n  &#125;,\n&#125;\n\n2.5.2 动态导航与动态路由绑定1、设置全局前置路由守卫，加载菜单信息，还可以通过判断是否登录页面，是否有 jwt 等判断条件提前判断是否能加载菜单，同时还可以通过开关 hasRoute 来动态判断是否已经加载过菜单。将获取到的菜单动态生成路由，进行绑定，将 title、icon 等非路由属性放到 meta 路由元信息中。\n&#x2F;&#x2F; 引入VueRouter\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 引入 Axios\nimport axios from &#39;..&#x2F;axios&#39;\n&#x2F;&#x2F; 引入 Vuex\nimport store from &#39;..&#x2F;store&#39;\n\n&#x2F;&#x2F; 创建 router 实例对象（路由器），去管理一组一组的路由规则，并暴露出去\nconst router &#x3D; new VueRouter(&#123;\n  &#x2F;&#x2F; 路由配置\n  routes: [\n    &#123;\n      path: &#39;&#x2F;&#39;,\n      redirect: &#39;&#x2F;home&#39;,\n      name: &#39;Main&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;layout&#x2F;Main.vue&#39;),\n      children: [\n        &#123;\n          path: &#39;&#x2F;userCenter&#39;,\n          name: &#39;UserCenter&#39;,\n          component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;UserCenter.vue&#39;),\n          meta: &#123;\n            title: &#39;个人中心&#39;,\n          &#125;,\n        &#125;,\n        &#123;\n          path: &#39;&#x2F;home&#39;,\n          name: &#39;Home&#39;,\n          component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Home.vue&#39;)\n        &#125;,\n      ]\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;login&#39;,\n      name: &#39;Login&#39;,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;Login.vue&#39;),\n    &#125;\n  ]\n&#125;)\n\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n  let hasRoute &#x3D; store.state.menu.hasRoute;\n  if (to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n    next();\n  &#125; else if(!localStorage.getItem(&#39;jwt&#39;))&#123;\n    next(&#39;&#x2F;login&#39;);\n  &#125; else if (!hasRoute)&#123;\n    axios.get(&#39;&#x2F;hrms&#x2F;sys&#x2F;menu&#x2F;getNavMenu&#39;).then(res &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 拿到 menuList 菜单列表\n      store.commit(&#39;SET_MENU_LIST&#39;, res.data.data.menuList);\n      &#x2F;&#x2F; 拿到 permissionList 权限列表\n      store.commit(&#39;SET_PERMISSION_LIST&#39;, res.data.data.permissionList);\n  \n      &#x2F;&#x2F; 动态绑定路由\n      res.data.data.menuList.forEach(menu &#x3D;&gt; &#123;\n        if (menu.children) &#123;\n          menu.children.forEach(child &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 转成路由\n            let route &#x3D; menuToRouter(child);\n            &#x2F;&#x2F; 把路由添加到路由管理器中\n            if (route) &#123;\n              router.addRoute(&#39;Main&#39;, route);\n            &#125;\n          &#125;)\n        &#125; else &#123;\n          let route &#x3D; menuToRouter(menu);\n          if (route) &#123;\n            router.addRoute(&#39;Main&#39;, route);\n          &#125;\n        &#125;\n      &#125;);\n      hasRoute &#x3D; true;\n      store.commit(&#39;CHANGE_ROUTE_STATUS&#39;, hasRoute);\n      next(to.path);\n    &#125;)\n  &#125;else &#123;\n    next();\n  &#125;\n&#125;)\n\nconst menuToRouter &#x3D; (menu) &#x3D;&gt; &#123;\n  if(!menu.component)&#123;\n    return null;\n  &#125; else &#123;\n    return &#123;\n      path: menu.path,\n      name: menu.name,\n      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;&#39; + menu.component +&#39;.vue&#39;),\n      meta: &#123;\n        title: menu.title,\n        icon: menu.icon\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nexport default router\n\n2、在 src&#x2F;store 目录中新建 menu.js，用来存储菜单数据\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 Vuex\nimport Vuex from &#39;vuex&#39;\n&#x2F;&#x2F; 应用 Vuex 插件\nVue.use(Vuex)\n\nexport default &#123;\n  mutations: &#123;\n    SET_MENU_LIST(state, menuList) &#123;\n      state.menuList &#x3D; menuList;\n    &#125;,\n    SET_PERMISSION_LIST(state, permissionList) &#123;\n      state.permissionList &#x3D; permissionList;\n    &#125;,\n    CHANGE_ROUTE_STATUS(state, hasRoute) &#123;\n      state.hasRoute &#x3D; hasRoute;\n    &#125;,\n  &#125;,\n  state: &#123;\n    menuList: [],\n    permissionList: [],\n    hasRoute: false,\n  &#125;,\n&#125;\n\n3、在 src&#x2F;store&#x2F;index.js 文件中引入 menu.js，然后添加到 modules\nimport menu from &#39;.&#x2F;menu&#39;\n\n&#x2F;&#x2F;创建并暴露 store\nexport default new Vuex.Store(&#123;\n  actions,\n  mutations,\n  state,\n  getters,\n  modules: &#123;\n    menu,\n  &#125;,\n&#125;)\n\n4、在左侧菜单栏 NavAside.vue 中直接获取 store 中的 menuList 数据，显示菜单\n&lt;script&gt;\nexport default &#123;\n  name: &#39;NavAside&#39;,\n  computed: &#123;\n    menuList() &#123;\n      return this.$store.state.menu.menuList\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n2.5.3 导航与动态标签页绑定1、在 src&#x2F;layout 目录下新建 Tabs.vue 文件，删除标签页时，判断首页不能删除，以及点击标签页跳转到对应路由\n&lt;template&gt;\n  &lt;el-tabs\n    v-model&#x3D;&quot;editableTabsValue&quot;\n    type&#x3D;&quot;card&quot;\n    closable\n    @tab-remove&#x3D;&quot;removeTab&quot;\n    @tab-click&#x3D;&quot;clickTab&quot;\n  &gt;\n    &lt;el-tab-pane\n      v-for&#x3D;&quot;tab in editableTabs&quot;\n      :key&#x3D;&quot;tab.name&quot;\n      :label&#x3D;&quot;tab.title&quot;\n      :name&#x3D;&quot;tab.name&quot;\n    &gt;\n    &lt;&#x2F;el-tab-pane&gt;\n  &lt;&#x2F;el-tabs&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Tabs&#39;,\n  computed: &#123;\n    editableTabsValue: &#123;\n      get() &#123;\n        return this.$store.state.menu.editableTabsValue\n      &#125;,\n      set(val) &#123;\n        this.$store.state.menu.editableTabsValue &#x3D; val\n      &#125;\n    &#125;,\n    editableTabs: &#123;\n      get() &#123;\n        return this.$store.state.menu.editableTabs\n      &#125;,\n      set(val) &#123;\n        this.$store.state.menu.editableTabs &#x3D; val\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    removeTab(targetName) &#123;\n      let tabs &#x3D; this.editableTabs;\n      let activeName &#x3D; this.editableTabsValue;\n\n      if (targetName &#x3D;&#x3D;&#x3D; &#39;Home&#39;) &#123;\n        return false;\n      &#125;\n      if (activeName &#x3D;&#x3D;&#x3D; targetName) &#123;\n        tabs.forEach((tab, index) &#x3D;&gt; &#123;\n          if (tab.name &#x3D;&#x3D;&#x3D; targetName) &#123;\n            let nextTab &#x3D; tabs[index + 1] || tabs[index - 1];\n            if (nextTab) &#123;\n              activeName &#x3D; nextTab.name;\n            &#125;\n          &#125;\n        &#125;);\n      &#125;\n\n      this.editableTabsValue &#x3D; activeName;\n      this.editableTabs &#x3D; tabs.filter(tab &#x3D;&gt; tab.name !&#x3D;&#x3D; targetName);\n      this.$router.push(&#123; name: activeName &#125;)\n    &#125;,\n    clickTab(tab) &#123;\n      this.$router.push(&#123; name: tab.name &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n2、在主容器 Main.vue 中的主体部分加上标签页\n&lt;template&gt;\n  &lt;el-container&gt;\n    &lt;el-aside width&#x3D;&quot;&#123;asideWidth: &#39;200px&#39;&#125;&quot;&gt;\n      &lt;NavAside&gt;&lt;&#x2F;NavAside&gt;\n    &lt;&#x2F;el-aside&gt;\n    &lt;el-container&gt;\n      &lt;el-header&gt;\n        &lt;NavHeader&gt;&lt;&#x2F;NavHeader&gt;\n      &lt;&#x2F;el-header&gt;\n      &lt;el-main&gt;\n        &lt;Tabs &#x2F;&gt;\n        &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n      &lt;&#x2F;el-main&gt;\n    &lt;&#x2F;el-container&gt;\n  &lt;&#x2F;el-container&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport NavAside from &#39;@&#x2F;layout&#x2F;NavAside.vue&#39;\nimport NavHeader from &#39;@&#x2F;layout&#x2F;NavHeader.vue&#39;\nimport Tabs from &#39;@&#x2F;layout&#x2F;Tabs.vue&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Main&#39;,\n  components: &#123;\n    NavAside,\n    NavHeader,\n    Tabs\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3、在 src&#x2F;store&#x2F;menu.js 文件里添加点击路由添加对应标签页的方法，并激活对应标签页。只有标签页不存在，才进行添加\nexport default &#123;\n  mutations: &#123;\n    ADD_TAB(state, tab) &#123;\n      let index &#x3D; state.editableTabs.findIndex(item &#x3D;&gt; item.name &#x3D;&#x3D;&#x3D; tab.name);\n      if (index &#x3D;&#x3D;&#x3D; -1) &#123;\n        state.editableTabs.push(&#123;\n          title: tab.title,\n          name: tab.name,\n        &#125;);\n      &#125;\n      state.editableTabsValue &#x3D; tab.name;\n    &#125;,\n  &#125;,\n  state: &#123;\n    editableTabsValue: &#39;Home&#39;,\n    editableTabs: [&#123;\n      title: &#39;首页&#39;,\n      name: &#39;Home&#39;,\n    &#125;],\n  &#125;,\n&#125;\n\n4、在左侧菜单栏 NavAside.vue 文件中，给菜单项加上点击事件，调用上面的添加标签页方法\n&lt;template&gt;\n\t&lt;router-link\n\t  v-else\n\t  :to&#x3D;&quot;menu.path&quot;\n\t  :key&#x3D;&quot;menu.name&quot;\n\t&gt;\n\t  &lt;el-menu-item\n\t\t:index&#x3D;&quot;menu.name&quot;\n\t\t@click&#x3D;&quot;addTab(menu)&quot;\n\t  &gt;\n          &lt;i :class&#x3D;&quot;&#39;el-icon-&#39; + menu.icon&quot;&gt;&lt;&#x2F;i&gt;\n          &lt;span slot&#x3D;&quot;title&quot;&gt; &#123;&#123; menu.title &#125;&#125; &lt;&#x2F;span&gt;\n\t  &lt;&#x2F;el-menu-item&gt;\n\t&lt;&#x2F;router-link&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;NavAside&#39;,\n  methods: &#123;\n    addTab(menu) &#123;\n      this.$store.commit(&#39;ADD_TAB&#39;, menu)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n5、在 App.vue 中监视刷新浏览器后回显之前激活的标签页\n&lt;template&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  watch: &#123;\n    $route(to) &#123;\n      if (to.path !&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;\n        let obj &#x3D; &#123;\n          name: to.name,\n          title: to.meta.title,\n        &#125;\n        this.$store.commit(&#39;ADD_TAB&#39;, obj)\n      &#125;\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n2.6 菜单管理\n1、新建菜单组件 Menu.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div\n      class&#x3D;&quot;mainHeader&quot;\n      style&#x3D;&quot;height: 630px;&quot;\n    &gt;\n      &lt;el-row\n        type&#x3D;&quot;flex&quot;\n        justify&#x3D;&quot;space-between&quot;\n        class&#x3D;&quot;mainMessage&quot;\n      &gt;\n        &lt;el-col class&#x3D;&quot;mainMessageLeft&quot;&gt;\n          &lt;div&gt;&lt;b&gt;菜单管理&lt;&#x2F;b&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;el-col&gt;\n        &lt;el-col\n          :span&#x3D;&quot;4&quot;\n          class&#x3D;&quot;mainMessageRight&quot;\n          style&#x3D;&quot;margin-right: 7px;&quot;\n        &gt;\n          &lt;div&gt;\n            &lt;el-button\n              type&#x3D;&quot;primary&quot;\n              size&#x3D;&quot;small&quot;\n              @click&#x3D;&quot;$bus.$emit(&#39;menuAdd&#39;, menuList)&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;sys:menu:add&#39;)&quot;\n            &gt;新增&lt;&#x2F;el-button&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;el-col&gt;\n      &lt;&#x2F;el-row&gt;\n      &lt;!--列表--&gt;\n      &lt;el-table\n        :data&#x3D;&quot;menuList&quot;\n        id&#x3D;&quot;out-table&quot;\n        class&#x3D;&quot;mainTable&quot;\n        :header-cell-style&#x3D;&quot;&#123;background:&#39;#ddd&#39;&#125;&quot;\n        max-height&#x3D;&quot;520&quot;\n        border\n        :fit&#x3D;&quot;true&quot;\n        row-key&#x3D;&quot;menuId&quot;\n        :tree-props&#x3D;&quot;&#123;children: &#39;children&#39;, hasChildren: &#39;hasChildren&#39;&#125;&quot;\n      &gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;menuName&quot;\n          label&#x3D;&quot;名称&quot;\n          align&#x3D;&quot;center&quot;\n          width&#x3D;&quot;150&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;permission&quot;\n          label&#x3D;&quot;权限编码&quot;\n          align&#x3D;&quot;center&quot;\n          width&#x3D;&quot;120&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;icon&quot;\n          label&#x3D;&quot;图标&quot;\n          align&#x3D;&quot;center&quot;\n          width&#x3D;&quot;180&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;type&quot;\n          label&#x3D;&quot;类型&quot;\n          align&#x3D;&quot;center&quot;\n        &gt;\n          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n            &lt;el-tag\n              v-if&#x3D;&quot;scope.row.type &#x3D;&#x3D;&#x3D; 0&quot;\n              size&#x3D;&quot;small&quot;\n            &gt;目录&lt;&#x2F;el-tag&gt;\n            &lt;el-tag\n              v-else-if&#x3D;&quot;scope.row.type &#x3D;&#x3D;&#x3D; 1&quot;\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;success&quot;\n            &gt;菜单&lt;&#x2F;el-tag&gt;\n            &lt;el-tag\n              v-else-if&#x3D;&quot;scope.row.type &#x3D;&#x3D;&#x3D; 2&quot;\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;info&quot;\n            &gt;按钮&lt;&#x2F;el-tag&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;path&quot;\n          label&#x3D;&quot;菜单URL&quot;\n          align&#x3D;&quot;center&quot;\n          width&#x3D;&quot;120&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;component&quot;\n          label&#x3D;&quot;菜单组件&quot;\n          align&#x3D;&quot;center&quot;\n          width&#x3D;&quot;200&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;orderNum&quot;\n          label&#x3D;&quot;排序号&quot;\n          align&#x3D;&quot;center&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;valiFlag&quot;\n          label&#x3D;&quot;状态&quot;\n          align&#x3D;&quot;center&quot;\n        &gt;\n          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n            &lt;el-tag\n              v-if&#x3D;&quot;scope.row.valiFlag &#x3D;&#x3D;&#x3D; 0&quot;\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;danger&quot;\n            &gt;禁用&lt;&#x2F;el-tag&gt;\n            &lt;el-tag\n              v-else-if&#x3D;&quot;scope.row.valiFlag &#x3D;&#x3D;&#x3D; 1&quot;\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;success&quot;\n            &gt;正常&lt;&#x2F;el-tag&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          label&#x3D;&quot;操作&quot;\n          align&#x3D;&quot;center&quot;\n          width&#x3D;&quot;200&quot;\n          fixed&#x3D;&quot;right&quot;\n        &gt;\n          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n            &lt;el-button\n              type&#x3D;&quot;primary&quot;\n              size&#x3D;&quot;small&quot;\n              @click&#x3D;&quot;$bus.$emit(&#39;menuEdit&#39;, menuList, scope.row)&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;sys:menu:update&#39;)&quot;\n            &gt;编辑&lt;&#x2F;el-button&gt;\n            &lt;el-button\n              type&#x3D;&quot;danger&quot;\n              size&#x3D;&quot;small&quot;\n              slot&#x3D;&quot;reference&quot;\n              @click&#x3D;&quot;menuDel(scope.row.menuId)&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;sys:menu:delete&#39;)&quot;\n            &gt;删除&lt;&#x2F;el-button&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n      &lt;&#x2F;el-table&gt;\n      &lt;MenuAdd &#x2F;&gt;\n      &lt;MenuEdit &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport MenuAdd from &#39;.&#x2F;MenuAdd&#39;\nimport MenuEdit from &#39;.&#x2F;MenuEdit&#39;\nimport &#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;css&#x2F;mainStyle.css&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Menu&#39;,\n  data() &#123;\n    return &#123;\n      menuList: [],\n      dialogFormVisible: false,\n    &#125;\n  &#125;,\n  methods: &#123;\n    getMenuTree() &#123;\n      this.$axios.get(&#39;&#x2F;hrms&#x2F;sys&#x2F;menu&#x2F;getMenuList?valiFlag&#x3D;&#39;).then(res &#x3D;&gt; &#123;\n        this.menuList &#x3D; res.data.data;\n      &#125;)\n    &#125;,\n    menuDel(menuId) &#123;\n      this.$confirm(&#39;确定删除吗&#39;, &#39;提示&#39;, &#123;\n        confirmButtonText: &#39;确定&#39;,\n        cancelButtonText: &#39;取消&#39;,\n        type: &#39;warning&#39;\n      &#125;).then(() &#x3D;&gt; &#123;\n        this.$axios.delete(&quot;&#x2F;hrms&#x2F;sys&#x2F;menu&#x2F;deleteMenu&#x2F;&quot; + menuId).then(() &#x3D;&gt; &#123;\n          this.$message.success(&quot;删除成功&quot;)\n          this.getMenuTree()\n        &#125;)\n      &#125;).catch(() &#x3D;&gt; &#123;\n        this.$message.success(&#39;已取消删除&#39;);\n      &#125;)\n    &#125;,\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;refreshMenuList&#39;, () &#x3D;&gt; &#123;\n      this.getMenuTree();\n    &#125;);\n  &#125;,\n  created() &#123;\n    this.getMenuTree();\n  &#125;,\n  components: &#123;\n    MenuAdd,\n    MenuEdit,\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n2、新增菜单对话框 MenuAdd.vue\n&lt;template&gt;\n  &lt;el-dialog\n    title&#x3D;&quot;菜单信息&quot;\n    :visible.sync&#x3D;&quot;dialogFormVisible&quot;\n    :close-on-click-modal&#x3D;&quot;false&quot;\n    class&#x3D;&quot;el-dialog-menu&quot;\n  &gt;\n    &lt;el-form\n      :model&#x3D;&quot;addForm&quot;\n      :rules&#x3D;&quot;addFormRules&quot;\n      ref&#x3D;&quot;addForm&quot;\n    &gt;\n      &lt;el-form-item\n        label&#x3D;&quot;上级菜单&quot;\n        prop&#x3D;&quot;parentId&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;!--模拟树形下拉框--&gt;\n        &lt;el-select\n          v-model&#x3D;&quot;addForm.parentId&quot;\n          placeholder&#x3D;&quot;请选择上级菜单&quot;\n        &gt;\n          &lt;template v-for&#x3D;&quot;item in menuList&quot;&gt;\n            &lt;el-option\n              :key&#x3D;&quot;item.menuId&quot;\n              :label&#x3D;&quot;item.menuName&quot;\n              :value&#x3D;&quot;item.menuId&quot;\n            &gt;&lt;&#x2F;el-option&gt;\n            &lt;template v-for&#x3D;&quot;child in item.children&quot;&gt;\n              &lt;el-option\n                :key&#x3D;&quot;child.menuId&quot;\n                :label&#x3D;&quot;child.menuName&quot;\n                :value&#x3D;&quot;child.menuId&quot;\n              &gt;\n                &lt;span&gt;&#123;&#123; &#39;- &#39; + child.menuName &#125;&#125;&lt;&#x2F;span&gt;\n              &lt;&#x2F;el-option&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-select&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;菜单名称&quot;\n        prop&#x3D;&quot;menuName&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.menuName&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;权限编码&quot;\n        prop&#x3D;&quot;permission&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.permission&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;图标&quot;\n        prop&#x3D;&quot;icon&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.icon&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;菜单URL&quot;\n        prop&#x3D;&quot;path&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.path&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;菜单组件&quot;\n        prop&#x3D;&quot;component&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.component&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;类型&quot;\n        prop&#x3D;&quot;type&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-radio-group v-model&#x3D;&quot;addForm.type&quot;&gt;\n          &lt;el-radio :label&#x3D;0&gt;目录&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;1&gt;菜单&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;2&gt;按钮&lt;&#x2F;el-radio&gt;\n        &lt;&#x2F;el-radio-group&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;状态&quot;\n        prop&#x3D;&quot;valiFlag&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-radio-group v-model&#x3D;&quot;addForm.valiFlag&quot;&gt;\n          &lt;el-radio :label&#x3D;0&gt;禁用&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;1&gt;正常&lt;&#x2F;el-radio&gt;\n        &lt;&#x2F;el-radio-group&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;排序号&quot;\n        prop&#x3D;&quot;orderNum&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input-number\n          v-model&#x3D;&quot;addForm.orderNum&quot;\n          :min&#x3D;&quot;1&quot;\n          label&#x3D;&quot;排序号&quot;\n        &gt;1&lt;&#x2F;el-input-number&gt;\n      &lt;&#x2F;el-form-item&gt;\n    &lt;&#x2F;el-form&gt;\n    &lt;div\n      slot&#x3D;&quot;footer&quot;\n      class&#x3D;&quot;dialog-footer&quot;\n    &gt;\n      &lt;el-button @click&#x3D;&quot;resetForm(&#39;addForm&#39;)&quot;&gt;取 消&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;submitAddForm(&#39;addForm&#39;)&quot;\n      &gt;确 定&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MenuAdd&#39;,\n  data() &#123;\n    return &#123;\n      dialogFormVisible: false,\n      menuList: [],\n      addForm: &#123;&#125;,\n      addFormRules: &#123;\n        menuName: [\n          &#123; required: true, message: &#39;请输入名称&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        permission: [\n          &#123; required: true, message: &#39;请输入权限编码&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        type: [\n          &#123; required: true, message: &#39;请选择状态&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        orderNum: [\n          &#123; required: true, message: &#39;请填入排序号&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        valiFlag: [\n          &#123; required: true, message: &#39;请选择状态&#39;, trigger: &#39;blur&#39; &#125;\n        ]\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    submitAddForm(formName) &#123;\n      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          this.$axios.post(&#39;&#x2F;hrms&#x2F;sys&#x2F;menu&#x2F;addMenu&#39;, this.addForm).then(() &#x3D;&gt; &#123;\n            this.resetForm(formName)\n            this.$message.success(&#39;添加成功&#39;)\n            this.$bus.$emit(&#39;refreshMenuList&#39;)\n          &#125;)\n        &#125; else &#123;\n          console.log(&#39;error submit!!&#39;);\n          return false;\n        &#125;\n      &#125;);\n    &#125;,\n    resetForm(formName) &#123;\n      this.$refs[formName].resetFields();\n      this.addForm &#x3D; &#123;&#125;\n      this.dialogFormVisible &#x3D; false\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;menuAdd&#39;, (menuList) &#x3D;&gt; &#123;\n      this.dialogFormVisible &#x3D; true\n      this.menuList &#x3D; menuList\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.el-dialog-menu &#123;\n  width: 100%;\n  margin-top: -90px;\n  overflow: hidden;\n&#125;\n&lt;&#x2F;style&gt;\n\n3、编辑菜单对话框 MenuEdit.vue\n&lt;template&gt;\n  &lt;el-dialog\n    title&#x3D;&quot;菜单信息&quot;\n    :visible.sync&#x3D;&quot;dialogFormVisible&quot;\n    :close-on-click-modal&#x3D;&quot;false&quot;\n    class&#x3D;&quot;el-dialog-menu&quot;\n  &gt;\n    &lt;el-form\n      :model&#x3D;&quot;editForm&quot;\n      :rules&#x3D;&quot;editFormRules&quot;\n      ref&#x3D;&quot;editForm&quot;\n    &gt;\n      &lt;el-form-item\n        label&#x3D;&quot;上级菜单&quot;\n        prop&#x3D;&quot;parentId&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;!--模拟树形下拉框--&gt;\n        &lt;el-select\n          v-model&#x3D;&quot;editForm.parentId&quot;\n          placeholder&#x3D;&quot;请选择上级菜单&quot;\n        &gt;\n          &lt;template v-for&#x3D;&quot;item in menuList&quot;&gt;\n            &lt;el-option\n              :key&#x3D;&quot;item.menuId&quot;\n              :label&#x3D;&quot;item.menuName&quot;\n              :value&#x3D;&quot;item.menuId&quot;\n            &gt;&lt;&#x2F;el-option&gt;\n            &lt;template v-for&#x3D;&quot;child in item.children&quot;&gt;\n              &lt;el-option\n                :key&#x3D;&quot;child.menuId&quot;\n                :label&#x3D;&quot;child.menuName&quot;\n                :value&#x3D;&quot;child.menuId&quot;\n              &gt;\n                &lt;span&gt;&#123;&#123; &#39;- &#39; + child.menuName &#125;&#125;&lt;&#x2F;span&gt;\n              &lt;&#x2F;el-option&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-select&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;菜单名称&quot;\n        prop&#x3D;&quot;menuName&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.menuName&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;权限编码&quot;\n        prop&#x3D;&quot;permission&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.permission&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;图标&quot;\n        prop&#x3D;&quot;icon&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.icon&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;菜单URL&quot;\n        prop&#x3D;&quot;path&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.path&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;菜单组件&quot;\n        prop&#x3D;&quot;component&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.component&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;类型&quot;\n        prop&#x3D;&quot;type&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-radio-group v-model&#x3D;&quot;editForm.type&quot;&gt;\n          &lt;el-radio :label&#x3D;0&gt;目录&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;1&gt;菜单&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;2&gt;按钮&lt;&#x2F;el-radio&gt;\n        &lt;&#x2F;el-radio-group&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;状态&quot;\n        prop&#x3D;&quot;valiFlag&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-radio-group v-model&#x3D;&quot;editForm.valiFlag&quot;&gt;\n          &lt;el-radio :label&#x3D;0&gt;禁用&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;1&gt;正常&lt;&#x2F;el-radio&gt;\n        &lt;&#x2F;el-radio-group&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;排序号&quot;\n        prop&#x3D;&quot;orderNum&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input-number\n          v-model&#x3D;&quot;editForm.orderNum&quot;\n          :min&#x3D;&quot;1&quot;\n          label&#x3D;&quot;排序号&quot;\n        &gt;1&lt;&#x2F;el-input-number&gt;\n      &lt;&#x2F;el-form-item&gt;\n    &lt;&#x2F;el-form&gt;\n    &lt;div\n      slot&#x3D;&quot;footer&quot;\n      class&#x3D;&quot;dialog-footer&quot;\n    &gt;\n      &lt;el-button @click&#x3D;&quot;resetForm(&#39;editForm&#39;)&quot;&gt;取 消&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;submitEditForm(&#39;editForm&#39;)&quot;\n      &gt;确 定&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MenuEdit&#39;,\n  data() &#123;\n    return &#123;\n      dialogFormVisible: false,\n      menuList: [],\n      editForm: &#123;&#125;,\n      editFormRules: &#123;\n        menuName: [\n          &#123; required: true, message: &#39;请输入名称&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        permission: [\n          &#123; required: true, message: &#39;请输入权限编码&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        type: [\n          &#123; required: true, message: &#39;请选择状态&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        orderNum: [\n          &#123; required: true, message: &#39;请填入排序号&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        valiFlag: [\n          &#123; required: true, message: &#39;请选择状态&#39;, trigger: &#39;blur&#39; &#125;\n        ]\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    submitEditForm(formName) &#123;\n      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          this.$axios.put(&#39;&#x2F;hrms&#x2F;sys&#x2F;menu&#x2F;updateMenu&#39;, this.editForm).then(() &#x3D;&gt; &#123;\n            this.dialogFormVisible &#x3D; false;\n            this.$message.success(&#39;修改成功&#39;);\n            this.$bus.$emit(&#39;refreshMenuList&#39;)\n          &#125;)\n        &#125; else &#123;\n          console.log(&#39;error submit!!&#39;);\n          return false;\n        &#125;\n      &#125;)\n    &#125;,\n    resetForm(formName) &#123;\n      this.$refs[formName].resetFields();\n      this.$bus.$emit(&#39;refreshMenuList&#39;)\n      this.dialogFormVisible &#x3D; false\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;menuEdit&#39;, (menuList, menu) &#x3D;&gt; &#123;\n      this.dialogFormVisible &#x3D; true\n      this.menuList &#x3D; menuList\n      this.editForm &#x3D; menu\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.el-dialog-menu &#123;\n  width: 100%;\n  margin-top: -90px;\n  overflow: hidden;\n&#125;\n&lt;&#x2F;style&gt;\n\n2.7 角色管理1、新建角色组件 Role.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div class&#x3D;&quot;mainHeader&quot;&gt;\n      &lt;el-form\n        :inline&#x3D;&quot;true&quot;\n        class&#x3D;&quot;demo-form-inline&quot;\n        size&#x3D;&quot;small&quot;\n        :model&#x3D;&quot;searchForm&quot;\n        ref&#x3D;&quot;searchForm&quot;\n        @submit.native.prevent&#x3D;&quot;getRoleList&quot;\n      &gt;\n        &lt;el-form-item\n          label&#x3D;&quot;角色名称&quot;\n          prop&#x3D;&quot;roleName&quot;\n        &gt;\n          &lt;el-input\n            v-model&#x3D;&quot;searchForm.roleName&quot;\n            placeholder&#x3D;&quot;请输入角色名称&quot;\n            clearable\n          &gt;\n          &lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-button\n            size&#x3D;&quot;small&quot;\n            type&#x3D;&quot;primary&quot;\n            icon&#x3D;&quot;el-icon-search&quot;\n            @click&#x3D;&quot;getRoleList()&quot;\n          &gt;查询&lt;&#x2F;el-button&gt;\n          &lt;el-button\n            @click&#x3D;&quot;() &#x3D;&gt; this.$refs[&#39;searchForm&#39;].resetFields()&quot;\n            icon&#x3D;&quot;el-icon-refresh-right&quot;\n          &gt;重置&lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-form-item&gt;\n      &lt;&#x2F;el-form&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;div class&#x3D;&quot;mainBody&quot;&gt;\n      &lt;el-row\n        type&#x3D;&quot;flex&quot;\n        justify&#x3D;&quot;space-between&quot;\n        class&#x3D;&quot;mainMessage&quot;\n      &gt;\n        &lt;el-col class&#x3D;&quot;mainMessageLeft&quot;&gt;\n          &lt;div&gt;&lt;b&gt;查询结果&lt;&#x2F;b&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;el-col&gt;\n        &lt;el-col\n          :span&#x3D;&quot;4&quot;\n          class&#x3D;&quot;mainMessageRight&quot;\n        &gt;\n          &lt;div&gt;\n            &lt;el-button\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;primary&quot;\n              @click&#x3D;&quot;roleAdd&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;sys:role:add&#39;)&quot;\n            &gt;\n              新增\n            &lt;&#x2F;el-button&gt;\n            &lt;el-button\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;danger&quot;\n              :disabled&#x3D;&quot;delBatchBtn&quot;\n              @click&#x3D;&quot;delRole(null)&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;sys:role:delete&#39;)&quot;\n            &gt;删除选中&lt;&#x2F;el-button&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;el-col&gt;\n      &lt;&#x2F;el-row&gt;\n      &lt;RoleAdd &#x2F;&gt;\n\n      &lt;template&gt;\n        &lt;el-table\n          ref&#x3D;&quot;multipleTable&quot;\n          class&#x3D;&quot;mainTable&quot;\n          border\n          :fit&#x3D;&quot;true&quot;\n          :data&#x3D;&quot;roleList&quot;\n          max-height&#x3D;&quot;420&quot;\n          :header-cell-style&#x3D;&quot;&#123;background:&#39;#ddd&#39;&#125;&quot;\n          @selection-change&#x3D;&quot;handleSelectionChange&quot;\n          :default-sort&#x3D;&quot;&#123;prop: &#39;roleName&#39;, order: &#39;ascending&#39;&#125;&quot;\n        &gt;\n          &lt;el-table-column type&#x3D;&quot;selection&quot;&gt;\n          &lt;&#x2F;el-table-column&gt;\n          &lt;el-table-column\n            prop&#x3D;&quot;roleName&quot;\n            align&#x3D;&quot;center&quot;\n            sortable\n            label&#x3D;&quot;名称&quot;\n          &gt;\n          &lt;&#x2F;el-table-column&gt;\n          &lt;el-table-column\n            prop&#x3D;&quot;code&quot;\n            align&#x3D;&quot;center&quot;\n            label&#x3D;&quot;唯一编码&quot;\n            width&#x3D;&quot;120&quot;\n          &gt;\n          &lt;&#x2F;el-table-column&gt;\n          &lt;el-table-column\n            prop&#x3D;&quot;remark&quot;\n            align&#x3D;&quot;center&quot;\n            label&#x3D;&quot;描述&quot;\n            width&#x3D;&quot;500&quot;\n          &gt;\n          &lt;&#x2F;el-table-column&gt;\n          &lt;el-table-column\n            prop&#x3D;&quot;valiFlag&quot;\n            label&#x3D;&quot;状态&quot;\n            align&#x3D;&quot;center&quot;\n          &gt;\n            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n              &lt;el-tag\n                v-if&#x3D;&quot;scope.row.valiFlag &#x3D;&#x3D;&#x3D; 0&quot;\n                size&#x3D;&quot;small&quot;\n                type&#x3D;&quot;danger&quot;\n              &gt;禁用&lt;&#x2F;el-tag&gt;\n              &lt;el-tag\n                v-else-if&#x3D;&quot;scope.row.valiFlag &#x3D;&#x3D;&#x3D; 1&quot;\n                size&#x3D;&quot;small&quot;\n                type&#x3D;&quot;success&quot;\n              &gt;正常&lt;&#x2F;el-tag&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;el-table-column&gt;\n          &lt;el-table-column\n            label&#x3D;&quot;操作&quot;\n            align&#x3D;&quot;center&quot;\n            width&#x3D;&quot;320&quot;\n          &gt;\n            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n              &lt;el-button\n                size&#x3D;&quot;small&quot;\n                type&#x3D;&quot;primary&quot;\n                @click&#x3D;&quot;rolePermission(scope.row)&quot;\n                v-if&#x3D;&quot;hasAuth(&#39;sys:role:permission&#39;)&quot;\n              &gt;分配权限&lt;&#x2F;el-button&gt;\n              &lt;el-button\n                size&#x3D;&quot;small&quot;\n                type&#x3D;&quot;success&quot;\n                @click&#x3D;&quot;roleEdit(scope.row)&quot;\n                v-if&#x3D;&quot;hasAuth(&#39;sys:role:update&#39;)&quot;\n              &gt;编辑&lt;&#x2F;el-button&gt;\n              &lt;el-button\n                size&#x3D;&quot;small&quot;\n                type&#x3D;&quot;danger&quot;\n                @click&#x3D;&quot;delRole(scope.row.roleId)&quot;\n                v-if&#x3D;&quot;hasAuth(&#39;sys:role:delete&#39;)&quot;\n              &gt;删除&lt;&#x2F;el-button&gt;\n            &lt;&#x2F;template&gt;\n          &lt;&#x2F;el-table-column&gt;\n        &lt;&#x2F;el-table&gt;\n        &lt;RolePermission &#x2F;&gt;\n        &lt;RoleEdit &#x2F;&gt;\n      &lt;&#x2F;template&gt;\n\n      &lt;el-pagination\n        class&#x3D;&quot;mainPagination&quot;\n        @size-change&#x3D;&quot;handleSizeChange&quot;\n        @current-change&#x3D;&quot;handleCurrentChange&quot;\n        :current-page&#x3D;&quot;current&quot;\n        :page-sizes&#x3D;&quot;[10, 20, 50, 100]&quot;\n        :page-size&#x3D;&quot;size&quot;\n        layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;\n        :total&#x3D;&quot;total&quot;\n      &gt;\n      &lt;&#x2F;el-pagination&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport &#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;css&#x2F;mainStyle.css&#39;;\nimport RoleAdd from &#39;.&#x2F;RoleAdd.vue&#39;;\nimport RolePermission from &#39;.&#x2F;RolePermission.vue&#39;;\nimport RoleEdit from &#39;.&#x2F;RoleEdit.vue&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &quot;Role&quot;,\n  data() &#123;\n    return &#123;\n      searchForm: &#123;\n        roleName: &#39;&#39;\n      &#125;,\n      roleList: [],\n      multipleSelection: [],\n      delBatchBtn: true,\n      current: 1,\n      size: 10,\n      total: 0,\n    &#125;\n  &#125;,\n  methods: &#123;\n    roleAdd() &#123;\n      this.$bus.$emit(&#39;roleAdd&#39;)\n    &#125;,\n    rolePermission(row) &#123;\n      this.$bus.$emit(&#39;RolePermission&#39;, row)\n    &#125;,\n    roleEdit(row) &#123;\n      this.$bus.$emit(&#39;RoleEdit&#39;, row)\n    &#125;,\n    handleSelectionChange(val) &#123;\n      this.multipleSelection &#x3D; val;\n      this.delBatchBtn &#x3D; val.length &#x3D;&#x3D; 0\n    &#125;,\n    getRoleList() &#123;\n      this.$axios.get(&#39;&#x2F;hrms&#x2F;sys&#x2F;role&#x2F;getRoleList&#39;, &#123;\n        params: &#123;\n          roleName: this.searchForm.roleName,\n          valiFlag: &#39;&#39;,\n          current: this.current,\n          size: this.size\n        &#125;\n      &#125;).then(res &#x3D;&gt; &#123;\n        this.roleList &#x3D; res.data.data.records;\n        this.current &#x3D; res.data.data.current;\n        this.size &#x3D; res.data.data.size;\n        this.total &#x3D; res.data.data.total;\n      &#125;);\n    &#125;,\n    handleSizeChange(val) &#123;\n      this.size &#x3D; val\n      this.getRoleList()\n    &#125;,\n    handleCurrentChange(val) &#123;\n      this.current &#x3D; val\n      this.getRoleList()\n    &#125;,\n    delRole(roleId) &#123;\n      this.$confirm(&#39;是否确定删除?&#39;, &#39;提示&#39;, &#123;\n        confirmButtonText: &#39;确定&#39;,\n        cancelButtonText: &#39;取消&#39;,\n        type: &#39;warning&#39;\n      &#125;).then(() &#x3D;&gt; &#123;\n        var roleIds &#x3D; []\n        roleId ? roleIds.push(roleId) : this.multipleSelection.forEach(row &#x3D;&gt; &#123;\n          roleIds.push(row.roleId)\n        &#125;)\n        this.$axios.delete(&quot;&#x2F;hrms&#x2F;sys&#x2F;role&#x2F;deleteRole&quot;, &#123;\n          data: &#123;\n            roleIds: roleIds\n          &#125;\n        &#125;).then(() &#x3D;&gt; &#123;\n          this.$message.success(&#39;删除角色成功&#39;)\n          this.getRoleList()\n        &#125;)\n      &#125;).catch(() &#x3D;&gt; &#123;\n        this.$message(&#123;\n          type: &#39;success&#39;,\n          message: &#39;已取消删除&#39;\n        &#125;);\n      &#125;);\n    &#125;,\n  &#125;,\n  created() &#123;\n    this.getRoleList()\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;refreshRoleList&#39;, () &#x3D;&gt; &#123;\n      this.getRoleList()\n    &#125;)\n  &#125;,\n  components: &#123;\n    RoleAdd,\n    RolePermission,\n    RoleEdit\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n2、新增角色对话框 RoleAdd.vue\n&lt;template&gt;\n  &lt;el-dialog\n    title&#x3D;&quot;角色信息&quot;\n    :visible.sync&#x3D;&quot;dialogFormVisible&quot;\n    width&#x3D;&quot;600px&quot;\n    @close&#x3D;&quot;resetForm(&#39;addForm&#39;)&quot;\n    :close-on-click-modal&#x3D;&quot;false&quot;\n  &gt;\n    &lt;el-form\n      :model&#x3D;&quot;addForm&quot;\n      :rules&#x3D;&quot;addFormRules&quot;\n      ref&#x3D;&quot;addForm&quot;\n    &gt;\n      &lt;el-form-item\n        label&#x3D;&quot;角色名称&quot;\n        prop&#x3D;&quot;roleName&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.roleName&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;唯一编码&quot;\n        prop&#x3D;&quot;code&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.code&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;描述&quot;\n        prop&#x3D;&quot;remark&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;addForm.remark&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;状态&quot;\n        prop&#x3D;&quot;valiFlag&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-radio-group v-model&#x3D;&quot;addForm.valiFlag&quot;&gt;\n          &lt;el-radio :label&#x3D;&quot;0&quot;&gt;禁用&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;&quot;1&quot;&gt;正常&lt;&#x2F;el-radio&gt;\n        &lt;&#x2F;el-radio-group&gt;\n      &lt;&#x2F;el-form-item&gt;\n    &lt;&#x2F;el-form&gt;\n    &lt;div\n      slot&#x3D;&quot;footer&quot;\n      class&#x3D;&quot;dialog-footer&quot;\n    &gt;\n      &lt;el-button @click&#x3D;&quot;dialogFormVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;submitAddForm(&#39;addForm&#39;)&quot;\n      &gt;确 定&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;RoleAdd&#39;,\n  data() &#123;\n    return &#123;\n      dialogFormVisible: false,\n      addForm: &#123;&#125;,\n      addFormRules: &#123;\n        roleName: [\n          &#123; required: true, message: &#39;请输入名称&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        code: [\n          &#123; required: true, message: &#39;请输入唯一编码&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        valiFlag: [\n          &#123; required: true, message: &#39;请选择状态&#39;, trigger: &#39;blur&#39; &#125;\n        ]\n      &#125;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    submitAddForm(formName) &#123;\n      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          this.$axios.post(&#39;&#x2F;hrms&#x2F;sys&#x2F;role&#x2F;addRole&#39;, this.addForm).then(() &#x3D;&gt; &#123;\n            this.$message.success(&#39;添加角色成功&#39;)\n            this.dialogFormVisible &#x3D; false;\n            this.$bus.$emit(&#39;refreshRoleList&#39;)\n          &#125;)\n        &#125; else &#123;\n          console.log(&#39;error submit!!&#39;);\n          return false;\n        &#125;\n      &#125;);\n    &#125;,\n    resetForm(formName) &#123;\n      this.$refs[formName].resetFields();\n    &#125;,\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;roleAdd&#39;, () &#x3D;&gt; &#123;\n      this.dialogFormVisible &#x3D; true\n    &#125;)\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3、编辑角色对话框 RoleEdit.vue\n&lt;template&gt;\n  &lt;el-dialog\n    title&#x3D;&quot;角色信息&quot;\n    :visible.sync&#x3D;&quot;dialogFormVisible&quot;\n    width&#x3D;&quot;600px&quot;\n    @close&#x3D;&quot;resetForm&quot;\n    :close-on-click-modal&#x3D;&quot;false&quot;\n  &gt;\n    &lt;el-form\n      :model&#x3D;&quot;editForm&quot;\n      :rules&#x3D;&quot;editFormRules&quot;\n      ref&#x3D;&quot;editForm&quot;\n    &gt;\n      &lt;el-form-item\n        label&#x3D;&quot;角色名称&quot;\n        prop&#x3D;&quot;roleName&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.roleName&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;唯一编码&quot;\n        prop&#x3D;&quot;code&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.code&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;描述&quot;\n        prop&#x3D;&quot;remark&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.remark&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;状态&quot;\n        prop&#x3D;&quot;valiFlag&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-radio-group v-model&#x3D;&quot;editForm.valiFlag&quot;&gt;\n          &lt;el-radio :label&#x3D;&quot;0&quot;&gt;禁用&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;&quot;1&quot;&gt;正常&lt;&#x2F;el-radio&gt;\n        &lt;&#x2F;el-radio-group&gt;\n      &lt;&#x2F;el-form-item&gt;\n    &lt;&#x2F;el-form&gt;\n    &lt;div\n      slot&#x3D;&quot;footer&quot;\n      class&#x3D;&quot;dialog-footer&quot;\n    &gt;\n      &lt;el-button @click&#x3D;&quot;dialogFormVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;updateRole(&#39;editForm&#39;)&quot;\n      &gt;确 定&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;RoleEdit&#39;,\n  data() &#123;\n    return &#123;\n      dialogFormVisible: false,\n      editForm: &#123;&#125;,\n      editFormRules: &#123;\n        roleName: [\n          &#123; required: true, message: &#39;请输入名称&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        code: [\n          &#123; required: true, message: &#39;请输入唯一编码&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        valiFlag: [\n          &#123; required: true, message: &#39;请选择状态&#39;, trigger: &#39;blur&#39; &#125;\n        ]\n      &#125;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    updateRole(formName) &#123;\n      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          this.$axios.put(&#39;&#x2F;hrms&#x2F;sys&#x2F;role&#x2F;updateRole&#39;, this.editForm).then(() &#x3D;&gt; &#123;\n            this.$message.success(&#39;修改角色成功&#39;)\n            this.dialogFormVisible &#x3D; false;\n          &#125;)\n        &#125; else &#123;\n          console.log(&#39;error submit!!&#39;);\n          return false;\n        &#125;\n      &#125;);\n    &#125;,\n    resetForm() &#123;\n      this.editForm &#x3D; &#123;&#125;;\n      this.$bus.$emit(&#39;refreshRoleList&#39;)\n    &#125;,\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;RoleEdit&#39;, row &#x3D;&gt; &#123;\n      this.dialogFormVisible &#x3D; true\n      this.editForm &#x3D; row\n    &#125;)\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n4、分配权限对话框 RolePermission.vue\n&lt;template&gt;\n  &lt;el-dialog\n    title&#x3D;&quot;分配权限&quot;\n    class&#x3D;&quot;el-dialog-role&quot;\n    :visible.sync&#x3D;&quot;dialogFormVisible&quot;\n    width&#x3D;&quot;600px&quot;\n    :close-on-click-modal&#x3D;&quot;false&quot;\n    @closed&#x3D;&quot;resetForm(&#39;permissionForm&#39;)&quot;\n  &gt;\n    &lt;el-form\n      :model&#x3D;&quot;permissionForm&quot;\n      ref&#x3D;&quot;permissionForm&quot;\n    &gt;\n      &lt;el-tree\n        :data&#x3D;&quot;permissionTree&quot;\n        show-checkbox\n        ref&#x3D;&quot;permissionTree&quot;\n        :check-strictly&#x3D;&quot;checkStrictly&quot;\n        node-key&#x3D;&quot;menuId&quot;\n        :default-expand-all&#x3D;true\n        :props&#x3D;&quot;defaultProps&quot;\n      &gt;\n      &lt;&#x2F;el-tree&gt;\n    &lt;&#x2F;el-form&gt;\n    &lt;div\n      slot&#x3D;&quot;footer&quot;\n      class&#x3D;&quot;dialog-footer&quot;\n    &gt;\n      &lt;el-button @click&#x3D;&quot;dialogFormVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;rolePermission&quot;\n      &gt;确 定&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;RolePermission&#39;,\n  data() &#123;\n    return &#123;\n      dialogFormVisible: false,\n      permissionTree: [],\n      permissionForm: &#123;&#125;,\n      defaultProps: &#123;\n        children: &#39;children&#39;,\n        label: &#39;menuName&#39;,\n      &#125;,\n      checkStrictly: true,\n    &#125;\n  &#125;,\n  methods: &#123;\n    rolePermission() &#123;\n      var menuIds &#x3D; this.$refs.permissionTree.getCheckedKeys();\n      &#x2F;&#x2F; menuIds &#x3D; menuIds.concat(this.$refs.permTree.getHalfCheckedKeys()) &#x2F;&#x2F; 半选中状态的父节点\n      this.$axios.post(&quot;&#x2F;hrms&#x2F;sys&#x2F;role&#x2F;assignPermissions&#x2F;&quot; + this.permissionForm.roleId, menuIds).then(() &#x3D;&gt; &#123;\n        this.$message.success(&quot;分配权限成功&quot;);\n        this.$bus.$emit(&quot;refreshRoleList&quot;);\n        this.$store.state.menu.hasRoute &#x3D; false;\n        this.dialogFormVisible &#x3D; false\n      &#125;)\n    &#125;,\n    resetForm(formName) &#123;\n      this.$refs[formName].resetFields();\n    &#125;,\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;RolePermission&#39;, row &#x3D;&gt; &#123;\n      this.dialogFormVisible &#x3D; true;\n      this.permissionForm &#x3D; row;\n      this.$axios.get(&quot;&#x2F;hrms&#x2F;sys&#x2F;menu&#x2F;getMenuList?valiFlag&#x3D;1&quot;).then(res &#x3D;&gt; &#123;\n        this.permissionTree &#x3D; res.data.data;\n        this.$refs.permissionTree.setCheckedKeys(row.menuIds);\n      &#125;)\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n.el-dialog-role &#123;\n  width: 100%;\n  margin-top: -90px;\n&#125;\n&lt;&#x2F;style&gt;\n\n2.8 用户管理1、新建用户组件 User.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div class&#x3D;&quot;mainHeader&quot;&gt;\n      &lt;el-form\n        :inline&#x3D;&quot;true&quot;\n        class&#x3D;&quot;demo-form-inline&quot;\n        size&#x3D;&quot;small&quot;\n        :model&#x3D;&quot;searchForm&quot;\n        ref&#x3D;&quot;searchForm&quot;\n        @submit.native.prevent&#x3D;&quot;getEmployeeList&quot;\n      &gt;\n        &lt;el-form-item\n          label&#x3D;&quot;姓名&quot;\n          prop&#x3D;&quot;empName&quot;\n        &gt;\n          &lt;el-input\n            v-model&#x3D;&quot;searchForm.empName&quot;\n            placeholder&#x3D;&quot;请输入用户姓名&quot;\n            clearable\n          &gt;\n          &lt;&#x2F;el-input&gt;\n        &lt;&#x2F;el-form-item&gt;\n        &lt;el-form-item&gt;\n          &lt;el-button\n            size&#x3D;&quot;small&quot;\n            type&#x3D;&quot;primary&quot;\n            icon&#x3D;&quot;el-icon-search&quot;\n            @click&#x3D;&quot;getEmployeeList&quot;\n          &gt;查询&lt;&#x2F;el-button&gt;\n          &lt;el-button\n            @click&#x3D;&quot;() &#x3D;&gt; this.$refs[&#39;searchForm&#39;].resetFields()&quot;\n            icon&#x3D;&quot;el-icon-refresh-right&quot;\n          &gt;重置&lt;&#x2F;el-button&gt;\n        &lt;&#x2F;el-form-item&gt;\n      &lt;&#x2F;el-form&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;div class&#x3D;&quot;mainBody&quot;&gt;\n      &lt;el-row\n        type&#x3D;&quot;flex&quot;\n        justify&#x3D;&quot;space-between&quot;\n        class&#x3D;&quot;mainMessage&quot;\n      &gt;\n        &lt;el-col class&#x3D;&quot;mainMessageLeft&quot;&gt;\n          &lt;div&gt;&lt;b&gt;查询结果&lt;&#x2F;b&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;el-col&gt;\n      &lt;&#x2F;el-row&gt;\n      &lt;el-table\n        class&#x3D;&quot;mainTable&quot;\n        ref&#x3D;&quot;multipleTable&quot;\n        border\n        :fit&#x3D;&quot;true&quot;\n        :header-cell-style&#x3D;&quot;&#123;background:&#39;#ddd&#39;&#125;&quot;\n        max-height&#x3D;&quot;420&quot;\n        :data&#x3D;&quot;employeeList&quot;\n        :default-sort&#x3D;&quot;&#123;prop: &#39;empName&#39;, order: &#39;ascending&#39;&#125;&quot;\n      &gt;\n        &lt;el-table-column\n          label&#x3D;&quot;头像&quot;\n          align&#x3D;&quot;center&quot;\n        &gt;\n          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n            &lt;el-avatar\n              size&#x3D;&quot;small&quot;\n              :src&#x3D;&quot;scope.row.avatar&quot;\n            &gt;&lt;&#x2F;el-avatar&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;empName&quot;\n          label&#x3D;&quot;用户名&quot;\n          align&#x3D;&quot;center&quot;\n          sortable\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          label&#x3D;&quot;角色名称&quot;\n          align&#x3D;&quot;center&quot;\n          width&#x3D;&quot;200&quot;\n        &gt;\n          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n            &lt;el-tag\n              style&#x3D;&quot;margin-right: 5px;&quot;\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;info&quot;\n              v-for&#x3D;&quot;item in scope.row.sysRoleDOS&quot;\n              :key&#x3D;&quot;item.empId&quot;\n            &gt;&#123;&#123;item.roleName&#125;&#125;&lt;&#x2F;el-tag&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;empCode&quot;\n          label&#x3D;&quot;工号&quot;\n          sortable\n          align&#x3D;&quot;center&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;idcardNo&quot;\n          label&#x3D;&quot;身份证号&quot;\n          width&#x3D;&quot;180&quot;\n          align&#x3D;&quot;center&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          label&#x3D;&quot;状态&quot;\n          align&#x3D;&quot;center&quot;\n        &gt;\n          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n            &lt;el-tag\n              v-if&#x3D;&quot;scope.row.valiFlag &#x3D;&#x3D;&#x3D; 0&quot;\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;danger&quot;\n            &gt;禁用&lt;&#x2F;el-tag&gt;\n            &lt;el-tag\n              v-else-if&#x3D;&quot;scope.row.valiFlag &#x3D;&#x3D;&#x3D; 1&quot;\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;success&quot;\n            &gt;正常&lt;&#x2F;el-tag&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          prop&#x3D;&quot;createTime&quot;\n          label&#x3D;&quot;创建时间&quot;\n          sortable\n          align&#x3D;&quot;center&quot;\n        &gt;\n        &lt;&#x2F;el-table-column&gt;\n        &lt;el-table-column\n          align&#x3D;&quot;center&quot;\n          label&#x3D;&quot;操作&quot;\n          fixed&#x3D;&quot;right&quot;\n          width&#x3D;&quot;300&quot;\n        &gt;\n          &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n            &lt;el-button\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;primary&quot;\n              @click&#x3D;&quot;userRole(scope.row)&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;employee:role&#39;)&quot;\n            &gt;分配角色&lt;&#x2F;el-button&gt;\n            &lt;el-button\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;danger&quot;\n              @click&#x3D;&quot;rePassword(scope.row)&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;employee:resetPassword&#39;)&quot;\n            &gt;重置密码&lt;&#x2F;el-button&gt;\n            &lt;el-button\n              size&#x3D;&quot;small&quot;\n              type&#x3D;&quot;success&quot;\n              @click&#x3D;&quot;userEdit(scope.row)&quot;\n              v-if&#x3D;&quot;hasAuth(&#39;employee:update&#39;)&quot;\n            &gt;编辑&lt;&#x2F;el-button&gt;\n          &lt;&#x2F;template&gt;\n        &lt;&#x2F;el-table-column&gt;\n      &lt;&#x2F;el-table&gt;\n      &lt;el-pagination\n        class&#x3D;&quot;mainPagination&quot;\n        @size-change&#x3D;&quot;handleSizeChange&quot;\n        @current-change&#x3D;&quot;handleCurrentChange&quot;\n        :current-page&#x3D;&quot;current&quot;\n        :page-sizes&#x3D;&quot;[10, 20, 50, 100]&quot;\n        :page-size&#x3D;&quot;size&quot;\n        layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;\n        :total&#x3D;&quot;total&quot;\n      &gt;\n      &lt;&#x2F;el-pagination&gt;\n    &lt;&#x2F;div&gt;\n    &lt;UserEdit &#x2F;&gt;\n    &lt;UserRole &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#39;..&#x2F;..&#x2F;..&#x2F;assets&#x2F;css&#x2F;mainStyle.css&#39;\nimport UserEdit from &#39;.&#x2F;UserEdit&#39;\nimport UserRole from &#39;.&#x2F;UserRole&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &quot;User&quot;,\n  data() &#123;\n    return &#123;\n      searchForm: &#123;\n        empName: &#39;&#39;\n      &#125;,\n      current: 1,\n      total: 0,\n      size: 10,\n      dialogFormVisible: false,\n      employeeList: [],\n    &#125;\n  &#125;,\n  methods: &#123;\n    getEmployeeList() &#123;\n      this.$axios.get(&#39;&#x2F;hrms&#x2F;employee&#x2F;getEmployeeList&#39;, &#123;\n        params: &#123;\n          empName: this.searchForm.empName,\n          pageNum: this.current,\n          pageSize: this.size,\n          valiFlag: 1\n        &#125;\n      &#125;).then(res &#x3D;&gt; &#123;\n        this.employeeList &#x3D; res.data.data.records\n        this.current &#x3D; res.data.data.current\n        this.size &#x3D; res.data.data.size\n        this.total &#x3D; res.data.data.total\n      &#125;)\n    &#125;,\n    handleSizeChange(val) &#123;\n      this.size &#x3D; val\n      this.getEmployeeList()\n    &#125;,\n    handleCurrentChange(val) &#123;\n      this.current &#x3D; val\n      this.getEmployeeList()\n    &#125;,\n    userEdit(row) &#123;\n      this.$bus.$emit(&#39;UserEdit&#39;, row)\n    &#125;,\n    userRole(row) &#123;\n      this.$bus.$emit(&#39;UserRole&#39;, row)\n    &#125;,\n    rePassword(row) &#123;\n      this.$confirm(&#39;将重置用户【&#39; + row.empName + &#39;】的密码, 是否继续?&#39;, &#39;提示&#39;, &#123;\n        confirmButtonText: &#39;确定&#39;,\n        cancelButtonText: &#39;取消&#39;,\n        type: &#39;warning&#39;\n      &#125;).then(() &#x3D;&gt; &#123;\n        this.$axios.post(&quot;&#x2F;hrms&#x2F;employee&#x2F;resetPassword&quot;, row.empId).then(() &#x3D;&gt; &#123;\n          this.$message.success(&#39;重置密码成功&#39;)\n        &#125;)\n      &#125;).catch(() &#x3D;&gt; &#123;\n        this.$message.success(&#39;已取消重置密码&#39;)\n      &#125;)\n    &#125;\n  &#125;,\n  created() &#123;\n    this.getEmployeeList()\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;refreshEmployeeList&#39;, () &#x3D;&gt; this.getEmployeeList())\n  &#125;,\n  components: &#123;\n    UserEdit,\n    UserRole\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n2、编辑用户对话框 UserEdit.vue\n&lt;template&gt;\n  &lt;el-dialog\n    title&#x3D;&quot;用户信息&quot;\n    :visible.sync&#x3D;&quot;dialogFormVisible&quot;\n    width&#x3D;&quot;600px&quot;\n    @closed&#x3D;&quot;resetForm(&#39;editForm&#39;)&quot;\n    :close-on-click-modal&#x3D;&quot;false&quot;\n  &gt;\n    &lt;el-form\n      :model&#x3D;&quot;editForm&quot;\n      :rules&#x3D;&quot;editFormRules&quot;\n      ref&#x3D;&quot;editForm&quot;\n    &gt;\n      &lt;el-form-item\n        label&#x3D;&quot;用户名&quot;\n        prop&#x3D;&quot;empName&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.empName&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;工号&quot;\n        prop&#x3D;&quot;empCode&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.empCode&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;身份证号&quot;\n        prop&#x3D;&quot;idcardNo&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-input\n          v-model&#x3D;&quot;editForm.idcardNo&quot;\n          autocomplete&#x3D;&quot;off&quot;\n        &gt;&lt;&#x2F;el-input&gt;\n      &lt;&#x2F;el-form-item&gt;\n      &lt;el-form-item\n        label&#x3D;&quot;状态&quot;\n        prop&#x3D;&quot;valiFlag&quot;\n        label-width&#x3D;&quot;100px&quot;\n      &gt;\n        &lt;el-radio-group v-model&#x3D;&quot;editForm.valiFlag&quot;&gt;\n          &lt;el-radio :label&#x3D;&quot;0&quot;&gt;禁用&lt;&#x2F;el-radio&gt;\n          &lt;el-radio :label&#x3D;&quot;1&quot;&gt;正常&lt;&#x2F;el-radio&gt;\n        &lt;&#x2F;el-radio-group&gt;\n      &lt;&#x2F;el-form-item&gt;\n    &lt;&#x2F;el-form&gt;\n    &lt;div\n      slot&#x3D;&quot;footer&quot;\n      class&#x3D;&quot;dialog-footer&quot;\n    &gt;\n      &lt;el-button @click&#x3D;&quot;dialogFormVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;updateEmployee(&#39;editForm&#39;)&quot;\n      &gt;确 定&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;UserEdit&#39;,\n  data() &#123;\n    return &#123;\n      editForm: &#123;&#125;,\n      dialogFormVisible: false,\n      editFormRules: &#123;\n        empName: [\n          &#123; required: true, message: &#39;请输入用户名称&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        empCode: [\n          &#123; required: true, message: &#39;请输入工号&#39;, trigger: &#39;blur&#39; &#125;\n        ],\n        valiFlag: [\n          &#123; required: true, message: &#39;请选择状态&#39;, trigger: &#39;blur&#39; &#125;\n        ]\n      &#125;,\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;UserEdit&#39;, row &#x3D;&gt; &#123;\n      this.dialogFormVisible &#x3D; true;\n      this.editForm &#x3D; row\n    &#125;)\n  &#125;,\n  methods: &#123;\n    updateEmployee(formName) &#123;\n      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;\n        if (valid) &#123;\n          this.$axios.put(&#39;&#x2F;hrms&#x2F;employee&#x2F;updateEmployee&#39;, this.editForm).then(() &#x3D;&gt; &#123;\n            this.$message.success(&#39;修改成功&#39;)\n            this.dialogFormVisible &#x3D; false;\n          &#125;)\n        &#125; else &#123;\n          console.log(&#39;error submit!!&#39;);\n          return false;\n        &#125;\n      &#125;);\n    &#125;,\n    resetForm() &#123;\n      this.editForm &#x3D; &#123;&#125;;\n      this.$bus.$emit(&#39;refreshEmployeeList&#39;)\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3、分配角色对话框 UserRole.vue\n&lt;template&gt;\n  &lt;el-dialog\n    title&#x3D;&quot;分配角色&quot;\n    :visible.sync&#x3D;&quot;dialogFormVisible&quot;\n    width&#x3D;&quot;600px&quot;\n    @closed&#x3D;&quot;resetForm(&#39;userRoleForm&#39;)&quot;\n    :close-on-click-modal&#x3D;&quot;false&quot;\n  &gt;\n    &lt;el-form\n      :model&#x3D;&quot;userRoleForm&quot;\n      ref&#x3D;&quot;userRoleForm&quot;\n    &gt;\n      &lt;el-tree\n        :data&#x3D;&quot;roleTree&quot;\n        show-checkbox\n        ref&#x3D;&quot;roleTree&quot;\n        node-key&#x3D;&quot;roleId&quot;\n        :check-strictly&#x3D;&quot;checkStrictly&quot;\n        :default-expand-all&#x3D;true\n        :props&#x3D;&quot;defaultProps&quot;\n      &gt;\n      &lt;&#x2F;el-tree&gt;\n    &lt;&#x2F;el-form&gt;\n    &lt;div\n      slot&#x3D;&quot;footer&quot;\n      class&#x3D;&quot;dialog-footer&quot;\n    &gt;\n      &lt;el-button @click&#x3D;&quot;dialogFormVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;\n      &lt;el-button\n        type&#x3D;&quot;primary&quot;\n        @click&#x3D;&quot;userRole&quot;\n      &gt;确 定&lt;&#x2F;el-button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;el-dialog&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;UserRole&#39;,\n  data() &#123;\n    return &#123;\n      dialogFormVisible: false,\n      userRoleForm: &#123;&#125;,\n      roleTree: [],\n      defaultProps: &#123;\n        children: &#39;children&#39;,\n        label: &#39;roleName&#39;\n      &#125;,\n      checkStrictly: true,\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;UserRole&#39;, row &#x3D;&gt; &#123;\n      this.dialogFormVisible &#x3D; true;\n      this.userRoleForm &#x3D; row;\n\n      this.$axios.get(&#39;&#x2F;hrms&#x2F;sys&#x2F;role&#x2F;getRoleList&#39;, &#123;\n        params: &#123;\n          roleName: &#39;&#39;,\n          valiFlag: &#39;1&#39;,\n          current: 1,\n          size: 10\n        &#125;\n      &#125;).then(res &#x3D;&gt; &#123;\n        this.roleTree &#x3D; res.data.data.records\n        this.$refs.roleTree.setCheckedKeys(row.roleIds);\n      &#125;)\n    &#125;)\n  &#125;,\n  methods: &#123;\n    userRole() &#123;\n      var roleIds &#x3D; this.$refs.roleTree.getCheckedKeys()\n      this.$axios.post(&quot;&#x2F;hrms&#x2F;employee&#x2F;assignRoles&#x2F;&quot; + this.userRoleForm.empId, roleIds).then(() &#x3D;&gt; &#123;\n        this.$message.success(&#39;分配角色成功&#39;)\n        this.$store.state.menu.hasRoute &#x3D; false;\n        this.$bus.$emit(&#39;refreshEmployeeList&#39;)\n        this.dialogFormVisible &#x3D; false\n      &#125;)\n    &#125;,\n    resetForm(formName) &#123;\n      this.$refs[formName].resetFields();\n      this.roleTree &#x3D; &#123;&#125;\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n3. Spring Security 后端项目搭建3.1 执行流程图流程说明：\n\n客户端发起一个请求，进入 Security 过滤器链\n当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理。如果不是登出路径则直接进入下一个过滤器\n当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器\n进入认证 BasicAuthenticationFilter 进行用户认证，成功的话会把认证了的结果写入到 SecurityContextHolder 中 SecurityContext 的属性 authentication 上面。如果认证失败就会交给 AuthenticationEntryPoint 认证失败处理类，或者抛出异常被后续 ExceptionTranslationFilter 过滤器处理异常，如果是 AuthenticationException 就交给 AuthenticationEntryPoint 处理，如果是 AccessDeniedException 异常则交给 AccessDeniedHandler 处理\n当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层，否则到 AccessDeniedHandler 鉴权失败处理器处理\n\nSpring Security 详细可参考：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;123482893\n项目中用到的部分组件：\n\nLogoutFilter - 登出过滤器\nlogoutSuccessHandler - 登出成功之后的处理器\nUsernamePasswordAuthenticationFilter - from提交用户名密码登录认证过滤器\nAuthenticationFailureHandler - 登录失败处理器\nAuthenticationSuccessHandler - 登录成功处理器\nBasicAuthenticationFilter - Basic身份认证过滤器\nSecurityContextHolder - 安全上下文静态工具类\nAuthenticationEntryPoint - 认证失败入口\nExceptionTranslationFilter - 异常处理过滤器\nAccessDeniedHandler - 权限不足操作类\nFilterSecurityInterceptor - 权限判断拦截器、出口\n\n3.2 准备3.2.1 Security POM 依赖&lt;!-- Spring Security --&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- Redis --&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.6.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- jjwt --&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;$&#123;jjwt.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- kaptcha --&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;cloud.agileframework&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-kaptcha&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.1.0.M19&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n3.2.2 RedisConfig 配置类重新定义 Redis 的序列化规则。将 RedisTemplate 的 Key 的序列化规则设为 StringRedisSerializer，Value 的序列化规则设为 Jackson2JsonRedisSerializer\n关于 Redis 序列化规则参考：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;124565124\n@Configuration\npublic class RedisConfig &#123;\n\n    @Bean\n    RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        RedisTemplate redisTemplate &#x3D; new RedisTemplate();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);\n        redisTemplate.setDefaultSerializer(jackson2JsonRedisSerializer);\n\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n  \n        return redisTemplate;\n    &#125;\n&#125;\n\n3.2.3 CorsConfig 跨域配置类浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的。同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致\n前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题，需要进行处理让前端能进行跨域请求\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer &#123;\n\n    private CorsConfiguration buildConfig() &#123;\n        CorsConfiguration corsConfiguration &#x3D; new CorsConfiguration();\n        corsConfiguration.addAllowedOrigin(&quot;*&quot;); &#x2F;&#x2F; 允许所有来源\n        corsConfiguration.addAllowedHeader(&quot;*&quot;); &#x2F;&#x2F; 允许所有请求头\n        corsConfiguration.addAllowedMethod(&quot;*&quot;); &#x2F;&#x2F; 允许所有方法\n        corsConfiguration.addExposedHeader(&quot;Authorization&quot;);\n        return corsConfiguration;\n    &#125;\n\n    @Bean\n    public CorsFilter corsFilter() &#123;\n        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource &#x3D; new UrlBasedCorsConfigurationSource();\n        urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, buildConfig());\n        return new CorsFilter(urlBasedCorsConfigurationSource);\n    &#125;\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n        &#x2F;&#x2F; 设置允许跨域的路径\n        registry.addMapping(&quot;&#x2F;**&quot;)\n                &#x2F;&#x2F; 设置允许跨域请求的域名\n                .allowedOriginPatterns(&quot;*&quot;)\n                &#x2F;&#x2F; 是否允许 cookie\n&#x2F;&#x2F;                .allowCredentials(true)\n                &#x2F;&#x2F; 设置允许的请求方式\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)\n                &#x2F;&#x2F; 设置允许的 header 属性\n                .allowedHeaders(&quot;*&quot;)\n                &#x2F;&#x2F; 跨域允许时间\n                .maxAge(3600);\n    &#125;\n&#125;\n\n3.2.4 MybatisPlusConfig 配置类@Configuration\n@MapperScan(&quot;fan.**.dao&quot;)\npublic class MybatisPlusConfig &#123;\n\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;\n        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();\n        &#x2F;&#x2F; 添加分页插件\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        &#x2F;&#x2F; 添加全表更新删除插件\n        interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());\n        return interceptor;\n    &#125;\n&#125;\n\n3.2.5 RedisUtil 工具类@Component\npublic class RedisUtil &#123;\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    &#x2F;&#x2F; 指定缓存失效时间\n    public boolean expire(String key, long time) &#123;\n        try &#123;\n            if (time &gt; 0) &#123;\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n            &#125;\n            return true;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return false;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; hash 存储数据\n    public boolean hashSet(String key, String item, Object value) &#123;\n        try &#123;\n            redisTemplate.opsForHash().put(key, item, value);\n            return true;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return false;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; hash 存储数据带过期时间\n    public boolean hashSet(String key, String item, Object value, long time) &#123;\n        try &#123;\n            redisTemplate.opsForHash().put(key, item, value);\n            if (time &gt; 0) &#123;\n                expire(key, time);\n            &#125;\n            return true;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return false;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; hash 获取数据\n    public Object hashGet(String key, String item) &#123;\n        return redisTemplate.opsForHash().get(key, item);\n    &#125;\n\n    &#x2F;&#x2F; hash 删除值\n    public void hashDel(String key, Object... item) &#123;\n        redisTemplate.opsForHash().delete(key, item);\n    &#125;\n\n    &#x2F;&#x2F; String 存储数据\n    public boolean set(String key, Object value) &#123;\n        try &#123;\n            redisTemplate.opsForValue().set(key, value);\n            return true;\n        &#125; catch (Exception e) &#123;\n            return false;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; String 存储数据带过期时间\n    public boolean set(String key, Object value, long time) &#123;\n        try &#123;\n            if (time &gt; 0) &#123;\n                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n            &#125; else &#123;\n                set(key, value);\n            &#125;\n            return true;\n        &#125; catch (Exception e) &#123;\n            return false;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; String 获取数据\n    public Object get(String key) &#123;\n        return key &#x3D;&#x3D; null ? null : redisTemplate.opsForValue().get(key);\n    &#125;\n\n    &#x2F;&#x2F; 判断key是否存在\n    public boolean hasKey(String key) &#123;\n        try &#123;\n            return redisTemplate.hasKey(key);\n        &#125; catch (Exception e) &#123;\n            return false;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 删除缓存\n    public void del(String... key) &#123;\n        if (key !&#x3D; null &amp;&amp; key.length &gt; 0) &#123;\n            if (key.length &#x3D;&#x3D; 1) &#123;\n                redisTemplate.delete(key[0]);\n            &#125; else &#123;\n                redisTemplate.delete(CollectionUtils.arrayToList(key));\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n3.2.6 Result 统一结果处理@Data\n@Builder\npublic class Result implements Serializable &#123;\n\n    private static final long serialVersionUID &#x3D; -1L;\n    private Integer code;\n    private String message;\n    private Object data;\n\n    public static Result success(Object data) &#123;\n        return Result.builder().code(200).message(&quot;操作成功&quot;).data(data).build();\n    &#125;\n\n    public static Result success(String message, Object data) &#123;\n        return Result.builder().code(200).message(message).data(data).build();\n    &#125;\n\n    public static Result success(int code, String message, Object data) &#123;\n        return Result.builder().code(code).message(message).data(data).build();\n    &#125;\n\n    public static Result fail(String message) &#123;\n        return Result.builder().code(400).message(message).build();\n    &#125;\n\n    public static Result fail(int code, String message) &#123;\n        return Result.builder().code(code).message(message).build();\n    &#125;\n\n    public static Result fail(int code, String message, Object data) &#123;\n        return Result.builder().code(code).message(message).data(data).build();\n    &#125;\n&#125;\n\n3.3 用户认证用户认证问题，分为首次登陆和二次认证\n\n首次登录认证：用户名、密码和验证码完成登录\n二次 token 认证：请求头携带 Jwt 进行身份认证\n\n3.3.1 生成验证码1、在前面导入了 Google 的 Kaptcha 依赖包，可以用这个来生成图片验证码，首先新建一个图片验证码配置类，配置图片验证码的参数\n@Configuration\npublic class KaptchaConfig &#123;\n    @Bean\n    public DefaultKaptcha producer() &#123;\n        Properties properties &#x3D; new Properties();\n        properties.put(&quot;kaptcha.border&quot;, &quot;no&quot;);\n        properties.put(&quot;kaptcha.textproducer.font.color&quot;, &quot;black&quot;);\n        properties.put(&quot;kaptcha.textproducer.char.space&quot;, &quot;4&quot;);\n        properties.put(&quot;kaptcha.image.height&quot;, &quot;40&quot;);\n        properties.put(&quot;kaptcha.image.width&quot;, &quot;120&quot;);\n        properties.put(&quot;kaptcha.textproducer.font.size&quot;, &quot;30&quot;);\n\n        Config config &#x3D; new Config(properties);\n        DefaultKaptcha defaultKaptcha &#x3D; new DefaultKaptcha();\n        defaultKaptcha.setConfig(config);\n\n        return defaultKaptcha;\n    &#125;\n&#125;\n\n2、然后在 Controller 中生成图片验证码并进行映射把验证码存入 Redis，使用一个随机字符串作为 Key，并传给前端，前端再把 Key 和用户输入的验证码传回来，这样就可以通过 Key 获取到保存的验证码和用户的验证码进行比较了是否一致因为是图片验证码的方式，所以进行了 encode，把图片进行了 base64 编码，这样前端就可以显示图片\n@RestController\n@RequestMapping(&quot;&#x2F;api&quot;)\npublic class AuthController &#123;\n\n    @Resource\n    private Producer producer;\n\n    @Resource\n    private RedisUtil redisUtil;\n\n    @GetMapping(&quot;&#x2F;api&#x2F;getCaptcha&quot;)\n    public Result getCaptcha() throws IOException &#123;\n\n        String token &#x3D; UUID.randomUUID().toString();\n        String captcha &#x3D; producer.createText(); &#x2F;&#x2F; 生成验证码字符串\n\n        BufferedImage image &#x3D; producer.createImage(captcha);\n        ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();\n        ImageIO.write(image, &quot;jpg&quot;, byteArrayOutputStream); &#x2F;&#x2F; 生成图片字节数组\n\n        Base64Encoder base64Encoder &#x3D; new Base64Encoder();\n        &#x2F;&#x2F; 转换为base64，生成图片验证码\n        String captchaImg &#x3D; &quot;data:image&#x2F;jpg;base64,&quot; + base64Encoder.encode(byteArrayOutputStream.toByteArray());\n\n        redisUtil.hashSet(Const.CAPTCHA_KEY, token, captcha, 120); &#x2F;&#x2F; 将验证码存入redis\n\n        return Result.success(MapUtil.builder().put(&quot;token&quot;, token).put(&quot;captchaImg&quot;, captchaImg).build());\n    &#125;\n&#125;\n\n3.3.2 登录成功处理器@Component\npublic class LoginSuccessHandler implements AuthenticationSuccessHandler &#123;\n\n    @Resource\n    private JwtUtil jwtUtil;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;\n        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);\n        ServletOutputStream outputStream &#x3D; response.getOutputStream();\n\n        &#x2F;&#x2F; 生成 jwt，并放到响应头中\n        String jwt &#x3D; jwtUtil.generateJwt(authentication.getName());\n        response.setHeader(jwtUtil.getHeader(), jwt);\n\n        Result success &#x3D; Result.success(&quot;登录成功&quot;);\n        outputStream.write(JSONUtil.toJsonStr(success).getBytes(StandardCharsets.UTF_8));\n\n        outputStream.flush();\n        outputStream.close();\n    &#125;\n&#125;\n\n3.3.3 登录失败处理器@Component\npublic class LoginFailureHandler implements AuthenticationFailureHandler &#123;\n\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;\n        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);\n        ServletOutputStream outputStream &#x3D; response.getOutputStream();\n\n        Result fail &#x3D; Result.fail(exception.getMessage().equals(&quot;Bad credentials&quot;) ? &quot;用户名或密码错误&quot; : exception.getMessage());\n        outputStream.write(JSONUtil.toJsonStr(fail).getBytes(StandardCharsets.UTF_8));\n\n        outputStream.flush();\n        outputStream.close();\n    &#125;\n&#125;\n\n3.3.4 图片验证码拦截器Spring Security 的所有过滤器都是没有图片验证码的，如果依然想沿用自带的 UsernamePasswordAuthenticationFilter，可以在这个过滤器之前添加一个图片验证码过滤器。或者自定义过滤器继承 UsernamePasswordAuthenticationFilter，然后在原有的认证逻辑上加上验证码验证逻辑。\n这里我们在 UsernamePasswordAuthenticationFilter 之前自定义一个图片过滤器 CaptchaFilter\n@Component\npublic class CaptchaFilter extends OncePerRequestFilter &#123;\n\n    @Resource\n    private RedisUtil redisUtil;\n\n    @Resource\n    private LoginFailureHandler loginFailureHandler;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n        if (request.getRequestURI().equals(&quot;&#x2F;hrms&#x2F;login&quot;) &amp;&amp; request.getMethod().equals(&quot;POST&quot;)) &#123;\n            try &#123;\n                &#x2F;&#x2F; 校验验证码\n                validate(request);\n                filterChain.doFilter(request, response);\n            &#125; catch (CustomException e) &#123;\n                &#x2F;&#x2F; 交给认证失败处理器处理\n                loginFailureHandler.onAuthenticationFailure(request, response, e);\n            &#125;\n        &#125; else &#123;\n            filterChain.doFilter(request, response);\n        &#125;\n\n    &#125;\n\n    &#x2F;&#x2F; 校验验证码\n    private void validate(HttpServletRequest request) &#123;\n        String captcha &#x3D; request.getParameter(&quot;captcha&quot;);\n        String token &#x3D; request.getParameter(&quot;token&quot;);\n\n        if (StringUtils.isBlank(captcha) || StringUtils.isBlank(token)) &#123;\n            throw new CustomException(&quot;验证码不能为空&quot;);\n        &#125;\n\n        if (!captcha.equals(redisUtil.hashGet(Const.CAPTCHA_KEY, token))) &#123;\n            throw new CustomException(&quot;验证码错误&quot;);\n        &#125;\n\n\t\tredisUtil.hashDel(Const.CAPTCHA_KEY, token);\n    &#125;\n&#125;\n\n3.3.5 SecurityConfig 核心配置类该配置类用于 Security 的核心配置。这里进行跨域和请求路径配置，放开登录登出以及验证码的请求，对其他请求进行拦截。并添加登录成功和失败处理器，将图片验证码过滤器添加到 UsernamePasswordAuthenticationFilter 之前\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Resource\n    private LoginFailureHandler loginFailureHandler;\n\n    @Resource\n    private LoginSuccessHandler loginSuccessHandler;\n   \n    @Resource\n    private CaptchaFilter captchaFilter;\n\n    public static final String[] AUTH_WHITELIST &#x3D; &#123;\n            &quot;&#x2F;login&quot;,\n            &quot;&#x2F;logout&quot;,\n            &quot;&#x2F;api&#x2F;**&quot;,\n    &#125;;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F; 开启跨域访问，关闭csrf防护\n        http.csrf().disable().cors();\n        &#x2F;&#x2F; 拦截规则\n        http.authorizeRequests()\n                .antMatchers(AUTH_WHITELIST).permitAll()\n                .anyRequest().authenticated();\n        &#x2F;&#x2F; 登录配置\n        http.formLogin()\n                .successHandler(loginSuccessHandler)\n                .failureHandler(loginFailureHandler);\n        &#x2F;&#x2F; 添加验证码过滤器在登录之前，添加jwt过滤器\n        http.addFilterBefore(captchaFilter, UsernamePasswordAuthenticationFilter.class);\n    &#125;\n&#125;\n\n3.5 异常处理3.5.1 自定义异常类public class CustomException extends AuthenticationException &#123;\n\n    public CustomException(String msg) &#123;\n        super(msg);\n    &#125;\n&#125;\n\n3.5.2 全局异常类@Slf4j\n@RestControllerAdvice\npublic class GlobalExceptionHandler &#123;\n\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler(value &#x3D; RuntimeException.class)\n    public Result handler(RuntimeException e) &#123;\n        e.printStackTrace();\n        return Result.fail(e.getMessage());\n    &#125;\n\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler(value &#x3D; MethodArgumentNotValidException.class)\n    public Result handler(MethodArgumentNotValidException e) &#123;\n        BindingResult bindingResult &#x3D; e.getBindingResult();\n        ObjectError objectError &#x3D; bindingResult.getAllErrors().stream().findFirst().get();\n        return Result.fail(objectError.getDefaultMessage());\n    &#125;\n&#125;\n\n3.5.3 认证失败处理器@Component\npublic class UnAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;\n        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);\n        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); &#x2F;&#x2F; 401，未认证\n        ServletOutputStream outputStream &#x3D; response.getOutputStream();\n\n        Result fail &#x3D; Result.fail(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage().equals(&quot;JWT异常&quot;) ? authException.getMessage() : &quot;请先登录&quot;);\n        outputStream.write(JSONUtil.toJsonStr(fail).getBytes(StandardCharsets.UTF_8));\n\n        outputStream.flush();\n        outputStream.close();\n    &#125;\n&#125;\n\n3.5.4 权限失败处理器@Component\npublic class UnAccessDeniedHandler implements AccessDeniedHandler&#123;\n\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;\n        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);\n        response.setStatus(HttpServletResponse.SC_FORBIDDEN); &#x2F;&#x2F; 403，未授权，禁止访问\n        ServletOutputStream outputStream &#x3D; response.getOutputStream();\n\n        Result fail &#x3D; Result.fail(HttpServletResponse.SC_FORBIDDEN, &quot;没有权限访问&quot;);\n        outputStream.write(JSONUtil.toJsonStr(fail).getBytes(StandardCharsets.UTF_8));\n\n        outputStream.flush();\n        outputStream.close();\n    &#125;\n&#125;\n\n3.6 鉴权3.6.1 JWT 工具类JWT 相关知识：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;123531422\n@Data\n@Component\npublic class JwtUtil &#123;\n\n    @Value(&quot;$&#123;fan.jwt.expire&#125;&quot;)\n    private String expire;\n    @Value(&quot;$&#123;fan.jwt.header&#125;&quot;)\n    private String header;\n    private final static RSA rsa &#x3D; new RSA();\n\n    &#x2F;&#x2F; 生成 JWT\n    public String generateJwt(String username) &#123;\n\n        RSAPrivateKey rsaPrivateKey &#x3D; (RSAPrivateKey) rsa.getPrivateKey();\n\n        String jwt &#x3D; Jwts.builder()\n                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)\n                .setSubject(username)\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + Long.parseLong(expire))) &#x2F;&#x2F; 设置过期时间\n                .signWith(SignatureAlgorithm.RS256, rsaPrivateKey)\n                .compact();\n        System.out.println(jwt + &quot;  生成的jwt&quot;);\n        return jwt;\n    &#125;\n\n    &#x2F;&#x2F; 解析 JWT\n    public Jws&lt;Claims&gt; parseJwt(String jwt) &#123;\n\n        RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) rsa.getPublicKey();\n        try &#123;\n            return Jwts.parser().setSigningKey(rsaPublicKey).parseClaimsJws(jwt);\n        &#125; catch (Exception e) &#123;\n            return null;\n        &#125;\n    &#125;\n&#125;\n\n3.6.2 JWT 过滤器过滤器会去获取请求头中的 JWT，对 JWT 进行解析取出其中的 username。使用 username 去 Redis 中获取对应的权限列表。然后封装 Authentication 对象存入 SecurityContextHolder\n在 Spring Security 中，会使用默认的 FilterSecurityInterceptor 来进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的 Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。在项目中只需要把当前登录用户的权限信息也存入 Authentication。然后设置资源所需要的权限即可\npublic class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123;\n    @Resource\n    private JwtUtil jwtUtil;\n\n    @Resource\n    private EmployeeService employeeService;\n\n    @Resource\n    private RedisUtil redisUtil;\n\n    @Resource\n    private UserDetailsServiceImpl userDetailsService;\n\n    @Resource\n    private UnAuthenticationEntryPoint unAuthenticationEntryPoint;\n\n    public JwtAuthenticationFilter(AuthenticationManager authenticationManager) &#123;\n        super(authenticationManager);\n    &#125;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n        String jwt &#x3D; request.getHeader(jwtUtil.getHeader());\n        if (StringUtils.isBlank(jwt)) &#123;\n            chain.doFilter(request, response);\n            return;\n        &#125;\n\n        Jws&lt;Claims&gt; claimsJws &#x3D; jwtUtil.parseJwt(jwt);\n        if (claimsJws &#x3D;&#x3D; null) &#123;\n            CustomException customException &#x3D; new CustomException(&quot;JWT异常&quot;);\n            unAuthenticationEntryPoint.commence(request, response, customException);\n            throw customException;\n        &#125;\n        String username &#x3D; claimsJws.getBody().getSubject();\n        EmployeeDTO employeeDTO &#x3D; employeeService.getEmpByCode(username);\n\n        List&lt;GrantedAuthority&gt; authorities;\n        if (redisUtil.hasKey(&quot;GrantedAuthority:&quot; + employeeDTO.getEmpName())) &#123;\n            authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList((String) redisUtil.get(&quot;GrantedAuthority:&quot; + employeeDTO.getEmpName()));\n        &#125; else &#123;\n            authorities &#x3D; userDetailsService.getAuthorities(employeeDTO);\n        &#125;\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken &#x3D;\n                new UsernamePasswordAuthenticationToken(username, claimsJws, authorities);\n\n        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);\n        chain.doFilter(request, response);\n    &#125;\n&#125;\n\n3.6.3 UserDetailsServiceImpl 实现类实现 UserDetailsService 接口，根据用户名从数据库查出用户信息和用户权限信息\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n\n    @Resource\n    private EmployeeService employeeService;\n\n    @Resource\n    private RedisUtil redisUtil;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        EmployeeDTO employeeDTO &#x3D; employeeService.getEmpByCode(username);\n        if (employeeDTO &#x3D;&#x3D; null) &#123;\n            throw new CustomException(&quot;用户名不存在&quot;);\n        &#125;\n\n        List&lt;GrantedAuthority&gt; authorities;\n        if (redisUtil.hasKey(&quot;GrantedAuthority:&quot; + employeeDTO.getEmpName())) &#123;\n            authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList((String) redisUtil.get(&quot;GrantedAuthority:&quot; + employeeDTO.getEmpName()));\n        &#125; else &#123;\n            System.out.println(&quot;UserDetailsServiceImpl从数据库中获取权限&quot;);\n            authorities &#x3D; getAuthorities(employeeDTO);\n        &#125;\n        return new SecurityUser(employeeDTO, authorities);\n    &#125;\n\n    public List&lt;GrantedAuthority&gt; getAuthorities(EmployeeDTO employeeDTO) &#123;\n\n        String authority &#x3D; employeeService.getAuthority(employeeDTO.getEmpId());\n        redisUtil.set(&quot;GrantedAuthority:&quot; + employeeDTO.getEmpName(), authority);\n\n        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(authority);\n        return authorities;\n    &#125;\n&#125;\n\n3.6.4 UserDetails 实现类保存用户信息\n@Data\npublic class SecurityUser implements UserDetails &#123;\n\n    private transient EmployeeDTO employeeDTO;\n    private Collection&lt;? extends GrantedAuthority&gt; authorities;\n\n    public SecurityUser(EmployeeDTO employeeDTO, List&lt;GrantedAuthority&gt; authorities) &#123;\n        this.employeeDTO &#x3D; employeeDTO;\n        this.authorities &#x3D; authorities;\n    &#125;\n\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return employeeDTO.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return employeeDTO.getEmpCode();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n\n3.6.5 CustomLogoutSuccessHandler 注销成功处理器@Component\npublic class CustomLogoutSuccessHandler implements LogoutSuccessHandler &#123;\n\n    @Resource\n    private JwtUtil jwtUtil;\n\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;\n        System.out.println(&quot;退出成功过滤器&quot;);\n\n        &#x2F;&#x2F; 手动退出\n        if (authentication !&#x3D; null) &#123;\n            new SecurityContextLogoutHandler().logout(request, response, authentication);\n        &#125;\n\n        response.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);\n        ServletOutputStream outputStream &#x3D; response.getOutputStream();\n\n        response.setHeader(jwtUtil.getHeader(), &quot;&quot;);\n        Result success &#x3D; Result.success(&quot;登出成功&quot;);\n        outputStream.write(JSONUtil.toJsonStr(success).getBytes(StandardCharsets.UTF_8));\n\n        outputStream.flush();\n        outputStream.close();\n    &#125;\n&#125;\n\n3.6.6 SecurityConfig 核心配置类完整配置@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Resource\n    private LoginFailureHandler loginFailureHandler;\n\n    @Resource\n    private LoginSuccessHandler loginSuccessHandler;\n\n    @Resource\n    private CaptchaFilter captchaFilter;\n\n    @Resource\n    private UnAccessDeniedHandler unAccessDeniedHandler;\n\n    @Resource\n    private UnAuthenticationEntryPoint unAuthenticationEntryPoint;\n\n    @Resource\n    private UserDetailsServiceImpl userDetailsServiceImpl;\n\n    @Resource\n    private CustomLogoutSuccessHandler customLogoutSuccessHandler;\n\n    @Bean\n    JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception &#123;\n        return new JwtAuthenticationFilter(authenticationManager());\n    &#125;\n\n    public static final String[] AUTH_WHITELIST &#x3D; &#123;\n            &quot;&#x2F;login&quot;,\n            &quot;&#x2F;logout&quot;,\n            &quot;&#x2F;api&#x2F;**&quot;,\n    &#125;;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        auth.userDetailsService(userDetailsServiceImpl).passwordEncoder(passwordEncoder());\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        &#x2F;&#x2F; 开启跨域访问，关闭csrf防护\n        http.csrf().disable().cors();\n        &#x2F;&#x2F; 拦截规则\n        http.authorizeRequests()\n                .antMatchers(AUTH_WHITELIST).permitAll()\n                .anyRequest().authenticated();\n        &#x2F;&#x2F; 登录配置\n        http.formLogin()\n                .successHandler(loginSuccessHandler)\n                .failureHandler(loginFailureHandler);\n        &#x2F;&#x2F; 添加验证码过滤器在登录之前，添加jwt过滤器\n        http.addFilterBefore(captchaFilter, UsernamePasswordAuthenticationFilter.class)\n                .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n        &#x2F;&#x2F; 添加自定义异常处理器\n        http.exceptionHandling()\n                .authenticationEntryPoint(unAuthenticationEntryPoint)\n                .accessDeniedHandler(unAccessDeniedHandler);\n        &#x2F;&#x2F; 添加自定义注销处理器\n        http.logout().logoutSuccessHandler(customLogoutSuccessHandler);\n    &#125;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() &#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n\n3.7 权限管理代码零散有点乱。仅供参考\n3.7.1 菜单管理1. Controller\n@RestController\n@RequestMapping(&quot;&#x2F;sys&#x2F;menu&quot;)\npublic class SysMenuController &#123;\n\n    @Resource\n    private EmployeeService employeeService;\n\n    @Resource\n    private SysMenuService sysMenuService;\n\n    @Resource\n    private SysRoleMenuService sysRoleMenuService;\n\n    @GetMapping(&quot;&#x2F;getNavMenu&quot;)\n    public Result getNavMenu(Principal principal) &#123;\n        &#x2F;&#x2F; 获取权限信息\n        EmployeeDTO employeeDTO &#x3D; employeeService.getEmpByCode(principal.getName());\n        String authority &#x3D; employeeService.getAuthority(employeeDTO.getEmpId());\n        String[] permissionList &#x3D; StringUtils.tokenizeToStringArray(authority, &quot;,&quot;);\n\n        &#x2F;&#x2F; 获取导航栏菜单\n        List&lt;SysMenuDTO&gt; menuList &#x3D; sysMenuService.getNavMenu(employeeService.getEmpByCode(principal.getName()));\n        return Result.success(&quot;获取导航栏菜单成功&quot;, MapUtil.builder().put(&quot;menuList&quot;, menuList).put(&quot;permissionList&quot;, permissionList).build());\n    &#125;\n\n    @GetMapping(&quot;&#x2F;getMenuList&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:menu:list&#39;)&quot;)\n    public Result getMenuList(String valiFlag) &#123;\n        return Result.success(&quot;获取菜单列表成功&quot;, sysMenuService.getMenuList(valiFlag));\n    &#125;\n\n    @PostMapping(&quot;&#x2F;addMenu&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:menu:add&#39;)&quot;)\n    public Result addMenu(@Validated @RequestBody SysMenuDO sysMenuDO) &#123;\n        if (org.apache.commons.lang3.StringUtils.isBlank(sysMenuDO.getParentId())) &#123;\n            sysMenuDO.setParentId(&quot;0&quot;);\n        &#125;\n        sysMenuDO.setMenuId(UUID.randomUUID().toString());\n        sysMenuDO.setCreateTime(LocalDateTime.now());\n        sysMenuDO.setUpdateTime(LocalDateTime.now());\n        return Result.success(&quot;添加菜单成功&quot;, sysMenuService.save(sysMenuDO));\n    &#125;\n\n    @PutMapping(&quot;&#x2F;updateMenu&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:menu:update&#39;)&quot;)\n    public Result updateMenu(@Validated @RequestBody SysMenuDO sysMenuDO) &#123;\n\n        sysMenuDO.setUpdateTime(LocalDateTime.now());\n        sysMenuService.updateById(sysMenuDO);\n        &#x2F;&#x2F; 清除所有与菜单相关的缓存\n        employeeService.clearUserAuthorityByMenuId(sysMenuDO.getMenuId());\n        return Result.success(&quot;更新菜单成功&quot;);\n    &#125;\n\n    @DeleteMapping(&quot;&#x2F;deleteMenu&#x2F;&#123;menuId&#125;&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:menu:delete&#39;)&quot;)\n    public Result deleteMenu(@PathVariable(&quot;menuId&quot;) String menuId) &#123;\n        long parent_id &#x3D; sysMenuService.count(new QueryWrapper&lt;SysMenuDO&gt;().eq(&quot;parent_id&quot;, menuId));\n        if (parent_id &gt; 0) &#123;\n            return Result.fail(&quot;该菜单下存在子菜单，不能删除&quot;);\n        &#125;\n\n        sysMenuService.removeById(menuId);\n        &#x2F;&#x2F; 清除所有与菜单相关的缓存\n        employeeService.clearUserAuthorityByMenuId(menuId);\n\n        &#x2F;&#x2F; 同步删除中间关联表\n        sysRoleMenuService.remove(new QueryWrapper&lt;SysRoleMenuDO&gt;().eq(&quot;menu_id&quot;, menuId));\n        return Result.success(&quot;删除菜单成功&quot;);\n    &#125;\n&#125;\n\n2. ServiceImpl 实现类。接口实现 IService 接口\n@Service\npublic class SysMenuServiceImpl extends ServiceImpl&lt;SysMenuDAO, SysMenuDO&gt; implements SysMenuService &#123;\n\n    @Resource\n    private SysMenuDAO sysMenuDAO;\n\n    @Resource\n    private SysMenuDTOConvert sysMenuDTOConvert;\n\n\t&#x2F;&#x2F; 根据员工id获取导航菜单列表id\n    @Override\n    public List&lt;String&gt; getNavMenuIds(String empId) &#123;\n        return sysMenuDAO.getNavMenuIds(empId);\n    &#125;\n\n\t&#x2F;&#x2F; 获取用户导航菜单列表\n    @Override\n    public List&lt;SysMenuDTO&gt; getNavMenu(EmployeeDTO employeeDTO) &#123;\n        List&lt;String&gt; navMenuIds &#x3D; getNavMenuIds(employeeDTO.getEmpId());\n        List&lt;SysMenuDO&gt; sysMenuDOS &#x3D; this.listByIds(navMenuIds);\n\n        &#x2F;&#x2F; 转树状结构\n        List&lt;SysMenuDO&gt; sysMenuDOSTree &#x3D; navBuildTree(sysMenuDOS);\n        &#x2F;&#x2F; 转DTO\n        List&lt;SysMenuDTO&gt; sysMenuDTOS &#x3D; convert(sysMenuDOSTree);\n        return sysMenuDTOS;\n    &#125;\n\n\t&#x2F;&#x2F; 获取所有菜单列表\n    @Override\n    public List&lt;SysMenuDO&gt; getMenuList(String valiFlag) &#123;\n\n        List&lt;SysMenuDO&gt; sysMenuDOS &#x3D; this.list(new QueryWrapper&lt;SysMenuDO&gt;().eq(StringUtils.isNotBlank(valiFlag),&quot;vali_flag&quot;, valiFlag)\n                .orderByAsc(&quot;order_num&quot;));\n\n        return buildTree(sysMenuDOS);\n    &#125;\n\n\t&#x2F;&#x2F; 将菜单列表转为树状结构\n    private List&lt;SysMenuDO&gt; buildTree(List&lt;SysMenuDO&gt; sysMenuDOS)&#123;\n        List&lt;SysMenuDO&gt; finalMenu &#x3D; new ArrayList&lt;&gt;();\n\n        for (SysMenuDO sysMenuDO : sysMenuDOS) &#123;\n\n            for (SysMenuDO menuDO : sysMenuDOS) &#123;\n                if (sysMenuDO.getMenuId().equals(menuDO.getParentId())) &#123;\n                    sysMenuDO.getChildren().add(menuDO);\n                &#125;\n            &#125;\n\n            if (sysMenuDO.getParentId().equals(&quot;0&quot;))&#123;\n                finalMenu.add(sysMenuDO);\n            &#125;\n        &#125;\n        return finalMenu;\n    &#125;\n\n    private List&lt;SysMenuDO&gt; navBuildTree(List&lt;SysMenuDO&gt; sysMenuDOS)&#123;\n        List&lt;SysMenuDO&gt; finalMenu &#x3D; new ArrayList&lt;&gt;();\n\n        for (SysMenuDO sysMenuDO : sysMenuDOS) &#123;\n\n            for (SysMenuDO menuDO : sysMenuDOS) &#123;\n                if (sysMenuDO.getMenuId().equals(menuDO.getParentId()) &amp;&amp; menuDO.getType() &#x3D;&#x3D; 1) &#123;\n                    sysMenuDO.getChildren().add(menuDO);\n                &#125;\n            &#125;\n\n            if (sysMenuDO.getParentId().equals(&quot;0&quot;))&#123;\n                finalMenu.add(sysMenuDO);\n            &#125;\n        &#125;\n        return finalMenu;\n    &#125;\n\n\t&#x2F;&#x2F; 将树状菜单结构转为DTO\n    private List&lt;SysMenuDTO&gt; convert(List&lt;SysMenuDO&gt; sysMenuDOSTree) &#123;\n        List&lt;SysMenuDTO&gt; sysMenuDTOS &#x3D; new ArrayList&lt;&gt;();\n\n        sysMenuDOSTree.forEach(sysMenuDO -&gt; &#123;\n            SysMenuDTO sysMenuDTO &#x3D; sysMenuDTOConvert.convertToSysMenuDTO(sysMenuDO);\n\n            if (sysMenuDO.getChildren().size() &gt; 0)&#123;\n                sysMenuDTO.setChildren(convert(sysMenuDO.getChildren()));\n            &#125;\n\n            sysMenuDTOS.add(sysMenuDTO);\n        &#125;);\n\n        return sysMenuDTOS;\n    &#125;\n&#125;\n\n3. Mapper\n&lt;mapper namespace&#x3D;&quot;fan.security.dao.SysMenuDAO&quot;&gt;\n\n    &lt;select id&#x3D;&quot;getNavMenuIds&quot; resultType&#x3D;&quot;java.lang.String&quot;&gt;\n        SELECT DISTINCT sys_role_menu.menu_id\n        FROM sys_employee_role\n                 LEFT JOIN sys_role_menu ON sys_employee_role.role_id &#x3D; sys_role_menu.role_id\n        WHERE sys_employee_role.emp_id &#x3D; #&#123;empId&#125;\n    &lt;&#x2F;select&gt;\n\n&lt;&#x2F;mapper&gt;\n\n3.7.2 角色管理1. Controller\n@RestController\n@RequestMapping(&quot;&#x2F;sys&#x2F;role&quot;)\npublic class SysRoleController extends BaseController &#123;\n\n    @Resource\n    private SysRoleService sysRoleService;\n\n    @Resource\n    private EmployeeService employeeService;\n\n    @Resource\n    private SysRoleMenuService sysRoleMenuService;\n\n    @Resource\n    private SysEmployeeRoleService sysEmployeeRoleService;\n\n    @GetMapping(&quot;&#x2F;getRoleList&quot;)\n    @PreAuthorize(&quot;hasAnyAuthority(&#39;sys:role:list&#39;)&quot;)\n    public Result getRoleList(String roleName, String valiFlag) &#123;\n\n        Page&lt;SysRoleDO&gt; sysRoleDOPage &#x3D; sysRoleService.page(getPage(), new QueryWrapper&lt;SysRoleDO&gt;()\n                .eq(StringUtils.isNotBlank(valiFlag), &quot;vali_flag&quot;, valiFlag)\n                .like(StringUtils.isNotBlank(roleName), &quot;role_name&quot;, roleName));\n\n        sysRoleDOPage.getRecords().forEach(sysRoleDO -&gt; &#123;\n            List&lt;SysRoleMenuDO&gt; sysRoleMenuDOS &#x3D; sysRoleMenuService.list(new QueryWrapper&lt;SysRoleMenuDO&gt;().eq(&quot;role_id&quot;, sysRoleDO.getRoleId()));\n            List&lt;String&gt; menuIds &#x3D; sysRoleMenuDOS.stream().map(p -&gt; p.getMenuId()).collect(Collectors.toList());\n            sysRoleDO.setMenuIds(menuIds);\n        &#125;);\n        return Result.success(sysRoleDOPage);\n    &#125;\n\n    @PostMapping(&quot;&#x2F;addRole&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:role:add&#39;)&quot;)\n    public Result addRole(@Validated @RequestBody SysRoleDO sysRoleDO) &#123;\n        sysRoleDO.setCreateTime(LocalDateTime.now());\n        sysRoleDO.setUpdateTime(LocalDateTime.now());\n        sysRoleDO.setValiFlag(Const.STATUS_ON);\n        return Result.success(&quot;添加角色成功&quot;, sysRoleService.save(sysRoleDO));\n    &#125;\n\n    @PutMapping(&quot;&#x2F;updateRole&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:role:update&#39;)&quot;)\n    public Result updateRole(@Validated @RequestBody SysRoleDO sysRoleDO) &#123;\n        sysRoleDO.setUpdateTime(LocalDateTime.now());\n        sysRoleService.updateById(sysRoleDO);\n        employeeService.clearUserAuthorityByRoleId(sysRoleDO.getRoleId());\n        return Result.success(&quot;修改角色成功&quot;);\n    &#125;\n\n    @DeleteMapping(&quot;&#x2F;deleteRole&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:role:delete&#39;)&quot;)\n    @Transactional\n    public Result deleteRole(@RequestBody RoleConditionDTO roleConditionDTO) &#123;\n\n        sysRoleService.removeByIds(roleConditionDTO.getRoleIds());\n\n        &#x2F;&#x2F; 删除中间表\n        sysEmployeeRoleService.remove(new QueryWrapper&lt;SysEmployeeRoleDO&gt;().in(&quot;role_id&quot;, roleConditionDTO.getRoleIds()));\n        sysRoleMenuService.remove(new QueryWrapper&lt;SysRoleMenuDO&gt;().in(&quot;role_id&quot;, roleConditionDTO.getRoleIds()));\n\n        &#x2F;&#x2F; 清除缓存\n        roleConditionDTO.getRoleIds().forEach(roleId -&gt; employeeService.clearUserAuthorityByRoleId(roleId));\n\n        return Result.success(&quot;删除角色成功&quot;);\n    &#125;\n\n    @PostMapping(&quot;&#x2F;assignPermissions&#x2F;&#123;roleId&#125;&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;sys:role:permission&#39;)&quot;)\n    @Transactional\n    public Result assignPermissions(@PathVariable(&quot;roleId&quot;) String roleId, @RequestBody String[] menuIds) &#123;\n        ArrayList&lt;SysRoleMenuDO&gt; sysRoleMenuDOS &#x3D; new ArrayList&lt;&gt;();\n\n        Arrays.stream(menuIds).forEach(menuId -&gt; &#123;\n            SysRoleMenuDO sysRoleMenuDO &#x3D; new SysRoleMenuDO();\n            sysRoleMenuDO.setRoleId(roleId);\n            sysRoleMenuDO.setMenuId(menuId);\n\n            sysRoleMenuDOS.add(sysRoleMenuDO);\n        &#125;);\n\n        &#x2F;&#x2F; 先删除原来的记录，再添加新的记录\n        sysRoleMenuService.remove(new QueryWrapper&lt;SysRoleMenuDO&gt;().eq(&quot;role_id&quot;, roleId));\n        sysRoleMenuService.saveBatch(sysRoleMenuDOS);\n\n        &#x2F;&#x2F; 清除缓存\n        employeeService.clearUserAuthorityByRoleId(roleId);\n        return Result.success(&quot;分配权限成功&quot;);\n    &#125;\n&#125;\n\n2. ServiceImpl 实现类。接口实现 IService 接口\n@Service\npublic class SysRoleServiceImpl extends ServiceImpl&lt;SysRoleDAO, SysRoleDO&gt; implements SysRoleService &#123;\n\n    @Resource\n    private SysRoleDAO sysRoleDAO;\n\n    @Override\n    public List&lt;String&gt; getRoleIdsByEmpId(String empId) &#123;\n        List&lt;String&gt; roleIds &#x3D; sysRoleDAO.getRoleIds(empId);\n\n        return roleIds;\n    &#125;\n\n    @Override\n    public List&lt;SysRoleDO&gt; getRoleListByRoleIds(List&lt;String&gt; roleIds) &#123;\n        return roleIds.isEmpty() ? null : sysRoleDAO.selectBatchIds(roleIds);\n    &#125;\n  \n&#125;\n\n3. Mapper\n&lt;mapper namespace&#x3D;&quot;fan.security.dao.SysRoleDAO&quot;&gt;\n\n    &lt;select id&#x3D;&quot;getRoleIds&quot; resultType&#x3D;&quot;java.lang.String&quot;&gt;\n        SELECT role_id\n        FROM sys_employee_role\n        WHERE emp_id &#x3D; #&#123;empId&#125;\n    &lt;&#x2F;select&gt;\n  \n&lt;&#x2F;mapper&gt;\n\n3.7.3 用户管理1. Controller\n@RestController\n@RequestMapping(&quot;&#x2F;employee&quot;)\npublic class EmployeeController &#123;\n\n    @Resource\n    private EmployeeService employeeService;\n\n    @Resource\n    private PasswordEncoder passwordEncoder;\n\n    @Resource\n    private SysRoleService sysRoleService;\n\n    @Resource\n    private SysEmployeeRoleService sysEmployeeRoleService;\n\n    @GetMapping(&quot;&#x2F;getEmployeeList&quot;)\n    @ApiOperation(value &#x3D; &quot;查询员工信息&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;employee:list&#39;)&quot;)\n    public Result getEmployeeList(EmployeeConditionDTO conditionDTO)&#123;\n        Page&lt;EmployeeDTO&gt; employeeDTOS &#x3D; employeeService.getEmployeeList(conditionDTO);\n\n        employeeDTOS.getRecords().forEach(employeeDTO -&gt; &#123;\n            List&lt;String&gt; roleIds &#x3D; sysRoleService.getRoleIdsByEmpId(employeeDTO.getEmpId());\n            employeeDTO.setRoleIds(roleIds);\n            employeeDTO.setSysRoleDOS(sysRoleService.getRoleListByRoleIds(roleIds));\n        &#125;);\n        return Result.success(&quot;查询员工信息成功&quot;, employeeDTOS);\n    &#125;\n\n    @PutMapping(&quot;&#x2F;updateEmployee&quot;)\n    @ApiOperation(value &#x3D; &quot;修改员工信息&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;employee:update&#39;)&quot;)\n    public Result updateEmployee(@RequestBody EmployeeDTO employeeDTO)&#123;\n        return Result.success(&quot;修改员工成功&quot;, employeeService.updateEmployee(employeeDTO));\n    &#125;\n\n    @PostMapping(&quot;&#x2F;assignRoles&#x2F;&#123;empId&#125;&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;employee:role&#39;)&quot;)\n    public  Result assignRoles(@PathVariable(&quot;empId&quot;) String empId, @RequestBody String[] roleIds) &#123;\n        ArrayList&lt;SysEmployeeRoleDO&gt; sysEmployeeRoleDOS &#x3D; new ArrayList&lt;&gt;();\n\n        Arrays.stream(roleIds).forEach(roleId -&gt; &#123;\n            SysEmployeeRoleDO sysEmployeeRoleDO &#x3D; new SysEmployeeRoleDO();\n            sysEmployeeRoleDO.setEmpId(empId);\n            sysEmployeeRoleDO.setRoleId(roleId);\n\n            sysEmployeeRoleDOS.add(sysEmployeeRoleDO);\n        &#125;);\n\n        sysEmployeeRoleService.remove(new QueryWrapper&lt;SysEmployeeRoleDO&gt;().eq(&quot;emp_id&quot;, empId));\n        sysEmployeeRoleService.saveBatch(sysEmployeeRoleDOS);\n        &#x2F;&#x2F; 清除缓存\n        EmployeeDO employeeDO &#x3D; employeeService.getEmpById(empId);\n        employeeService.clearUserAuthority(employeeDO.getEmpName());\n\n        return Result.success(&quot;分配角色成功&quot;);\n    &#125;\n\n    @PostMapping(&quot;&#x2F;resetPassword&quot;)\n    @PreAuthorize(&quot;hasAuthority(&#39;employee:resetPassword&#39;)&quot;)\n    public Result resetPassword(@RequestBody String empId) &#123;\n        EmployeeDO employeeDO &#x3D; employeeService.getEmpById(empId);\n        employeeDO.setPassword(passwordEncoder.encode(\n                employeeDO.getIdcardNo().substring(employeeDO.getIdcardNo().length() - 6)));\n\n        return Result.success(&quot;重置密码成功&quot;, employeeService.resetPassword(employeeDO));\n    &#125;\n\n    @GetMapping(&quot;&#x2F;getEmpByName&quot;)\n    public Result getEmpByName(String empName) &#123;\n\n        return Result.success(&quot;通过用户名查询员工成功&quot;, employeeService.getEmpByName(empName));\n    &#125;\n&#125;\n\n2. ServiceImpl 实现类。接口实现 IService 接口\n@Service\npublic class EmployeeServiceImpl implements EmployeeService &#123;\n\n    @Resource\n    private EmployeeDAO employeeDAO;\n\n    @Resource\n    private EmployeeDTOConvert employeeDTOConvert;\n\n    @Resource\n    private SysMenuService sysMenuService;\n\n    @Resource\n    private RedisUtil redisUtil;\n\n    @Override\n    public Page&lt;EmployeeDTO&gt; getEmployeeList(EmployeeConditionDTO conditionDTO) &#123;\n\n        QueryWrapper&lt;EmployeeDO&gt; employeeDOQueryWrapper &#x3D; new QueryWrapper&lt;&gt;();\n\n        if (!StringUtils.isBlank(conditionDTO.getEmpName())) &#123;\n            employeeDOQueryWrapper.like(&quot;emp_name&quot;, conditionDTO.getEmpName());\n        &#125;\n        if (!StringUtils.isBlank(conditionDTO.getEmpCode())) &#123;\n            employeeDOQueryWrapper.eq(&quot;emp_code&quot;, conditionDTO.getEmpCode());\n        &#125;\n        if (conditionDTO.getValiFlag() !&#x3D; null) &#123;\n            employeeDOQueryWrapper.eq(&quot;vali_flag&quot;, conditionDTO.getValiFlag());\n        &#125;\n\n        Page&lt;EmployeeDO&gt; page &#x3D; new Page&lt;&gt;(conditionDTO.getPageNum(), conditionDTO.getPageSize());\n        Page&lt;EmployeeDO&gt; employeeDOPage &#x3D; employeeDAO.selectPage(page, employeeDOQueryWrapper);\n\n        Page&lt;EmployeeDTO&gt; employeeDTOPage &#x3D; new Page&lt;&gt;();\n        List&lt;EmployeeDTO&gt; employeeDTOS &#x3D; new ArrayList&lt;&gt;();\n        if (!ObjectUtils.isEmpty(employeeDOPage.getRecords())) &#123;\n            employeeDOPage.getRecords().stream().forEach(employeeDO -&gt; employeeDTOS.add(employeeDTOConvert.convertToEmployeeDTO(employeeDO)));\n        &#125;\n\n        BeanUtils.copyProperties(employeeDOPage, employeeDTOPage);\n        employeeDTOPage.setRecords(employeeDTOS);\n        return employeeDTOPage;\n    &#125;\n\n    @Override\n    public Integer updateEmployee(EmployeeDTO employeeDTO) &#123;\n        EmployeeDO employeeDO &#x3D; employeeDTOConvert.convertToEmployeeDO(employeeDTO);\n        employeeDO.setUpdateTime(LocalDateTime.now());\n\n        return employeeDAO.updateById(employeeDO);\n    &#125;\n\n    @Override\n    public Integer resetPassword(EmployeeDO employeeDO) &#123;\n        employeeDO.setUpdateTime(LocalDateTime.now());\n\n        return employeeDAO.updateById(employeeDO);\n    &#125;\n\n    @Override\n    public EmployeeDO getEmpByName(String empName) &#123;\n        return employeeDAO.selectOne(new QueryWrapper&lt;EmployeeDO&gt;().eq(&quot;emp_name&quot;, empName));\n    &#125;\n\n    @Override\n    public EmployeeDO getEmpById(String empId) &#123;\n        return employeeDAO.selectById(empId);\n    &#125;\n\n    @Override\n    public EmployeeDTO getEmpByCode(String username) &#123;\n        QueryWrapper&lt;EmployeeDO&gt; queryWrapper &#x3D; new QueryWrapper&lt;EmployeeDO&gt;().eq(&quot;emp_code&quot;, username);\n        EmployeeDO employeeDO &#x3D; employeeDAO.selectOne(queryWrapper);\n        if (employeeDO &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125; else &#123;\n            EmployeeDTO employeeDTO &#x3D; employeeDTOConvert.convertToEmployeeDTO(employeeDO);\n            return employeeDTO;\n        &#125;\n    &#125;\n\n    @Override\n    public String getAuthority(String empId) &#123;\n\n        String authority &#x3D; &quot;&quot;;\n\n        &#x2F;&#x2F; 获取角色列表\n        List&lt;SysRoleDO&gt; sysRoleDOS &#x3D; employeeDAO.getAuthority(empId);\n        if (sysRoleDOS.size() &gt; 0) &#123;\n            String roleCodes &#x3D; sysRoleDOS.stream().map(sysRoleDO -&gt; &quot;ROLE_&quot; + sysRoleDO.getCode()).collect(Collectors.joining(&quot;,&quot;));\n            authority &#x3D; roleCodes.concat(&quot;,&quot;);\n        &#125;\n\n        &#x2F;&#x2F; 获取菜单权限列表\n        List&lt;String&gt; navMenuIds &#x3D; sysMenuService.getNavMenuIds(empId);\n        if (navMenuIds.size() &gt; 0) &#123;\n            List&lt;SysMenuDO&gt; sysMenuDOS &#x3D; sysMenuService.list(new QueryWrapper&lt;SysMenuDO&gt;().eq(&quot;vali_flag&quot;, 1).in(&quot;menu_id&quot;, navMenuIds));\n            String permissions &#x3D; sysMenuDOS.stream().map(sysMenuDO -&gt; sysMenuDO.getPermission()).collect(Collectors.joining(&quot;,&quot;));\n            authority &#x3D; authority.concat(permissions);\n        &#125;\n        return authority;\n    &#125;\n\n    @Override\n    public void clearUserAuthority(String username) &#123;\n        redisUtil.del(&quot;GrantedAuthority:&quot; + username);\n    &#125;\n\n    @Override\n    public void clearUserAuthorityByRoleId(String roleId) &#123;\n        List&lt;String&gt; empIds &#x3D; employeeDAO.getEmpIdsByRoleId(roleId);\n        if (empIds.size() &gt; 0) &#123;\n            employeeDAO.selectBatchIds(empIds).forEach(employeeDO -&gt; &#123;\n                System.out.println(&quot;根据角色Id清除用户权限缓存，姓名为：&quot; + employeeDO.getEmpName());\n                clearUserAuthority(employeeDO.getEmpName());\n            &#125;);\n        &#125;\n    &#125;\n\n    @Override\n    public void clearUserAuthorityByMenuId(String menuId) &#123;\n        employeeDAO.getEmpsByMenuId(menuId).forEach(employeeDO -&gt; &#123;\n            if (employeeDO !&#x3D; null) &#123;\n                System.out.println(&quot;根据菜单Id清除用户权限缓存，姓名为：&quot; + employeeDO.getEmpName());\n                clearUserAuthority(employeeDO.getEmpName());\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n3. Mapper\n&lt;mapper namespace&#x3D;&quot;fan.employee.dao.EmployeeDAO&quot;&gt;\n    &lt;update id&#x3D;&quot;deleteEmployee&quot;&gt;\n        UPDATE employee\n        SET vali_flag &#x3D; &#39;0&#39;\n        WHERE emp_id in\n        &lt;foreach item&#x3D;&quot;item&quot; collection&#x3D;&quot;list&quot; index&#x3D;&quot;index&quot; open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;\n            #&#123;item&#125;\n        &lt;&#x2F;foreach&gt;\n    &lt;&#x2F;update&gt;\n    &lt;select id&#x3D;&quot;getAuthority&quot; resultType&#x3D;&quot;fan.security.entity.SysRoleDO&quot;&gt;\n        SELECT *\n        FROM sys_role\n        WHERE role_id in (\n            SELECT role_id\n            FROM sys_employee_role\n            WHERE emp_id &#x3D; #&#123;empId&#125;\n        ) and vali_flag &#x3D; &#39;1&#39;\n    &lt;&#x2F;select&gt;\n    &lt;select id&#x3D;&quot;getEmpIdsByRoleId&quot; resultType&#x3D;&quot;java.lang.String&quot;&gt;\n        SELECT emp_id\n        FROM sys_employee_role\n        WHERE role_id &#x3D; #&#123;roleId&#125;\n    &lt;&#x2F;select&gt;\n    &lt;select id&#x3D;&quot;getEmpsByMenuId&quot; resultType&#x3D;&quot;fan.employee.entity.EmployeeDO&quot;&gt;\n        SELECT DISTINCT employee.*\n        FROM sys_employee_role\n                 LEFT JOIN &#96;sys_role_menu&#96; ON sys_role_menu.role_id &#x3D; sys_employee_role.role_id\n                 LEFT JOIN &#96;employee&#96; ON employee.emp_id &#x3D; sys_employee_role.emp_id\n        WHERE sys_role_menu.menu_id &#x3D; #&#123;menuId&#125;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n","slug":"BlogRepository/开发实践/Spring Security + Vue2 + Element-UI 总结","date":"2022-05-08T20:03:09.000Z","categories_index":"开发实践","tags_index":"Spring","author_index":"凡"},{"id":"39438e0eff462191bb311410e951b530","title":"Redis 序列化规则及重定义","content":"1. JdkSerializationRedisSerializerRestTemplate 默认的序列化方式，当存储时 Key 会变成一串字符串\n\n优点反序列化时不需要提供类型信息(class)，\n缺点\n需要实现Serializable接口\n存储的为二进制数据\n序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存\n\n\n\n2. StringRedisSerializerStringRedisTemplate 默认的序列化方式，key 和 Value 都会采用此方式进行序列化，是被推荐使用的，对开发者友好，轻量级，效率也比较高\n3. GenericToStringSerializer需要调用者给传一个对象到字符串互转的 Converter\n4. Jackson2JsonRedisSerializer\n优点速度快，序列化后的字符串短小精悍，不需要实现 Serializable 接口\n缺点此类的构造函数中有一个类型参数，必须提供要序列化对象的类型信息(.class对象），其在反序列化过程中用到了类型信息\n\n一般传入的都是 Object.class 类型。假如存储的是带泛型的 List 对象，序列化带泛型的数据时，会以 Map 的结构进行存储；进行反序列化时不能将 Map 解析成对象，从 Redis 获取的值为 LinkedHashMap 类型，此时进行转换的话会报错（可以使用 GenericJackson2JsonRedisSerializer 解决这个问题）\nRedisTemplate 的 Key 序列化规则为 StringRedisSerializer，Value 的序列化规则为 Jackson2JsonRedisSerializer\n@Configuration\npublic class RedisConfig &#123;\n\n    @Bean\n    RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        RedisTemplate redisTemplate &#x3D; new RedisTemplate();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n\n        StringRedisSerializer stringRedisSerializer &#x3D; new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);\n\n        redisTemplate.setDefaultSerializer(jackson2JsonRedisSerializer);\n\n        redisTemplate.setKeySerializer(stringRedisSerializer);\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n  \n        return redisTemplate;\n    &#125;\n&#125;\n\n\n5. GenericJackson2JsonRedisSerializer与 Jackson2JsonRedisSerializer 大致相同，但会额外存储序列化对象的包命和类名，反序列化时以这个作为标识就可以反序列化成指定的对象\nRedisTemplate 的 Key 序列化规则为 StringRedisSerializer，Value 的序列化规则为 GenericJackson2JsonRedisSerializer\n@Configuration\npublic class RedisConfig &#123;\n\n    @Bean\n    RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        RedisTemplate redisTemplate &#x3D; new RedisTemplate();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n\n        StringRedisSerializer stringRedisSerializer &#x3D; new StringRedisSerializer();\n        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer &#x3D; new GenericJackson2JsonRedisSerializer();\n\n        &#x2F;&#x2F; 配置序列化\n        redisTemplate.setDefaultSerializer(genericJackson2JsonRedisSerializer);\n\n        redisTemplate.setKeySerializer(stringRedisSerializer);\n        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);\n\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);\n\n        return redisTemplate;\n    &#125;\n&#125;\n","slug":"BlogRepository/Redis/Redis 序列化规则及重定义","date":"2022-05-03T22:56:01.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"凡"},{"id":"245a7be88615344e5adce1986b47a4ce","title":"MyBatis-Plus 使用总结","content":"1. POM 依赖&lt;!-- mybatis-plus --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.5.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- mybatis-plus-generator 生成器--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mybatis-plus-generator&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.5.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- freemarker 模板引擎--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-freemarker&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;2.6.7&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2. YML 配置mybatis-plus:\n  mapper-locations: classpath*:&#x2F;mapper&#x2F;**Mapper.xml\n  configuration:\n    local-cache-scope: statement\n\n3. MybatisPlusConfig 配置类配置分页插件以及全表更新删除插件\n@Configuration\n@MapperScan(&quot;fan.**.dao&quot;)\npublic class MybatisPlusConfig &#123;\n\n\t@Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;\n        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();\n        &#x2F;&#x2F; 添加分页插件\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n        &#x2F;&#x2F; 添加全表更新删除插件\n        interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());\n        return interceptor;\n    &#125;\n&#125;\n\n4. CodeGenerator 代码生成\n获取项目数据库所对应表和字段的信息（information_schema 数据库的 TABLES 和 COLUMNS）\n# 获取表\nSELECT *\nFROM information_schema. TABLES\nWHERE TABLE_SCHEMA &#x3D; (SELECT DATABASE());\n# 获取字段\nSELECT *\nFROM information_schema. COLUMNS\nWHERE TABLE_SCHEMA &#x3D; (SELECT DATABASE()) AND TABLE_NAME &#x3D; &quot;sys_user&quot;;\n使用生成器的模板新建一个 freemarker（模板引擎）的页面模板 - SysUser.java.ftl - ${baseEntity}\n\n提供相关需要进行渲染的动态数据 - BaseEntity、表字段、注释、baseEntity&#x3D;SuperEntity\n\n使用 freemarker 模板引擎进行渲染 - SysUser.java\n\n\npublic class CodeGenerator &#123;\n\n    private static final DataSourceConfig.Builder DATA_SOURCE_CONFIG &#x3D; new DataSourceConfig\n            .Builder(&quot;jdbc:mysql:&#x2F;&#x2F;124.222.118.90:3306&#x2F;enterprise_hrms?connectTimeout&#x3D;5000&amp;socketTimeout&#x3D;10000&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;GMT%2B8&quot;, &quot;root&quot;, &quot;fan223&quot;);\n\n    public static void main(String[] args) &#123;\n        FastAutoGenerator.create(DATA_SOURCE_CONFIG)\n                &#x2F;&#x2F; 全局配置\n                .globalConfig((scanner, builder) -&gt; builder.author(scanner.apply(&quot;请输入作者名称&quot;)).enableSwagger())\n                &#x2F;&#x2F; 包配置\n                .packageConfig((scanner, builder) -&gt; builder.parent(scanner.apply(&quot;请输入包名&quot;)))\n                &#x2F;&#x2F; 策略配置\n                .strategyConfig((scanner, builder) -&gt; builder.addInclude(scanner.apply(&quot;请输入表名，多个表名用,隔开&quot;)))\n                &#x2F;&#x2F; 模板配置\n                .templateEngine(new FreemarkerTemplateEngine())\n                .execute();\n    &#125;\n&#125;\n\n详细配置信息：https://baomidou.com/pages/981406/\n生成如下：Service\npublic interface SysMenuService extends IService&lt;SysMenuDO&gt; &#123;\n\n&#125;\n\nServiceImpl\n@Service\npublic class SysMenuServiceImpl extends ServiceImpl&lt;SysMenuDAO, SysMenuDO&gt; implements SysMenuService &#123;\n\n&#125;\n\nDAO\npublic interface SysMenuDAO extends BaseMapper&lt;SysMenuDO&gt; &#123;\n\n&#125;\n\n5. 使用分页前提先要配置分页插件，否则无效\npublic Page&lt;EmployeeDTO&gt; getEmployeeList(ConditionDTO conditionDTO) &#123;\n\n        QueryWrapper&lt;EmployeeDO&gt; queryWrapper &#x3D; new QueryWrapper&lt;&gt;();\n\n\t\t&#x2F;&#x2F; 创建一个 Page，传入当前页和页面大小\n        Page&lt;EmployeeDO&gt; page &#x3D; new Page&lt;&gt;(conditionDTO.getPageNum(), conditionDTO.getPageSize());\n        &#x2F;&#x2F; 调用 selectPage() 方法，返回一个 Page 对象\n        Page&lt;EmployeeDO&gt; employeeDOPage &#x3D; employeeDAO.selectPage(page, queryWrapper);\n\n\t\t&#x2F;&#x2F; 转换为 DTO\n        ......\n        return employeeDTOPage;\n    &#125;\n\n返回结果如下所示：current 表示当前页，size 表示单页最大数量，total 表示总数，pages 表示页面数，records 表示数据。\n6. in 的使用在 Mybatis-Plus 中，当传入参数为 list 集合的时候，会自动把其封装为一个 map，以 “list” 作为 key，每个元素的值作为 value，格式为 Map&lt;”list”, value&gt;。当传入参数为数组的时候会自动把其封装为一个 map，以 “array” 作为 key，每个元素的值作为 value，格式为 Map&lt;&quot;array&quot;, value&gt;\npublic interface EmployeeDAO extends BaseMapper&lt;EmployeeDO&gt; &#123;\n\n    void deleteEmployee(List&lt;String&gt; empIds);\n&#125;\n\n正确写法：\n&lt;update id&#x3D;&quot;deleteEmployee&quot;&gt;\n\tUPDATE employee\n\tSET vali_flag &#x3D; &#39;0&#39;\n\tWHERE emp_id in\n\t&lt;foreach item&#x3D;&quot;item&quot; collection&#x3D;&quot;list&quot; index&#x3D;&quot;index&quot; open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;\n\t\t#&#123;item&#125;\n\t&lt;&#x2F;foreach&gt;\n&lt;&#x2F;update&gt;\n\n错误写法\n&lt;update id&#x3D;&quot;deleteEmployee&quot;&gt;\n\tUPDATE employee\n\tSET vali_flag &#x3D; &#39;0&#39;\n\tWHERE emp_id in\n\t&lt;foreach item&#x3D;&quot;item&quot; collection&#x3D;&quot;empIds&quot; index&#x3D;&quot;index&quot; open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;\n\t\t#&#123;item&#125;\n\t&lt;&#x2F;foreach&gt;\n&lt;&#x2F;update&gt;\n","slug":"BlogRepository/开发技术及框架/MyBatis-Plus 使用总结","date":"2022-05-03T04:47:04.000Z","categories_index":"开发技术及框架","tags_index":"MyBatis-Plus","author_index":"凡"},{"id":"1fa3d488b05424ad20d9fbd33108a055","title":"Java基础总结回顾","content":"1. 说明1.1 编译与运行\n编译：是指将编写的 Java 源文件翻译成 JVM 认识的 class 文件，在这个过程中， javac 编译器会检查所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功\n运行：是指将 class文件 交给 JVM 去运行，此时 JVM 会去执行编写的程序\n\n1.2 main 方法主方法，写法是固定格式不可以更改。main 方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从 main 方法这里开始执行\n1.3 keywords  关键字指在程序中，Java 已经定义好的单词，具有特殊含义。如 public 、class 、static 、void 等，这些单词已经被 Java 定义好，全部都是小写字母\n1.4 标识符指在程序中，自己定义的内容，如类的名字、方法的名字和变量的名字等等命名规则： 硬性要求\n\n标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线）\n标识符不能以数字开头\n标识符不能是关键字\n\n命名规范： 软性建议\n\n类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）\n方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）\n变量名规范：全部小写\n\n2. 常量、变量、数据类型、运算符2.1 常量是指在 Java 程序中固定不变的数据\n2.2 变量常量是固定不变的数据，那么在程序中可以变化的量称为变量，Java 中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型\n变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值\n数据类型 变量名 &#x3D; 数据值;\n\n变量名称：在同一个大括号范围内，变量的名字不可以相同变量赋值：定义的变量，不赋值不能使用\n2.3 数据类型Java的数据类型分为两大类：\n\n基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔\n引用数据类型：包括 类 、 数组 、 接口\n\n四类八种基本数据类型：\n2.4 数据类型转换Java 程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换\n2.4.1 自动转换将 取值范围小的类型 自动提升为 取值范围大的类型，byte、short、char 运算时直接提升为 int\npublic static void main(String[] args) &#123;\n\tbyte a &#x3D; 1;\n\tint b &#x3D; a + 1;\n\tSystem.out.println(b);\n&#125;\n\n\n2.4.2 强制转换将 取值范围大的类型 强制转换成 取值范围小的类型 。自动转换是 Java 自动执行的，而强制转换需要自己手动执行\n数据类型 变量名 &#x3D; （数据类型）被转数据值;\n\n&#x2F;&#x2F; double 类型数据强制转成 int 类型，直接去掉小数点\nint i &#x3D; (int)1.5;\n\npublic static void main(String[] args) &#123;\n\t&#x2F;&#x2F; short 类型变量，内存中 2 个字节\n\tshort s &#x3D; 1;\n\t&#x2F;*\n\t出现编译失败\n\ts 和 1 做运算的时候，1 是 int 类型，s 会被提升为 int 类型\n\ts+1 后的结果是 int 类型，将结果在赋值会 short 类型时发生错误\n\tshort 内存 2 个字节，int 类型 4 个字节\n\t必须将 int 强制转成 short 才能完成赋值\n\t*&#x2F;\n\ts &#x3D; s + 1; &#x2F;&#x2F; 编译失败\n\ts &#x3D; (short)(s+1); &#x2F;&#x2F; 编译成功\n&#125;\n\n\n\n浮点转成整数，直接取消小数点，可能造成数据损失精度\nint 强制转成 short 砍掉2个字节，可能造成数据丢失\n\n2.5 运算符2.5.1 位运算符\n2.5.2 赋值运算符\n2.5.3 三元运算符数据类型 变量名 &#x3D; 布尔类型表达式？结果1：结果2;\n\n2.5.4 instanceof该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）\n(Object reference variable) instanceof  (class&#x2F;interface type);\nObject name &#x3D; &quot;James&quot;;\nObject age &#x3D; 17;\nboolean resultName &#x3D; name instanceof String; &#x2F;&#x2F; 由于 name 是 String 类型，所以返回 true\nboolean resultAge &#x3D; age instanceof String; &#x2F;&#x2F; 由于 age 是 Integer 类型，所以返回 false\n\n其中左边 obj 为一个对象，右边 Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果 result 都返回 true，否则返回false。\n注：编译器会检查 obj 是否能转换成右边的 Class 类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\n2.5.5 运算符优先级\n3. 数组3.1 概念存储数据长度固定的容器，保证多个数据的数据类型要一致，数组有定长特性，长度一旦指定，不可更改\n1. 数组存储的数据类型[] 数组名字 &#x3D; new 数组存储的数据类型[长度];\n2. 数据类型[] 数组名 &#x3D; new 数据类型[]&#123;元素1,元素2,元素3...&#125;;\n3. 数据类型[] 数组名 &#x3D; &#123;元素1,元素2,元素3...&#125;;\n\n3.2 数组内存图3.2.1 内存概述内存是计算机中的重要原件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理。\n3.2.2 JVM 内存划分（简略）1.8 之后，方法区由元空间（Metaspace）取代\n3.2.3 两个独立数组内存图\n3.3 数组工具类\nArrays.sort：元素排序，会改变原数组\nArrays.toString：返回指定数组内容的字符串表示形式\nArrays.binarySearch：查找元素位置\ncontains：查找元素是否存在\nArrays.equals：数组比较\nCollections.min、Collections.max：获取最大值和最小值int min &#x3D; (int) Collections.min(Arrays.asList(numbers));\nArrays.asList、addAll：数组合并List list &#x3D; new ArrayList(Arrays.asList(a));\nlist.addAll(Arrays.asList(b));\nArrays.fill：数组填充\nSystem.arraycopy：数组扩容&#x2F;复制\nretainAll： 数组交集\nremoveAll：数组差集\n\n4. 类与对象、封装、继承、多态4.1 类与对象类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物\n\n属性：就是该事物的状态信息，成员变量：对应事物的属性，有默认值\n行为：就是该事物能够做什么， 成员方法：对应事物的行为\n\n对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为\n类与对象的关系：\n\n类是对一类事物的描述，是抽象的\n对象是一类事物的实例，是具体的\n类是对象的模板，对象是类的实体\n\n4.2 成员变量和局部变量区别\n在类中的位置不同：成员变量：类中，方法外；局部变量：方法中或者方法声明上(形式参数)\n作用范围不一样：成员变量：类中；局部变量：方法中\n初始化值的不同： 成员变量：有默认值；局部变量：没有默认值。必须先定义，赋值，最后使用\n在内存中的位置不同： 成员变量：堆内存；局部变量：栈内存\n生命周期不同： 成员变量：随着对象的创建而存在，随着对象的消失而消失；局部变量：随着方法的调用而存在，随着方法的调用完毕而消失\n\n4.3 封装 private面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装用来防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。\n将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问，this 代表当前对象的引用(谁调用就代表谁)\n4.4 继承 super多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。多个类可以称为子类，单独那一个类称为父类、超类（superclass）或者基类。\n子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为\n4.5 继承之后的属性和行为\n子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量。super，代表父类的存储空间标识(可以理解为父亲的引用)\n子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。子类方法覆盖父类方法，必须要保证权限大于等于父类权限\n构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用\nJava只支持单继承，不支持多继承\n\n4.6 抽象类 abstract把没有方法主体的方法称为抽象方法。该方法的具体实现由子类提供。Java语法规定，如果一个类包含抽象方法，那么该类必须是抽象类\n修饰符 abstract 返回值类型 方法名 (参数列表)；\n\n继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。\n4.7 多态是指同一行为，具有多个不同表现形式\n父类类型 变量名 &#x3D; new 子类对象；\n变量名.方法名();\n\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法\n4.8 引用类型转换4.8.1 向上转型多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。\n父类类型 变量名 &#x3D; new 子类类型();\n\n4.8.2 向下转型父类类型向子类类型向下转换的过程，这个过程是强制的\n子类类型 变量名 &#x3D; (子类类型) 父类变量名;\n\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。想要调用子类特有的方法，必须做向下转型。可以使用 instanceof 关键字，给引用变量做类型的校验\n5. 修饰符、内部类5.1 修饰符5.1.1 权限修饰符\n5.1.2 finalfinal： 不可改变。可以用于修饰类、方法和变量\n\nfinal 变量：变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值\nfinal 方：父类中的 final 方法可以被子类继承，但是不能被子类重写\nfinal 类：final 类不能被继承，没有类能够继承 final 类的任何特性\n\n5.1.3  static\n静态变量static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。\n静态方法static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\n\n5.1.4 synchronizesynchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符\n5.1.5 transient序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型\n5.1.6 volatilevolatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值\n一个 volatile 对象引用可能是 null\npublic class MyRunnable implements Runnable&#123;\n    private volatile boolean active;\n    public void run()&#123;\n        active &#x3D; true;\n        while (active)&#123; &#x2F;&#x2F; 第一行\n            &#x2F;&#x2F; 代码\n        &#125;\n    &#125;\n    public void stop()&#123;\n        active &#x3D; false; &#x2F;&#x2F; 第二行\n    &#125;\n&#125;\n&#x2F;* 通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），\n在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，\n那么在 第二行 的 active 值为 false 时循环不会停止。\n但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。\n*&#x2F;\n\n5.2 内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类\n5.2.1 成员内部类定义在类中方法外的类\nclass 外部类 &#123;\n\tclass 内部类&#123;\n\t&#125;\n&#125;\n\n内部类可以直接访问外部类的成员，包括私有成员。外部类要访问内部类的成员，必须要建立内部类的对象。\n外部类名.内部类名 对象名 &#x3D; new 外部类型().new 内部类型()；\n\n5.2.2  匿名内部类内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象，匿名内部类必须继承一个父类或者实现一个父接口\nnew 父类名或者接口名()&#123;\n\t&#x2F;&#x2F; 方法重写\n\t@Override\n\tpublic void method() &#123;\n\t\t&#x2F;&#x2F; 执行语句\n\t&#125;\n&#125;;\n\n6. String 类、Math 类、Collections 类6.1 String 类字符串不变：字符串的值在创建后不能被更改\n\npublic boolean equals (Object anObject) ：将此字符串与指定对象进行比较\npublic boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写\ncompareTo、compareToIgnoreCase：字符串比较\nregionMatches：比较字符串区域相等\npublic int length () ：返回此字符串的长度\npublic String concat (String str)、+ ：将指定的字符串连接到该字符串的末尾\npublic char charAt (int index) ：返回指定索引处的 char值\npublic int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引\npublic String substring (int beginIndex) ：返回一个子字符串，从 beginIndex 开始截取字符串到字符串结尾\npublic String substring (int beginIndex, int endIndex) ：返回一个子字符串，从 beginIndex 到 endIndex 截取字符串。含 beginIndex，不含 endIndex\npublic char[] toCharArray () ：将此字符串转换为新的字符数组\npublic byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组\npublic String replace (CharSequence target, CharSequence replacement) 、replaceFirst、replaceAll：将与 target 匹配的字符串使用 replacement 字符串替换\npublic String[] split(String regex) ：将此字符串按照给定的 regex（规则）拆分为字符串数组\nStringBuffer.reverse：字符串反转\ndelete（StringBuffer）：字符串删除\npublic boolean startsWith(String prefix)  ：判断是否以某字符串开头\n\n6.2 Math类\npublic static double abs(double a) ：返回 double 值的绝对值\npublic static double ceil(double a) ：返回大于等于参数的最小的整数\npublic static double floor(double a) ：返回小于等于参数最大的整数\npublic static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)\n\n6.3 Collections 类\n排序\n查找，替换操作\n同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)\n\n排序操作\nvoid reverse(List list)&#x2F;&#x2F;反转\nvoid shuffle(List list)&#x2F;&#x2F;随机排序\nvoid sort(List list)&#x2F;&#x2F;按自然排序的升序排序\nvoid sort(List list, Comparator c)&#x2F;&#x2F;定制排序，由Comparator控制排序逻辑\nvoid swap(List list, int i , int j)&#x2F;&#x2F;交换两个索引位置的元素\nvoid rotate(List list, int distance)&#x2F;&#x2F;旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面\n\n查找，替换操作\nint binarySearch(List list, Object key)&#x2F;&#x2F;对List进行二分查找，返回索引，注意List必须是有序的\nint max(Collection coll)&#x2F;&#x2F;根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\nint max(Collection coll, Comparator c)&#x2F;&#x2F;根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\nvoid fill(List list, Object obj)&#x2F;&#x2F;用指定的元素代替指定list中的所有元素\nint frequency(Collection c, Object o)&#x2F;&#x2F;统计元素出现次数\nint indexOfSubList(List list, List target)&#x2F;&#x2F;统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)\nboolean replaceAll(List list, Object oldVal, Object newVal)&#x2F;&#x2F;用新元素替换旧元素\n\n同步控制Collections 提供了多个 synchronizedXxx() 方法，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题\nHashSet，TreeSet，ArrayList, LinkedList, HashMap, TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合，但效率非常低，需要线程安全的集合类型时考虑使用 JUC 包下的并发集合\nsynchronizedCollection(Collection&lt;T&gt;  c) &#x2F;&#x2F;返回指定 collection 支持的同步（线程安全的）collection。\nsynchronizedList(List&lt;T&gt; list)&#x2F;&#x2F;返回指定列表支持的同步（线程安全的）List。\nsynchronizedMap(Map&lt;K,V&gt; m) &#x2F;&#x2F;返回由指定映射支持的同步（线程安全的）Map。\nsynchronizedSet(Set&lt;T&gt; s) &#x2F;&#x2F;返回指定 set 支持的同步（线程安全的）set。\n\n6.4 Comparator 比较器排序简单的说就是两个对象之间比较大小，在 JAVA 中提供了两种比较实现的方式，一种是比较死板的采用 java.lang.Comparable 接口去实现，一种是灵活的当我需要做排序的时候在去选择的 java.util.Comparator 接口完成\n\npublic static  void sort(List list) 这个方法完成的排序，实际上要求了被排序的类型需要实现 Comparable 接口完成比较的功能\n\npublic static  void sort(List list，Comparator&lt;? super T&gt; ) 方法灵活的完成，这个里面就涉及到了 Comparator 这个接口位于 java.util 包下，排序是 comparator 能实现的功能之一，该接口代表一个比较器，比较器具有可比性！需要比较两个对象谁排在前谁排在后：\npublic int compare(String o1, String o2) ：比较其两个参数的顺序\n\n两个对象比较的结果有三种：大于，等于，小于如果要按照升序排序， 则 o1 小于 o2，返回（负数），相等返回0，o1 大于o2返回（正数） 如果要按照降序排序 则 o1 小于 o2，返回（正数），相等返回0，o1大于o2返回（负数）\n\nComparable 和 Comparator 两个接口的区别\n\nComparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。只能在类中实现 compareTo() 一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过 Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器\nComparator：强行对某个对象进行整体排序。可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序\n\n\n\n7. 异常7.1 非检查性异常\n7.2 检查性异常\n7.3 异常方法\n7.4 声明自定义异常\n所有异常都必须是 Throwable 的子类\n如果希望写一个检查性异常类，则需要继承 Exception 类\n如果你想写一个运行时异常类，那么需要继承 RuntimeException 类\n\n&#x2F;&#x2F; 自定义异常类，继承Exception类\npublic class InsufficientFundsException extends Exception&#123;\n  &#x2F;&#x2F;此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱\n  private double amount;\n  public InsufficientFundsException(double amount)&#123;\n    this.amount &#x3D; amount;\n  &#125; \n  public double getAmount()&#123;\n    return amount;\n  &#125;\n&#125;\n\n7.5 通用异常\nJVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类\n程序级异常：由程序或者 API 程序抛出的异常。如 IllegalArgumentException 类，IllegalStateException 类\n\n8. 时间处理8.1 格式化时间 SimpleDateFormat、printfpublic class Main&#123;\n    public static void main(String[] args)&#123;\n        Date date &#x3D; new Date();\n        String strDateFormat &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;;\n        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(strDateFormat);\n        System.out.println(sdf.format(date)); &#x2F;&#x2F; 2015-03-27 21:13:23\n     \t&#x2F;&#x2F; printf 的使用  \n    \tSystem.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date); &#x2F;&#x2F; 星期一 九月 10 10:43:36 CST 2012\n    &#125;\n&#125;\n\n\n8.2 获取某个时间点 Calendarpublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Calendar cal &#x3D; Calendar.getInstance();\n        int day &#x3D; cal.get(Calendar.DATE);\n        int month &#x3D; cal.get(Calendar.MONTH) + 1;\n        int year &#x3D; cal.get(Calendar.YEAR);\n        int dow &#x3D; cal.get(Calendar.DAY_OF_WEEK);\n        int dom &#x3D; cal.get(Calendar.DAY_OF_MONTH);\n        int doy &#x3D; cal.get(Calendar.DAY_OF_YEAR);\n \n        System.out.println(&quot;当期时间: &quot; + cal.getTime()); &#x2F;&#x2F; Fri Mar 27 21:44:15 CST 2015\n        System.out.println(&quot;日期: &quot; + day); &#x2F;&#x2F; 27\n        System.out.println(&quot;月份: &quot; + month); &#x2F;&#x2F; 3\n        System.out.println(&quot;年份: &quot; + year); &#x2F;&#x2F; 2015\n        System.out.println(&quot;一周的第几天: &quot; + dow);  &#x2F;&#x2F; 6, 星期日为一周的第一天输出为 1，星期一输出为 2，以此类推\n        System.out.println(&quot;一月中的第几天: &quot; + dom); &#x2F;&#x2F; 27\n        System.out.println(&quot;一年的第几天: &quot; + doy); &#x2F;&#x2F; 86\n    &#125;\n&#125;\n\n8.3 LocalDateTime 代替 Calendarpublic static void main(String[] args) &#123;\n\tLocalDateTime localDateTime &#x3D; LocalDateTime.now();\n\n    System.out.println(localDateTime); &#x2F;&#x2F; 2021-12-22T08:56:53.923\n\tSystem.out.println(localDateTime.plusYears(2)); &#x2F;&#x2F; 加2年\n\tSystem.out.println(localDateTime.plusDays(2)); &#x2F;&#x2F; 加两天\n\tSystem.out.println(localDateTime.minusYears(2)); &#x2F;&#x2F; 减两年\n\tSystem.out.println(localDateTime.minusDays(2)); &#x2F;&#x2F; 减两天\n\tSystem.out.println(localDateTime.toString());    &#x2F;&#x2F; 转字符串 结果：2021-12-22T08:56:53.923\n\tSystem.out.println(localDateTime.toLocalDate()); &#x2F;&#x2F; 获取日期(LocalDate) 结果：2021-12-22\n\tSystem.out.println(localDateTime.toLocalTime()); &#x2F;&#x2F; 获取时间(LocalTime) 结果：08:56:53.923\n\tSystem.out.println(localDateTime.getDayOfMonth()); &#x2F;&#x2F; 获取当前时间月份的第几天\n\tSystem.out.println(localDateTime.getDayOfWeek());  &#x2F;&#x2F; 获取当前周的第几天\n\tSystem.out.println(localDateTime.getDayOfYear());  &#x2F;&#x2F; 获取当前时间在该年属于第几天\n\tSystem.out.println(localDateTime.getYear()); &#x2F;&#x2F; 获取当前时间的年份\n\tSystem.out.println(localDateTime.getMonthValue()); &#x2F;&#x2F; 获取当前时间的月份(阿拉伯文)\n\tSystem.out.println(localDateTime.getMonth());      &#x2F;&#x2F; 获取当前时间的月份(英文)\n\tSystem.out.println(localDateTime.getHour());       &#x2F;&#x2F; 获取当前时间的小时数\n\tSystem.out.println(localDateTime.getMinute());     &#x2F;&#x2F; 获取当前时间的分钟数\n\n\t&#x2F;&#x2F; 构造时间\n\tLocalDateTime startTime &#x3D; LocalDateTime.of(2021, 1, 1, 20, 31, 20);\n\tLocalDateTime endTime &#x3D; LocalDateTime.of(2021, 1, 3, 20, 31, 20);\n\t&#x2F;&#x2F; 比较时间\n\tSystem.out.println(localDateTime.isAfter(startTime)); &#x2F;&#x2F; 结果：true\n\tSystem.out.println(localDateTime.isBefore(endTime));  &#x2F;&#x2F; 结果：false\n\t&#x2F;&#x2F;获取毫秒数(使用 Instant)\n\tSystem.out.println(localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()); \n\t&#x2F;&#x2F;获取秒数(使用 Instant)\n    System.out.println(localDateTime.atZone(ZoneId.systemDefault()).toInstant().getEpochSecond()); \n    &#x2F;&#x2F; LocalDateTime 获取秒数\n\tLong second &#x3D; LocalDateTime.now().toEpochSecond(ZoneOffset.of(&quot;+8&quot;));\n\t&#x2F;&#x2F; LocalDateTime 获取毫秒数\n\tLong milliSecond &#x3D; LocalDateTime.now().toInstant(ZoneOffset.of(&quot;+8&quot;)).toEpochMilli();\n\t&#x2F;&#x2F; 获取本月的第一天的0点0分0秒和最后一天的23点59分59秒\n\tLocalDateTime beginMonth &#x3D; localDateTime.with(TemporalAdjusters.firstDayOfMonth()).withHour(0).withMinute(0).withSecond(0);\n\tLocalDateTime endMonth &#x3D; localDateTime.with(TemporalAdjusters.lastDayOfMonth()).withHour(23).withMinute(59).withSecond(59);\n\t&#x2F;&#x2F; LocalDateTime 转 Date\n\tDate date &#x3D; Date.from(localDateTime.toInstant(ZoneOffset.of(&quot;+8&quot;)));\n\t&#x2F;&#x2F; Date 转 LocalDateTime\n\tdate.toInstant().atOffset(ZoneOffset.of(&quot;+8&quot;)).toLocalDateTime();\n&#125;\n\n8.4 Instant 代替 Date时区需要加 8 小时\npublic static void main(String[] args) &#123;\n\tInstant instant &#x3D; Instant.now().plusMillis(TimeUnit.HOURS.toMillis(8));\n\tSystem.out.println(instant); &#x2F;&#x2F; 2021-12-22T08:59:57.491Z\n&#125;\n\n8.5 DateTimeFormatter 代替 SimopleDateFormat时间要使用 LocalDateTime\npublic static void main(String[] args) &#123;\n\tDateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n\tString format &#x3D; dtf.format(LocalDateTime.now());\n\tSystem.out.println(format); &#x2F;&#x2F; 2021-12-22 09:04:47\n&#125;\n\n8.6 日期比较\n使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值\n使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true\n使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口\n\n9. 正则、标签、finalize9.1 正则9.1.1 语法\n9.1.2 Matcher9.1.2.1 索引方法\n9.1.2.2 查找方法\nmatches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求\nlookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配\n\n\npublic class RegexMatches&#123;\n    private static final String REGEX &#x3D; &quot;foo&quot;;\n    private static final String INPUT &#x3D; &quot;fooooooooooooooooo&quot;;\n    private static final String INPUT2 &#x3D; &quot;ooooofoooooooooooo&quot;;\n    private static Pattern pattern;\n    private static Matcher matcher;\n    private static Matcher matcher2;\n \n    public static void main( String[] args )&#123;\n       pattern &#x3D; Pattern.compile(REGEX);\n       matcher &#x3D; pattern.matcher(INPUT);\n       matcher2 &#x3D; pattern.matcher(INPUT2);\n \n       System.out.println(&quot;Current REGEX is: &quot;+REGEX); &#x2F;&#x2F; foo\n       System.out.println(&quot;Current INPUT is: &quot;+INPUT); &#x2F;&#x2F; fooooooooooooooooo\n       System.out.println(&quot;Current INPUT2 is: &quot;+INPUT2); &#x2F;&#x2F; ooooofoooooooooooo\n \n       System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt()); &#x2F;&#x2F; true\n       System.out.println(&quot;matches(): &quot;+matcher.matches()); &#x2F;&#x2F; false\n       System.out.println(&quot;lookingAt(): &quot;+matcher2.lookingAt()); &#x2F;&#x2F; false\n   &#125;\n&#125;\n\n9.1.2.3 替换方法\n9.1.2.4 PatternSyntaxExceptionPatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误\n9.2 标签Java 中的标签是为循环设计的，是为了在多重循环中方便的使用 break 和coutinue\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        String strSearch &#x3D; &quot;This is the string in which you have to search for a substring.&quot;;\n        String substring &#x3D; &quot;substring&quot;;\n        boolean found &#x3D; false;\n        int max &#x3D; strSearch.length() - substring.length();\n        &#x2F;&#x2F; 标签\n        testlbl:\n        for (int i &#x3D; 0; i &lt;&#x3D; max; i++) &#123;\n            int length &#x3D; substring.length();\n            int j &#x3D; i;\n            int k &#x3D; 0;\n            while (length-- !&#x3D; 0) &#123;\n                if(strSearch.charAt(j++) !&#x3D; substring.charAt(k++))&#123;\n                    continue testlbl;\n                &#125;\n            &#125;\n            found &#x3D; true;\n            break testlbl; &#x2F;&#x2F; break 到标签位置\n        &#125;\n        if (found) &#123;\n            System.out.println(&quot;发现子字符串。&quot;);\n        &#125;\n        else &#123;\n            System.out.println(&quot;字符串中没有发现子字符串。&quot;);\n        &#125;\n    &#125;\n&#125;\n\n9.3 finalize在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。如：可以使用 finalize() 来确保一个对象打开的文件被关闭了。在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。\nprotected void finalize()&#123;\n   &#x2F;&#x2F; 在这里终结代码\n&#125;\n&#x2F;* 关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。\n当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法\n*&#x2F;\n\n10. IO10.1 IO 流\n10.2 字节流10.2.1 FileInputStream该流用于从文件读取数据，它的对象可以用关键字 new 来创建\n&#x2F;&#x2F; 可以使用字符串类型的文件名来创建一个输入流对象来读取文件\n\tInputStream is &#x3D; new FileInputStream(&quot;E:&#x2F;&#x2F;a.txt&quot;);\n&#x2F;&#x2F; 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象\n    File file &#x3D; new File(&quot;E:&#x2F;&#x2F;a.txt&quot;);\n    InputStream in &#x3D; new FileInputStream(file);\n\tint len &#x3D; 0;\n    while ((len &#x3D; fis.read()) !&#x3D; -1)&#123;\n    \tSystem.out.println(len); &#x2F;&#x2F; 228 189 160 229 165 189\n    &#125;\n\tbyte[] bytes &#x3D; new byte[1024];\n\tint len &#x3D; 0;\n\twhile ((len &#x3D; fis.read(bytes)) !&#x3D; -1)&#123;\n\t\tSystem.out.println(new String(bytes,0,len)); &#x2F;&#x2F; 你好...\n\t&#125;\n\tfis.close();\n\n\n10.2.2 FileOutputStream该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件\n&#x2F;&#x2F; 使用字符串类型的文件名来创建一个输出流对象\n\tOutputStream os &#x3D; new FileOutputStream(&quot;E:&#x2F;&#x2F;b.txt&quot;);\n&#x2F;&#x2F; 使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象\n    File file &#x3D; new File(&quot;E:&#x2F;&#x2F;a.txt&quot;);\n    OutputStream os &#x3D; new FileOutputStream(file);\n\tos.write(97); &#x2F;&#x2F; a\n\tbyte[] bytes &#x3D; &#123;65,66,67,68,69&#125;;\n\tos.write(bytes); &#x2F;&#x2F; ABCDE\n\tos.write(&quot;你好&quot;.getBytes()); &#x2F;&#x2F; 你好\n\tos.close();\n\n\n10.3 字符流10.3.1 FileReaderFileReader fr &#x3D; new FileReader(&quot;E:&#x2F;&#x2F;a.txt&quot;);\nchar[] chars &#x3D; new char[1024];\nint len &#x3D; 0;\nwhile ((len &#x3D; fr.read(chars)) !&#x3D; -1)&#123;\n\tSystem.out.println(new String(chars,0,len)); &#x2F;&#x2F; 你好...\n&#125;\nfr.close();\n\n10.3.2 FileWriterFileWriter fw &#x3D; new FileWriter(&quot;E:&#x2F;&#x2F;a.txt&quot;);\nFileWriter fw &#x3D; new FileWriter(&quot;E:&#x2F;&#x2F;a.txt&quot;,true); &#x2F;&#x2F; 续写开关 true:不会创建新的文件覆盖源文件,可以续写\nchar[] chars &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125;;\nfw.write(chars); &#x2F;&#x2F; abcd\nfw.write(&quot;你好&quot;); &#x2F;&#x2F; abcd你好\nfw.flush();\nfw.close();\n\n10.4 缓冲流&#x2F;&#x2F; 写入文件\nBufferedWriter out &#x3D; new BufferedWriter(new FileWriter(&quot;E:&#x2F;&#x2F;runoob.txt&quot;));\nout.write(&quot;菜鸟教程&quot;);\nout.close();\n&#x2F;&#x2F; 读取文件\nBufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;E:&#x2F;&#x2F;runoob.txt&quot;));\nString str;\nwhile ((str &#x3D; br.readLine()) !&#x3D; null)&#123;\n\tSystem.out.println(str); &#x2F;&#x2F; 菜鸟教程\n&#125;\n\n11. Collection11.1 集合框架Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：\n\n接口： 是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象\n实现（类）： 是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap\n算法： 是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现\n\n\n11.2 集合接口Set 和 List 的区别：\n\nSet 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素\nSet 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;\nList 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt;\n\n\n11.3 集合实现类java.util 包中定义的类：\n10.4 遍历推荐使用 entrySet 和 forEach 方法\npublic static void main(String[] args) &#123;\n\tMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(16);\n\tmap.put(&quot;张三&quot;,&quot;13&quot;);\n\tmap.put(&quot;李四&quot;,&quot;14&quot;);\n\tmap.put(&quot;王五&quot;,&quot;16&quot;);\n\tmap.put(&quot;赵六&quot;,&quot;13&quot;);\n\tfor (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;\n\t\tSystem.out.println(entry.getKey() + &quot; &quot; + entry.getValue());\n\t&#125;\n\tmap.forEach((key,value) -&gt; &#123;\n\t\tSystem.out.println(key + &quot; &quot; + value);\n\t&#125;);\n&#125;\n\n11.5 允许空值情况\n11.6 ArrayList\n11.7 LinkedListJava LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。以下情况使用 ArrayList :\n\n频繁访问列表中的某一个元素\n只需要在列表末尾进行添加和删除元素操作\n\n以下情况使用 LinkedList :\n\n你需要通过循环迭代来访问列表中的某些元素\n需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作\n\n11.8 HashMap进阶部分见：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;123276268\n","slug":"BlogRepository/Java/Java基础总结回顾","date":"2022-04-12T09:31:14.000Z","categories_index":"Java","tags_index":"Java","author_index":"凡"},{"id":"785e31ee7915429fd9b18ba85be30b4c","title":"VSCode 常用插件及配置使用","content":"1. 常用插件\nBracket Pair Colorizer 2\nDebugger for Chrome\nAuto Close Tag\nAuto Rename Tag\nBeautify\nESLint\nJava extension pack：Java 相关包大全\nGitHub Copilot\nHTML CSS Support\nHTML Snippets\nJavaScript (ES6) code snippets\nLive Server：可以将 html 网页用一个虚拟服务器打开\nMaterial Icon Theme\nNight Owl：主题插件\nopen in browser：网页通过浏览器打开\nOpen in External App：文件以外部应用打开\nPath Intellisense\nSpring Boot Extension Pack：Spring Boot 相关包大全\nVetur\nVue 3 Snippets\nbackbackground\n\n\n2. 配置 Java Home打开设置，搜索 javahome，在 Java Home 里输入 Java JDK 的路径可以看到用户配置里多了我们一条配置的信息\n3. 配置 Maven 的配置文件位置打开设置，搜索 maven，在 Maven: User Settings 里输入 maven 配置文件的路径可以看到用户配置里多了我们一条配置的信息\n4. 更改 JDK 版本支持新版默认最低支持 JDK 11，需要重新修改为 JDK 8找到 Language Support for Java(TM) by Red Hat，安装另一个版本为 0.64.1\n5. 更换终端为 CMD默认终端为 Windows Powershell，更换为 CMD，按下快捷键 Ctrl + Shift + P，然后输入 terminal 进行搜索，选择 Terminal：Select Default Profile然后选择终端类型为 CMD可以看到用户配置里多了我们一条配置的信息\n6. 设置 open in browser 的默认浏览器打开设置，搜索  open in browser，将默认浏览器设为 Chrome 或者其他自己选择的浏览器可以看到用户配置里多了我们一条配置的信息\n7. 设置 Live Server 的默认浏览器打开设置，搜索  live server，在下拉框选择默认的浏览器可以看到用户配置里多了我们一条配置的信息\n8. 禁用自动更新打开设置，搜索  update，将 update mode 更改为 none，然后重启即可可以看到用户配置里多了我们一条配置的信息\n9. 代码格式、ESLint 配置&#123;\n  &quot;bracket-pair-colorizer-2.depreciation-notice&quot;: false,\n  &quot;editor.inlineSuggest.enabled&quot;: true,\n  &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;,\n  &quot;workbench.colorTheme&quot;: &quot;Night Owl&quot;,\n  &quot;java.home&quot;: &quot;C:&#x2F;Java&#x2F;JDK1.8.0_131&quot;,\n  &quot;java.configuration.maven.userSettings&quot;: &quot;D:&#x2F;DevelopmentTools&#x2F;NewMaven&#x2F;apache-maven-3.8.2&#x2F;conf&#x2F;settings.xml&quot;,\n  &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Command Prompt&quot;,\n  &quot;open-in-browser.default&quot;: &quot;Chrome&quot;,\n  &quot;liveServer.settings.CustomBrowser&quot;: &quot;chrome&quot;,\n  &quot;update.mode&quot;: &quot;none&quot;,\n  &#x2F;&#x2F; vscode 默认启用了根据文件类型自动设置 tabsize 的选项，这里关闭\n  &quot;editor.detectIndentation&quot;: false,\n  &#x2F;&#x2F; 重新设定 tabsize\n  &quot;editor.tabSize&quot;: 2,\n  &#x2F;&#x2F; 每次保存的时候自动格式化代码\n  &quot;editor.formatOnSave&quot;: true,\n  &#x2F;&#x2F; 每次保存的时候将代码按 eslint 格式进行修复\n  &quot;editor.codeActionsOnSave&quot;: &#123;\n    &quot;source.fixAll.eslint&quot;: true\n  &#125;,\n  &#x2F;&#x2F; 配置 eslint 验证规则\n  &quot;eslint.validate&quot;: [\n    &quot;javascript&quot;,\n    &quot;javascriptreact&quot;,\n    &quot;typescript&quot;,\n    &quot;typescriptreact&quot;,\n    &quot;vue&quot;,\n  ],\n  &#x2F;&#x2F; 让函数(名)和后面的括号之间加个空格 不加空格 false\n  &quot;javascript.format.insertSpaceAfterFunctionParenthesis&quot;: false,\n  &#x2F;&#x2F; 格式化 html 代码\n  &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,\n  &#x2F;&#x2F; 让 vue 中的 js 按编辑器自带的 ts 格式进行格式化\n  &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;,\n&#125;\n\n10. 定义用户代码片段点击 User Snippets搜索 html，选择 HTML 的 html.json\n&#123;\n  &quot;HTML模板&quot;: &#123;\n    &quot;prefix&quot;: &quot;html&quot;,\n    &quot;body&quot;: [\n      &quot;&lt;!DOCTYPE html&gt;&quot;,\n      &quot;&lt;html lang&#x3D;\\&quot;\\&quot;&gt;&quot;,\n      &quot;&quot;,\n      &quot;&lt;head&gt;&quot;,\n      &quot;  &lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;,\n      &quot;  &lt;meta http-equiv&#x3D;\\&quot;X-UA-Compatible\\&quot; content&#x3D;\\&quot;IE&#x3D;edge\\&quot;&gt;&quot;,\n      &quot;  &lt;meta name&#x3D;\\&quot;viewport\\&quot; content&#x3D;\\&quot;width&#x3D;device-width,initial-scale&#x3D;1.0\\&quot;&gt;&quot;,\n      &quot;  &lt;title&gt;$1&lt;&#x2F;title&gt;&quot;,\n      &quot;&lt;&#x2F;head&gt;&quot;,\n      &quot;&lt;body&gt;&quot;,\n      &quot;  &lt;div id&#x3D;\\&quot;app\\&quot;&gt;&quot;,\n      &quot;    $2&quot;,\n      &quot;  &lt;&#x2F;div&gt;&quot;,\n      &quot;  &lt;script&gt;&quot;,\n      &quot;    new Vue(&#123;&quot;,\n      &quot;      el: &#39;#app&#39;,&quot;,\n      &quot;      data() &#123;&quot;,\n      &quot;        return &#123;&quot;,\n      &quot;          $3&quot;,\n      &quot;        &#125;&quot;,\n      &quot;      &#125;,&quot;,\n      &quot;    &#125;)&quot;,\n      &quot;  &lt;&#x2F;script&gt;&quot;,\n      &quot;&lt;&#x2F;body&gt;&quot;,\n      &quot;&lt;&#x2F;html&gt;&quot;\n    ]\n  &#125;\n&#125;\n\n在 html 文件里输入 html 选择该代码片段即可生成模板\n11. background 配置&#123;\n  &#x2F;&#x2F; background 配置\n  &quot;background.enabled&quot;: true,\n  &quot;background.useDefault&quot;: false,\n  &quot;background.style&quot;: &#123;\n    &quot;content&quot;: &quot;&#39;&#39;&quot;,\n    &quot;pointer-events&quot;: &quot;none&quot;,\n    &quot;position&quot;: &quot;absolute&quot;,\n    &quot;z-index&quot;: &quot;99999&quot;,\n    &quot;width&quot;: &quot;100%&quot;,\n    &quot;height&quot;: &quot;100%&quot;,\n    &quot;background-position&quot;: &quot;center&quot;,\n    &quot;background-repeat&quot;: &quot;no-repeat&quot;,\n    &quot;background-size&quot;: &quot;cover&quot;,\n    &quot;opacity&quot;: 0.2\n  &#125;,\n  &quot;background.fullscreen&quot;: &#123;\n    &quot;image&quot;: [\n      &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;Fan&#x2F;Pictures&#x2F;壁纸&#x2F;3.jpg&quot;, &#x2F;&#x2F; 图片的url\n      &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;Fan&#x2F;Pictures&#x2F;壁纸&#x2F;2.jpg&quot;,\n      &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;Fan&#x2F;Pictures&#x2F;壁纸&#x2F;1.jpg&quot;,\n      &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;Fan&#x2F;Pictures&#x2F;壁纸&#x2F;4.jpg&quot;\n    ],\n    &#x2F;&#x2F; &quot;image&quot;: [&quot;https:&#x2F;&#x2F;pathtoimage.png&quot;], &#x2F;&#x2F; 当开启轮播图的时候，可以用数组配置多张图片\n    &quot;opacity&quot;: 0.65, &#x2F;&#x2F; 建议值 0.85 ~ 0.95\n    &quot;size&quot;: &quot;cover&quot;, &#x2F;&#x2F; css, 建议使用 &#96;cover&#96;自适应，或者 &#96;contain&#96;、&#96;200px 200px&#96;\n    &quot;interval&quot;: 1800 &#x2F;&#x2F; 设置图片轮播切换间隔 &#96;秒&#96; 数，默认 &#96;0&#96; 表示不开启\n  &#125;,\n  &quot;background.loop&quot;: true,\n&#125;\n","slug":"BlogRepository/开发工具及环境/VSCode 常用插件及配置使用","date":"2022-04-05T12:38:14.000Z","categories_index":"开发工具及环境","tags_index":"Java,VSCode,编辑器","author_index":"凡"},{"id":"65f75b6b84cce39d7f43815b1be7dc49","title":"AutoHotkey 使用总结","content":"1. 下载官网下载地址：https://www.autohotkey.com/\n\n点击下载最新版本\n\n得到 exe 文件\n2. 安装双击 exe 文件进行安装，默认安装路径，点击 Install\n\n安装完成\n\n3. 使用官方文档地址：Quick Reference | AutoHotkey v2\n3.1 创建一个脚本 .ahk\n右键点桌面空白处\n点击 “新建” 菜单\n点击里面的 “AutoHotkey Script” 新建一个脚本\n给脚本命名，备注：文件名必须带 .ahk 后缀，例如 MyScript.ahk\n找到刚刚新建的脚本并右键点击它\n点击 “Edit Script”\n编辑脚本的窗口，也许是记事本，或者自定义的系统默认的编辑器\n\n3.2 简单的示例在上面创建好的脚本里写入：\nMsgBox &quot;Hello, world!&quot;\n\n\n保存文件，双击运行脚本，如下：\n\n4. 热键热键有时也称为快捷键, 因为它们能简便地触发动作(例如运行程序或键盘宏)\n热键修饰符，详见官网文档：热键 - 定义与使用 | AutoHotkey v2\n\n多个热键可以垂直地叠放来让它们执行相同的动作，例如：\n^Numpad0::\n^Numpad1::\n&#123;\n    MsgBox &quot;Pressing either Control+Numpad0 or Control+Numpad1 will display this message.&quot;\n&#125;\n\n5. 按键列表按键列表，详见官网文档：按键列表(键盘, 鼠标和操纵杆) | AutoHotkey v2\n\n6. 重映射按键内置重映射功能的语法为 OriginKey::DestinationKey， 如只包含下面这行内容的脚本会将 A 重映射成 B：\na::b\n\n上面的例子没有改变 B 自身的功能，B 会继续发送 “b” 的键击，除非把它重映射成其他功能：\na::b\nb::a\n\n\n6.1 自定义组合键通常快捷键组合由可选的前缀&#x2F;修饰键（Ctrl，Alt，Shift 和 LWin&#x2F;RWin）和单个后缀键组成. 标准的修饰键就是这样设计的，所以按下时通常没有立即效果\n两个按键（包括鼠标，但不包括操纵杆按钮）的自定义组合热键可以通过在它们之间使用 “&amp;“ 来定义。因为它们是为与前缀键一起使用而设计的，所以自定义组合有以下特殊行为：\n\n除非前缀键是标准的修饰键或可切换键（如：CapsLock），否则前缀键将失去其原来的功能\n如果前缀键还用作另一个热键中的后缀，则默认情况下，该热键在释放时触发，如果它用于激活自定义组合，则根本不会触发。如果同时有 key-down 热键和 key-up 热键，两个热键将同时被触发\n\nNumpad0 &amp; Numpad1::MsgBox &quot;You pressed Numpad1 while holding down Numpad0.&quot;\nNumpad0 &amp; Numpad2::Run &quot;Notepad&quot;\n\n按住 Numpad0，然后按下第二个按键可以触发热键\n6.2 发送按键 Send发送(输入) 一些按键到一个程序中，可以使用 Send 函数，该函数表示发送按键，模拟打字或按键操作\n\n对于特殊按键需要加上花括号 &#123;&#125; 来对其进行转义，如 &#123;!&#125;，它将告诉 AutoHotkey &#123;!&#125; 表示 “感叹号”，而不是要 “按下 Alt”，如果不在特殊按键列表中，没必要加花括号.\nSend &quot;This text has been typed&#123;!&#125;&quot; ;  注意大括号中的感叹号? 这是因为, 如果没有 &#123;&#125;, AHK 将按下 Alt 键.\n\n; 跟上面的例子类似, 只是这次是 Enter 键. AHK 将会输出 &quot;Enter&quot;\n; 如果 Enter 没有加上 &#123;&#125; 的话.\nSend &quot;Multiple Enter lines have Enter been sent.&quot; ; 错误的\nSend &quot;Multiple&#123;Enter&#125;lines have&#123;Enter&#125;been sent.&quot; ; 正确的\n\n想要表示按住或松开某个按键，可以将这个键用花括号围起来，同时加上单词 UP 或 DOWN，例如：\n; 下面这个例子表示按下一个键的时候再按下另一个键(或多个键)..\n; 如果其中一个方法不奏效, 试试另一个.\nSend &quot;^s&quot;                     ; 表示发送 CTRL+S\nSend &quot;&#123;Ctrl down&#125;s&#123;Ctrl up&#125;&quot;  ; 表示发送 CTRL+S\nSend &quot;&#123;Ctrl down&#125;c&#123;Ctrl up&#125;&quot;\nSend &quot;&#123;b down&#125;&#123;b up&#125;&quot;\nSend &quot;&#123;Tab down&#125;&#123;Tab up&#125;&quot;\nSend &quot;&#123;Up down&#125;&quot;  ; 按下向上键.\nSleep 1000        ; 保持 1 秒.\nSend &quot;&#123;Up up&#125;&quot;    ; 然后松开向上键.\n\n6.3 自定义组合键使用!a::Send &quot;&#123;Left&#125;&quot;\n\n!d::Send &quot;&#123;Right&#125;&quot;\n\n!w::Send &quot;&#123;Up&#125;&quot;\n\n!s::Send &quot;&#123;Down&#125;&quot;\n\n!h::Send &quot;&#123;Home&#125;&quot;\n\n!;::Send &quot;&#123;End&#125;&quot;\n\n按下 Alt+H，Send 发送为 Home\n\n本文只讲到了重映射按键相关知识，更多操作可自行查看官网文档\n","slug":"BlogRepository/其他实践/AutoHotkey 使用总结","date":"2022-04-01T03:52:10.000Z","categories_index":"其他实践","tags_index":"Windows","author_index":"凡"},{"id":"89fa61e4b6ffba4def01cdceb73b7872","title":"Vue2 总结（开发）","content":"1. Vue CLI 脚手架1.1 安装npm install -g @vue&#x2F;cli\n# OR\nyarn global add @vue&#x2F;cli\n\n1.2 升级npm update -g @vue&#x2F;cli\n# 或者\nyarn global upgrade --latest @vue&#x2F;cli\n\n1.3 创建一个项目vue create hello-world\n\n会被提示选取一个 preset。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性创建完成\n1.4 目录结构\n1.5 运行vue-cli2.0\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,\n  &quot;start&quot;: &quot;npm run dev&quot;,\n  &quot;build&quot;: &quot;node build&#x2F;build.js&quot;\n&#125;\n\nvue-cli3.0\n&quot;scripts&quot;: &#123;\n  &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &#x2F;&#x2F; 运行项目\n  &quot;build&quot;: &quot;vue-cli-service build&quot;, &#x2F;&#x2F; build\n  &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#x2F;&#x2F; 运行语法检查\n&#125;,\n\n启动运行项目\nnpm run serve\n\nnpm run xxx 中的 xxx 可以理解为键值对的 key，实际上 run 的是在 package.json 里面 scripts 配置的 value。比如，npm run serve 实际运行的是 vue-cli-service serve，而放在 3.0 以前 npm run dev 运行的则是 node build&#x2F;dev-server.js 文件\n2. Demo 案例2.1 components定义两个组件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;demo&quot;&gt;\n    &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学校地址：&#123;&#123;schoolAddress&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;showName&quot;&gt;点我提示学校名&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default (&#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;School&#39;,\n  data() &#123;\n    return &#123;\n      schoolName: &#39;Vue&#39;,\n      schoolAddress: &#39;湖南&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    showName() &#123;\n      alert(this.schoolName)\n    &#125;,\n    demo() &#123; &#125;\n  &#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.demo &#123;\n  background-color: orange;\n&#125;\n&lt;&#x2F;style&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125; &lt;&#x2F;h2&gt;\n    &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125; &lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Student&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;张三&#39;,\n      age: 18\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n2.2 App.vue管理所有的其他的组件\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;img alt&#x3D;&quot;Vue logo&quot;\n         src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;\n    &lt;School&gt;&lt;&#x2F;School&gt;\n    &lt;Student&gt;&lt;&#x2F;Student&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport School from &#39;.&#x2F;components&#x2F;School.vue&#39;\nimport Student from &#39;.&#x2F;components&#x2F;Student.vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    School,\n    Student\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n#app &#123;\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n2.3 main.js&#x2F;&#x2F; 项目入口文件\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\n\n&#x2F;&#x2F; 关闭 Vue 的生产提示\nVue.config.productionTip &#x3D; false\n\nnew Vue(&#123;\n  render: h &#x3D;&gt; h(App),\n&#125;).$mount(&#39;#app&#39;)\n\n2.4 index.html&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n    &lt;!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;!-- 开启移动端的理想视口 --&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0&quot;&gt;\n    &lt;!-- 配置页签图标 --&gt;\n    &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;&lt;%&#x3D; BASE_URL %&gt;favicon.ico&quot;&gt;\n    &lt;!-- 配置网页标题 --&gt;\n    &lt;title&gt;&lt;%&#x3D; htmlWebpackPlugin.options.title %&gt;Fan&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- 当浏览器不支持js时noscript中的元素就会被渲染 --&gt;\n    &lt;noscript&gt;\n      &lt;strong&gt;We&#39;re sorry but &lt;%&#x3D; htmlWebpackPlugin.options.title %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;&#x2F;strong&gt;\n    &lt;&#x2F;noscript&gt;\n    &lt;!-- 容器 --&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;!-- built files will be auto injected --&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3. render 函数默认引入的 Vue 是一个不完整的 Vue（运行版的 vue），缺少模板解析器，此时使用 components 来注册组件会报错可以看到有两个解决方案，第一种引入完整的 vue.js，第二种使用 render 函数\n3.1 引入完整版的 vue.js完整版的 Vue 在 vue&#x2F;dist 下的 vue.js引入完整版的 vue.js\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#x2F;dist&#x2F;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\n\n&#x2F;&#x2F; 关闭 Vue 的生产提示\nVue.config.productionTip &#x3D; false\n\nnew Vue(&#123;\n  template: &#96;\n    &lt;div&gt;\n      &lt;App&gt;&lt;&#x2F;App&gt;\n    &lt;&#x2F;div&gt;\n  &#96;,\n  components: &#123;\n    App\n  &#125;\n&#125;).$mount(&#39;#app&#39;)\n\n\n此时运行成功\n3.2 使用 render 函数由于运行版的 vue 没有模板解析器，不能使用 template 配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\n\n&#x2F;&#x2F; 关闭 Vue 的生产提示\nVue.config.productionTip &#x3D; false\n\nnew Vue(&#123;\n  &#x2F;&#x2F; render(createElement) &#123;\n  &#x2F;&#x2F;   return createElement(App);\n  &#x2F;&#x2F; &#125;,\n  &#x2F;&#x2F; render:h &#x3D;&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n\n4. 配置文件\n使用 vue inspect &gt; output.js 可以查看到 Vue 脚手架的默认配置\n使用 vue.config.js 可以对脚手架进行个性化定制，官网配置地址 https://cli.vuejs.org/zh/config/#vue-config-js\n\nconst &#123; defineConfig &#125; &#x3D; require(&#39;@vue&#x2F;cli-service&#39;)\nmodule.exports &#x3D; defineConfig(&#123;\n  transpileDependencies: true,\n  lintOnSave: false,\n  pages: &#123;\n    index: &#123;\n      &#x2F;&#x2F; page 的入口，默认 main.js\n      entry: &#39;src&#x2F;aa.js&#39;\n    &#125;\n  &#125;\n&#125;)\n\n5. ref 、props 与 mixin5.1 ref\n被用来给元素或子组件注册引用信息（id的替代者）\n应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）\n使用方式：\n打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....\\&lt;/h1&gt; 或 \\&lt;School ref=&quot;xxx&quot;&gt;\\&lt;/School&gt;\n获取：this.$refs.xxx\n\n\n\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;\n    &lt;h1 v-text&#x3D;&quot;msg&quot; ref&#x3D;&quot;title&quot;&gt;&lt;&#x2F;h1&gt;\n    &lt;button ref&#x3D;&quot;btn&quot; @click&#x3D;&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;&#x2F;button&gt;\n    &lt;School ref&#x3D;&quot;sch&quot; &#x2F;&gt;\n    &lt;Student&gt;&lt;&#x2F;Student&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport School from &#39;.&#x2F;components&#x2F;School.vue&#39;\nimport Student from &#39;.&#x2F;components&#x2F;Student.vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  data() &#123;\n    return &#123;\n      msg: &#39;MSG&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    showDOM() &#123;\n      console.log(this.$refs.title) &#x2F;&#x2F; 真实DOM元素\n      console.log(this.$refs.btn) &#x2F;&#x2F; 真实DOM元素\n      console.log(this.$refs.sch) &#x2F;&#x2F; School组件的实例对象（vc）\n    &#125;\n  &#125;,\n  components: &#123;\n    School,\n    Student\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n5.2 props5.2.1 概念让组件接收外部传过来的数据\n\n传递数据：&lt;Demo name=&quot;xxx&quot;/&gt;\n接收数据：\n第一种方式（只接收）：props:[&#39;name&#39;]\n第二种方式（限制类型）：props:&#123;name:String&#125;\n第三种方式（限制类型、限制必要性、指定默认值）：props:&#123;\n  \tname:&#123;\n      \ttype: String, &#x2F;&#x2F; 类型\n      \trequired: true, &#x2F;&#x2F; 必要性\n      \tdefault: &#39;老王&#39; &#x2F;&#x2F; 默认值\n  \t&#125;\n&#125;\n\n\nprops 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么需要复制 props 的内容到 data 中一份，然后去修改 data 中的数据\n\n5.2.2 使用App.vue，使用组件 School.vue 时传入数据\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;\n    &lt;!-- age 为数字类型，但传入的是一个字符串，此时需要用 v-vind 数据绑定，将 &quot;&quot; 里的看成一个表达式然后传入 --&gt;\n    &lt;School schoolName&#x3D;&quot;Vue&quot; schoolAddress&#x3D;&quot;长沙&quot; :age&#x3D;&quot;18&quot; &#x2F;&gt;\n    &lt;Student &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport School from &#39;.&#x2F;components&#x2F;School.vue&#39;\nimport Student from &#39;.&#x2F;components&#x2F;Student.vue&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    School,\n    Student\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\nSchool.vue，使用 props 接收传进来的数据\n&lt;template&gt;\n  &lt;!-- 组件的结构 --&gt;\n  &lt;div class&#x3D;&quot;demo&quot;&gt;\n    &lt;h2&gt;&#123;&#123;info&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学校地址：&#123;&#123;schoolAddress&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt; &#123;&#123;age + 1&#125;&#125; &lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;showName&quot;&gt;点我提示学校名&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default (&#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;School&#39;,\n  data() &#123;\n    return &#123;\n      info: &#39;原生信息&#39;\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; 接收数据\n  &#x2F;&#x2F; props: [&#39;schoolName&#39;, &#39;schoolAddress&#39;, &#39;age&#39;],\n  props: &#123;\n    schoolName: &#123;\n      type: String, &#x2F;&#x2F; 类型\n      required: true, &#x2F;&#x2F; 必要性\n      default: &#39;Vue&#39; &#x2F;&#x2F; 默认值\n    &#125;,\n    schoolAddress: String,\n    age: Number\n  &#125;\n&#125;);\n&lt;&#x2F;script&gt;\n\n展示将传进来的数据\n5.3 mixin（混入&#x2F;合）5.3.1 概念可以把多个组件共用的配置提取成一个混入对象\n\n定义混入：&#123;\n   data()&#123;....&#125;,\n   methods:&#123;....&#125;\n   ....\n&#125;\n使用混入：全局混入：Vue.mixin(xxx)，会给所有都加上混入局部混入：mixins:[‘xxx’]\n\n5.3.2 使用定义混入，mixin.js\nexport const mixin1 &#x3D; &#123;\n\tmethods: &#123;\n\t\tshowName()&#123;\n\t\t\talert(this.name)\n\t\t&#125;\n\t&#125;,\n\tmounted() &#123;\n\t\tconsole.log(&#39;你好啊！&#39;)\n\t&#125;,\n&#125;\nexport const mixin2 &#x3D; &#123;\n\tdata() &#123;\n\t\treturn &#123;\n\t\t\tx:100,\n\t\t\ty:200\n\t\t&#125;\n\t&#125;,\n&#125;\n\n使用局部混入，School.vue\n&lt;script&gt;\nimport &#123; mixin1, mixin2 &#125; from &#39;..&#x2F;mixin.js&#39;;\nexport default (&#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;School&#39;,\n  data() &#123;\n    return &#123;\n      info: &#39;原生信息&#39;\n    &#125;\n  &#125;,\n  &#x2F;&#x2F; 使用局部混入\n  mixins: [mixin1, mixin2],\n  props: [&#39;schoolName&#39;, &#39;schoolAddress&#39;, &#39;age&#39;],\n&#125;);\n&lt;&#x2F;script&gt;\n\n使用全局混入，main.js\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\nimport &#123; mixin1, mixin2 &#125; from &#39;.&#x2F;mixin&#39;\n\n&#x2F;&#x2F; 关闭 Vue 的生产提示\nVue.config.productionTip &#x3D; false\n&#x2F;&#x2F; 全局混入\nVue.mixin(mixin1)\nVue.mixin(mixin2)\n\nnew Vue(&#123;\n  render:h &#x3D;&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n\n\n6. 插件6.1 概念用于增强 Vue，包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据\n\n定义插件：对象.install &#x3D; function (Vue, options) &#123;\n\t&#x2F;&#x2F; 1. 添加全局过滤器\n\tVue.filter(....)\n\t&#x2F;&#x2F; 2. 添加全局指令\n\tVue.directive(....)\n\t&#x2F;&#x2F; 3. 配置全局混入(合)\n\tVue.mixin(....)\n\t&#x2F;&#x2F; 4. 添加实例方法\n\tVue.prototype.$myMethod &#x3D; function () &#123;...&#125;\n\t&#x2F;&#x2F; 5. 给 Vue 原型上添加一个方法（vm 和 vc 都能用）\n\tVue.prototype.$myProperty &#x3D; xxxx\n&#125;\n使用插件：Vue.use()\n\n6.2 使用定义一个插件 plugins.js\nexport default &#123;\n\tinstall(Vue, x, y, z)&#123;\n\n\t\tconsole.log(Vue, x, y, z)\n\t\t&#x2F;&#x2F;全局过滤器\n\t\tVue.filter(&#39;mySlice&#39;,function(value)&#123;\n\t\t\treturn value.slice(0,  4)\n\t\t&#125;)\n\n\t\t&#x2F;&#x2F;定义全局指令\n\t\tVue.directive(&#39;fbind&#39;,&#123;\n\t\t\t&#x2F;&#x2F;指令与元素成功绑定时（一上来）\n\t\t\tbind(element,binding)&#123;\n\t\t\t\telement.value &#x3D; binding.value\n\t\t\t&#125;,\n\t\t\t&#x2F;&#x2F;指令所在元素被插入页面时\n\t\t\tinserted(element)&#123;\n\t\t\t\telement.focus()\n\t\t\t&#125;,\n\t\t\t&#x2F;&#x2F;指令所在的模板被重新解析时\n\t\t\tupdate(element,binding)&#123;\n\t\t\t\telement.value &#x3D; binding.value\n\t\t\t&#125;\n\t\t&#125;)\n\n\t\t&#x2F;&#x2F;定义混入\n\t\tVue.mixin(&#123;\n\t\t\tdata() &#123;\n\t\t\t\treturn &#123;\n\t\t\t\t\tx:100,\n\t\t\t\t\ty:200\n\t\t\t\t&#125;\n\t\t\t&#125;,\n\t\t&#125;)\n\n\t\t&#x2F;&#x2F; 给 Vue原型上添加一个方法（vm 和 vc 都能用）\n\t\tVue.prototype.hello &#x3D; ()&#x3D;&gt;&#123;alert(&#39;你好啊&#39;)&#125;\n\t&#125;\n&#125;\n\n使用插件，main.js\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\nimport plugins from &#39;.&#x2F;plugins&#39;;\n\n&#x2F;&#x2F; 关闭 Vue 的生产提示\nVue.config.productionTip &#x3D; false\n&#x2F;&#x2F; 使用插件，传入三个值\nVue.use(plugins, 1, 2, 3)\n\nnew Vue(&#123;\n  render:h &#x3D;&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n\n\n7. scoped 样式让样式在局部生效，防止冲突。写法：&lt;style scoped&gt;\n组件中所写的样式最后都是会汇总到一起的，假如存在重名的情况，则会产生样式冲突，后引入的组件的样式会覆盖前面引入的组件中的重名样式。使用 scoped 可以让样式只在该组件作用域内生效\n&lt;template&gt;&lt;&#x2F;template&gt;\n&lt;script&gt;&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n#app &#123;\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n&#125;\n&lt;&#x2F;style&gt;\n\n8. 组件化案例\n组件化编码流程：\n拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突\n实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n一个组件在用：放在组件自身即可\n一些组件在用：放在他们共同的父组件上（状态提升）\n\n\n实现交互：从绑定事件开始\n\n\nprops 适用于：\n父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件 通信\n子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）\n\n\n使用 v-model 时：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的\nprops 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做\n\n\n8.1 定义 componentsMyHeader.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;todo-header&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot;\n           placeholder&#x3D;&quot;请输入你的任务名称，按回车键确认&quot;\n           v-model&#x3D;&quot;name&quot;\n           @keyup.enter&#x3D;&quot;add&quot; &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; nanoid &#125; from &#39;nanoid&#39;\n\nexport default &#123;\n  name: &#39;MyHeader&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    add() &#123;\n      &#x2F;&#x2F; 校验数据，输入不能为空\n      if (!this.name.trim()) return alert(&#39;输入不能为空&#39;);\n      &#x2F;&#x2F; 将用户的输入包装成一个 todo 对象\n      const todoObj &#x3D; &#123; id: nanoid(), name: this.name, done: false &#125;;\n      &#x2F;&#x2F; 调用 App 加到 vc 上的方法，添加一个 todo 对象\n      this.addTodo(todoObj);\n      &#x2F;&#x2F; 清空输入\n      this.name &#x3D; &#39;&#39;;\n    &#125;\n  &#125;,\n  props: [&#39;addTodo&#39;],\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\nMyList.vue\n&lt;template&gt;\n  &lt;ul class&#x3D;&quot;todo-main&quot;&gt;\n    &lt;!-- 展示 App 传过来的数据， MyItem 组件，传入数据和方法 --&gt;\n    &lt;MyItem v-for&#x3D;&quot;todoObj in todoList&quot;\n            :key&#x3D;&quot;todoObj.id&quot;\n            :todo&#x3D;&quot;todoObj&quot;\n            :checkTodo&#x3D;&quot;checkTodo&quot;\n            :deleteTodo&#x3D;&quot;deleteTodo&quot; &#x2F;&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport MyItem from &#39;.&#x2F;MyItem.vue&#39;;\n\nexport default &#123;\n  name: &#39;MyList&#39;,\n  &#x2F;&#x2F; 接收 App 传过来的数据，根据 :xxx&#x3D;&#39;&#39; 的 xxx 名称来接收\n  props: [&#39;todoList&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;],\n  components: &#123;\n    MyItem\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\nMyItem.vue\n&lt;template&gt;\n  &lt;li&gt;\n    &lt;label&gt;\n      &lt;input type&#x3D;&quot;checkbox&quot;\n             :checked&#x3D;&#39;todo.done&#39;\n             @change&#x3D;&quot;handleCheck(todo.id)&quot; &#x2F;&gt;\n      &lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，修改了props --&gt;\n      &lt;!-- &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;todo.done&quot;&#x2F;&gt; --&gt;\n      &lt;span&gt;&#123;&#123;todo.name&#125;&#125;&lt;&#x2F;span&gt;\n    &lt;&#x2F;label&gt;\n    &lt;button class&#x3D;&quot;btn btn-danger&quot; @click&#x3D;&quot;handleDelete(todo.id)&quot;&gt;删除&lt;&#x2F;button&gt;\n  &lt;&#x2F;li&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script scoped&gt;\nexport default &#123;\n  name: &#39;MyItem&#39;,\n  methods: &#123;\n    handleCheck(id) &#123;\n      &#x2F;&#x2F; 调用 App 组件的方法，将 todo.done 值取反\n      this.checkTodo(id);\n    &#125;,\n    &#x2F;&#x2F; 调用 App 组件的方法，删除一个 todo\n    handleDelete(id) &#123;\n      this.deleteTodo(id);\n    &#125;\n  &#125;,\n  props: [&#39;todo&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;],\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\nMyFooter.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;todo-footer&quot;\n       v-show&#x3D;&quot;total&quot;&gt;\n    &lt;label&gt;\n      &lt;!-- &lt;input type&#x3D;&quot;checkbox&quot; :checked&#x3D;&quot;isAll&quot; @change&#x3D;&quot;checkAll&quot; &#x2F;&gt; --&gt;\n      &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;isAll&quot;&gt;\n    &lt;&#x2F;label&gt;\n    &lt;span&gt;\n      &lt;span&gt;已完成&#123;&#123;doneTotal&#125;&#125; &lt;&#x2F;span&gt; &#x2F; 全部&#123;&#123;total&#125;&#125;\n    &lt;&#x2F;span&gt;\n    &lt;button class&#x3D;&quot;btn btn-danger&quot; @click&#x3D;&quot;clearAll&quot;&gt;清除已完成任务&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;MyFooter&#39;,\n  computed: &#123;\n    total() &#123;\n      return this.todos.length\n    &#125;,\n    doneTotal() &#123;\n      &#x2F;&#x2F; return this.todos.reduce((pre, current) &#x3D;&gt; &#123;\n      &#x2F;&#x2F;   return pre + (current.done &#x3D;&#x3D;&#x3D; true ? 1 : 0);\n      &#x2F;&#x2F; &#125;, 0)\n      return this.todos.reduce((pre, current) &#x3D;&gt; pre + (current.done &#x3D;&#x3D;&#x3D; true ? 1 : 0), 0)\n    &#125;,\n    isAll: &#123;\n      get() &#123;\n        return this.doneTotal &#x3D;&#x3D;&#x3D; this.total &amp;&amp; this.total &gt; 0\n      &#125;,\n      set(value) &#123;\n        this.checkAllTodo(value);\n      &#125;\n    &#125;\n  &#125;,\n  methods: &#123;\n    clearAll() &#123;\n      this.clearAllTodo();\n    &#125;\n  &#125;,\n  props: [&#39;todos&#39;, &#39;checkAllTodo&#39;, &#39;clearAllTodo&#39;]\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n8.2 App.vue&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div class&#x3D;&quot;todo-container&quot;&gt;\n      &lt;div class&#x3D;&quot;todo-wrap&quot;&gt;\n        &lt;MyHeader :addTodo&#x3D;&quot;addTodo&quot; &#x2F;&gt;\n        &lt;!-- 传递 todos 给 MyList，名称为 todoList，要用数据绑定，使 &#39;&#39; 里的内容为表达式 --&gt;\n        &lt;MyList :todoList&#x3D;&quot;todos&quot;\n                :checkTodo&#x3D;&quot;checkTodo&quot;\n                :deleteTodo&#x3D;&quot;deleteTodo&quot; &#x2F;&gt;\n        &lt;MyFooter :todos&#x3D;&quot;todos&quot;\n                  :checkAllTodo&#x3D;&quot;checkAllTodo&quot;\n                  :clearAllTodo&#x3D;&quot;clearAllTodo&quot; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport MyHeader from &#39;.&#x2F;components&#x2F;MyHeader.vue&#39;;\nimport MyFooter from &#39;.&#x2F;components&#x2F;MyFooter.vue&#39;;\nimport MyList from &#39;.&#x2F;components&#x2F;MyList.vue&#39;;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  data() &#123;\n    return &#123;\n      todos: [\n        &#123; id: &#39;1001&#39;, name: &#39;吃饭&#39;, done: true &#125;,\n        &#123; id: &#39;1002&#39;, name: &#39;睡觉&#39;, done: false &#125;,\n        &#123; id: &#39;1003&#39;, name: &#39;学习&#39;, done: true &#125;,\n      ]\n    &#125;\n  &#125;,\n  methods: &#123;\n    &#x2F;&#x2F; 添加一个 todo\n    addTodo(todoObj) &#123;\n      this.todos.unshift(todoObj)\n    &#125;,\n    &#x2F;&#x2F; 勾选或取消勾选一个 todo\n    checkTodo(id) &#123;\n      this.todos.forEach(todo &#x3D;&gt; &#123;\n        if (todo.id &#x3D;&#x3D;&#x3D; id) todo.done &#x3D; !todo.done;\n      &#125;)\n    &#125;,\n    &#x2F;&#x2F; 删除一个 todo\n    deleteTodo(id) &#123;\n      if (confirm(&#39;确定删除吗？&#39;)) &#123;\n        this.todos &#x3D; this.todos.filter(todo &#x3D;&gt; &#123;\n          return todo.id !&#x3D;&#x3D; id;\n        &#125;)\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; 全选或全不选\n    checkAllTodo(done) &#123;\n      this.todos.forEach(todo &#x3D;&gt; &#123;\n        todo.done &#x3D; done;\n      &#125;)\n    &#125;,\n    &#x2F;&#x2F; 清除所有已经完成的 todo\n    clearAllTodo() &#123;\n      this.todos &#x3D; this.todos.filter(todo &#x3D;&gt; !todo.done)\n    &#125;\n  &#125;,\n  components: &#123;\n    MyHeader,\n    MyFooter,\n    MyList\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style&gt;&lt;&#x2F;style&gt;\n\n8.3 reduce 方法pre 初始为 0 ，之后为上一次这个函数的返回值，current 为当前对象\nthis.todos.reduce((pre, current) &#x3D;&gt; &#123;\n\tconsole.log(&#39;@&#39;, pre);\n\tconsole.log(&#39;@&#39;, current);\n\treturn pre + 1;\n&#125;, 0)\n\n\n9. webStorage 浏览器本地存储9.1 概念\n存储内容大小一般支持 5MB 左右（不同浏览器可能不一样）\n浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制\n相关API：\nxxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值\nxxxxxStorage.getItem(&#39;person&#39;);该方法接受一个键名作为参数，返回键名对应的值\nxxxxxStorage.removeItem(&#39;key&#39;);该方法接受一个键名作为参数，并把该键名从存储中删除\nxxxxxStorage.clear()该方法会清空存储中的所有数据\n\n\n备注：\nSessionStorage 存储的内容会随着浏览器窗口关闭而消失\nLocalStorage 存储的内容，需要手动清除才会消失\nxxxxxStorage.getItem(xxx) 如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null\nJSON.parse(null) 的结果依然是 null\n\n\n\n9.2 纯 HTML 使用&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h2&gt;浏览器本地存储&lt;&#x2F;h2&gt;\n    &lt;button onclick&#x3D;&quot;saveData()&quot;&gt;点击存储数据&lt;&#x2F;button&gt;\n    &lt;button onclick&#x3D;&quot;getData()&quot;&gt;点击读取数据&lt;&#x2F;button&gt;\n    &lt;button onclick&#x3D;&quot;deleteData()&quot;&gt;点击删除数据&lt;&#x2F;button&gt;\n    &lt;button onclick&#x3D;&quot;clearData()&quot;&gt;点击清空数据&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let person &#x3D; &#123;name: &#39;张三&#39;, age: 18&#125;;\n    function saveData()&#123;\n        localStorage.setItem(&#39;msg&#39;, &#39;hello&#39;);\n        localStorage.setItem(&#39;key&#39;, &#39;value&#39;);\n        localStorage.setItem(&#39;person&#39;, JSON.stringify(person))\n    &#125;\n    function getData()&#123;\n\t\tconsole.log(localStorage.getItem(&#39;msg&#39;))\n\t\tconsole.log(localStorage.getItem(&#39;key&#39;))\n\n\t\tconst result &#x3D; localStorage.getItem(&#39;person&#39;)\n\t\tconsole.log(JSON.parse(result))\n\t&#125;\n\tfunction deleteData()&#123;\n\t\tlocalStorage.removeItem(&#39;key&#39;)\n\t&#125;\n\tfunction clearData()&#123;\n\t\tlocalStorage.clear()\n\t&#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n存储数据读取数据删除数据清空数据\n9.3 Vue 中使用将组件化案例中写死的 todos 改为从浏览器本地存储中读取，读取不到时就为空数组，然后使用侦听器对 todos 进行监视，每当 todos 发生变化，就把 todos 重新存储到浏览器本地存储\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  data() &#123;\n    return &#123;\n      &#x2F;&#x2F; 从浏览器本地存储中读取\n      todos: JSON.parse(localStorage.getItem(&#39;todos&#39;)) || []\n    &#125;\n  &#125;,\n  watch: &#123;\n  \t&#x2F;&#x2F; 需要开启深度监视，监视里面每一个对象的变化\n    todos: &#123;\n      deep: true,\n      handler(value) &#123;\n        localStorage.setItem(&#39;todos&#39;, JSON.stringify(value));\n      &#125;\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n10. 组件自定义事件10.1 概念\n一种组件间通信的方式，适用于：子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件\n使用场景：Fu 是父组件，Zi 是子组件，Zi 想给 Fu 传数据，那么就要在 Fu 中给 Zi 绑定自定义事件（事件的回调也在 Fu 中）\n绑定自定义事件：\n第一种方式，在父组件中：&lt;Demo @fan=&quot;test&quot;/&gt;  或 &lt;Demo v-on:fan=&quot;test&quot;/&gt;，fan 表示自定义事件名，test 表示回调函数\n第二种方式，在父组件中：&lt;Demo ref&#x3D;&quot;de&quot;&#x2F;&gt;\n......\nmounted()&#123;\n  &#x2F;&#x2F; ‘fan’ 表示自定义事件名，this.test 表示回调函数\n  this.$refs.de.$on(&#39;fan&#39;,this.test)\n&#125;\n若想让自定义事件只能触发一次，可以使用 once 修饰符，或 $once 方法\n\n\n触发自定义事件：this.$emit(‘fan’,数据)\n解绑自定义事件 ：this.$off(‘fan’)\n组件上也可以绑定原生 DOM 事件，需要使用 native 修饰符\n注意：通过 this.$refs.xxx.$on(‘fan’, 回调函数)绑定自定义事件时，回调函数要么配置在 methods 中，要么用箭头函数，否则 this 指向会出问题（这时 this 代表触发自定义事件的组件 Zi，而并非自定义事件和回调函数所在的组件 Fu）\n销毁当前 Student 组件的实例，销毁后所有 Student 实例的自定义事件全都不奏效，但原生 DOM 事件依然有效\n\n10.2 绑定App.vue，自定义事件\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;h2&gt;接收到的学生名字：&#123;&#123;studentName&#125;&#125; &lt;&#x2F;h2&gt;\n    &lt;!-- 通过父组件给子组件传递函数类型的props实现：子给父传递数据 --&gt;\n    &lt;!-- &lt;School :getSchoolName&#x3D;&quot;getSchoolName&quot; &#x2F;&gt; --&gt;\n    &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（第一种写法，使用@或v-on） --&gt;\n    &lt;!-- &lt;Student @fan.once&#x3D;&quot;getStudentName&quot; &#x2F;&gt; --&gt;\n\n    &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（第二种写法，使用ref），要配合 mounted 绑定自定义事件  --&gt;\n    &lt;Student ref&#x3D;&quot;stu&quot; &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Student from &#39;.&#x2F;components&#x2F;Student&#39;\n\nexport default &#123;\n  name: &#39;App&#39;,\n  data() &#123;\n    return &#123;\n      studentName: &#39;&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    getSchoolName(name) &#123;\n      console.log(&#39;App收到了学校名：&#39;, name)\n    &#125;,\n    getStudentName(name, ...params) &#123;\n      console.log(&#39;App收到了学生名：&#39;, name, params, this)\n      this.studentName &#x3D; name;\n    &#125;,\n  &#125;,\n  components: &#123; Student &#125;,\n  mounted() &#123;\n    this.$refs.stu.$on(&#39;fan&#39;, this.getStudentName) &#x2F;&#x2F; 绑定自定义事件，配合 ref\n    &#x2F;&#x2F; this.$refs.stu.$once(&#39;fan&#39;, this.getStudentName) &#x2F;&#x2F; 绑定自定义事件（一次性）\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style&gt;&lt;&#x2F;style&gt;\n\nStudent.vue，触发自定义事件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;student&quot;&gt;\n    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;sendStudentlName&quot;&gt;把学生名给App&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Student&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n      number: 0\n    &#125;\n  &#125;,\n  methods: &#123;\n    sendStudentlName() &#123;\n      &#x2F;&#x2F; 触发 Student组件实例身上的自定义事件 fan\n      this.$emit(&#39;fan&#39;, this.name, 11, 22, 33)\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\n点击将子组件的学生名字传给父组件，同时查看回调函数写在 methods 里的 this查看回调函数直接写在 this.$refs.xxx.$on(‘组件名’, 回调函数) 里的 this\n10.3 解绑和销毁销毁当前 Student 组件的实例，销毁后所有 Student 实例的自定义事件全都不奏效，但原生 DOM 事件依然有效\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;student&quot;&gt;\n    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;当前求和为：&#123;&#123;number&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;add&quot;&gt;点我number++&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;sendStudentlName&quot;&gt;把学生名给App&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;unbind&quot;&gt;解绑atguigu事件&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;death&quot;&gt;销毁当前Student组件的实例(vc)&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Student&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n      number: 0\n    &#125;\n  &#125;,\n  methods: &#123;\n    sendStudentlName() &#123;\n      &#x2F;&#x2F; 触发 Student组件实例身上的自定义事件 fan\n      this.$emit(&#39;fan&#39;, this.name, 11, 22, 33)\n    &#125;,\n    unbind() &#123;\n      this.$off(&#39;fan&#39;);\n      &#x2F;&#x2F; this.$off([&#39;fan&#39;,&#39;demo&#39;]) &#x2F;&#x2F; 解绑多个自定义事件\n      &#x2F;&#x2F; this.$off() &#x2F;&#x2F; 解绑所有的自定义事件\n    &#125;,\n    death() &#123;\n      &#x2F;&#x2F; 销毁了当前Student组件的实例，销毁后所有 Student 实例的自定义事件全都不奏效\n      this.$destroy();\n    &#125;,\n    add() &#123;\n      console.log(&#39;add回调被调用了&#39;)\n      this.number++\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\n使用自定义事件解绑自定义事件，此时该自定义事件不奏效销毁实例，此时自定义事件全都不奏效，但原生 DOM 事件仍奏效\n11. 全局事件总线（GlobalEventBus）11.1 概念一种组件间通信的方式，适用于任意组件间通信\n\n安装全局事件总线：new Vue(&#123;\n\t......\n\tbeforeCreate() &#123;\n\t\t&#x2F;&#x2F; 安装全局事件总线，$bus就是当前应用的vm\n\t\tVue.prototype.$bus &#x3D; this\n\t&#125;,\n\t......\n&#125;) \n使用事件总线：\n接收数据：A组件想接收数据，则在A组件中给 $bus 绑定自定义事件，事件的回调留在A组件自身methods()&#123;\n    demo(data)&#123;......&#125;\n&#125;\n......\nmounted() &#123;\n    this.$bus.$on(&#39;xxxx&#39;,this.demo)\n&#125;\n提供数据：this.$bus.$emit(‘xxxx’, 数据)\n最好在 beforeDestroy 钩子中，用 $off 去解绑当前组件所用到的事件\n\n\n\n11.2 使用Student.vue，向 School.vue 传递数据，使用 this.$bus.$emit(‘xxx’, data) 触发自定义事件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;student&quot;&gt;\n    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Student&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    sendStudentName() &#123;\n      this.$bus.$emit(&#39;hello&#39;, this.name);\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\nSchool.vue，接收从 Student.vue 传过来的数据，使用 this.$bus.$on(‘xxx’, data &#x3D;&gt; { })) 监听自定义事件进行接收\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;school&quot;&gt;\n    &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;收到的学生姓名：&#123;&#123;studentName&#125;&#125; &lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;School&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;Vue&#39;,\n      address: &#39;北京&#39;,\n      studentName: &#39;&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    &#x2F;&#x2F; getName(data) &#123;\n    &#x2F;&#x2F;   console.log(&#39;School 组件收到了数据：&#39;, data);\n    &#x2F;&#x2F;   this.studentName &#x3D; data;\n    &#x2F;&#x2F; &#125;\n  &#125;,\n  mounted() &#123;\n    &#x2F;&#x2F; this.$bus.$on(&#39;hello&#39;, this.getName)\n    this.$bus.$on(&#39;hello&#39;, data &#x3D;&gt; &#123;\n      console.log(&#39;School 组件收到了数据：&#39;, data);\n      this.studentName &#x3D; data;\n    &#125;);\n  &#125;,\n  &#x2F;&#x2F; 解绑事件\n  beforeDestroy() &#123;\n    this.$bus.$off(&#39;hello&#39;);\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\n点击传递数据\n12. 消息订阅与发布（pubsub）12.1 概念一种组件间通信的方式，适用于任意组件间通信\n\n安装 ：pubsub：npm install pubsub-j\n引入 ：import pubsub from &#39;pubsub-js&#39;\n接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身methods()&#123;\n\tdemo(MsgName, data)&#123;......&#125;\n&#125;\n......\nmounted() &#123;\n\tthis.pid &#x3D; pubsub.subscribe(&#39;xxx&#39;,this.demo) &#x2F;&#x2F; 订阅消息\n&#125;\n提供数据：pubsub.publish(‘xxx’,数据)\n最好在 beforeDestroy 钩子中，用 pubSub.unsubscribe(pid) 去取消订阅\n\n12.2 使用Student.vue，提供数据（发布），使用 pubsub.publish(‘xxx’, data)\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;student&quot;&gt;\n    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport pubsub from &#39;pubsub-js&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Student&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    sendStudentName() &#123;\n      &#x2F;&#x2F; this.$bus.$emit(&#39;hello&#39;, this.name);\n      pubsub.publish(&#39;hello&#39;, this.name)\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\nSchool.vue，接收数据（订阅），使用 pubsub.subscribe(‘xxx’, (msgName, data) &#x3D;&gt; {  })\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;school&quot;&gt;\n    &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;收到的学生姓名：&#123;&#123;studentName&#125;&#125; &lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport pubsub from &#39;pubsub-js&#39;;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;School&#39;,\n  data() &#123;\n    return &#123;\n      name: &#39;Vue&#39;,\n      address: &#39;北京&#39;,\n      studentName: &#39;&#39;\n    &#125;\n  &#125;,\n  mounted() &#123;\n    &#x2F;&#x2F; this.$bus.$on(&#39;hello&#39;, data &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(&#39;School 组件收到了数据：&#39;, data);\n    &#x2F;&#x2F;   this.studentName &#x3D; data;\n    &#x2F;&#x2F; &#125;);\n    this.pubId &#x3D; pubsub.subscribe(&#39;hello&#39;, (msgName, data) &#x3D;&gt; &#123;\n      console.log(&#39;有人发布了 hello 消息，hello 消息的回调函数执行了&#39;, msgName, data);\n      this.studentName &#x3D; data;\n    &#125;)\n  &#125;,\n  beforeDestroy() &#123;\n    &#x2F;&#x2F; this.$bus.$off(&#39;hello&#39;);\n    pubsub.unsubscribe(this.pubId)\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\n点击传递数据\n13. nextTick在下一次 DOM 更新结束后执行其指定的回调，当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行，语法：this.$nextTick(回调函数)\n修改组件化案例，添加一个编辑的功能，MyItem.vue 添加编辑功能和焦点事件，省略其他代码\n&lt;template&gt;\n  &lt;li&gt;\n    &lt;label&gt;\n      &lt;span v-show&#x3D;&quot;!todo.isEdit&quot;&gt;&#123;&#123;todo.name&#125;&#125;&lt;&#x2F;span&gt;\n      &lt;input v-show&#x3D;&quot;todo.isEdit&quot;\n             type&#x3D;&quot;text&quot;\n             :value&#x3D;&quot;todo.name&quot;\n             @blur&#x3D;&quot;handleBlur(todo, $event)&quot;\n             ref&#x3D;&quot;inputName&quot;&gt;\n    &lt;&#x2F;label&gt;\n    &lt;button class&#x3D;&quot;btn btn-danger&quot; @click&#x3D;&quot;handleDelete(todo.id)&quot;&gt;删除&lt;&#x2F;button&gt;\n    &lt;button class&#x3D;&quot;btn btn-editor&quot; @click&#x3D;&quot;handleEdit(todo)&quot;&gt;编辑&lt;&#x2F;button&gt;\n  &lt;&#x2F;li&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script scoped&gt;\nexport default &#123;\n  name: &#39;MyItem&#39;,\n  methods: &#123;\n    &#x2F;&#x2F; 编辑\n    handleEdit(todo) &#123;\n      &#x2F;&#x2F; if(todo.hasOwnProperty(&#39;isEdit&#39;)) &#123;\n      &#x2F;&#x2F; 点击编辑，假如有 isEdit 属性，则设置为 true，让其显示\n      if (Object.prototype.hasOwnProperty.call(todo, &#39;isEdit&#39;)) &#123;\n        todo.isEdit &#x3D; true;\n      &#125; else &#123;\n        &#x2F;&#x2F; 否则给其添加一个 isedit 属性，设置为 true\n        this.$set(todo, &#39;isEdit&#39;, true);\n      &#125;\n      &#x2F;&#x2F; 在显示输入框之后，获取输入框焦点，配合 blur 使用\n      this.$nextTick(function () &#123;\n        this.$refs.inputName.focus();\n      &#125;)\n    &#125;,\n    &#x2F;&#x2F; 失去焦点回调（真正执行修改逻辑）\n    handleBlur(todo, event) &#123;\n      &#x2F;&#x2F; 失去焦点，将 isEdit 设置为 false，隐藏输入框，显示&lt;span&gt;\n      todo.isEdit &#x3D; false;\n      &#x2F;&#x2F; 进行空值判断\n      if (!event.target.value.trim()) return alert(&#39;输入不能为空&#39;);\n      &#x2F;&#x2F; 传递修改的值给 App\n      this.$bus.$emit(&#39;updateTodo&#39;, todo.id, event.target.value)\n    &#125;\n  &#125;,\n  props: [&#39;todo&#39;],\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;\n\nApp.vue，省略其他代码\n&lt;template&gt;&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n  mounted() &#123;\n    &#x2F;&#x2F; 更新，接收传过来的值\n    this.$bus.$on(&#39;updateTodo&#39;, (id, name) &#x3D;&gt; &#123;\n      this.todos.forEach((todo) &#x3D;&gt; &#123;\n        if (todo.id &#x3D;&#x3D;&#x3D; id) todo.name &#x3D; name;\n      &#125;)\n    &#125;)\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style&gt;&lt;&#x2F;style&gt;\n\n14. Vue 封装的过度与动画 transition14.1 概念在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名\n\n准备好样式：\n元素进入的样式（未设置 name 属性，默认为 v-xxx）：\nv-enter：进入的起点，定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除\nv-enter-active：进入过程中，定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数\nv-enter-to：进入的终点，定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡&#x2F;动画完成之后移除\n\n\n元素离开的样式：\nv-leave：离开的起点，定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除\nv-leave-active：离开过程中，定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数\nv-leave-to：离开的终点，定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡&#x2F;动画完成之后移除\n\n\n\n\n使用 &lt;transition&gt; 包裹要过度的元素，并配置 name 属性：&lt;transition name&#x3D;&quot;hello&quot;&gt;\n   \t&lt;h1 v-show&#x3D;&quot;isShow&quot;&gt;你好啊！&lt;&#x2F;h1&gt;\n&lt;&#x2F;transition&gt;\n若有多个元素需要过度，则需要使用：&lt;transition-group&gt;，且每个元素都要指定 key 值\n自定义过渡的类名\n\n14.2 动画效果先创建动画，然后使用 &lt;transition&gt; … &lt;&#x2F;transition&gt;，将需要动画过度的 … 包裹起来，用 .xxx-enter-active 表示进来的时候的效果，.xxx-leave-active 表示离开的时候的效果，xxx 可以在 &lt;transition&gt; 里用 name 属性指定，同时还可以用 apper 设置动画一进来就加载\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;isShow &#x3D; !isShow&quot;&gt;显示&#x2F;隐藏&lt;&#x2F;button&gt;\n    &lt;!-- name 表示设置动画样式的名称，appper 表示一进来就加载动画 --&gt;\n    &lt;transition name&#x3D;&quot;hello&quot; appear&gt;\n      &lt;h1 v-show&#x3D;&quot;isShow&quot;&gt;你好啊！&lt;&#x2F;h1&gt;\n    &lt;&#x2F;transition&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Test&#39;,\n  data() &#123;\n    return &#123;\n      isShow: true\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n&#x2F;* 创建动画 *&#x2F;\n@keyframes fan &#123;\n  from &#123;\n    transform: translateX(-100%);\n  &#125;\n  to &#123;\n    transform: translateX(0px);\n  &#125;\n&#125; \n&#x2F;* 来的时候的效果 *&#x2F;\n.hello-enter-active &#123;\n  animation: fan 0.5s linear;\n&#125;\n&#x2F;* 离开的时候的效果 *&#x2F;\n.hello-leave-active &#123;\n  animation: fan 0.5s linear reverse;\n&#125;\n\nh1 &#123;\n  background-color: orange;\n&#125;\n&lt;&#x2F;style&gt;\n\n14.3 过度效果&lt;transition&gt;&lt;&#x2F;transition&gt; 只能使用一个元素，多个元素使用 &lt;transition-group&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;isShow &#x3D; !isShow&quot;&gt;显示&#x2F;隐藏&lt;&#x2F;button&gt;\n    &lt;transition-group name&#x3D;&quot;hello&quot; appear&gt;\n      &lt;!-- 设置交替显示 --&gt;\n      &lt;h1 v-show&#x3D;&quot;!isShow&quot; key&#x3D;&quot;1&quot;&gt;你好啊！&lt;&#x2F;h1&gt;\n      &lt;h1 v-show&#x3D;&quot;isShow&quot; key&#x3D;&quot;2&quot;&gt;Fan！&lt;&#x2F;h1&gt;\n    &lt;&#x2F;transition-group&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Test&#39;,\n  data() &#123;\n    return &#123;\n      isShow: true\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\nh1 &#123;\n  background-color: orange;\n&#125;\n&#x2F;* 进入的起点、离开的终点 *&#x2F;\n.hello-enter, .hello-leave-to &#123;\n  transform: translateX(-100%);\n&#125;\n.hello-enter-active, .hello-leave-active &#123;\n  transition: 0.5s linear;\n&#125;\n&#x2F;* 进入的终点、离开的起点 *&#x2F;\n.hello-enter-to, .hello-leave &#123;\n  transform: translateX(0);\n&#125;\n&lt;&#x2F;style&gt;\n\n14.4 集成第三方库 Animate.css\n安装：npm install animate.css --save\n引入：import &#39;animate.css&#39;;\nname 设置为 animate__animated 前缀加名字，然后使用自定义类名配合使用\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;isShow &#x3D; !isShow&quot;&gt;显示&#x2F;隐藏&lt;&#x2F;button&gt;\n    &lt;transition appear\n                name&#x3D;&quot;animate__animated animate__bounce&quot;\n                enter-active-class&#x3D;&quot;animate__swing&quot;\n                leave-active-class&#x3D;&quot;animate__backOutUp&quot;&gt;\n      &lt;h1 v-show&#x3D;&quot;isShow&quot;&gt;你好啊！&lt;&#x2F;h1&gt;\n    &lt;&#x2F;transition&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#39;animate.css&#39;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Test&#39;,\n  data() &#123;\n    return &#123;\n      isShow: true\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\nh1 &#123;\n  background-color: orange;\n&#125;\n&lt;&#x2F;style&gt;\n\n15. Vue 中的 ajax15.1 请求方式发 ajax 请求的方式：\n\nxhr（ new XMLHttpRequest() ）：xhr.open(); xhr.send();\nJQuery：封装（很多 DOM 操作），$.get，$.post\nAxios：封装， 体积小\nfetch：与 xhr 同级，会包装两层，同时兼容性差\nvue-resource ：Vue 里的插件库\n\n15.2 解决 ajax 请求跨域问题\ncors（Cross-origin resource sharing）：跨域资源共享，需要后端加上HTTP 头\njsonp：只能解决 get 请求\n代理服务器\n\n15.2.1 代理方式一在 vue.config.js 中添加如下配置：\ndevServer:&#123;\n\tproxy:&quot;http:&#x2F;&#x2F;localhost:5000&quot;\n&#125;\n\n\n优点：配置简单，请求资源时直接发给前端（8080）即可，会代理到 5000\n缺点：不能配置多个代理，不能灵活的控制请求是否走代理\n工作方式：若按照上述配置代理，当请求了前端不存在的资源时（没有匹配到静态文件的请求），那么该请求会转发给服务器 （优先匹配前端资源）\n\n发送请求\n&lt;template&gt;\n  &lt;div&gt; &lt;button @click&#x3D;&quot;getStudents&quot;&gt;获取学生信息&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport axios from &#39;axios&#39; &#x2F;&#x2F; 引入 axios\nexport default &#123;\n  name: &#39;App&#39;,\n  methods: &#123;\n    getStudents() &#123;\n      axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;students&#39;).then(\n        response &#x3D;&gt; &#123;\n          console.log(&#39;请求成功了&#39;, response.data)\n        &#125;,\n        error &#x3D;&gt; &#123;\n          console.log(&#39;请求失败了&#39;, error.message)\n        &#125;\n      )\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n15.2.2 代理方式二编写 vue.config.js 配置具体代理规则：\nconst &#123; defineConfig &#125; &#x3D; require(&#39;@vue&#x2F;cli-service&#39;)\nmodule.exports &#x3D; defineConfig(&#123;\n  devServer: &#123;\n    proxy: &#123;\n      &#39;&#x2F;fan&#39;: &#123; &#x2F;&#x2F; 匹配所有以 &#39;&#x2F;fan&#39;开头的请求路径\n        target: &#39;http:&#x2F;&#x2F;localhost:5000&#39;, &#x2F;&#x2F; 代理目标的基础路径\n        pathRewriter: &#123;\n          &#x2F;&#x2F; 请求默认会加上拦截的前缀，设置转发请求时去掉前缀 &#39;&#x2F;fan&#39;\n          &#39;^ &#x2F;fan&#39;: &#39;&#39;\n        &#125;,\n        ws: true, &#x2F;&#x2F; 用于支持 WebSocket\n        &#x2F;&#x2F; 默认值为 true，服务器收到的请求头中的 host 为：localhost:5000，代理目标的地址\n        &#x2F;&#x2F; 设置为 false 时，服务器收到的请求头中的 host 为：localhost:8080，代理服务器的地址\n        changeOrigin: true &#x2F;&#x2F; 用于控制请求头中的 host 值\n      &#125;,\n      &#39;&#x2F;foo&#39;: &#123;\n        target: &#39;&lt;other_url&gt;&#39;\n      &#125;\n    &#125;\n  &#125;\n&#125;)\n\n\n优点：可以配置多个代理，且可以灵活的控制请求是否走代理\n缺点：配置略微繁琐，请求资源时必须加前缀\n\n发送请求，url 加上前缀\n&lt;template&gt;\n  &lt;div&gt; &lt;button @click&#x3D;&quot;getStudents&quot;&gt;获取学生信息&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport axios from &#39;axios&#39; &#x2F;&#x2F; 引入 axios\nexport default &#123;\n  name: &#39;App&#39;,\n  methods: &#123;\n    getStudents() &#123;\n      &#x2F;&#x2F; 加上前缀 &#x2F;fan，才会被匹配到走代理\n      axios.get(&#39;&#x2F;fan&#x2F;students&#39;).then(\n        response &#x3D;&gt; &#123;\n          console.log(&#39;请求成功了&#39;, response.data)\n        &#125;,\n        error &#x3D;&gt; &#123;\n          console.log(&#39;请求失败了&#39;, error.message)\n        &#125;\n      )\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n15.3 使用安装 Axios：npm install axios --save单组件引入：import axios from &#39;axios&#39;，直接使用 axiosmain.js 全局引入：Vue.prototype.$axios = axios，使用 this.$axios 来使用 Axios\nSearch.vue，搜索框，将 ajax 请求到的数据传给 List.vue\n&lt;template&gt;\n  &lt;section class&#x3D;&quot;jumbotron&quot;&gt;\n    &lt;h3 class&#x3D;&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;&#x2F;h3&gt;\n    &lt;div&gt;\n      &lt;input type&#x3D;&quot;text&quot;\n             placeholder&#x3D;&quot;enter the name you search&quot;\n             v-model&#x3D;&quot;keyWord&quot; &#x2F;&gt; \n      &lt;button @click&#x3D;&quot;searchUsers&quot;&gt;Search&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;section&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport axios from &#39;axios&#39;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Search&#39;,\n  data() &#123;\n    return &#123;\n      keyWord: &#39;&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    searchUsers() &#123;\n      &#x2F;&#x2F; 请求前更新 List 的数据\n      &#x2F;&#x2F; 欢迎词为 true（只有第一次需要欢迎词，后面都不需要），加载中为 false，错误信息为 false，数据为空数组\n      this.$bus.$emit(&#39;updateListData&#39;, &#123; isFirst: true, isLoading: false, errMsg: &#39;&#39;, users: [] &#125;)\n      &#x2F;&#x2F; 向 GitHub 发送 ajax 请求\n      axios.get(&#96;https:&#x2F;&#x2F;api.github.com&#x2F;search&#x2F;users?q&#x3D;$&#123;this.keyWord&#125;&#96;).then(\n        response &#x3D;&gt; &#123;\n          console.log(&#39;请求成功了&#39;)\n          &#x2F;&#x2F; 请求成功后更新 List 的数据，传递给 Lsit组件，不需要欢迎词，\n          this.$bus.$emit(&#39;updateListData&#39;, &#123; isLoading: false, errMsg: &#39;&#39;, users: response.data.items &#125;)\n        &#125;,\n        error &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 请求失败后更新 List 的数据\n          console.log(&#39;请求失败&#39;, error.message);\n          this.$bus.$emit(&#39;updateListData&#39;, &#123; isLoading: false, errMsg: error.message, users: [] &#125;)\n        &#125;\n      )\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\nList.vue，接收数据进行展示\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;row&quot;&gt;\n    &lt;!-- 展示用户列表 --&gt;\n    &lt;div v-show&#x3D;&quot;info.users.length&quot;\n         class&#x3D;&quot;card&quot;\n         v-for&#x3D;&quot;user in info.users&quot;\n         :key&#x3D;&quot;user.login&quot;&gt;\n      &lt;a :href&#x3D;&quot;user.html_url&quot; target&#x3D;&quot;_blank&quot;&gt;\n        &lt;img :src&#x3D;&quot;user.avatar_url&quot; style&#x3D;&#39;width: 100px&#39; &#x2F;&gt;\n      &lt;&#x2F;a&gt;\n      &lt;p class&#x3D;&quot;card-text&quot;&gt;&#123;&#123;user.login&#125;&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n    &lt;!-- 展示欢迎词 --&gt;\n    &lt;h1 v-show&#x3D;&quot;info.isFirst&quot;&gt;欢迎使用！&lt;&#x2F;h1&gt;\n    &lt;!-- 展示加载中 --&gt;\n    &lt;h1 v-show&#x3D;&quot;info.isLoading&quot;&gt;加载中....&lt;&#x2F;h1&gt;\n    &lt;!-- 展示错误信息 --&gt;\n    &lt;h1 v-show&#x3D;&quot;info.errMsg&quot;&gt;&#123;&#123;info.errMsg&#125;&#125;&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;List&#39;,\n  data() &#123;\n    return &#123;\n      info: &#123;\n        isFirst: true,\n        isLoading: false,\n        errMsg: &#39;&#39;,\n        users: []\n      &#125;\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.$bus.$on(&#39;updateListData&#39;, dataObj &#x3D;&gt; &#123;\n      console.log(&#39;List 组件收到了数据&#39;);\n      &#x2F;&#x2F; 设置后面存在的对象属性会覆盖原来的属性，不存在的则不会覆盖，保留原来的属性\n      this.info &#x3D; &#123; ...this.info, ...dataObj &#125;\n    &#125;)\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n15.4 请求携带参数15.4.1 Get 请求三种方式：\nonSubmit() &#123;\n  &#x2F;&#x2F; axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test&#39;, &#123; params: &#123; recrTitle: &#39;开发&#39; &#125; &#125;).then(\n  &#x2F;&#x2F; axios.get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test?recrTitle&#x3D;开发&#39;).then(\n  axios(&#123;\n\tmethod: &#39;get&#39;,\n\turl: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test&#39;,\n\tparams: &#123;\n\t  recrTitle: &#39;开发&#39;\n\t&#125;,\n\theaders: &#123; token: &#39;&#39;&#125;\n  &#125;).then(\n    response &#x3D;&gt; &#123;\n      this.menuList &#x3D; response.data\n    &#125;\n  )\n&#125;\n\n参数会带在 URL 后面\n15.4.2 Post 请求\nonSubmit() &#123;\n  &#x2F;&#x2F; axios.post(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test&#39;, &#123; recrTitle: &#39;开发&#39; &#125;).then(\n  &#x2F;&#x2F; axios.post(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test&#39;, this.formData&#125;).then(\n  axios(&#123;\n\tmethod: &#39;post&#39;,\n\turl: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test&#39;,\n\tdata: &#123;\n\t  recrTitle: &#39;开发&#39;\n\t&#125;,\n  &#125;).then(\n    response &#x3D;&gt; &#123;\n      this.menuList &#x3D; response.data\n    &#125;\n  )\n&#125;\n\n\n15.4.3 Put 请求与 Post 请求同\n15.4.4 Delete 请求onSubmit() &#123;\n  &#x2F;&#x2F; axios.delete(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test&#39;, &#123; data: &#123; recrTitle: &#39;开发&#39; &#125; &#125;).then(\n  axios(&#123;\n\tmethod: &#39;post&#39;,\n\turl: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hrms&#x2F;recruitment&#x2F;test&#39;,\n\tdata: &#123;\n\t  recrTitle: &#39;开发&#39;\n\t&#125;,\n  &#125;).then(\n    response &#x3D;&gt; &#123;\n      this.menuList &#x3D; response.data\n    &#125;\n  )\n&#125;\n\n15.5 vue-resource（插件库）\n安装：npm install vue-resource\n引入：import vueResource from &#39;vue-resource&#39;\n使用：Vue.use(vueResource)\n发送请求时，把 axios 换成 this.$http，其他与axios 同\n\nthis.$http.get(&#96;https:&#x2F;&#x2F;api.github.com&#x2F;search&#x2F;users?q&#x3D;$&#123;this.keyWord&#125;&#96;).then(\n\tresponse &#x3D;&gt; &#123;\n\t\tconsole.log(&#39;请求成功了&#39;)\n\t&#125;\n\terror &#x3D;&gt; &#123;\n\t\tconsole.log(&#39;请求失败了&#39;)\n\t&#125;\n)\n\n16. 插槽让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件\n16.1 默认插槽Category.vue，定义插槽，子组件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;category&quot;&gt;\n    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;&#x2F;h3&gt;\n    &lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;\n    &lt;slot&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Category&#39;,\n  props: [&#39;title&#39;]\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\nApp.vue，父组件，填入 html 结构到子组件 Category.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;Category title&#x3D;&quot;美食&quot;&gt;\n      &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;s3.ax1x.com&#x2F;2021&#x2F;01&#x2F;16&#x2F;srJlq0.jpg&quot;\n           alt&#x3D;&quot;&quot;&gt;\n    &lt;&#x2F;Category&gt;\n\n    &lt;Category title&#x3D;&quot;游戏&quot;&gt;\n      &lt;ul&gt;\n        &lt;li v-for&#x3D;&quot;(g,index) in games&quot;\n            :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;Category&gt;\n\n    &lt;Category title&#x3D;&quot;电影&quot;&gt;\n      &lt;video controls\n             src&#x3D;&quot;http:&#x2F;&#x2F;clips.vorwaerts-gmbh.de&#x2F;big_buck_bunny.mp4&quot;&gt;&lt;&#x2F;video&gt;\n    &lt;&#x2F;Category&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Category from &#39;.&#x2F;components&#x2F;Category&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123; Category &#125;,\n  data() &#123;\n    return &#123;\n      games: [&#39;红色警戒&#39;, &#39;穿越火线&#39;, &#39;劲舞团&#39;, &#39;超级玛丽&#39;],\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n16.2 具名插槽Category.vue，定义插槽，使用 slot 给插槽定义名字，假如存在多个插槽时必须定义名字，只有一个插槽可忽略\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;category&quot;&gt;\n    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;&#x2F;h3&gt;\n    &lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;\n    &lt;slot name&#x3D;&quot;center&quot;&gt;Center 我是一些默认值，当使用者没有传递具体结构时，我会出现&lt;&#x2F;slot&gt;\n    &lt;slot name&#x3D;&quot;footer&quot;&gt;Footer 我是一些默认值，当使用者没有传递具体结构时，我会出现&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Category&#39;,\n  props: [&#39;title&#39;]\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\nApp.vue，父组件，填入 html 结构到子组件 Category.vue，使用 slot 表示填入对应的插槽\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;container&quot;&gt;\n    &lt;Category title&#x3D;&quot;美食&quot;&gt;\n      &lt;!-- 填入插槽 center --&gt;\n      &lt;img slot&#x3D;&quot;center&quot;\n           src&#x3D;&quot;https:&#x2F;&#x2F;s3.ax1x.com&#x2F;2021&#x2F;01&#x2F;16&#x2F;srJlq0.jpg&quot;\n           alt&#x3D;&quot;&quot;&gt;\n      &lt;!-- 插槽 footer 未填入，则显示默认值 --&gt;\n    &lt;&#x2F;Category&gt;\n\n    &lt;Category title&#x3D;&quot;游戏&quot;&gt;\n      &lt;!-- 填入插槽 center --&gt;\n      &lt;ul slot&#x3D;&quot;center&quot;&gt;\n        &lt;li v-for&#x3D;&quot;(g,index) in games&quot;\n            :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n      &lt;!-- 填入插槽 footer --&gt;\n      &lt;div class&#x3D;&quot;foot&quot;\n           slot&#x3D;&quot;footer&quot;&gt;\n        &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot;&gt;单机游戏&lt;&#x2F;a&gt;\n        &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot;&gt;热门游戏&lt;&#x2F;a&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;Category&gt;\n\n    &lt;Category title&#x3D;&quot;电影&quot;&gt;\n      &lt;video slot&#x3D;&quot;center&quot;\n             controls\n             src&#x3D;&quot;http:&#x2F;&#x2F;clips.vorwaerts-gmbh.de&#x2F;big_buck_bunny.mp4&quot;&gt;&lt;&#x2F;video&gt;\n      &lt;!-- &lt;template v-slot:footer&gt; --&gt;\n      &lt;template slot&#x3D;&quot;footer&quot;&gt;\n        &lt;div class&#x3D;&quot;foot&quot;&gt;\n          &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot;&gt;经典&lt;&#x2F;a&gt;\n          &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot;&gt;热门&lt;&#x2F;a&gt;\n          &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot;&gt;推荐&lt;&#x2F;a&gt;\n        &lt;&#x2F;div&gt;\n        &lt;h4 align&#x3D;&quot;center&quot;&gt; 欢迎观看！&lt;&#x2F;h4&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Category&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Category from &#39;.&#x2F;components&#x2F;Category&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123; Category &#125;,\n  data() &#123;\n    return &#123;\n      games: [&#39;红色警戒&#39;, &#39;穿越火线&#39;, &#39;劲舞团&#39;, &#39;超级玛丽&#39;],\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n\n16.3 作用域插槽数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）\nCategory.vue，数据在里面，通过数据绑定，让 App.vue 可以获取到数据，:name&#x3D;‘xxx’，name 表示绑定的名字，xxx 为表达式\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;category&quot;&gt;\n    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;&#x2F;h3&gt;\n    &lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;\n    &lt;slot :games&#x3D;&quot;games&quot;\n          :msg&#x3D;&quot;hello&quot;&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Category&#39;,\n  props: [&#39;title&#39;],\n  data() &#123;\n    return &#123;\n      games: [&#39;红色警戒&#39;, &#39;穿越火线&#39;, &#39;劲舞团&#39;, &#39;超级玛丽&#39;],\n      hello: &#39;hello&#39;\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\nApp.vue，使用 scope&#x3D;‘xxx’ 或 slot-scope&#x3D;‘xxx’ 来获取数据对象，然后用该数据对象 xxx.name 获取 Category 组件的数据，或者直接 scope&#x3D;{name} 或 slot-scope&#x3D;{name} 直接获取传过来的数据\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;container&quot;&gt;\n\n    &lt;Category title&#x3D;&quot;游戏&quot;&gt;\n      &lt;!-- &lt;template scope&#x3D;&quot;fan&quot;&gt; --&gt;\n      &lt;!-- 先获取数据对象，名字自定义，然后用该数据对象.name 获取数据，name 为数据绑定时的名字 --&gt;\n      &lt;template slot-scope&#x3D;&quot;fan&quot;&gt;\n        &lt;ul&gt;\n          &lt;li v-for&#x3D;&quot;(g,index) in fan.games&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n        &lt;h4&gt; &#123;&#123;fan.msg&#125;&#125; &lt;&#x2F;h4&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Category&gt;\n\n    &lt;Category title&#x3D;&quot;游戏&quot;&gt;\n      &lt;!-- 直接通过 &#123;name&#125; 获取数据 --&gt;\n      &lt;template slot-scope&#x3D;&quot;&#123;games, msg&#125;&quot;&gt;\n        &lt;ol&gt;\n          &lt;li v-for&#x3D;&quot;(g,index) in games&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;\n        &lt;&#x2F;ol&gt;\n        &lt;h4&gt; &#123;&#123;msg&#125;&#125; &lt;&#x2F;h4&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Category&gt;\n\n    &lt;Category title&#x3D;&quot;游戏&quot;&gt;\n      &lt;template slot-scope&#x3D;&quot;fan&quot;&gt;\n        &lt;h4 v-for&#x3D;&quot;(g,index) in fan.games&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;h4&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Category&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Category from &#39;.&#x2F;components&#x2F;Category&#39;\nexport default &#123;\n  name: &#39;App&#39;,\n  components: &#123; Category &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n\n17. Vuex17.1 概念在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 Vue 应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信\n\n多个组件依赖于同一状态\n来自不同组件的行为需要变更同一状态\n\n\n17.2 Vuex 核心概念和 API17.2.1 state\nVuex 管理的状态对象\n\n它应该是唯一的\nconst state &#x3D; &#123;\n\txxx: initValue\n&#125;\n\n\n\n\n17.2.2 actions\n值为一个对象，包含多个响应用户动作的回调函数\n\n在组件中使用：$store.dispatch(‘对应的 action 回调名’, 参数) 触发 actions 中的回调\n\n通过 commit() 来触发 mutation 中函数的调用, 间接更新 state\n\n可以包含异步代码（定时器, ajax 等等）\nconst actions &#x3D; &#123;\n\tyyy(context, value)&#123;\n\t    if (context.state.xxx % 2) &#123;\n\t      console.log(context, value);\n\t      context.commit(&#39;YYY&#39;, value)\n\t    &#125;\n\t&#125;,\n&#125;\ncontext： 上下文，包含多个可能会用到的方法，如 dispatch，可以分发 Action\nconst actions &#x3D; &#123;\n\tyyy(context, value)&#123;\n\t\tcontext.dispatch(&#39;yyyy&#39;, value);\n\t&#125;,\n\tyyyy(context, value)&#123;\n\t\t......\n\t\tcontext.commit(&#39;YYY&#39;, value)\n\t&#125;,\n&#125;\n\n17.2.3 mutations\n值是一个对象，包含多个直接更新 state 的方法\n在 action 中使用：commit(‘对应的 mutations 方法名’, 参数) 触发 mutations 中的回调\n不能写异步代码、只能单纯的操作 stateconst mutations &#x3D; &#123;\n\tYYY(state, value)&#123;\n\t    state.xxx +&#x3D; value;\n\t&#125;,\n&#125;\n\n17.2.4 getters当 state 中的数据需要经过加工后再使用时，使用 getters 加工\n\n值为一个对象，包含多个用于返回数据的函数\n如何使用？—— $store.getters.xxxconst getters &#x3D; &#123;\n\tzzz(state)&#123;\n\t    return state.xxx * 10\n\t&#125;,\n&#125;\n\n17.2.5 modules\n包含多个 module，用于模块化\n一个 module 是一个 store 的配置对象\n与一个组件（包含有共享数据）对应\n\n17.3 搭建 Vuex 环境17.3.1 安装vue2 中要使用 vuex3 版本，vuex4 只能在 vue3 中使用\nnpm install vuex@3\n\n17.3.2 准备 store在 src 目录下创建 store&#x2F;index.js\n&#x2F;&#x2F; 该文件用于创建 Vuex 中最为核心的 store\n\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 Vuex\nimport Vuex from &#39;vuex&#39;\n&#x2F;&#x2F; 应用 Vuex 插件\nVue.use(Vuex)\n\n&#x2F;&#x2F; 准备 actions——用于响应组件中的动作\nconst actions &#x3D; &#123;&#125;\n&#x2F;&#x2F; 准备 mutations——用于操作数据（state）\nconst mutations &#x3D; &#123;&#125;\n&#x2F;&#x2F; 准备state——用于存储数据\nconst state &#x3D; &#123;&#125;\n&#x2F;&#x2F; 准备getters——用于将state中的数据进行加工\nconst getters &#x3D; &#123;&#125;\n\n&#x2F;&#x2F;创建并暴露 store\nexport default new Vuex.Store(&#123;\n  &#x2F;&#x2F;actions: actions,\n  actions,\n  mutations,\n  state,\n  getters\n&#125;)\n\n17.3.3 在 main.js 引入 store&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\n\n&#x2F;&#x2F; 关闭 Vue 的生产提示\nVue.config.productionTip &#x3D; false\n\n&#x2F;&#x2F; 引入 store，假如 store 文件夹下为 index.js，则默认会去找，可以不写\n&#x2F;&#x2F; import store from &#39;.&#x2F;store&#x2F;index&#39;\nimport store from &#39;.&#x2F;store&#39;\n\nnew Vue(&#123;\n  render:h &#x3D;&gt; h(App),\n  store, &#x2F;&#x2F; 使用\n  beforeCreate() &#123;\n    Vue.prototype.$bus &#x3D; this;\n  &#125;,\n&#125;).$mount(&#39;#app&#39;)\n\n使用时用 this.$store 来使用 store\n17.4 工作流程&#x2F;原理\n\n按照流程，数据在 state 中，sum &#x3D; 0\n首先在 Count.vue 中用 this.$store.dispatch(&#39;addOdd&#39;, this.num) 传递函数名和参数给 store 的 actions\nactions 接收到后进行处理（逻辑判断等）后再用 context.commit(&#39;ADD&#39;, value) 传递建议大写的函数名和参数给 mutations\n在 mutations 中对 state 中的数据进行操作\n假如不用在 actions 进行处理（逻辑判断等），可以直接在 Count.vue 中用 this.$store.commit(&#39;REDUCE&#39;, this.num) 传递给 mutations\n\n17.5 使用Count.vue，用于计算的组件，组件中读取 Vuex 中的数据（state）：$store.state.sum，读取加工后的数据（getter）：$store.getters.bigSum\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;当前求和为：&#123;&#123;$store.state.sum&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;h1&gt;放大 10 倍后的值：&#123;&#123;$store.getters.bigSum&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;select v-model.number&#x3D;&quot;num&quot;&gt;\n      &lt;option value&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;option&gt;\n      &lt;option value&#x3D;&quot;2&quot;&gt;2&lt;&#x2F;option&gt;\n      &lt;option value&#x3D;&quot;3&quot;&gt;3&lt;&#x2F;option&gt;\n    &lt;&#x2F;select&gt;\n    &lt;button @click&#x3D;&quot;increment&quot;&gt;+&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;decrement&quot;&gt;-&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;incrementWait&quot;&gt;等一等再加&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Count&#39;,\n  data() &#123;\n    return &#123;\n      num: 1, &#x2F;&#x2F; 用户选择的数字\n    &#125;\n  &#125;,\n  methods: &#123;\n    increment() &#123;\n      &#x2F;&#x2F; this.$store.dispatch(&#39;add&#39;, this.num)\n      this.$store.commit(&#39;ADD&#39;, this.num) &#x2F;&#x2F; 直接 commit 给 mutations\n    &#125;,\n    decrement() &#123;\n      &#x2F;&#x2F; this.$store.dispatch(&#39;reduce&#39;, this.num)\n      this.$store.commit(&#39;REDUCE&#39;, this.num) &#x2F;&#x2F; 直接 commit 给 mutations\n    &#125;,\n    incrementOdd() &#123;\n      &#x2F;&#x2F; 先 dispatch给 actions 进行处理，然后再 commit 给 mutations\n      this.$store.dispatch(&#39;addOdd&#39;, this.num)\n    &#125;,\n    incrementWait() &#123;\n      this.$store.dispatch(&#39;addWait&#39;, this.num)\n    &#125;,\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style lang&#x3D;&quot;css&quot;&gt;&lt;&#x2F;style&gt;\n\nstore，即 src&#x2F;store&#x2F;index.js\n&#x2F;&#x2F; 该文件用于创建 Vuex 中最为核心的 store\n\n&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 Vuex\nimport Vuex from &#39;vuex&#39;\n&#x2F;&#x2F; 应用 Vuex 插件\nVue.use(Vuex)\n\n&#x2F;&#x2F; 准备 actions——用于响应组件中的动作\nconst actions &#x3D; &#123;\n  &#x2F;&#x2F; add(context, value) &#123;\n  &#x2F;&#x2F;   context.commit(&#39;ADD&#39;, value);\n  &#x2F;&#x2F; &#125;,\n  &#x2F;&#x2F; reduce(context, value)&#123;\n  &#x2F;&#x2F;   context.commit(&#39;REDUCE&#39;, value)\n  &#x2F;&#x2F; &#125;,\n  addOdd(context, value)&#123;\n    if (context.state.sum % 2) &#123;\n      context.commit(&#39;ADD&#39;, value)\n    &#125;\n  &#125;,\n  addWait(context, value)&#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      context.commit(&#39;ADD&#39;, value)\n    &#125;, 500);\n  &#125;\n&#125;\n&#x2F;&#x2F; 准备 mutations——用于操作数据（state）\nconst mutations &#x3D; &#123;\n  ADD(state, value)&#123;\n    state.sum +&#x3D; value;\n  &#125;,\n  REDUCE(state, value)&#123;\n    state.sum -&#x3D; value;\n  &#125;,\n&#125;\n&#x2F;&#x2F; 准备state——用于存储数据\nconst state &#x3D; &#123;\n  sum: 0 &#x2F;&#x2F; 和\n&#125;\n&#x2F;&#x2F; 准备getters——用于将state中的数据进行加工\nconst getters &#x3D; &#123;\n\tbigSum(state)&#123;\n\t\treturn state.sum*10\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 创建并暴露 store\nexport default new Vuex.Store(&#123;\n  actions,\n  mutations,\n  state,\n  getters\n&#125;)\n\n\n17.6 map 方法\nmapState方法：用于帮助我们映射 state 中的数据为计算属性computed: &#123;\n\t&#x2F;&#x2F; ...Obj，将 Obj 里的每一组 key:value 展开放到该位置\n\t&#x2F;&#x2F; 借助 mapState 生成计算属性：sum、school、subject（对象写法）\n    ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),\n\n\t&#x2F;&#x2F; 借助 mapState 生成计算属性：sum、school、subject（数组写法），名字相同可简写\n\t...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n&#125;,\nmapGetters方法：用于帮助我们映射 getters 中的数据为计算属性 computed: &#123;\n\t&#x2F;&#x2F; 借助mapGetters 生成计算属性：bigSum（对象写法）\n\t...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),\n\n\t&#x2F;&#x2F; 借助mapGetters 生成计算属性：bigSum（数组写法），名字相同可简写\n\t...mapGetters([&#39;bigSum&#39;])\n&#125;,\nmapActions方法：用于帮助我们生成与 actions 对话的方法，即：包含 $store.dispatch(xxx) 的函数methods:&#123;\n\t&#x2F;&#x2F; 靠 mapActions 生成：incrementOdd、incrementWait（对象形式）\n\t...mapActions(&#123;incrementOdd:&#39;addOdd&#39;,incrementWait:&#39;addWait&#39;&#125;)\n\n\t&#x2F;&#x2F; 靠 mapActions 生成：incrementOdd、incrementWait（数组形式），名字相同可简写\n\t...mapActions([&#39;addOdd&#39;,&#39;addWait&#39;])\n&#125;\nmapMutations方法：用于帮助我们生成与 mutations 对话的方法，即：包含 $store.commit(xxx)的函数methods:&#123;\n\t&#x2F;&#x2F; 靠 mapActions 生成：increment、decrement（对象形式）\n\t...mapMutations(&#123;increment:&#39;ADD&#39;,decrement:&#39;REDUCE&#39;&#125;),\n\n\t&#x2F;&#x2F; 靠 mapMutations 生成：JIA、JIAN（对象形式），名字相同可简写\n\t...mapMutations([&#39;ADD&#39;,&#39;REDUCE&#39;]),\n&#125;\n\n备注：mapActions与 mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;h1&gt;放大 10 倍后的值：&#123;&#123;$store.getters.bigSum&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;h1&gt;学校：&#123;&#123;school&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;h1&gt;学科：&#123;&#123;subject&#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;select v-model.number&#x3D;&quot;num&quot;&gt;\n      &lt;option value&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;option&gt;\n      &lt;option value&#x3D;&quot;2&quot;&gt;2&lt;&#x2F;option&gt;\n      &lt;option value&#x3D;&quot;3&quot;&gt;3&lt;&#x2F;option&gt;\n    &lt;&#x2F;select&gt;\n    &lt;!-- 需要传参 --&gt;\n    &lt;button @click&#x3D;&quot;increment(num)&quot;&gt;+&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;decrement(num)&quot;&gt;-&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;incrementOdd(num)&quot;&gt;当前求和为奇数再加&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;incrementWait(num)&quot;&gt;等一等再加&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; mapState, mapGetters, mapActions, mapMutations &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Count&#39;,\n  data() &#123;\n    return &#123;\n      num: 1, &#x2F;&#x2F; 用户选择的数字\n    &#125;\n  &#125;,\n  methods: &#123;\n    ...mapMutations(&#123; increment: &#39;ADD&#39;, decrement: &#39;REDUCE&#39; &#125;),\n\n    ...mapActions(&#123; incrementOdd: &#39;addOdd&#39;, incrementWait: &#39;addWait&#39; &#125;)\n  &#125;,\n  computed: &#123;\n    ...mapState([&#39;sum&#39;, &#39;school&#39;, &#39;subject&#39;]),\n\n    ...mapGetters([&#39;bigSum&#39;])\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n&lt;style lang&#x3D;&quot;css&quot;&gt;&lt;&#x2F;style&gt;\n\n\n17.7 模块化+命名空间修改 store\nconst countAbout &#x3D; &#123;\n  namespaced:true, &#x2F;&#x2F; 开启命名空间\n  state:&#123;x:1&#125;,\n  mutations: &#123; ... &#125;,\n  actions: &#123; ... &#125;,\n  getters: &#123;\n    bigSum(state)&#123;\n       return state.sum * 10\n    &#125;\n  &#125;\n&#125;\n\nconst personAbout &#x3D; &#123;\n  namespaced:true, &#x2F;&#x2F; 开启命名空间\n  state:&#123; ... &#125;,\n  mutations: &#123; ... &#125;,\n  actions: &#123; ... &#125;\n&#125;\n\nconst store &#x3D; new Vuex.Store(&#123;\n  modules: &#123;\n    countAbout,\n    personAbout\n  &#125;\n&#125;)\n\n\n开启命名空间后，组件中读取 state 数据&#x2F;&#x2F; 方式一：自己直接读取\nthis.$store.state.personAbout.list\n&#x2F;&#x2F; 方式二：借助 mapState读取，在前面加上模块的名字\n...mapState(&#39;countAbout&#39;, [&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n开启命名空间后，组件中读取 getters 数据&#x2F;&#x2F; 方式一：自己直接读取\nthis.$store.getters[&#39;personAbout&#x2F;firstPersonName&#39;]\n&#x2F;&#x2F; 方式二：借助 mapGetters 读取\n...mapGetters(&#39;countAbout&#39;, [&#39;bigSum&#39;])\n开启命名空间后，组件中调用 dispatch&#x2F;&#x2F; 方式一：自己直接 dispatch\nthis.$store.dispatch(&#39;personAbout&#x2F;addPersonWang&#39;, person)\n&#x2F;&#x2F; 方式二：借助 mapActions\n...mapActions(&#39;countAbout&#39;, &#123;incrementOdd:&#39;addOdd&#39;,incrementWait:&#39;addWait&#39;&#125;)\n开启命名空间后，组件中调用commit &#x2F;&#x2F; 方式一：自己直接 commit\nthis.$store.commit(&#39;personAbout&#x2F;ADD_PERSON&#39;, person)\n&#x2F;&#x2F; 方式二：借助 mapMutations\n...mapMutations(&#39;countAbout&#39;, &#123;increment:&#39;ADD&#39;,decrement:&#39;REDUCE&#39;&#125;),\n\n18. vue-router 路由一个路由（route）就是一组映射关系（key - value），key 为路径, value 可能是 function 或 componen，多个路由需要路由器（router）进行管理。vue-router 是 vue 的一个插件库，专门用来实现 SPA 应用\n18.1 SPA\n单页 Web 应用（single page web application，SPA）\n整个应用只有一个完整的页面。\n点击页面中的导航链接不会刷新页面，只会做页面的局部更新\n数据需要通过 ajax 请求获取\n\n18.2 路由分类\n后端路由：\n理解：value 是 function, 用于处理客户端提交的请求\n工作过程：服务器接收到一个请求时, 根据请求路径找到匹配的函数来处理请求, 返回响应数据\n\n\n前端路由：\n理解：value 是 component，用于展示页面内容\n工作过程：当浏览器的路径改变时, 对应的组件就会显示\n\n\n\n18.3 基础使用\n安装：npm install vue-router@3，当前 vue-router 默认版本为 vue-router4，用在 Vue3 中，Vue2 只能用 vue-router3，安装时需要指定版本\n创建 router 的组件，路由组件通常存放在 src&#x2F;pages 文件夹，一般组件通常存放在 src&#x2F;components 文件夹\n创建路由器，在 src 目录下创建 router&#x2F;index.js&#x2F;&#x2F; 该文件专门用于创建整个应用的路由器\n&#x2F;&#x2F; 引入VueRouter\nimport VueRouter from &#39;vue-router&#39;\n\n&#x2F;&#x2F; 引入路由组件\nimport Home from &#39;..&#x2F;pages&#x2F;Home.vue&#39;\nimport About from &#39;..&#x2F;pages&#x2F;About.vue&#39;\n\n\n&#x2F;&#x2F; 创建 router 实例对象（路由器），去管理一组一组的路由规则，并暴露出去\nexport default new VueRouter(&#123;\n  &#x2F;&#x2F; 路由配置\n  routes: [\n    &#123;\n      path: &#39;&#x2F;about&#39;,\n      component: About\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;home&#39;,\n      component: Home\n    &#125;,\n  ]\n&#125;)\nmain.js，引入 vue-router，使用该插件&#x2F;&#x2F; 引入 Vue\nimport Vue from &#39;vue&#39;\n&#x2F;&#x2F; 引入 App 组件\nimport App from &#39;.&#x2F;App.vue&#39;\n&#x2F;&#x2F; 引入 VueRouter\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 引入路由器\nimport router from &#39;.&#x2F;router&#x2F;index.js&#39;\n\n&#x2F;&#x2F; 关闭 Vue 的生产提示\nVue.config.productionTip &#x3D; false\n\n&#x2F;&#x2F; 应用插件\nVue.use(VueRouter)\n\n&#x2F;&#x2F;创建vm\nnew Vue(&#123;\n\tel:&#39;#app&#39;,\n\trender: h &#x3D;&gt; h(App),\n\trouter:router\n&#125;)\nApp.vue，使用 &lt;router-link to&#x3D;”&#x2F;xxx”&gt; 标签实现路由的切换，to 表示路由路径，使用 &lt;router-view&gt; 标签指定组件的呈现位置&lt;template&gt;\n  &lt;div&gt;\n\t&lt;h2&gt;Vue Router Demo&lt;&#x2F;h2&gt;\n    &lt;div&gt;\n\t\t&lt;!-- 原始 html 中使用a标签实现页面的跳转 --&gt;\n\t\t&lt;!-- &lt;a class&#x3D;&quot;list-group-item active&quot; href&#x3D;&quot;.&#x2F;about.html&quot;&gt;About&lt;&#x2F;a&gt; --&gt;\n\t\t&lt;!-- &lt;a class&#x3D;&quot;list-group-item&quot; href&#x3D;&quot;.&#x2F;home.html&quot;&gt;Home&lt;&#x2F;a&gt; --&gt;\n\n\t\t&lt;!-- Vue中借助 router-link 标签实现路由的切换 --&gt;\n\t\t&lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;\n\t\t&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;Home&lt;&#x2F;router-link&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;div&gt;\n\t\t&lt;!-- 指定组件的呈现位置 --&gt;\n\t\t&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n\t&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;App&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n点击页面中的导航链接不会刷新页面，只会做页面的局部更新\n\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\n每个组件都有自己的 $route 属性，里面存储着自己的路由信息\n整个应用只有一个 router，可以通过组件的 $router 属性获取到\n\n18.4 多级（嵌套）路由\n再准备两个路由组件 Message.vue 和 News.vue\n\n在路由器里配置路由规则，src&#x2F;router&#x2F;index.js，使用 children 属性来配置多级路由\n&#x2F;&#x2F; 该文件专门用于创建整个应用的路由器\n&#x2F;&#x2F; 引入VueRouter\nimport VueRouter from &#39;vue-router&#39;\n\n&#x2F;&#x2F; 引入路由组件\nimport Home from &#39;..&#x2F;pages&#x2F;Home.vue&#39;\nimport About from &#39;..&#x2F;pages&#x2F;About.vue&#39;\nimport News from &#39;..&#x2F;pages&#x2F;News.vue&#39;\nimport Message from &#39;..&#x2F;pages&#x2F;Message.vue&#39;\n\n\n&#x2F;&#x2F; 创建一个路由器\nexport default new VueRouter(&#123;\n  &#x2F;&#x2F; 路由配置\n  routes: [\n    &#123;\n      path: &#39;&#x2F;about&#39;,\n      component: About\n    &#125;,\n    &#123;\n      path: &#39;&#x2F;home&#39;, &#x2F;&#x2F; 默认为一级路由\n      component: Home,\n      children: [ &#x2F;&#x2F; children 配置二级路由\n        &#123;\n          path: &#39;news&#39;, &#x2F;&#x2F; 此处前面不要加 &#x2F;，如一定不要写：&#x2F;news\n          component: News,\n        &#125;,\n        &#123;\n          path: &#39;message&#39;,\n          component: Message &#125;,\n      ]\n    &#125;,\n  ]\n&#125;)\n在 Home.vue 路由组件添加子路由\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;Home组件内容&lt;&#x2F;h2&gt;\n    &lt;div&gt; &lt;ul class&#x3D;&quot;nav nav-tabs&quot;&gt;\n        &lt;li&gt;\n          &lt;!-- 跳转（要写完整路径）--&gt;\n          &lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;News&lt;&#x2F;router-link&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li&gt;\n          &lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;message&quot;&gt;Message&lt;&#x2F;router-link&gt;\n        &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;\n      &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Home&#39;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n18.5 路由传参18.5.1 路由的query参数\n传递参数&lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;message in messageList&quot; :key&#x3D;&quot;message.id&quot;&gt;\n        &lt;!-- 跳转路由并携带 query 参数，to 的字符串写法 --&gt;\n        &lt;!-- &lt;router-link :to&#x3D;&quot;&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;$&#123;message.id&#125;&amp;title&#x3D;$&#123;message.title&#125;&#96;&quot;&gt; &#123;&#123; message.title &#125;&#125; &lt;&#x2F;router-link&gt; --&gt;\n\n        &lt;!-- 跳转路由并携带 query 参数，to 的对象写法 --&gt;\n        &lt;router-link :to&#x3D;&quot;&#123;\n            path:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\n            query:&#123;\n              id: message.id,\n              title: message.title\n            &#125;\n          &#125;&quot;&gt; &#123;&#123;message.title&#125;&#125; &lt;&#x2F;router-link&gt;\n      &lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Message&#39;,\n  data() &#123;\n    return &#123;\n      messageList: [\n        &#123; id: &#39;001&#39;, title: &#39;message001&#39; &#125;,\n        &#123; id: &#39;002&#39;, title: &#39;message002&#39; &#125;,\n        &#123; id: &#39;003&#39;, title: &#39;message003&#39; &#125;,\n      ]\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n接收参数&lt;template&gt;\n  &lt;ul&gt;\n  \t&lt;!-- 接收参数 --&gt;\n    &lt;li&gt;消息编号：&#123;&#123;$route.query.id&#125;&#125;&lt;&#x2F;li&gt;\n    &lt;li&gt;消息标题：&#123;&#123;$route.query.title&#125;&#125; &lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Detail&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n18.5.2 命名路由在路由器里（即 src&#x2F;router&#x2F;index.js）使用 name 属性给路由命名\n&#x2F;&#x2F; 该文件专门用于创建整个应用的路由器\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 引入组件\n......\n\n&#x2F;&#x2F; 创建一个路由器\nexport default new VueRouter(&#123;\n  &#x2F;&#x2F; 路由配置\n  routes: [\n    &#123; path: &#39;&#x2F;about&#39;, component: About &#125;,\n    &#123; path: &#39;&#x2F;home&#39;, component: Home, children: [\n        &#123; path: &#39;news&#39;, component: News, &#125;,\n        &#123; path: &#39;message&#39;, component: Message,\n          children: [\n            &#123;\n              name: &#39;detail&#39;, &#x2F;&#x2F; 给路由命名\n              path: &#39;detail&#39;,\n              component: Detail,\n            &#125;\n          ]\n        &#125;,\n      ]\n    &#125;,\n  ]\n&#125;)\n\n简化路由的跳转\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;message in messageList&quot; :key&#x3D;&quot;message.id&quot;&gt;\n        &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;\n        &lt;router-link :to&#x3D;&quot;&#123;\n            name: &#39;detail&#39;,\n            &lt;!-- path:&#39;&#x2F;home&#x2F;message&#x2F;detail&#39;, --&gt;\n            query:&#123;\n              id: message.id,\n              title: message.title\n            &#125;\n          &#125;&quot;&gt; &#123;&#123;message.title&#125;&#125; &lt;&#x2F;router-link&gt;\n      &lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n18.5.2 路由的 params 参数路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用命名路由 name 配置\n\n配置路由，声明接收 params 参数&#x2F;&#x2F; 该文件专门用于创建整个应用的路由器\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 引入组件\n......\n\n&#x2F;&#x2F; 创建一个路由器\nexport default new VueRouter(&#123;\n  &#x2F;&#x2F; 路由配置\n  routes: [\n    &#123; path: &#39;&#x2F;about&#39;, component: About &#125;,\n    &#123; path: &#39;&#x2F;home&#39;, component: Home, children: [\n        &#123; path: &#39;news&#39;, component: News, &#125;,\n        &#123; path: &#39;message&#39;, component: Message,\n          children: [\n            &#123;\n              name: &#39;detail&#39;, &#x2F;&#x2F; 给路由命名\n              path:&#39;detail&#x2F;:id&#x2F;:title&#39;, &#x2F;&#x2F; 使用占位符声明接收 params 参数\n              component: Detail,\n            &#125;\n          ]\n        &#125;,\n      ]\n    &#125;,\n  ]\n&#125;)\n传递参数&lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;message in messageList&quot; :key&#x3D;&quot;message.id&quot;&gt;\n        &lt;!-- 跳转并携带 params 参数，to 的字符串写法 --&gt;\n\t\t&lt;!-- &lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;message.id&#125;&#x2F;$&#123;message.title&#125;&quot;&gt;&#123;&#123;message.title&#125;&#125;&lt;&#x2F;router-link&gt; --&gt;\n\n        &lt;!-- 跳转路由并携带 params 参数，to 的对象写法 --&gt;\n        &lt;router-link :to&#x3D;&quot;&#123;\n            name: &#39;detail&#39;,\n            params:&#123;\n              id: message.id,\n              title: message.title\n            &#125;\n          &#125;&quot;&gt; &#123;&#123;message.title&#125;&#125; &lt;&#x2F;router-link&gt;\n      &lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n接收参数&lt;template&gt;\n  &lt;ul&gt;\n    &lt;li&gt;消息编号：&#123;&#123;$route.params.id&#125;&#125;&lt;&#x2F;li&gt;\n    &lt;li&gt;消息标题：&#123;&#123;$route.params.title&#125;&#125; &lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;template&gt;\n\n\n18.6 路由的 props 配置在路由器里（即 src&#x2F;router&#x2F;index.js）使用 name 属性给路由命名\n&#x2F;&#x2F; 该文件专门用于创建整个应用的路由器\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 引入组件\n......\n\n&#x2F;&#x2F; 创建一个路由器\nexport default new VueRouter(&#123;\n  &#x2F;&#x2F; 路由配置\n  routes: [\n    &#123; path: &#39;&#x2F;about&#39;, component: About &#125;,\n    &#123; path: &#39;&#x2F;home&#39;, component: Home, children: [\n        &#123; path: &#39;news&#39;, component: News, &#125;,\n        &#123; path: &#39;message&#39;, component: Message,\n          children: [\n            &#123;\n              name: &#39;detail&#39;, &#x2F;&#x2F; 给路由命名\n              path: &#39;detail&#x2F;:id&#x2F;:title&#39;,\n              component: Detail,\n              &#x2F;&#x2F; 第一种写法：props 值为对象，该对象中所有的 key-value 的组合最终都会通过 props 传给 Detail 组件\n              &#x2F;&#x2F; props:&#123;a:900&#125;\n\n              &#x2F;&#x2F; 第二种写法：props 值为布尔值，布尔值为 true，则把路由收到的所有 params 参数通过 props 传给 Detail 组件\n              &#x2F;&#x2F; props:true\n\n              &#x2F;&#x2F;第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n              props($route)&#123; &#x2F;&#x2F; 或者写为 route、&#123;route:&#123;id, title&#125;&#125;\n                return &#123;\n                  id: $route.params.id,\n                  title: $route.params.title\n                &#125;\n              &#125;\n            &#125;\n          ]\n        &#125;,\n      ]\n    &#125;,\n  ]\n&#125;)\n\n让路由组件更方便的收到参数\n&lt;template&gt;\n  &lt;ul&gt;\n    &lt;li&gt;消息编号：&#123;&#123;id&#125;&#125;&lt;&#x2F;li&gt;\n    &lt;li&gt;消息标题：&#123;&#123;title&#125;&#125; &lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Detail&#39;,\n  props: [&#39;id&#39;, &#39;title&#39;],\n&#125;\n&lt;&#x2F;script&gt;\n\n18.7 &lt;router-link&gt;的 replace 属性控制路由跳转时操作浏览器历史记录的模式\n\n浏览器的历史记录有两种写入方式：分别为 push 和 replace，push 是追加历史记录，replace 是替换当前记录。路由跳转时候默认为 push\n开启 replace 模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt;，完整写法为：&lt;router-link :replace=&quot;true&quot; .......&gt;News&lt;/router-link&gt;\n\n18.8 编程式路由导航不借助 &lt;router-link&gt; 实现路由跳转，让路由跳转更加灵活\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;message in messageList&quot; :key&#x3D;&quot;message.id&quot;&gt;\n        &lt;!-- 跳转路由并携带 params 参数，to的对象写法 --&gt;\n        &lt;router-link :to&#x3D;&quot;&#123;\n            name: &#39;detail&#39;,\n            params:&#123;\n              id: message.id,\n              title: message.title\n            &#125;\n          &#125;&quot;&gt; &#123;&#123;message.title&#125;&#125; &lt;&#x2F;router-link&gt;\n        &lt;button @click&#x3D;&quot;pushShow(message)&quot;&gt;push查看&lt;&#x2F;button&gt;\n        &lt;button&gt;replace查看&lt;&#x2F;button&gt;\n      &lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n    &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  &#x2F;&#x2F; eslint-disable-next-line vue&#x2F;multi-word-component-names\n  name: &#39;Message&#39;,\n  methods: &#123;\n    pushShow(message) &#123;\n      this.$router.push(&#123;\n        name: &#39;detail&#39;,\n        params: &#123;\n          id: message.id,\n          title: message.title\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n使用 push 和 replace 方法来进行跳转操作，可用于 button 按钮控制前进和后退\nthis.$router.forward() &#x2F;&#x2F; 前进\nthis.$router.back() &#x2F;&#x2F; 后退\nthis.$router.go() &#x2F;&#x2F; 可前进也可后退，传入参数为前进或后退的步数\n\n18.9 缓存路由组件让不展示的路由组件保持挂载，不被销毁，在组件的呈现位置包上 &lt;keep-alive&gt; 标签，include 属性表示组件名\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;Home组件内容&lt;&#x2F;h2&gt;\n    &lt;div&gt;\n      &lt;ul class&#x3D;&quot;nav nav-tabs&quot;&gt;\n        &lt;li&gt;\n          &lt;router-link class&#x3D;&quot;list-group-item&quot; active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;News&lt;&#x2F;router-link&gt;\n        &lt;&#x2F;li&gt;\n        &lt;li&gt;\n          &lt;router-link class&#x3D;&quot;list-group-item&quot; active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;home&#x2F;message&quot;&gt;Message&lt;&#x2F;router-link&gt;\n        &lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n      &lt;!-- 缓存多个路由组件 --&gt;\n\t  &lt;!-- &lt;keep-alive :include&#x3D;&quot;[&#39;News&#39;,&#39;Message&#39;]&quot;&gt; --&gt;\n      &lt;!-- 缓存一个路由组件 --&gt;\n\t  &lt;keep-alive include&#x3D;&quot;News&quot;&gt; \n\t\t&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n\t  &lt;&#x2F;keep-alive&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n切换其他组件再回来，内容还在\n18.10 路由组件的生命周期钩子路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\nactivated ：路由组件被激活时触发\ndeactivated ：路由组件非激活时触发\n\n&lt;script&gt;\n\texport default &#123;\n\t\tname:&#39;News&#39;,\n\t\tdata() &#123;\n\t\t\treturn &#123;\n\t\t\t\topacity:1\n\t\t\t&#125;\n\t\t&#125;,\n\t\tactivated() &#123;\n\t\t\tconsole.log(&#39;News组件被激活了&#39;)\n\t\t\tthis.timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n\t\t\t\tthis.opacity -&#x3D; 0.01\n\t\t\t\tif(this.opacity &lt;&#x3D; 0) this.opacity &#x3D; 1\n\t\t\t&#125;,16)\n\t\t&#125;,\n\t\tdeactivated() &#123;\n\t\t\tconsole.log(&#39;News组件失活了&#39;)\n\t\t\tclearInterval(this.timer)\n\t\t&#125;,\n\t&#125;\n&lt;&#x2F;script&gt;\n\n18.11 路由（导航）守卫对路由进行权限控制，分为全局守卫、独享守卫、组件内守卫\n18.11.1 meta 路由元信息将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的 meta 属性来实现，并且它可以在路由地址和导航守卫上都被访问到：\nconst router &#x3D;  new VueRouter(&#123;\n\troutes:[\n\t\t&#123;\n\t\t\tname:&#39;guanyu&#39;,\n\t\t\tpath:&#39;&#x2F;about&#39;,\n\t\t\tcomponent:About,\n\t\t\tmeta:&#123;isAuth:true, title:&#39;关于&#39;&#125;\n\t\t&#125;,\n\t]\n&#125;)\n\n18.11.2 全局守卫在路由器 src&#x2F;router&#x2F;index.js 定义全局守卫，分为全局前置守卫和后置守卫，可以通过路由元信息存储的内容来进行验证\n&#x2F;&#x2F; 该文件专门用于创建整个应用的路由器\nimport VueRouter from &#39;vue-router&#39;\n&#x2F;&#x2F; 引入组件\n......\n\n&#x2F;&#x2F; 创建并暴露一个路由器\nconst router &#x3D;  new VueRouter(&#123;\n\troutes:[\n\t\t&#123; name:&#39;guanyu&#39;, path:&#39;&#x2F;about&#39;, component:About, meta:&#123;title:&#39;关于&#39;&#125; &#125;,\n\t\t&#123; name:&#39;zhuye&#39;, path:&#39;&#x2F;home&#39;, component:Home, meta:&#123;title:&#39;主页&#39;&#125;,\n\t\t\tchildren:[\n\t\t\t\t&#123; name:&#39;xinwen&#39;, path:&#39;news&#39;, component:News, meta:&#123;isAuth:true,title:&#39;新闻&#39;&#125; &#125;,\n\t\t\t\t&#123; name:&#39;xiaoxi&#39;, path:&#39;message&#39;, component:Message, meta:&#123;isAuth:true,title:&#39;消息&#39;&#125;,\n\t\t\t\t\tchildren:[\n\t\t\t\t\t\t&#123; name:&#39;xiangqing&#39;, path:&#39;detail&#39;, component:Detail, meta:&#123;isAuth:true,title:&#39;详情&#39;&#125;, props:true\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t]\n\t\t\t\t&#125;\n\t\t\t]\n\t\t&#125;\n\t]\n&#125;)\n\n&#x2F;&#x2F; 全局前置路由守卫————初始化的时候被调用、每次路由切换之前被调用\nrouter.beforeEach((to, from, next)&#x3D;&gt;&#123;\n\tif(to.meta.isAuth)&#123; &#x2F;&#x2F; 判断是否需要鉴权\n\t\tif(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;vue&#39;)&#123;\n\t\t\tnext()\n\t\t&#125;else&#123;\n\t\t\talert(&#39;学校名不对，无权限查看！&#39;)\n\t\t&#125;\n\t&#125;else&#123;\n\t\tnext()\n\t&#125;\n&#125;)\n\n&#x2F;&#x2F;全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用\nrouter.afterEach((to, from)&#x3D;&gt;&#123;\n\tdocument.title &#x3D; to.meta.title || &#39;系统&#39;\n&#125;)\n\nexport default router\n\n参数 To 和 From点击 News，进行权限判断\n18.11.3 独享守卫只有前置守卫，没有后置\nconst router &#x3D;  new VueRouter(&#123;\n\troutes:[\n\t\t&#123;\n\t\t\tname:&#39;zhuye&#39;, path:&#39;&#x2F;home&#39;, component:Home, meta:&#123;title:&#39;主页&#39;&#125;,\n\t\t\tchildren:[\n\t\t\t\t&#123;\n\t\t\t\t\tname:&#39;xinwen&#39;,\n\t\t\t\t\tpath:&#39;news&#39;,\n\t\t\t\t\tcomponent:News,\n\t\t\t\t\tmeta:&#123;isAuth:true,title:&#39;新闻&#39;&#125;,\n\t\t\t\t\tbeforeEnter: (to, from, next) &#x3D;&gt; &#123;\n\t\t\t\t\t\tif(to.meta.isAuth)&#123; &#x2F;&#x2F; 判断是否需要鉴权\n\t\t\t\t\t\t\tif(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;vue&#39;)&#123;\n\t\t\t\t\t\t\t\tnext()\n\t\t\t\t\t\t\t&#125;else&#123;\n\t\t\t\t\t\t\t\talert(&#39;学校名不对，无权限查看！&#39;)\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;else&#123;\n\t\t\t\t\t\t\tnext()\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;,\n\t\t\t]\n\t\t&#125;\n\t]\n&#125;)\n&#x2F;&#x2F; 全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用\nrouter.afterEach((to,from)&#x3D;&gt;&#123;\n\tdocument.title &#x3D; to.meta.title || &#39;系统&#39;\n&#125;)\nexport default router\n\n18.11.4 组件内守卫&lt;script&gt;\n\texport default &#123;\n\t\tname:&#39;About&#39;,\n\t\t&#x2F;&#x2F; 通过路由规则，进入该组件时被调用\n\t\tbeforeRouteEnter (to, from, next) &#123;\n\t\t\tif(to.meta.isAuth)&#123; &#x2F;&#x2F;判断是否需要鉴权\n\t\t\t\tif(localStorage.getItem(&#39;school&#39;)&#x3D;&#x3D;&#x3D;&#39;vue&#39;)&#123;\n\t\t\t\t\tnext()\n\t\t\t\t&#125;else&#123;\n\t\t\t\t\talert(&#39;学校名不对，无权限查看！&#39;)\n\t\t\t\t&#125;\n\t\t\t&#125;else&#123;\n\t\t\t\tnext()\n\t\t\t&#125;\n\t\t&#125;,\n\t\t&#x2F;&#x2F; 通过路由规则，离开该组件时被调用\n\t\tbeforeRouteLeave (to, from, next) &#123;\n\t\t\tnext()\n\t\t&#125;\n\t&#125;\n&lt;&#x2F;script&gt;\n\n18.12 路由器的两种工作模式&#x2F;&#x2F; 创建并暴露一个路由器\nexport default new VueRouter(&#123;\n  &#x2F;&#x2F; mode: &#39;history&#39;\n  mode: &#39;hash&#39;,\n\troutes:[\n\t\t&#123;\n\t\t\tname:&#39;guanyu&#39;,\n\t\t\tpath:&#39;&#x2F;about&#39;,\n\t\t\tcomponent:About,\n\t\t\tmeta:&#123;title:&#39;关于&#39;&#125;\n\t\t&#125;,\n\t]\n&#125;)\n\n\nhash 模式：\n# 及其后面的内容就是 hash 值，但地址中永远带着 # 号，不美观\nhash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器，兼容性较好\n若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法\n\n\nhistory 模式：\n地址干净，美观\n兼容性和 hash 模式相比略差\n应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n\n\n\n19. Vue UI 组件库19.1 移动端常用 UI 组件库\nVant ：https://youzan.github.io/vant\nCube UI ：https://didi.github.io/cube-ui\nMint UI ：http://mint-ui.github.io\n\n19.2 PC 端常用 UI 组件库\nElement UI ：https://element.eleme.cn\nIView UI ：https://www.iviewui.com\n\n19.3 Element UI详见：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;124464590\n","slug":"BlogRepository/Vue/Vue2 总结（开发）","date":"2022-03-30T08:53:37.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"凡"},{"id":"9d80fc9fd98eea4d38697140d0ff638e","title":"Vue2 总结（Basic）","content":"1. 简介1.1 特点\n遵循 MVVM 模式\n编码简洁, 体积小, 运行效率高, 适合移动&#x2F;PC 端开发\n它本身只关注 UI, 也可以引入其它第三方库开发项目\n\n1.2 与其它 JS 框架的关联\n借鉴 Angular 的模板和数据绑定技术\n借鉴 React 的组件化和虚拟 DOM 技术\n\n1.3 Vue 周边库\nvue-cli: vue 脚手架\nvue-resource\naxios\nvue-router: 路由\nvuex: 状态管理\nelement-ui: 基于 vue 的 UI 组件库(PC 端）\n\n2. 环境配置2.1 下载 devtools点击官网的 生态系统 –&gt; Devtools跳转到 GitHub 地址，点击 Install the extension 下载插件选择对应的浏览器进行下载\n2.2 关闭生产提示点击官网的 学习 –&gt; API有一个全局配置 Vue.config，修改 productionTip 属性为 false\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\tVue.config.productionTip &#x3D; false ;\n&lt;&#x2F;script&gt;\n\n3. 初识 Vue3.1 引入 Vue.js&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;!-- 引入 Vue.js --&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n\n3.2 使用\n先创建一个容器，想让 Vue 工作，就必须创建一个 Vue 实例，且传入创建好的容器对象\n容器里的代码依然符合 HTML 规范，只不过混入了一些特殊的 Vue 语法；\n容器里的代码被称为【Vue模板】\nVue 实例和容器是一一对应的\n真实开发中只有一个 Vue 实例，并且会配合着组件一起使用\n容器中的插值语法 &#123;&#123;xxx&#125;&#125; 中的 xxx 要写 JS 表达式，且 xxx 可以自动读取到 data 中的所有属性\n一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新\n注意区分：JS 表达式 和 JS 代码(语句)\nJS表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：\na\na+b\ndemo(1)\nx === y ? &#39;a&#39; : &#39;b&#39;\n\n\nJS 代码(语句)\nif(){ }\nfor(){ }\n\n\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;!-- 引入 Vue.js --&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;!-- 准备好一个容器 --&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    Hello，Vue！&#123;&#123;name&#125;&#125; &#123;&#123;Date.now()&#125;&#125;\n  &lt;&#x2F;div&gt;\n\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false; &#x2F;&#x2F; 阻止 Vue 在启动时生成生产提示。\n\n    &#x2F;&#x2F; 创建 Vue 实例\n    let vm &#x3D; new Vue(&#123;\n      el: &#39;#root&#39;, &#x2F;&#x2F; el 用于指定当前 Vue 实例为哪个容器服务，值通常为 css 选择器字符串\n      data:&#123; &#x2F;&#x2F; data 中用于存储数据，数据供 el 所指定的容器去使用\n        name: &#39;凡&#39;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n4. 模板语法Vue 模板语法有 2 大类：\n\n插值语法：功能：用于解析标签体内容写法：**&#123;&#123;xxx&#125;&#125;**，xxx 是 JS 表达式，且可以直接读取到 data 中的所有属性\n指令语法：功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）举例：v-bind:href=&quot;xxx&quot; 或简写为 :href=&quot;xxx&quot;，xxx 同样要写 JS 表达式，且可以直接读取到 data 中的所有属性备注：Vue 中有很多的指令，且形式都是：v-???\n\n&lt;body&gt;\n  &lt;!-- 准备好一个容器 --&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    Hello，Vue！ &#123;&#123;name&#125;&#125; &#123;&#123;Date.now()&#125;&#125; &lt;br&gt;\n    &lt;a v-bind:href&#x3D;&quot;blog.url.toUpperCase()&quot;&gt;点击去&#123;&#123;blog.name&#125;&#125; &lt;&#x2F;a&gt;\n    &lt;a :href&#x3D;&quot;blog.url&quot;&gt;点击去&#123;&#123;blog.name&#125;&#125; &lt;&#x2F;a&gt;\n  &lt;&#x2F;div&gt;\n\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false; &#x2F;&#x2F;阻止 Vue 在启动时生成生产提示。\n\n    &#x2F;&#x2F; 创建 Vue 实例\n    let vm &#x3D; new Vue(&#123;\n      el: &#39;#root&#39;, &#x2F;&#x2F; el 用于指定当前 Vue 实例为哪个容器服务，值通常为 css 选择器字符串\n      data:&#123; &#x2F;&#x2F; data 中用于存储数据，数据供 el 所指定的容器去使用\n        name: &#39;凡&#39;,\n        blog: &#123;\n          name: &#39;Fan\\&#39;s Blog&#39;,\n          url: &#39;https:&#x2F;&#x2F;blog.fan223.cn&#39;\n        &#125;\n      &#125;\n    &#125;);\n    &#x2F;&#x2F; vm.$mount(&#39;#root&#39;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\nel 的两种写法&#x2F;&#x2F; 第一种\nlet vm &#x3D; new Vue(&#123;\n  el: &#39;#root&#39;, &#x2F;&#x2F; el 用于指定当前 Vue 实例为哪个容器服务，值通常为 css 选择器字符串\n  &#125;\n&#125;);\n&#x2F;&#x2F; 第二种\nlet vm &#x3D; new Vue(&#123;\n&#125;);\nvue.$mount(&#39;#root&#39;);\ndata 的两种写法&#x2F;&#x2F; 第一种 对象式\nlet vm &#x3D; new Vue(&#123;\n  data:&#123; &#x2F;&#x2F; data 中用于存储数据，数据供 el 所指定的容器去使用\n    name: &#39;凡&#39;,\n    blog: &#123;\n      name: &#39;Fan\\&#39;s Blog&#39;,\n      url: &#39;https:&#x2F;&#x2F;blog.fan223.cn&#39;\n    &#125;\n  &#125;\n&#125;);\n&#x2F;&#x2F; 第二种 函数式，在使用组件时，必须使用函数式，不然会报错\n&#x2F;&#x2F; 同时由 Vue 管理的函数不能用箭头函数 data:() &#x3D;&gt; &#123; &#125;，不然 this 不再是 Vue 实例，而是全局 Window 对象\nlet vm &#x3D; new Vue(&#123;\n  &#x2F;&#x2F; data: function()&#123;\n  &#x2F;&#x2F; data:() &#x3D;&gt; &#123; 箭头函数\n  data()&#123;\n    return &#123;\n      name: &#39;凡&#39;,\n      blog: &#123;\n        name: &#39;Fan\\&#39;s Blog&#39;,\n        url: &#39;https:&#x2F;&#x2F;blog.fan223.cn&#39;\n      &#125;\n    &#125;\n  &#125;\n&#125;);\n\n5. 数据绑定Vue 中有 2 种数据绑定的方式：\n\n单向绑定(v-bind)：数据只能从 data 流向页面，data 改变，页面会发生改变；页面改变，但 data 不会改变\n双向绑定(v-model)：数据不仅能从 data 流向页面，还可以从页面流向 data，任意改变一个，都会发生改变\n备注：\n双向绑定一般都应用在表单类元素上（如：input、select 等）\nv-model:value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值\n\n\n\n&lt;body&gt;\n  &lt;!-- 准备好一个容器 --&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; :value&#x3D;&quot;blog.name&quot; &gt; &lt;br&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; v-model&#x3D;&quot;blog.name&quot; &gt;\n  &lt;&#x2F;div&gt;\n\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false; &#x2F;&#x2F; 阻止 Vue 在启动时生成生产提示。\n\n    &#x2F;&#x2F; 创建 Vue 实例\n    let vm &#x3D; new Vue(&#123;\n      el: &#39;#root&#39;, &#x2F;&#x2F; el 用于指定当前 Vue 实例为哪个容器服务，值通常为 css 选择器字符串\n      data:&#123; &#x2F;&#x2F; data 中用于存储数据，数据供 el 所指定的容器去使用\n        name: &#39;凡&#39;,\n        blog: &#123;\n          name: &#39;Fan\\&#39;s Blog&#39;,\n          url: &#39;https:&#x2F;&#x2F;blog.fan223.cn&#39;\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n6. MVVM 模型\nM：模型(Model) ：对应 data 中的数据\nV：视图(View) ：模板\nVM：视图模型(ViewModel) ： Vue 实例对象\n\nvm 身上所有的属性 及 Vue 原型上所有属性，在 Vue 模板中都可以直接使用\n7. 数据代理数据代理：通过一个对象代理对另一个对象中属性的操作（读&#x2F;写）\n7.1 Object.defineProperty() 方法7.1.1 作用直接在一个对象上定义新属性，或者修改已经存在的属性\n&lt;body&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let person &#x3D; &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n    &#125;\n\n    Object.defineProperty(person, &#39;age&#39;,&#123;\n      value: 18,\n    &#125;);\n    console.log(person)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n其中，直接写在 person 中的属性是可以被枚举的，即可遍历的，而 Object.defineProperty() 方法定义的属性不能被枚举，同时也不能被修改和删除\nconsole.log(Object.keys(person));\n&#x2F;&#x2F; 或\nfor (const key in person) &#123;\n  if (Object.hasOwnProperty.call(person, key)) &#123;\n\tconsole.log(&#39;@&#39;, person[key])\n  &#125;\n&#125;\n\n\n7.1.2 开启控制属性&lt;body&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let person &#x3D; &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n    &#125;\n\n    Object.defineProperty(person, &#39;age&#39;,&#123;\n      value: 18,\n      enumerable: true,   &#x2F;&#x2F; 控制属性是否可以枚举，默认值是 false\n      writable: true,     &#x2F;&#x2F; 控制属性是否可以被修改，默认值是 false\n\t  configurable: true, &#x2F;&#x2F; 控制属性是否可以被删除，默认值是 false\n    &#125;);\n    console.log(Object.keys(person))\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n7.1.3 get() 和 set() 方法（核心）&lt;body&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let number &#x3D; 18;\n    let person &#x3D; &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n      age: number,\n    &#125;\n    console.log(Object.keys(person))\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n当使用一个变量为 age 赋值时，当修改变量的值，age 并不会发生改变使用 get() 和 set() 方法对值进行同步修改\n&lt;body&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    let number &#x3D; 18;\n    let person &#x3D; &#123;\n      name: &#39;张三&#39;,\n      sex: &#39;男&#39;,\n    &#125;\n\n    Object.defineProperty(person, &#39;age&#39;,&#123;\n      &#x2F;&#x2F; 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\n\t  get()&#123;\n\t\tconsole.log(&#39;有人读取age属性了&#39;)\n\t\treturn number\n\t  &#125;,\n\n\t  &#x2F;&#x2F; 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值\n\t  set(value)&#123;\n\t\tconsole.log(&#39;有人修改了age属性，且值是&#39;,value)\n\t\tnumber &#x3D; value\n\t  &#125;\n    &#125;);\n    console.log(Object.keys(person))\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n7.2 简单示例&lt;body&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\tlet obj1 &#x3D; &#123;x: 100&#125;;\n\tlet obj2 &#x3D; &#123;y: 200&#125;;\n\n\tObject.defineProperty(obj2, &#39;x&#39;,&#123;\n\n\t  get()&#123;\n\t\treturn obj1.x;\n\t  &#125;,\n\n\t  set(value)&#123;\n\t\tobj1.x &#x3D; value;\n\t  &#125;\n\t&#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n通过 obj2 代理的 obj1 的值，使用 obj2 对 ojb1 的值进行修改\n7.3 Vue 中的数据代理\n\n通过 vm 对象来代理 data 对象中属性的操作（读&#x2F;写），vm 中的 _data 即为 data 对象，vm._data &#x3D;&#x3D;&#x3D; data\nVue 中数据代理的好处：更加方便的操作 data 中的数据\n基本原理：\n通过 Object.defineProperty() 把 data 对象中所有属性添加到 vm 上\n为每一个添加到 vm 上的属性，都指定一个 getter&#x2F;setter\n在 getter&#x2F;setter 内部去操作（读&#x2F;写）data 中对应的属性\n\n\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;h1&gt;地址：&#123;&#123;address&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false; &#x2F;&#x2F; 阻止 vue 在启动时生成生产提示\n\n    let vm &#x3D; new Vue(&#123;\n      el: &#39;#root&#39;,\n      data() &#123;\n        return &#123;\n          name: &#39;张三&#39;,\n          address: &#39;长沙&#39;,\n        &#125;\n      &#125;\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n修改 name 属性的值，页面会即时变化\n8. 事件管理8.1 基本使用\n使用 v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名\n事件的回调需要配置在 methods 对象中，最终会在 vm 上\nmethods 中配置的函数，不要用箭头函数！否则 this 就不是 vm 了\nmethods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是vm 或 组件实例对象；\n@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot;  效果一致，但后者可以传参\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;button v-on:click&#x3D;&quot;showInfo1&quot;&gt;点击提示信息1（不传参）&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;showInfo2(77, $event)&quot;&gt;点击提示信息2（传参）&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n\n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data() &#123;\n        return &#123;\n          name: &quot;张三&quot;,\n        &#125;\n      &#125;,\n      methods: &#123;\n        showInfo1(event)&#123;\n          alert(&quot;info&quot;);\n        &#125;,\n        showInfo2(number, event)&#123;\n          alert(number);\n          console.log(event)\n          console.log(event.target.innerText);\n        &#125;\n      &#125;,\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n点击第一个事件：点击第二个事件：\n8.2 事件修饰符8.2.1 prevent 阻止默认事件（常用）点击链接会跳转到 href 里的地址，但是加上点击事件之后希望阻止原来的默认跳转事件，只发生点击事件，不发生跳转。两种方式\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot; @click&#x3D;&quot;showInfo1&quot;&gt;跳转到1&lt;&#x2F;a&gt;\n\t    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot; @click.prevent&#x3D;&quot;showInfo2&quot;&gt;跳转到2&lt;&#x2F;a&gt;\n\t&lt;&#x2F;div&gt;\n\t  \n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods: &#123;\n\t        showInfo1(event)&#123;\n\t          event.preventDefault();\n\t          alert(&quot;info1&quot;);\n\t        &#125;,\n\t        showInfo2(event)&#123;\n\t          alert(&quot;info2&quot;);\n\t        &#125;,\n\t      &#125;,\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n只发生点击事件，点击确定后，不发生跳转\n8.2.2 stop 阻止事件冒泡（常用）在发生 button 里的点击事件后，会冒泡到 div 的点击事件。现在想让 button 里的点击事件发生后不会冒泡到发生 div 的点击事件。两种方式。可以与其他修饰符连用，如阻止事件冒泡并阻止默认事件\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t    &lt;div class&#x3D;&quot;demo01&quot; @click&#x3D;&quot;showInfo1&quot;&gt;\n\t        &lt;!-- &lt;button @click&#x3D;&quot;showInfo2&quot;&gt;点击提示信息&lt;&#x2F;button&gt; --&gt;\n            &lt;button @click.stop&#x3D;&quot;showInfo2&quot;&gt;点击提示信息&lt;&#x2F;button&gt;\n            &lt;button href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot; @click.stop.prevent&#x3D;&quot;showInfo2&quot;&gt;点击提示信息&lt;&#x2F;button&gt;\n\t    &lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods: &#123;\n\t        showInfo1(event)&#123;\n\t          alert(&quot;info1&quot;);\n\t        &#125;,\n\t        showInfo2(event)&#123;\n\t          &#x2F;&#x2F; event.stopPropagation();\n\t          alert(&quot;info2&quot;);\n\t        &#125;,\n\t      &#125;,\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n点击 button，先发生 button 的事件，弹出 info2，然后会冒泡到 div 的事件，弹出 info1\n8.2.3 once 事件只触发一次（常用）一个事件，只想让第一次才生效，后面该事件不再生效\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t    &lt;button @click.once&#x3D;&quot;showInfo1&quot;&gt;点击提示信息&lt;&#x2F;button&gt;\n\t&lt;&#x2F;div&gt;\n\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods: &#123;\n\t        showInfo1(event)&#123;\n\t          alert(&quot;info1&quot;);\n\t        &#125;\n\t      &#125;,\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n第一次点击会有弹窗，但后面再点击不会弹窗\n8.2.4 capture 使用事件的捕获模式事件是先进行捕获，由外到内，由 div1 –&gt; div2；但事件发生是在冒泡，是由内到外，div2 –&gt; div1，现在想让事件在捕获阶段就发生\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t    &lt;div class&#x3D;&quot;box1&quot; @click&#x3D;&quot;showMsg(&#39;div1&#39;)&quot;&gt;\n\t      div1\n\t      &lt;div class&#x3D;&quot;box2&quot; @click&#x3D;&quot;showMsg(&#39;div2&#39;)&quot;&gt;\n\t        div2\n\t      &lt;&#x2F;div&gt;\n\t    &lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods: &#123;\n\t        showMsg(msg)&#123;\n\t          console.log(msg);\n\t        &#125;,\n\t      &#125;,\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n点击 div2，会先发生 div2，再冒泡到 div1 发生让事件在捕获阶段就发生，点击 div2，先捕获到 div1 发生div1，在捕获到div2 \n8.2.5 self 只有 event.target 是当前操作的元素时才触发事件当 button 事件发生后，会冒泡到 div，但此时并不是 div 在操作该事件，是 button 冒泡过来的。self 保证只有 event.target 是当前操作的元素时才触发事件，冒泡不会生效\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t    &lt;div class&#x3D;&quot;demo01&quot; @click.self&#x3D;&quot;showInfo1&quot;&gt;\n        &lt;button @click&#x3D;&quot;showInfo2&quot;&gt;点击提示信息&lt;&#x2F;button&gt;\n\t    &lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods: &#123;\n\t        showInfo1(event)&#123;\n\t          alert(&quot;info1&quot;);\n\t        &#125;,\n\t        showInfo2(event)&#123;\n\t          alert(&quot;info2&quot;);\n\t        &#125;,\n\t      &#125;,\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n只会发生 button 的事件，冒泡到 div 时，由于操作的元素不是 div，所以事件不会发生\n8.2.6 passive 事件的默认行为立即执行，无需等待事件回调执行完毕当事件发生时，会先调用事件绑定的函数方法，等方法执行完成后再发生事件。现在想让事件立即响应，无需等待方法执行完成\n&lt;head&gt;\n   &lt;style&gt;\n     .list&#123;\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground-color: peru;\n\t\toverflow: auto;  &#x2F;* 宽度不够元素溢出，形成滚动条 *&#x2F;\n\t  &#125;\n\t  li&#123;\n\t\theight: 100px;\n\t  &#125;\n   &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\t&lt;!-- &lt;ul @scroll&#x3D;&quot;demo&quot; class&#x3D;&quot;list&quot;&gt; --&gt;\n      &lt;ul @wheel&#x3D;&quot;demo&quot; class&#x3D;&quot;list&quot;&gt;\n\t    &lt;ul class&#x3D;&quot;list&quot;&gt;\n        &lt;li&gt;1&lt;&#x2F;li&gt;\n        &lt;li&gt;2&lt;&#x2F;li&gt;\n        &lt;li&gt;3&lt;&#x2F;li&gt;\n        &lt;li&gt;4&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods: &#123;\n\t        demo()&#123;\n            console.log(&quot;@&quot;)\n          &#125;\n\t      &#125;,\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\nscroll 滚动条滚动当滚动条发生移动时，会产生变化，移动到底时由于滚动条不会变使用不会发生变化，但上下移动会发生变化\nwheel 滚轮滚动只要滚轮移动时，就会发生变化，用鼠标拖动滚动条或上下光标移动滚动条，由于滚轮未移动，不会发生变化。到底之后移动滚轮，虽然滚动条没动但由于滚轮移动，也会发生变化\n\n修改一下事件的函数方法，使用 wheel 时，会先等方法执行完毕再发生滚动，使用 scroll 时，会发生滚动，同时方法也在执行，只有等方法执行完之后才能进行下一次滚动操作\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t    &lt;!-- &lt;ul @scroll&#x3D;&quot;demo&quot; class&#x3D;&quot;list&quot;&gt; --&gt;\n      &lt;ul @wheel.passive&#x3D;&quot;demo&quot; class&#x3D;&quot;list&quot;&gt;\n        &lt;li&gt;1&lt;&#x2F;li&gt;\n        &lt;li&gt;2&lt;&#x2F;li&gt;\n        &lt;li&gt;3&lt;&#x2F;li&gt;\n        &lt;li&gt;4&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods:&#123;\n\t\t\tdemo()&#123;\n\t\t\t\tfor (let i &#x3D; 0; i &lt; 100000; i++) &#123;\n\t\t\t\t\tconsole.log(&#39;#&#39;)\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n让滚动操作无需等待方法执行完成才进行操作\n8.3 按键修饰符\nVue中常用的按键别名：\n\n\n\n\n\n\n\n\n\n回车 &#x3D;&gt; enter删除 &#x3D;&gt; delete (捕获“删除”和“退格”键)退出 &#x3D;&gt; esc空格 &#x3D;&gt; space换行 &#x3D;&gt; tab (特殊，必须配合 keydown 去使用)上 &#x3D;&gt; up下 &#x3D;&gt; down左 &#x3D;&gt; left右 &#x3D;&gt; right\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t    &lt;!-- &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup&#x3D;&quot;showInfo&quot;&gt; --&gt;\n\t    &lt;!-- 进行判断，只有读取到回车才进行打印输出，否则每一次按键都会输出内容 --&gt;\n\t\t&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.enter&#x3D;&quot;showInfo&quot;&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods:&#123;\n\t        showInfo(event)&#123;\n\t        \t&#x2F;&#x2F; 进行判断，只有读取到回车才进行打印输出，否则每一次按键都会输出内容\n\t\t\t\t&#x2F;&#x2F; if(event.keyCode !&#x3D;&#x3D; 13) return;\n\t\t\t\tconsole.log(event.target.value);\n\t\t\t&#125;\n\t\t  &#125;\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\nVue 未提供别名的按键，可以使用按键原始的 Key 值去绑定，但多个单词组成的 Key 要转为 kebab-case（短横线命名）\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t\t&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup&#x3D;&quot;showInfo&quot;&gt;\n\t\t&lt;!-- 按下 CapsLock 键输出值，由多个单词组成，需要转换 --&gt;\n\t\t&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.caps-lock&#x3D;&quot;showInfo1&quot;&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods:&#123;\n          \tshowInfo(event)&#123;\n\t\t\t\tconsole.log(event.key, event.keyCode);\n\t\t\t&#125;,\n\t\t\tshowInfo1(event)&#123;\n\t\t\t\tconsole.log(event.target.value);\n\t\t\t&#125;\n\t\t  &#125;\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\n系统修饰键（用法特殊）：ctrl、alt、shift、meta（win）配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。配合 keydown 使用：正常触发事件\n&lt;!-- 按下 Ctrl 键，再按下任意其他键并释放即可使用 --&gt;\n&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.ctrl&#x3D;&quot;showInfo&quot;&gt;\n&lt;!-- 只能按下 Ctrl + y 然后释放才可使用 --&gt;\n&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.ctrl.y&#x3D;&quot;showInfo&quot;&gt;\n也可以使用 keyCode 去指定具体的按键（不推荐）\n&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.13&#x3D;&quot;showInfo&quot;&gt;\nVue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键别名\n&lt;body&gt;\n\t&lt;div id&#x3D;&quot;root&quot;&gt;\n\t\t&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keyup.huiche&#x3D;&quot;showInfo&quot;&gt;\n\t&lt;&#x2F;div&gt;\n\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t    Vue.config.productionTip &#x3D; false;\n\t\tVue.config.keyCodes.huiche &#x3D; 13; &#x2F;&#x2F; 自定义按键别名\n\n\t    let vm &#x3D; new Vue(&#123;\n\t      el: &quot;#root&quot;,\n\t      methods:&#123;\n          \tshowInfo(event)&#123;\n\t\t\t\tconsole.log(event.target.value);\n\t\t\t&#125;,\n\t\t  &#125;\n\t    &#125;);\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n9. 计算属性和侦听器9.1 计算属性 computed\n定义： 要用的属性不存在，要通过已有属性计算得来\n原理： 底层借助了 Objcet.defineproperty 方法提供的 getter 和 setter\nget() 函数什么时候执行？\n初次读取时会执行一次。\n当依赖的数据发生改变时会被再次调用\n\n\n优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便\n备注：\n计算属性最终会出现在 vm 上，直接读取使用即可\n如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变\n\n\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    姓：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot; &gt; &lt;br&gt;\n    名：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot; &gt;&lt;br&gt;\n    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        firstName: &#39;李&#39;,\n        lastName: &#39;四&#39;\n      &#125;,\n      &#x2F;&#x2F; 简写，只考虑读取的时候，fullName() 相当于直接 get()\n      &#x2F;&#x2F; computed: &#123;\n      &#x2F;&#x2F;   fullName()&#123;\n      &#x2F;&#x2F;     return this.firstName + &#39;-&#39; + this.lastName;\n      &#x2F;&#x2F;   &#125;\n      &#x2F;&#x2F; &#125;\n      computed: &#123;\n        fullName: &#123;\n          get()&#123;\n            return this.firstName + &#39;-&#39; + this.lastName;\n          &#125;,\n          set(value)&#123;\n            let arr &#x3D; value.split(&quot;-&quot;);\n            this.firstName &#x3D; arr[0];\n            this.lastName &#x3D; arr[1];\n          &#125;\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n通过姓和名计算出全名，修改全名的同时修改姓和名\n9.2 侦听器（监视属性）watch\n当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n监视的属性必须存在，才能进行监视！！\n监视的两种写法：\nnew Vue 时传入 watch 配置\n通过 vm.$watch 监视\n\n\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt;今天天气很&#123;&#123;info&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;button @click&#x3D;&quot;changeWeather&quot;&gt;切换天气&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        isHot: true\n      &#125;,\n      computed: &#123;\n        info()&#123;\n          return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;\n        &#125;\n      &#125;,\n      methods: &#123;\n        changeWeather()&#123;\n          this.isHot &#x3D; !this.isHot\n        &#125;\n      &#125;,\n      &#x2F;&#x2F; watch: &#123;\n      &#x2F;&#x2F;   isHot: &#123;\n      &#x2F;&#x2F;     immediate: true,\n      &#x2F;&#x2F;     handler(newValue, oldValue)&#123;\n      &#x2F;&#x2F;       console.log(&#39;isHost被修改了&#39;, newValue, oldValue)\n      &#x2F;&#x2F;     &#125;\n      &#x2F;&#x2F;   &#125;\n      &#x2F;&#x2F; &#125;\n      &#x2F;&#x2F; 简写，只考虑 handler() 的时候，isHot() 相当于直接 handler()\n      &#x2F;&#x2F;  isHot(newValue,oldValue)&#123;\n      &#x2F;&#x2F;    console.log(&#39;isHot 被修改了&#39;, newValue, oldValue)\n      &#x2F;&#x2F;  &#125;\n      &#x2F;&#x2F;&#125;\n    &#125;);\n\n    vm.$watch(&#39;isHot&#39;, &#123;\n      immediate: true,\n      handler(newValue, oldValue)&#123;\n        console.log(&#39;isHost被修改了&#39;, newValue, oldValue)\n      &#125;\n    &#125;)\n    &#x2F;&#x2F; 简写\n\t&#x2F;* vm.$watch(&#39;isHot&#39;,function(newValue,oldValue)&#123;\n      console.log(&#39;isHot被修改了&#39;,newValue,oldValue, this)\n    &#125;) *&#x2F;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n初始化的时候会调用一次监视的 handler 方法，随后点击切换天气，改变了 isHot 的值，都会被监视到，调用监视方法\n9.3 深度监视\nVue中的 watch 默认不监测对象内部值的改变（一层）\n\n配置 deep:true 可以监测对象内部值改变（多层）\n\n备注：\n\nVue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以！\n使用 watch 时根据数据的具体结构，决定是否采用深度监视\n\n\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h3&gt;a的值是:&#123;&#123;numbers.a&#125;&#125;&lt;&#x2F;h3&gt;\n\t\t&lt;button @click&#x3D;&quot;numbers.a++&quot;&gt;点我让a+1&lt;&#x2F;button&gt;\n\t\t&lt;h3&gt;b的值是:&#123;&#123;numbers.b&#125;&#125;&lt;&#x2F;h3&gt;\n\t\t&lt;button @click&#x3D;&quot;numbers.b++&quot;&gt;点我让b+1&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        numbers:&#123;\n\t\t\t\t\ta:1,\n\t\t\t\t\tb:1\n\t\t\t\t&#125;\n      &#125;,\n      watch: &#123;\n        numbers: &#123;\n          deep: true,\n          handler()&#123;\n            console.log(&quot;numbers 改变了！&quot;);\n          &#125;\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n点击 a+1 或 b+1，numbers 内部的属性值发生了改变，watch 监视 numbers 默认不监测其内部属性的改变，需要开启，之后 numbers 内部任意属性发生改变都会被检测\n9.4 computed 和 watch 之间的区别\ncomputed 能完成的功能，watch 都可以完成。\nwatch 能完成的功能，computed 不一定能完成，如：watch 可以进行异步操作\n两个重要的原则：\n所被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或 组件实例对象\n所有不被Vue所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数），最好写成箭头函数，这样 this 的指向才是 vm 或 组件实例对象\n\n\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    姓：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot; &gt; &lt;br&gt;\n    名：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot; &gt; &lt;br&gt;\n    全名：&#123;&#123;fullName&#125;&#125;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        firstName: &#39;张&#39;,\n        lastName: &#39;三&#39;,\n        fullName: &#39;张-三&#39;\n      &#125;,\n      watch: &#123;\n        firstName(val)&#123;\n          setTimeout(() &#x3D;&gt; &#123;\n            console.log(this);\n            this.fullName &#x3D; val + this.lastName;\n          &#125;, 1000);\n        &#125;,\n        lastName(val)&#123;\n          setTimeout(() &#x3D;&gt; &#123;\n            console.log(this);\n            this.fullName &#x3D; this.firstName + val;\n          &#125;, 1000);\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n输入之后，延迟一秒显示全名，这里的 timeout 回调函数，直接使用 function 的话 this 代表 Window，要使用箭头函数，箭头函数没有自己的 this，而是会继承上层作用域的 this，往上找到监视属性，此时的 this 代表 vm 或组件示例对象\n10. Class 与 Style 绑定10.1 Class 绑定10.1.1 直接加 Class先编写好 Clss 对应的样式\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n基础样式 basic：直接加一个样式：\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic normal&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n再加一个样式：\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic normal happy&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n\n10.1.2 字符串写法适用于：样式的类名不确定，需要动态指定\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;mood&quot; @click&#x3D;&quot;changeMood&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        mood: &#39;normal&#39;\n      &#125;,\n      methods: &#123;\n        changeMood()&#123;\n          &#x2F;&#x2F; let arr &#x3D; [&#39;normal&#39;, &#39;happy&#39;, &#39;sad&#39;];\n          &#x2F;&#x2F; let index &#x3D; Math.floor(Math.random() * 3);\n          &#x2F;&#x2F; this.mood &#x3D; arr[index];\n          this.mood &#x3D; &#39;happy&#39;;\n        &#125;\n      &#125;,\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n点击后随机切换\n10.1.3 数组写法适用于：要绑定的样式个数不确定、名字也不确定\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;classArr&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        classArr: [&#39;happy&#39;,&#39;normal&#39;, &#39;sad&#39;]\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n数组里移除一个属性新增一个属性\n10.1.4 对象写法适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;classObj&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        classObj: &#123;\n          fan1: false,\n          fan2: true,\n          fan3: true\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n改为 true，启用\n10.2 Style 绑定10.2.1 对象写法&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic&quot; :style&#x3D;&quot;styleObj&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        styleObj: &#123;\n          fontSize: &#39;40px&#39;,\n          color: &#39;red&#39;\n        &#125;\n      &#125;,\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n10.2.2 数组写法&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;div class&#x3D;&quot;basic&quot; :style&#x3D;&quot;styleArr&quot;&gt;Test&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        styleArr: [\n          &#123;\n            fontSize: &#39;40px&#39;,\n            color: &#39;red&#39;\n          &#125;,\n          &#123;\n            backgroundColor: &#39;skyblue&#39;\n          &#125;\n        ]\n      &#125;,\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n11. 条件渲染11.1 v-show\n写法：v-show&#x3D;”表达式”\n适用于：切换频率较高的场景\n特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1 v-show&#x3D;&quot;show&quot;&gt;显示&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        show: true\n      &#125;,\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n表达式为 false 则隐藏表达式为 true 则显示\n11.2 v-if\n写法：v-if&#x3D;”表达式”v-else-if&#x3D;”表达式”v-else&#x3D;”表达式”\n适用于：切换频率较低的场景\n特点：不展示的 DOM 元素直接被移除\n注意：v-if  可以和 v-else-if、v-else 一起使用，但要求结构不能被“打断”\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h2&gt;当前值 &#123;&#123;n&#125;&#125; &lt;&#x2F;h2&gt;&lt;br&gt;\n    &lt;button @click&#x3D;&quot;n++&quot;&gt;点击 n+1&lt;&#x2F;button&gt;&lt;br&gt;\n    &lt;h2 v-if&#x3D;&quot;n &#x3D;&#x3D;&#x3D; 1&quot;&gt;n &#x3D;&#x3D;&#x3D; 1&lt;&#x2F;h2&gt;\n    &lt;!--不能被打断 &lt;h2&gt;11&lt;&#x2F;h2&gt; --&gt;\n    &lt;h2 v-else-if&#x3D;&quot;n &#x3D;&#x3D;&#x3D; 2&quot;&gt;n &#x3D;&#x3D;&#x3D; 2&lt;&#x2F;h2&gt;\n    &lt;h2 v-else&gt;其他&lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        n: 0\n      &#125;,\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\nelse 的其他if 的 n &#x3D;&#x3D;&#x3D; 1else-if 的 n &#x3D;&#x3D;&#x3D; 2注：使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到\n12. 列表渲染12.1 基本使用v-for 指令:\n\n用于展示列表数据\n语法：v-for&#x3D;”(item, index) in items” :key&#x3D;”index”\n可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;!-- 遍历数组 --&gt;\n    &lt;h2&gt;人员列表（遍历数组）&lt;&#x2F;h2&gt;\n    &lt;ul&gt;\n      &lt;!-- &lt;li v-for&#x3D;&quot;p in persons&quot; :key&#x3D;&quot;p.id&quot;&gt;\n        &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; - &#123;&#123;p.id&#125;&#125;\n      &lt;&#x2F;li&gt; --&gt;\n      &lt;li v-for&#x3D;&quot;(p, index) in persons&quot; :key&#x3D;&quot;p.id&quot;&gt;\n        &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; - &#123;&#123;p.id&#125;&#125; - &#123;&#123;index&#125;&#125;\n      &lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  \n    &lt;!-- 遍历对象 --&gt;\n    &lt;h2&gt;汽车信息（遍历对象）&lt;&#x2F;h2&gt;\n    &lt;ul&gt;\n      &lt;!-- &lt;li v-for&#x3D;&quot;(value, key, index) in cars&quot; :key&#x3D;&quot;key&quot;&gt; --&gt;\n\t  &lt;li v-for&#x3D;&quot;(value, key) in cars&quot; :key&#x3D;&quot;key&quot;&gt;\n        &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125;\n      &lt;&#x2F;li&gt;\n\t&lt;&#x2F;ul&gt;\n\n    &lt;!-- 遍历字符串 --&gt;\n\t&lt;h2&gt;测试遍历字符串（用得少）&lt;&#x2F;h2&gt;\n\t&lt;ul&gt;\n\t\t&lt;li v-for&#x3D;&quot;(char, index) of str&quot; :key&#x3D;&quot;index&quot;&gt;\n\t\t\t&#123;&#123;char&#125;&#125; - &#123;&#123;index&#125;&#125;\n\t\t&lt;&#x2F;li&gt;\n\t&lt;&#x2F;ul&gt;\n\n\t&lt;!-- 遍历指定次数 --&gt;\n\t&lt;h2&gt;测试遍历指定次数（用得少）&lt;&#x2F;h2&gt;\n\t&lt;ul&gt;\n\t\t&lt;li v-for&#x3D;&quot;(number, index) of 5&quot; :key&#x3D;&quot;index&quot;&gt;\n\t\t\t&#123;&#123;index&#125;&#125; - &#123;&#123;number&#125;&#125;\n\t\t&lt;&#x2F;li&gt;\n\t&lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        persons: [\n          &#123;id: 111, name: &#39;张三&#39;, age: 18&#125;,\n          &#123;id: 222, name: &#39;李四&#39;, age: 20&#125;,\n          &#123;id: 333, name: &#39;王五&#39;, age: 22&#125;\n        ],\n        cars: &#123;\n          name: &#39;A7&#39;,\n          price: &#39;7777777&#39;,\n          color: &#39;黑色&#39;\n        &#125;,\n        str: &#39;Hello!&#39;\n      &#125;,\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n12.2 key 的原理React、Vue 中的 key 有什么作用？（key的内部原理）\n\n虚拟 DOM 中 key 的作用key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】，随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异进行比较\n对比规则\n旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key①若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM！②若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\n旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key创建新的真实 DOM，随后渲染到到页面\n\n\n用 index 作为 key 可能会引发的问题\n若对数据进行逆序添加、逆序删除等破坏顺序操作： 会产生没有必要的真实 DOM 更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。\n如果结构中还包含输入类的 DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题\n\n\n开发中如何选择 key?\n最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值。\n如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的\n\n\n\n\n\n12.3 列表过滤&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h2&gt;人员列表&lt;&#x2F;h2&gt;\n\t\t&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入名字&quot; v-model&#x3D;&quot;keyWord&quot;&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;(fp, index) in filterPersons&quot; :key&#x3D;&quot;fp.id&quot;&gt;\n        &#123;&#123;fp.name&#125;&#125; - &#123;&#123;fp.age&#125;&#125;\n      &lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        keyWord: &#39;&#39;,\n        persons:[\n\t\t\t&#123;id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;&#125;,\n\t\t\t&#123;id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;&#125;,\n\t\t\t&#123;id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;&#125;,\n\t\t\t&#123;id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;&#125;\n\t\t],\n        &#x2F;&#x2F; filterPersons: [] 一个新数组来保存过滤后的数据\n      &#125;,\n      &#x2F;&#x2F; watch 实现\n      &#x2F;&#x2F; watch: &#123;\n      &#x2F;&#x2F;   keyWord: &#123;\n      &#x2F;&#x2F;     immediate: true,\n      &#x2F;&#x2F;     handler(val)&#123;\n      &#x2F;&#x2F;       this.filterPersons &#x3D; this.persons.filter((p) &#x3D;&gt; &#123;\n      &#x2F;&#x2F;       return p.name.indexOf(val) !&#x3D;&#x3D; -1;\n      &#x2F;&#x2F;     &#125;)\n      &#x2F;&#x2F;     &#125;\n      &#x2F;&#x2F;   &#125;\n      &#x2F;&#x2F; &#125;\n      computed: &#123;\n        filterPersons()&#123;\n          return this.persons.filter((p) &#x3D;&gt; &#123;\n            return p.name.indexOf(this.keyWord) !&#x3D;&#x3D; -1;\n          &#125;)\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n输入搜索条件后进行过滤\n12.4 列表（过滤）排序&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h2&gt;人员列表&lt;&#x2F;h2&gt;\n\t\t&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入名字&quot; v-model&#x3D;&quot;keyWord&quot;&gt;\n    &lt;button @click&#x3D;&quot;sortType &#x3D; 2&quot;&gt;年龄升序&lt;&#x2F;button&gt;\n\t\t&lt;button @click&#x3D;&quot;sortType &#x3D; 1&quot;&gt;年龄降序&lt;&#x2F;button&gt;\n\t\t&lt;button @click&#x3D;&quot;sortType &#x3D; 0&quot;&gt;原顺序&lt;&#x2F;button&gt;\n    &lt;ul&gt;\n      &lt;li v-for&#x3D;&quot;(fp, index) in filterPersons&quot; :key&#x3D;&quot;fp.id&quot;&gt;\n        &#123;&#123;fp.name&#125;&#125; - &#123;&#123;fp.age&#125;&#125;\n      &lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        keyWord: &#39;&#39;,\n        sortType: 0,\n        persons:[\n\t\t\t&#123;id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:34,sex:&#39;女&#39;&#125;,\n\t\t\t&#123;id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:22,sex:&#39;女&#39;&#125;,\n\t\t\t&#123;id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:47,sex:&#39;男&#39;&#125;,\n\t\t\t&#123;id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;&#125;\n\t\t],\n      &#125;,\n      computed: &#123;\n        filterPersons()&#123;\n          let arr &#x3D; this.persons.filter((p) &#x3D;&gt; &#123;\n            return p.name.indexOf(this.keyWord) !&#x3D;&#x3D; -1;\n          &#125;)\n          if(this.sortType)&#123;\n            arr.sort((p1, p2) &#x3D;&gt; &#123;\n              return this.sortType &#x3D;&#x3D;&#x3D; 1 ? p1.age - p2.age : p2.age - p1.age\n            &#125;)\n          &#125;\n          return arr;\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n\n点击升序，sortType &#x3D;&#x3D;&#x3D; 2，p1.age - p2.age点击降序，sortType &#x3D;&#x3D;&#x3D; 1，p2.age - p1.age原顺序，sortType &#x3D;&#x3D;&#x3D; 0，返回原数组不进行排序过滤后排序\n12.5 Vue 数据监测原理\nVue 会监视 data 中所有层次的数据\n如何监测对象中的数据？通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据\n对象中后追加的属性，Vue 默认不做响应式处理\n如需给后添加的属性做响应式，需使用如下API：\nVue.set(target，propertyName&#x2F;index，value) 或\nvm.$set(target，propertyName&#x2F;index，value)\n\n\n\n\n如何监测数组中的数据？通过包裹数组更新元素的方法实现，本质就是做了两件事：\n调用原生对应的方法对数组进行更新\n重新解析模板，进而更新页面\n\n\n在 Vue 修改数组中的某个元素一定要用如下方法：\n使用这些API，会改变原来的数组push()、pop()、shift()、unshift()、splice()、sort()、reverse()\nVue.set() 或 vm.$set()\n\n\n使用 filter()、concat() 和 slice() 等方法不会改变原来的数组，可以用返回的新数组替换旧数组\n\n注：Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象（vm._data）添加属性！！！\n&lt;body&gt;\n  &lt;!-- 准备好一个容器--&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt;学生信息&lt;&#x2F;h1&gt;\n    &lt;button @click&#x3D;&quot;student.age++&quot;&gt;年龄+1岁&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n\t\t&lt;button @click&#x3D;&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n\t\t&lt;button @click&#x3D;&quot;student.sex &#x3D; &#39;未知&#39; &quot;&gt;修改性别&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n\t\t&lt;button @click&#x3D;&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n\t\t&lt;button @click&#x3D;&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n\t\t&lt;button @click&#x3D;&quot;addHobby&quot;&gt;添加一个爱好&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n\t\t&lt;button @click&#x3D;&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n\t\t&lt;button @click&#x3D;&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;&#x2F;button&gt; &lt;br&#x2F;&gt;\n    &lt;h3&gt;姓名：&#123;&#123;student.name&#125;&#125;&lt;&#x2F;h3&gt;\n\t\t\t&lt;h3&gt;年龄：&#123;&#123;student.age&#125;&#125;&lt;&#x2F;h3&gt;\n\t\t\t&lt;h3 v-if&#x3D;&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;&#x2F;h3&gt;\n\t\t\t&lt;h3&gt;爱好：&lt;&#x2F;h3&gt;\n\t\t\t&lt;ul&gt;\n\t\t\t\t&lt;li v-for&#x3D;&quot;(hobby,index) in student.hobbys&quot; :key&#x3D;&quot;index&quot;&gt;\n\t\t\t\t\t&#123;&#123;hobby&#125;&#125;\n\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t&lt;&#x2F;ul&gt;\n\t\t\t&lt;h3&gt;朋友们：&lt;&#x2F;h3&gt;\n\t\t\t&lt;ul&gt;\n\t\t\t\t&lt;li v-for&#x3D;&quot;(f,index) in student.friends&quot; :key&#x3D;&quot;index&quot;&gt;\n\t\t\t\t\t&#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;\n\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t&lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n  Vue.config.productionTip &#x3D; false &#x2F;&#x2F;阻止 vue 在启动时生成生产提示。\n\n  const vm &#x3D; new Vue(&#123;\n    el:&#39;#root&#39;,\n    data:&#123;\n\t\tstudent:&#123;\n\t\t\tname:&#39;tom&#39;,\n\t\t\tage:18,\n\t\t\thobbys:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;],\n\t\t\tfriends:[\n\t\t\t\t&#123;name:&#39;jerry&#39;,age:35&#125;,\n\t\t\t\t&#123;name:&#39;tony&#39;,age:36&#125;\n\t\t\t]\n\t\t&#125;\n\t&#125;,\n    methods: &#123;\n      addSex()&#123;\n        Vue.set(vm.student, &#39;sex&#39;, &#39;男&#39;) &#x2F;&#x2F; this.student &#x3D;&#x3D;&#x3D; vm._data.student &#x3D;&#x3D;&#x3D; vm.student\n        &#x2F;&#x2F; this.$set(this.student, &#39;sex&#39;, &#39;男&#39;) this &#x3D;&#x3D;&#x3D; vm\n      &#125;,\n      addFriend()&#123;\n        this.student.friends.unshift(&#123;name:&#39;jack&#39;,age:24&#125;)\n      &#125;,\n      updateFirstFriendName()&#123;\n        this.student.friends[0].name &#x3D; &#39;张三&#39;\n      &#125;,\n      addHobby()&#123;\n        this.student.hobbys.push(&#39;学习&#39;)\n      &#125;,\n      updateHobby()&#123;\n        &#x2F;&#x2F; this.student.hobbys.splice(0,1,&#39;开车&#39;) 从第 0 个开始删一个，删完之后再插入一个新的\n        &#x2F;&#x2F; Vue.set(this.student.hobbys, 0, &#39;开车&#39;)\n        this.$set(this.student.hobbys, 0, &#39;开车&#39;)\n      &#125;,\n      removeSmoke()&#123;\n        this.student.hobbys &#x3D; this.student.hobbys.filter((hobby) &#x3D;&gt; &#123;\n          return hobby !&#x3D;&#x3D; &#39;抽烟&#39;\n        &#125;)\n      &#125;\n    &#125;,\n  &#125;)\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\n使用 Vue.set() 或 vm.$set() 添加性别属性，使用 v-if，假如 sex 属性存在就显示，当添加了sex 属性后，存在了就显示出来，undefined 则不会显示使用 unshift 在前面添加一个对象使用 push 添加一个数组属性\n使用 Vue.set() 或 vm.$set() 或 splice() 方法修改数组属性的值\n13. 收集表单数据\n若：&lt;input type&#x3D;”text”&#x2F;&gt;，则 v-model 收集的是 value 值，用户输入的就是 value值\n若：&lt;input type&#x3D;”radio”&#x2F;&gt;，则 v-model 收集的是 value 值，且要给标签配置 value 值\n若：&lt;input type&#x3D;”checkbox”&#x2F;&gt;\n没有配置 input 的 value 属性，那么收集的就是 checked（勾选 or 未勾选，是布尔值）\n配置 input 的 value 属性:\nv-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值）\nv-model 的初始值是数组，那么收集的的就是 value 组成的数组\n\n\n\n\nv-model 的三个修饰符：\nlazy：失去焦点再收集数据\nnumber：输入字符串转为有效的数字\ntrim：输入首尾空格过滤\n\n\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;form @submit.prevent&#x3D;&quot;demo&quot;&gt;\n      &lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;\n      &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; v-model.trim&#x3D;&quot;username&quot;&gt;&lt;br&gt;&lt;br&gt;\n      密码：&lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;password&quot;&gt;&lt;br&gt;&lt;br&gt;\n      年龄：&lt;input type&#x3D;&quot;number&quot; v-model.number&#x3D;&quot;age&quot;&gt;&lt;br&gt;&lt;br&gt;\n      性别：\n      男：&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;gender&quot; value&#x3D;&quot;male&quot;&gt;\n      女：&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;gender&quot; value&#x3D;&quot;female&quot;&gt;&lt;br&gt;&lt;br&gt;\n      爱好：\n      吃饭：&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;hobby&quot; value&#x3D;&quot;eat&quot;&gt;\n      学习：&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;hobby&quot; value&#x3D;&quot;study&quot;&gt;\n      打游戏：&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;hobby&quot; value&#x3D;&quot;game&quot;&gt;&lt;br&gt;&lt;br&gt;\n      所属校区：\n      &lt;select v-model&#x3D;&quot;city&quot;&gt;\n        &lt;option value&#x3D;&quot;&quot;&gt;请选择校区&lt;&#x2F;option&gt;\n        &lt;option value&#x3D;&quot;beijing&quot;&gt;北京&lt;&#x2F;option&gt;\n        &lt;option value&#x3D;&quot;shanghai&quot;&gt;上海&lt;&#x2F;option&gt;\n        &lt;option value&#x3D;&quot;shenzhen&quot;&gt;深圳&lt;&#x2F;option&gt;\n       &lt;option value&#x3D;&quot;guangzhou&quot;&gt;广州&lt;&#x2F;option&gt;\n      &lt;&#x2F;select&gt;&lt;br&gt;&lt;br&gt;\n      其他信息：\n      &lt;textarea v-model.lazy&#x3D;&quot;other&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&gt;&lt;br&gt;\n      &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;agree&quot;&gt;阅读并接受&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.fan223.cn&quot;&gt;用户协议&lt;&#x2F;a&gt;&lt;br&gt;&lt;br&gt;\n      &lt;button&gt;提交&lt;&#x2F;button&gt;\n    &lt;&#x2F;form&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n\n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        username: &#39;&#39;,\n        password: &#39;&#39;,\n        age: &#39;&#39;,\n        gender: &#39;male&#39;,\n        hobby: [],\n        city: &#39;beijing&#39;,\n        other: &#39;&#39;,\n        agree: &#39;&#39;,\n      &#125;,\n      methods: &#123;\n\t\tdemo()&#123;\n\t\t  console.log(JSON.stringify(this.userInfo))\n\t\t&#125;\n\t  &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n输入年龄，使用 &lt;input type&#x3D;”number”&gt; 来约束只能输入数字，然后使用 v-model.number 将数字字符串转为数字类型需要设置 &lt;input type&#x3D;”radio”&#x2F;&gt; 的 value 值需要设置 &lt;input type&#x3D;”checkbox”&#x2F;&gt; 的 value 值，同时将存放类型设置为数组，才能进行一个或多个属性的选择使用 v-model.lazy 和 v-model.trim 设置失去焦点再收集数据以及首尾空格过滤不配置 &lt;input type&#x3D;”checkbox”&#x2F;&gt; 的 value 属性，收集为一个布尔值使用 @submit 来设置表单提交事件\n14. 过滤器对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）\n\n注册过滤器Vue.filter(name, callback) 全局过滤器new Vue{filters:{ }} 局部过滤器\n使用过滤器：**&#123;&#123; xxx | 过滤器名&#125;&#125;  或  v-bind:属性 &#x3D; “xxx | 过滤器名”**，可以在插值语法和指令语法里使用\n备注：\n前面的 xxx 为必传进过滤器的参数，同时过滤器也可以接收额外参数、多个过滤器也可以串联\n并没有改变原本的数据, 是产生新的对应的数据\n\n\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt;时间戳： &#123;&#123;time&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;h1&gt;格式化后的时间（不传参）： &#123;&#123;time | timeFormater&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;h1&gt;格式化后的时间（传参）： &#123;&#123;time | timeFormater(&#39;YYYY-MM-DD HH:mm:ss&#39;)&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;h1&gt;全局过滤器（串联）： &#123;&#123;time | timeFormater(&#39;YYYY-MM-DD HH:mm:ss&#39;) | customerslice&#125;&#125; &lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n    Vue.filter(&#39;customerslice&#39;,function(value)&#123;\n\t\treturn value.slice(0,4)\n\t&#125;)\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        time: 1648318081795\n      &#125;,\n      filters: &#123;\n      \t&#x2F;&#x2F; 不传参则使用默认 str，传参则覆盖\n        timeFormater(value, str&#x3D;&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&#123;\n\t\t\treturn dayjs(value).format(str)\n\t\t&#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n15. 指令15.1 内置指令\nv-bind : 单向绑定解析表达式, 可简写为 :xxx\nv-model : 双向数据绑定\nv-for : 遍历数组&#x2F;对象&#x2F;字符串\nv-on : 绑定事件监听, 可简写为@\nv-if 、v-else-if、v-else : 条件渲染（动态控制节点是否存在）\nv-show : 条件渲染 (动态控制节点是否展示)\nv-text ：向其所在的节点中渲染文本内容，但不能渲染包含 html 结构的内容。v-text 会替换掉节点中的内容，插值语法 &#123;&#123;xx&#125;&#125; 不会\nv-html ：可以向指定节点中渲染包含 html 结构的内容，其他与 v-text 同。v-html 有安全性问题，在网站上动态渲染任意 HTML 容易导致XSS攻击\nv-cloak（没有值）：本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性。使用 css 属性选择器设置 v-cloak 为 display:none 可以解决网速慢时页面展示出 &#123;&#123;xxx&#125;&#125; 的问题\nv-once ：v-once 所在节点在初次动态渲染后，就视为静态内容了，以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能\nv-pre ：跳过其所在节点的编译过程。可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\n\n15.2 自定义指令\n局部指令 ：new Vue({ directives:{指令名:配置对象} 或 directives{指令名:回调函数} })new Vue(&#123;\n\tdirectives:&#123;\n\t\t&#x2F;* &#39;big-number&#39;(element,binding)&#123; 完整写法，用引号包裹\n\t\t\telement.innerText &#x3D; binding.value * 10\n\t\t&#125;, *&#x2F;\n\t\t&#x2F;&#x2F; 函数式\n\t\tbig(element,binding)&#123;\n\t\t\tconsole.log(&#39;big&#39;,this) &#x2F;&#x2F; 注意此处的 this 是 Window\n\t\t\telement.innerText &#x3D; binding.value * 10\n\t\t&#125;,\n\t\t&#x2F;&#x2F; 对象式\n\t\tfbind:&#123;\n\t\t\t&#x2F;&#x2F; 指令与元素成功绑定时（一上来）调用\n\t\t\tbind(element, binding)&#123;\n\t\t\t\telement.value &#x3D; binding.value\n\t\t\t&#125;,\n\t\t\t&#x2F;&#x2F; 指令所在元素被插入页面时调用\n\t\t\tinserted(element, binding)&#123;\n\t\t\t\telement.focus()\n\t\t\t&#125;,\n\t\t\t&#x2F;&#x2F; 指令所在的模板被重新解析时调用\n\t\t\tupdate(element, binding)&#123;\n\t\t\t\telement.value &#x3D; binding.value\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;)\n全局指令 ：Vue.directive(指令名, 配置对象) 或   Vue.directive(指令名, 回调函数)\n备注\n指令定义时不加 v-，但使用时要加 v-\n指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名\n\n\n\n15.2.1 函数式\n指令与元素成功绑定时（一上来）会被调用\n指令所在的模板被重新解析时会被调用\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt;原始n的值：&#123;&#123;n&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;!-- 使用自定义指令 --&gt;\n    &lt;h1&gt;自定义指令放大10倍n的值：&lt;span v-big&#x3D;&quot;n&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;h1&gt;\n    &lt;button @click&#x3D;&quot;n++&quot;&gt;n加1&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        n: 1\n      &#125;,\n      directives: &#123;\n        &#x2F;&#x2F; 自定义指令，element 代表所在的元素，binding 代表绑定的对象\n        big(element, binding)&#123;\n          console.log(element, binding);\n          element.innerText &#x3D; binding.value * 10\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\nelement 即 v-big 所在的 &lt;span&gt; 元素，binding 代表绑定的对象，expression 为表达式，value 为传进来的值\n15.2.2 对象式配置对象中常用的3个回调：\n\nbind：指令与元素成功绑定时调用\ninserted：指令所在元素被插入页面时调用\nupdate：指令所在模板结构被重新解析时调用\n\n函数式即 bind + update 回调\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;h1&gt;原始n的值：&#123;&#123;n&#125;&#125; &lt;&#x2F;h1&gt;\n    &lt;input type&#x3D;&quot;text&quot; v-fbind:value&#x3D;&quot;n&quot;&gt;&lt;br&gt;\n    &lt;button @click&#x3D;&quot;n++&quot;&gt;n加1&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      data: &#123;\n        n: 1\n      &#125;,\n      directives: &#123;\n        fbind: &#123;\n          bind(element, binding)&#123;\n            element.value &#x3D; binding.value;\n          &#125;,\n          inserted(element, binding)&#123;\n            element.focus();\n          &#125;,\n          update(element, binding)&#123;\n            element.value &#x3D; binding.value;\n          &#125;\n        &#125;\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n默认获取焦点\n16. 生命周期生命周期又名：生命周期回调函数、生命周期函数、生命周期钩子。是 Vue 在关键时刻帮我们调用的一些特殊名称的函数。生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。生命周期函数中的 this 指向是 vm 或 组件实例对象\n&lt;body&gt;\n  &lt;!-- 准备好一个容器--&gt;\n  &lt;div id&#x3D;&quot;root&quot; :x&#x3D;&quot;n&quot;&gt;\n    &lt;h2 v-text&#x3D;&quot;n&quot;&gt;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;add&quot;&gt;点我n+1&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;bye&quot;&gt;点我销毁vm&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n  Vue.config.productionTip &#x3D; false &#x2F;&#x2F;阻止 vue 在启动时生成生产提示。\n\n  new Vue(&#123;\n    el:&#39;#root&#39;,\n    &#x2F;&#x2F; template:&#96;\n    &#x2F;&#x2F; \t&lt;div&gt;\n    &#x2F;&#x2F; \t\t&lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;&#x2F;h2&gt;\n    &#x2F;&#x2F; \t\t&lt;button @click&#x3D;&quot;add&quot;&gt;点我n+1&lt;&#x2F;button&gt;\n    &#x2F;&#x2F; \t&lt;&#x2F;div&gt;\n    &#x2F;&#x2F; &#96;,\n    data:&#123;\n      n:1\n    &#125;,\n    methods: &#123;\n      add()&#123;\n        console.log(&#39;add&#39;)\n        this.n++\n      &#125;,\n      bye()&#123;\n        console.log(&#39;bye&#39;)\n        this.$destroy()\n      &#125;\n    &#125;,\n    watch:&#123;\n      n()&#123;\n        console.log(&#39;n变了&#39;)\n      &#125;\n    &#125;,\n    &#x2F;&#x2F; 将要创建\n    beforeCreate() &#123;\n      console.log(&#39;beforeCreate&#39;)\n    &#125;,\n    &#x2F;&#x2F; 创建完毕\n    created() &#123;\n      console.log(&#39;created&#39;)\n    &#125;,\n    &#x2F;&#x2F; 将要挂载\n    beforeMount() &#123;\n      console.log(&#39;beforeMount&#39;)\n    &#125;,\n    &#x2F;&#x2F; 挂载完毕\n    mounted() &#123;\n      console.log(&#39;mounted&#39;)\n    &#125;,\n    &#x2F;&#x2F; 将要更新\n    beforeUpdate() &#123;\n      console.log(&#39;beforeUpdate&#39;)\n    &#125;,\n    &#x2F;&#x2F; 更新完毕\n    updated() &#123;\n      console.log(&#39;updated&#39;)\n    &#125;,\n    &#x2F;&#x2F; 将要销毁\n    beforeDestroy() &#123;\n      console.log(&#39;beforeDestroy&#39;)\n    &#125;,\n    &#x2F;&#x2F; 销毁完毕\n    destroyed() &#123;\n      console.log(&#39;destroyed&#39;)\n    &#125;,\n  &#125;)\n&lt;&#x2F;script&gt;\n\n初始化时数据发生改变时销毁常用的生命周期钩子：\n\nmounted: 发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】\nbeforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】\n\n关于销毁Vue实例：\n\n销毁后借助 Vue 开发者工具看不到任何信息\n销毁后自定义事件会失效，但原生 DOM 事件依然有效\n一般不会在 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了\n\n17. 组件化编程17.1 模块与组件、模块化与组件化\n模块 ：向外提供特定功能的 js 程序, 一般就是一个 js 文件，用于复用 js, 简化 js 的编写, 提高 js 运行效率\n**组件 ：用来实现局部（特定）功能效果的代码集合(html&#x2F;css&#x2F;js&#x2F;image…)**，用于复用编码，简化项目编码，提高运行效率\n模块化 ：当应用中的 js 都以模块来编写的, 那这个应用就是一个模块化的应用\n组件化 ：当应用中的功能都是多组件的方式来编写的, 那这个应用就是一个组件化的应用\n\n17.2 非单文件组件\n定义组件（创建组件）：使用 Vue.extend(options) 创建，其中 options 和 new Vue(options) 时传入的那个 options 几乎一样，只有两个区别；\nel 不要写，因为最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器\ndata 必须写成函数，避免组件被复用时，数据存在引用关系\n备注：使用 template 可以配置组件结构\n\n\n注册组件\n局部注册：靠 new Vue 的时候传入 components 选项\n全局注册：靠 Vue.component(‘组件名’,组件)\n\n\n使用组件（写组件标签）&lt;school&gt;&lt;&#x2F;school&gt; 或 &lt;school &#x2F;&gt; (需要 Vue 脚手架支持)\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;school&gt;&lt;&#x2F;school&gt;\n    &lt;student&gt;&lt;&#x2F;student&gt;\n    &lt;hello &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n\n\t&#x2F;&#x2F; 定义组件\n    const sh &#x3D; Vue.extend(&#123;\n      template: &#96;\n        &lt;div&gt;\n          &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;\n          &lt;h2&gt;学校地址：&#123;&#123;schoolAddress&#125;&#125;&lt;&#x2F;h2&gt;\n        &lt;&#x2F;div&gt;\n      &#96;,\n      data() &#123;\n        return &#123;\n          schoolName: &#39;Vue&#39;,\n          schoolAddress: &#39;湖南&#39;\n        &#125;\n      &#125;,\n    &#125;);\n    const student &#x3D; Vue.extend(&#123;\n      template:&#96;\n        &lt;div&gt;\n          &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125; &lt;&#x2F;h2&gt;\n          &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125; &lt;&#x2F;h2&gt;\n        &lt;&#x2F;div&gt;\n      &#96;,\n      data() &#123;\n        return &#123;\n          studentName: &#39;张三&#39;,\n          age: &#39;18&#39;\n        &#125;\n      &#125;,\n    &#125;);\n    const hello &#x3D; Vue.extend(&#123;\n\t\t\ttemplate:&#96;\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t&lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&#96;,\n\t\t\tdata()&#123;\n\t\t\t\treturn &#123;\n\t\t\t\t\tname: &#39;Tom&#39;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t&#125;);\n\t&#x2F;&#x2F; 注册全局组件\n    Vue.component(&#39;hello&#39;, hello);\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      &#x2F;&#x2F; 局部注册组件\n      components: &#123;\n      \t&#x2F;&#x2F; 使用时的标签名：定义的组件名\n        school: sh,\n        &#x2F;&#x2F; 当使用的标签名和定义的组件相同时可简写\n        student\n      &#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n17.3 组件写法\n组件名：一个单词组成 ：第一种写法(首字母小写)：school 、第二种写法(首字母大写)：School多个单词组成 ：第一种写法(kebab-case命名)：my-school 、第二种写法(CamelCase命名)：MySchool (需要 Vue 脚手架支持)备注：\n组件名尽可能回避 HTML 中已有的元素名称，例如：h2、H2 都不行\n可以使用 name 配置项指定组件在开发者工具中呈现的名字\n\n\n组件标签：第一种写法：&lt;school&gt;&lt;&#x2F;school&gt;第二种写法：&lt;school &#x2F;&gt;，不用使用 Vue 脚手架时，&lt;school&#x2F;&gt;会导致后续组件不能渲染。\n简写方式 ：const school &#x3D; Vue.extend(options) 可简写为：const school &#x3D; options\n\n17.4 组件嵌套定义一个 App 组件来管理其他所有组件，vm 只需要管理 App 组件\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n  \n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n\n    const student &#x3D; Vue.extend(&#123;\n      template:&#96;\n        &lt;div&gt;\n          &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125; &lt;&#x2F;h2&gt;\n          &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125; &lt;&#x2F;h2&gt;\n        &lt;&#x2F;div&gt;\n      &#96;,\n      data() &#123;\n        return &#123;\n          studentName: &#39;张三&#39;,\n          age: &#39;18&#39;\n        &#125;\n      &#125;,\n    &#125;);\n    const school &#x3D; Vue.extend(&#123;\n      template: &#96;\n        &lt;div&gt;\n          &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;\n          &lt;h2&gt;学校地址：&#123;&#123;schoolAddress&#125;&#125;&lt;&#x2F;h2&gt;\n          &lt;student&gt;&lt;&#x2F;student&gt;\n        &lt;&#x2F;div&gt;\n      &#96;,\n      data() &#123;\n        return &#123;\n          schoolName: &#39;Vue&#39;,\n          schoolAddress: &#39;湖南&#39;\n        &#125;\n      &#125;,\n      components: &#123;student&#125;\n    &#125;);\n  \n    const hello &#x3D; Vue.extend(&#123;\n\t\ttemplate:&#96;\n\t\t\t&lt;div&gt;\n\t\t\t\t&lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&#96;,\n\t\tdata()&#123;\n\t\t\treturn &#123;\n\t\t\t\tname: &#39;Tom&#39;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n  \n    const App &#x3D; Vue.extend(&#123;\n      template:&#96;\n        &lt;div&gt;\n          &lt;hello&gt;&lt;&#x2F;hello&gt;\n          &lt;school&gt;&lt;&#x2F;school&gt;\n        &lt;&#x2F;div&gt;\n      &#96;,\n      components: &#123;\n        hello,\n        school\n      &#125;\n    &#125;)\n  \n    let vm &#x3D; new Vue(&#123;\n      template: &#96;&lt;App&gt;&lt;&#x2F;App&gt;&#96;,\n      el: &quot;#root&quot;,\n      components: &#123;App&#125;\n    &#125;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n17.5 VueComponent\n组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，是 Vue.extend 生成的\n我们只需要写组件标签 &lt;school&#x2F;&gt; 或 &lt;school&gt;&lt;&#x2F;school&gt;，Vue 解析时会帮我们创建 school 组件的实例对象，即 Vue 帮我们执行的：new VueComponent(options)\n每次调用 Vue.extend，返回的都是一个全新的VueComponent\n关于 this 指向：\n组件 VueComponent 配置中：data 函数、methods 中的函数、watch 中的函数、computed 中的函数 它们的 this 均是 【VueComponent实例对象】\nnew Vue(options) 配置中：data 函数、methods 中的函数、watch 中的函数、computed 中的函数 它们的 this 均是【Vue实例对象】\n\n\nVueComponent 的实例对象，以后简称 vc（也可称之为：组件实例对象）。Vue 的实例对象，简称 vm\n\n17.6 内置关系VueComponent.prototype.proto &#x3D;&#x3D;&#x3D; Vue.prototype可以让组件实例对象（vc）可以访问到 Vue 原型上的属性、方法。\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;\n    &lt;!-- &lt;school&gt;&lt;&#x2F;school&gt; --&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    Vue.config.productionTip &#x3D; false;\n\n    const school &#x3D; Vue.extend(&#123;\n      template:&#96;\n        &lt;div&gt;\n          &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;\n        &lt;&#x2F;div&gt;\n      &#96;,\n      data() &#123;\n        return &#123;\n          name: &#39;张三&#39;\n        &#125;\n      &#125;,\n    &#125;)\n  \n    let vm &#x3D; new Vue(&#123;\n      el: &quot;#root&quot;,\n      components: &#123;\n        &#x2F;&#x2F; school\n      &#125;\n    &#125;);\n   console.log(school.prototype.__proto__ &#x3D;&#x3D;&#x3D; Vue.prototype);\n   console.log(school.prototype.__proto__ &#x3D;&#x3D;&#x3D; vm.__proto__);\n   Vue.prototype.x &#x3D; 99;\n  \n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n17.7 单文件组件School.vue\n&lt;template&gt;\n  &lt;!-- 组件的结构 --&gt;\n  &lt;div class&#x3D;&quot;demo&quot;&gt;\n    &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;学校地址：&#123;&#123;schoolAddress&#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;showName&quot;&gt;点我提示学校名&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  &#x2F;&#x2F; 组件交互相关的代码（数据、方法等等）\n  export default(&#123;\n    name: &#39;School&#39;,\n    data() &#123;\n      return &#123;\n        schoolName: &#39;Vue&#39;,\n        schoolAddress: &#39;湖南&#39;\n      &#125;\n    &#125;,\n    methods: &#123;\n\t\tshowName()&#123;\n\t\talert(this.name)\n\t  &#125;\n\t&#125;,\n  &#125;);\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n  &#x2F;* 组件的样式 *&#x2F;\n  .demo&#123;\n    background-color: orange;\n  &#125;\n&lt;&#x2F;style&gt;\n\nApp.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;School&gt;&lt;&#x2F;School&gt;\n    &lt;!-- &lt;Student&gt;&lt;&#x2F;Student&gt; --&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  import School from &#39;.&#x2F;School.vue&#39;\n  &#x2F;&#x2F; import Student from &#39;.&#x2F;Student.vue&#39;\n  export default &#123;\n    name: &#39;App&#39;,\n    components: &#123;\n      School,\n      &#x2F;&#x2F; Student\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\nmain.js\nimport App from &#39;.&#x2F;App.vue&#39;\n\nnew Vue(&#123;\n  el: &#39;#root&#39;,\n  components: &#123;App&#125;\n&#125;)\n","slug":"BlogRepository/Vue/Vue2 总结（Basic）","date":"2022-03-28T02:38:54.000Z","categories_index":"Vue","tags_index":"Vue","author_index":"凡"},{"id":"489b1959aeda27687de88f48f1d87894","title":"MapStruct 总结","content":"1. 概念在系统工程开发过程中，会有各个层之间的对象转换，比如 VO、DTO、PO、DO 等，如果都是手动 setter、getter 特别浪费时间，还可能操作错误，所以选择一个自动化工具会更加方便。常见的有 json2Json、Apache 和 Spring 的 BeanUtils.copyProperties()、BeanCopier、JMapper 等\n对象属性转换的操作无非是基于反射、AOP、CGlib、ASM、Javassist 在编译时和运行期进行处理，再有好的思路就是在编译前生成出对应的 setter、getter，就像手写出来的一样。MapStruct 就是直接在编译期生成对应的 setter、getter，性能更好、使用方便\n2. POM导入依赖\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.mapstruct&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mapstruct&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;1.5.0.RC1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.mapstruct&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mapstruct-processor&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;1.5.0.RC1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.mapstruct&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mapstruct-jdk8&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;1.5.0.RC1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n可以选择在 IDEA 中下载其插件\n3. 实体类定义几个 DO 和 DTO\n&#x2F;&#x2F; UserDO\n@Data\n@Builder\npublic class UserDO &#123;\n    private Integer id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String birthday;\n    private String phone;\n    private String userDOGender;\n    private Date createTime;\n    private Map&lt;String, String&gt; map;\n    private List&lt;PersonDO&gt; personList;\n&#125;\n&#x2F;&#x2F; UserDTO\n@Data\n@Builder\npublic class UserDTO &#123;\n    private Integer id;\n    private String name;\n    private Integer age;\n    private String address;\n    private String userDTOGender;\n    private Date createTime;\n    private Map&lt;String, String&gt; map;\n    private List&lt;PersonDO&gt; personList;\n&#125;\n&#x2F;&#x2F; PersonDO\n@Data\n@Builder\npublic class PersonDO &#123;\n    private Integer id;\n    private String name;\n    private String job;\n    private String remark;\n    private Date createTime;\n&#125;\n&#x2F;&#x2F; PersonDTO\n@Data\n@Builder\npublic class PersonDTO &#123;\n    private Integer id;\n    private String name;\n    private String job;\n&#125;\n\n3. 映射器\n如果 DTO 和实体类中的字段名称是一致的，只需要写方法签名即可\n如果参数名称有变化，需要使用 @Maping 注解，source 为原参数名称，target 为转换后的类的参数名称\n隐式类型转换在许多情况下，MapStruct 会自动处理类型转换。如在 source 中是 int 类型但在 target 中是 String 类型，会自动进行转换。以及所有 Java 基本数据类型及其相应的包装类型，如 int 和 Integer，boolean 和 Boolean 等。还有所有 Java Number类型和包装器类型之间，如 int 和 long 或 byte 和 Integer\n\n@Mapper &#x2F;&#x2F; 直接使用\n@Mapper(componentModel &#x3D; &quot;spring&quot;) &#x2F;&#x2F; 整合 Spring，设置 componentModel &#x3D; &quot;spring&quot;，需要使用的地方直接通过 @Resource 注入即可\npublic interface MapStruct &#123;\n\n\tMapStruct INSTANCE &#x3D; Mappers.getMapper(MapStruct.class);\n\n    @Mapping(source &#x3D; &quot;userDOGender&quot;, target &#x3D; &quot;userDTOGender&quot;)\n    UserDTO userDOToUserDTO(UserDO userDO);\n\n    @Mapping(source &#x3D; &quot;userDTOGender&quot;, target &#x3D; &quot;userDOGender&quot;)\n    UserDO UserDTOToUserDO(UserDTO userDTO);\n\n    PersonDTO personDOToPersonDTO(PersonDO personDO);\n\n    PersonDO PersonDTOToPersonDO(PersonDTO personDTO);\n&#125;\n\n编译后，会在同级目录生成实现类：\n@Generated(\n    value &#x3D; &quot;org.mapstruct.ap.MappingProcessor&quot;,\n    date &#x3D; &quot;2022-03-22T12:16:06+0800&quot;,\n    comments &#x3D; &quot;version: 1.5.0.RC1, compiler: javac, environment: Java 1.8.0_131 (Oracle Corporation)&quot;\n)\npublic class MapStructImpl implements MapStruct &#123;\n\n    @Override\n    public UserDTO userDOToUserDTO(UserDO userDO) &#123;\n        if ( userDO &#x3D;&#x3D; null ) &#123;\n            return null;\n        &#125;\n\n        UserDTO.UserDTOBuilder userDTO &#x3D; UserDTO.builder();\n\n        userDTO.userDTOGender( userDO.getUserDOGender() );\n        userDTO.id( userDO.getId() );\n        userDTO.name( userDO.getName() );\n        userDTO.age( userDO.getAge() );\n        userDTO.address( userDO.getAddress() );\n        userDTO.createTime( userDO.getCreateTime() );\n        Map&lt;String, String&gt; map &#x3D; userDO.getMap();\n        if ( map !&#x3D; null ) &#123;\n            userDTO.map( new LinkedHashMap&lt;String, String&gt;( map ) );\n        &#125;\n        List&lt;PersonDO&gt; list &#x3D; userDO.getPersonList();\n        if ( list !&#x3D; null ) &#123;\n            userDTO.personList( new ArrayList&lt;PersonDO&gt;( list ) );\n        &#125;\n\n        return userDTO.build();\n    &#125;\n\n    @Override\n    public UserDO UserDTOToUserDO(UserDTO userDTO) &#123;\n        if ( userDTO &#x3D;&#x3D; null ) &#123;\n            return null;\n        &#125;\n\n        UserDO.UserDOBuilder userDO &#x3D; UserDO.builder();\n\n        userDO.userDOGender( userDTO.getUserDTOGender() );\n        userDO.id( userDTO.getId() );\n        userDO.name( userDTO.getName() );\n        userDO.age( userDTO.getAge() );\n        userDO.address( userDTO.getAddress() );\n        userDO.createTime( userDTO.getCreateTime() );\n        Map&lt;String, String&gt; map &#x3D; userDTO.getMap();\n        if ( map !&#x3D; null ) &#123;\n            userDO.map( new LinkedHashMap&lt;String, String&gt;( map ) );\n        &#125;\n        List&lt;PersonDO&gt; list &#x3D; userDTO.getPersonList();\n        if ( list !&#x3D; null ) &#123;\n            userDO.personList( new ArrayList&lt;PersonDO&gt;( list ) );\n        &#125;\n\n        return userDO.build();\n    &#125;\n\n    @Override\n    public PersonDTO personDOToPersonDTO(PersonDO personDO) &#123;\n        if ( personDO &#x3D;&#x3D; null ) &#123;\n            return null;\n        &#125;\n\n        PersonDTO.PersonDTOBuilder personDTO &#x3D; PersonDTO.builder();\n\n        personDTO.id( personDO.getId() );\n        personDTO.name( personDO.getName() );\n        personDTO.job( personDO.getJob() );\n\n        return personDTO.build();\n    &#125;\n\n    @Override\n    public PersonDO PersonDTOToPersonDO(PersonDTO personDTO) &#123;\n        if ( personDTO &#x3D;&#x3D; null ) &#123;\n            return null;\n        &#125;\n\n        PersonDO.PersonDOBuilder personDO &#x3D; PersonDO.builder();\n\n        personDO.id( personDTO.getId() );\n        personDO.name( personDTO.getName() );\n        personDO.job( personDTO.getJob() );\n\n        return personDO.build();\n    &#125;\n&#125;\n\n4. 测试public class Test &#123;\n    public static void main(String[] args) &#123;\n        UserDO userDO &#x3D; UserDO.builder().id(1)\n                .name(&quot;张三&quot;)\n                .age(18)\n                .birthday(&quot;2003-01-04&quot;)\n                .phone(&quot;12343&quot;)\n                .userDOGender(&quot;男&quot;)\n                .createTime(new Date(System.currentTimeMillis()))\n                .map(new HashMap&lt;String, String&gt;()&#123;\n                    &#123;\n                        this.put(&quot;key&quot;, &quot;value&quot;);\n                    &#125;\n                &#125;)\n                .personList(new ArrayList&lt;PersonDO&gt;()&#123;\n                    &#123;\n                        this.add(PersonDO.builder().id(11).build());\n                    &#125;\n                &#125;).build();\n        UserDTO userDTO &#x3D; Mappers.getMapper(MapStruct.class).userDOToUserDTO(userDO);\n        System.out.println(userDTO);\n\n        PersonDTO personDTO &#x3D; PersonDTO.builder().id(11)\n                .name(&quot;李四&quot;)\n                .job(&quot;开发&quot;).build();\n        PersonDO personDO &#x3D; MapStruct.INSTANCE.PersonDTOToPersonDO(personDTO);\n        System.out.println(personDO);\n    &#125;\n&#125;\n\n\n5. 自定义转换规则MapStruct 只提供了隐式类型转换和默认的一些转换，假如需要特定的类型转换，如将 java.sql.Timestamp 日期转换为只保留年月日的字符串等，可以自定义转换规则\n5.1 使用 expression 表达式1、创建一个转换规则类\npublic class MapStructRule &#123;\n    public static String toDate(Timestamp date) &#123;\n        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\n        return simpleDateFormat.format(date);\n    &#125;\n&#125;\n\n2、在映射器对应的转换方法上使用 @Mapping 注解的 expression 属性标识转换规则，这里的属性值为需要写 全类名.方法名(参数)，使用了 expression 就不需要 source 属性\n@Mapper(componentModel &#x3D; &quot;spring&quot;) &#x2F;&#x2F; 整合 Spring，设置 componentModel &#x3D; &quot;spring&quot;，需要使用的地方直接通过 @Resource 注入即可\npublic interface MapStruct &#123;\n    MapStruct INSTANCE &#x3D; Mappers.getMapper(MapStruct.class);\n\n    @Mapping(target &#x3D; &quot;createTime&quot;, expression &#x3D; &quot;java(fan.fanblog.utils.MapStructRule.toDate(menuDO.getCreateTime()))&quot;)\n    @Mapping(target &#x3D; &quot;updateTime&quot;, expression &#x3D; &quot;java(fan.fanblog.utils.MapStructRule.toDate(menuDO.getUpdateTime()))&quot;)\n    MenuVO MenuDOToMenuVO(MenuDO menuDO);\n&#125;\n\n3、测试类\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        MenuDO menuDO &#x3D; new MenuDO();\n\n        menuDO.setCreateTime(new Timestamp(System.currentTimeMillis()));\n        menuDO.setUpdateTime(new Timestamp(System.currentTimeMillis()));\n        System.out.println(menuDO);\n\n        MenuVO menuVO &#x3D; MapStruct.INSTANCE.MenuDOToMenuVO(menuDO);\n        System.out.println(menuVO);\n    &#125;\n&#125;\n\n\n5.2 使用 @Named 注解1、创建一个转换规则类，在对应的转换方法上标注 @Named 注解表示转换方法名\npublic class MapStructRule &#123;\n    @Named(&quot;toDate&quot;)\n    public static String toDate(Timestamp date) &#123;\n        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n        return simpleDateFormat.format(date);\n    &#125;\n&#125;\n\n2、在映射器上使用 @Mapper 的 uses 属性，属性值为转换规则类的 Class 对象，然后再映射器对应的方法上使用 @Mapping 注解的 qualifiedByName 属性，属性值为转换规则类 @Named 定义的方法名\n@Mapper(componentModel &#x3D; &quot;spring&quot;, uses &#x3D; MapStructRule.class) &#x2F;&#x2F; 整合 Spring，设置 componentModel &#x3D; &quot;spring&quot;，需要使用的地方直接通过 @Resource 注入即可\npublic interface MapStruct &#123;\n    MapStruct INSTANCE &#x3D; Mappers.getMapper(MapStruct.class);\n\n    @Mapping(target &#x3D; &quot;createTime&quot;, source &#x3D; &quot;createTime&quot;, qualifiedByName &#x3D; &quot;toDate&quot;)\n    @Mapping(target &#x3D; &quot;updateTime&quot;, source &#x3D; &quot;updateTime&quot;, qualifiedByName &#x3D; &quot;toDate&quot;)\n    MenuVO MenuDOToMenuVO(MenuDO menuDO);\n&#125;\n\n3、测试类\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        MenuDO menuDO &#x3D; new MenuDO();\n\n        menuDO.setCreateTime(new Timestamp(System.currentTimeMillis()));\n        menuDO.setUpdateTime(new Timestamp(System.currentTimeMillis()));\n        System.out.println(menuDO);\n\n        MenuVO menuVO &#x3D; MapStruct.INSTANCE.MenuDOToMenuVO(menuDO);\n        System.out.println(menuVO);\n    &#125;\n&#125;\n\n\n6. 忽略属性不转换@Mapper(componentModel &#x3D; &quot;spring&quot;, uses &#x3D; MapStructRule.class) &#x2F;&#x2F; 整合 Spring，设置 componentModel &#x3D; &quot;spring&quot;，需要使用的地方直接通过 @Resource 注入即可\npublic interface MapStruct &#123;\n    MapStruct INSTANCE &#x3D; Mappers.getMapper(MapStruct.class);\n\n    @Mapping(target &#x3D; &quot;createTime&quot;, ignore &#x3D; true)\n    @Mapping(target &#x3D; &quot;updateTime&quot;, ignore &#x3D; true)\n    MenuDO MenuVOToMenuDO(MenuVO menuVO);\n&#125;\n","slug":"BlogRepository/开发技术及框架/MapStruct 总结","date":"2022-03-22T05:51:27.000Z","categories_index":"开发技术及框架","tags_index":"Java","author_index":"凡"},{"id":"8c40486acfd1c17dcd4c39c1d08317e3","title":"JWT 总结","content":"1. 跨域身份验证1.1 传统的 session 流程\n浏览器发起请求登陆，向服务器发送用户名和密码\n服务端验证身份，生成身份验证信息（用户角色、登录时间等），存储在服务端 的 session 中\n服务器向用户返回 session_id，session 信息都会写入到用户的 Cookie\n用户的每个后续请求都将通过在 Cookie 中取出 session_id 传给服务器\n服务器收到 session_id 并对比之前保存的数据，确认用户的身份\n服务器返回用户请求的内容\n\n1.2 JWT 流程\n浏览器发起请求登陆\n服务端验证身份，根据算法，将用户标识符打包生成 JWT, 并且返回给浏览器\n浏览器发起请求获取用户资料，把刚刚拿到的 JWT 一起发送给服务器\n服务器发现数据中有 JWT，进行验证\n服务器返回用户请求的内容\n\n1.3 session 与 JWT 区别\nsession 存储在服务端占用服务器资源，而 JWT 存储在客户端\nsession 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险，而 JWT 则通过参数传递\nsession 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用\n存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性\n\n1.4 JWT 工作原理在服务器身份验证之后，将生成一个 JSON 对象并将其发送回用户。之后，当用户与服务器通信时，客户在请求中发回 JSON 对象。服务器仅依赖于这个 JSON 对象来标识用户。为了防止用户篡改数据，服务器将在生成对象时添加签名。服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展\n2. 访问令牌的类型\n3. JWT 的组成JWTString&#x3D;Base64(Header) + &quot;.&quot; + Base64(Payload).HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret)\n\n该对象为一个很长的字符串，字符之间通过 “.” 分隔符分为三个子串。每一个子串表示了一个功能块，总共有以下三个部分：JWT 头、有效载荷和签名\n3.1 Header（JWT 头）JWT 头部分是一个描述 JWT 元数据的 JSON 对象，通常如下所示：\n&#123;\n\t&quot;alg&quot;: &quot;HS256&quot;,\n\t&quot;typ&quot;: &quot;JWT&quot;\n&#125;\n\n\nalg： 表示签名使用的算法，默认为 HMAC SHA256（写为 HS256）\ntyp： 表示令牌的类型，JWT 令牌统一写为 JWT。\n\n最后，使用 Base64URL 算法将上述 JSON 对象转换为字符串保存\n3.2 Payload（有效载荷）有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据，包含三个部分：\n\n标准声明\n公共声明\n私有声明\n\n3.2.1 标准声明字段interface Stantard &#123;\n  iss?: string; &#x2F;&#x2F; JWT的签发者，发行人\n  sub?: string; &#x2F;&#x2F; 主题\n  aud?: string; &#x2F;&#x2F; 接收JWT的一方，受众，用户\n  exp?: number; &#x2F;&#x2F; JWT的过期时间，这个过期时间必须要大于签发时间\n  nbf?: number; &#x2F;&#x2F; 定义在什么时间之前，该 JWT 都是不可用的\n  iat?: number; &#x2F;&#x2F; 该JWT签发的时间，发布时间\n  jti?: number; &#x2F;&#x2F;JWT的唯一身份标识，JWT ID\n&#125;\n\n3.2.2 公共声明的字段interface Public &#123;\n\t[key: string]: any;\n&#125;\n\n公共声明字段可以添加任意信息，但是因为可以被解密出来，所以不建议存放敏感信息。\n3.2.3 私有声明的字段interface Private &#123;\n\t[key: string]: any;\n&#125;\n\n3.2.4 示例一个JWT 的 payload 如下：\n&#123;\n\t&quot;ip&quot;: &quot;127.0.0.1&quot;,\n\t&quot;uuid&quot;: &quot;ff1212f5-d8d1-4496-bf41-d2dda73de19a&quot;,\n\t&quot;iat&quot;: 1527523017\n&#125;\n\n通过 Base64URL 算法加密生成第二部分的 payload\nconst payloadBuffer &#x3D; Buffer.from(\n\tJSON.stringify(&#123;\n\t\tip: &quot;127.0.0.1&quot;,\n\t\tuuid: &quot;ff1212f5-d8d1-4496-bf41-d2dda73de19a&quot;,\n\t\tiat: 1527523017\n\t&#125;)\n);\nconst payload &#x3D; payloadBuffer.toString(&quot;base64&quot;);\n\nconsole.log(payload);\n&#x2F;&#x2F; eyJpcCI6IjEyNy4wLjAuMSIsInV1aWQiOiJmZjEyMTJmNS1kOGQxLTQ0OTYtYmY0MS1kMmRkYTczZGUxOWEiLCJpYXQiOjE1Mjc1MjMwMTd9\n\n\n\n\n\n\n\n\n\n\n默认情况下 JWT 是未加密的，因为只是采用 Base64URL 算法，拿到 JWT 字符串后可以转换回原本的 JSON 数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到 JWT 中，以防止信息泄露。JWT 只是适合在网络中传输一些非敏感的信息。\n3.3 Signature（签名哈希）签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密钥仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）生成签名：\nsignature &#x3D; 加密算法(header + &quot;.&quot; + payload, 密钥);\nsignature &#x3D; HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(claims), secret)\n\n在计算出签名哈希后，JWT 头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用 “.” 分隔，就构成整个 JWT 对象。\n3.4 Base64URL 算法JWT 头和有效载荷序列化的算法都用到了 Base64URL。该算法和常见 Base64 算法类似，稍有差别。作为令牌的 JWT 可以放在 URL 中（例如 api.example&#x2F;?token&#x3D;xxx）。Base64 中用的三个字符是 “+”，”&#x2F;“ 和 “&#x3D;”，由于在 URL 中有特殊含义，因此 Base64URL 中对他们做了替换：”&#x3D;” 去掉，”+” 用 “-“ 替换，”&#x2F;“ 用 “_” 替换，这就是 Base64URL 算法。\n4. JWT 安全性4.1 Token如何做身份验证？\n首先，JWT 的 Token 相当是明文，是可以解密的，任何存在 payload 的东西，都没有秘密可言，所以隐私数据不能签发 Token\n而服务端，拿到 Token 后解密，即可知道用户信息，例如示例中的 uuid\n有了 uuid，那么你就知道这个用户是谁，是否有权限进行下一步的操作\n\n4.2 如何防止 Token 被串改？\n此时 signature 字段就是关键了，能被解密出明文的只有 header 和 payload\n假如被人串改了 payload，那么服务器可以通过 signature 去验证是否被篡改过，在服务端在执行一次 signature &#x3D; 加密算法(header + “.” + payload, 密钥);，然后对比 signature 是否一致，如果一致则说明没有被篡改。\n所以服务器的密钥不能被泄漏。如果泄漏，将存在以下风险：客户端可以自行签发 Token、其他人可以肆意篡改 Token\n\n4.3 问题\nJWT 默认不加密，但可以加密。生成原始令牌后，可以使用该令牌再次对其进行加密\n当 JWT 未加密方法时，一些私密数据无法通过 JWT 传输\nJWT 不仅可用于认证，还可用于信息交换。善用 JWT 有助于减少服务器请求数据库的次数\nJWT 的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦 JWT 签发，在有效期内将会一直有效\nJWT 本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT 的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证\n为了减少盗用和窃取，JWT 不建议使用 HTTP 协议来传输代码，而是使用加密的 HTTPS 协议进行传输\n\n5. JWT 种类JWT（JSON Web Token）指的是一种规范，这种规范允许我们使用 JWT 在两个组织之间传递安全可靠的信息，JWT 的具体实现可以分为以下几种：\n\nnonsecure JWT：未经过签名，不安全的 JWT\nJWS：经过签名的 JWT\nJWE：payload 部分经过加密的 JWT\n\n5.1 nonsecure JWT经过签名，不安全的 JWT。其 header 部分没有指定签名算法\n&#123;\n\t&quot;alg&quot;: &quot;none&quot;,\n\t&quot;typ&quot;: &quot;JWT&quot;\n&#125;\n\n并且也没有 Signature 部分\n5.2 JWS5.2.1 概念JWS ，也就是 JWT Signature，其结构就是在之前 nonsecure JWT 的基础上，在头部声明签名算法，并在最后添加上签名。创建签名，是保证 JWT 不能被他人随意篡改。我们通常使用的 JWT 一般都是 JWS。\n为了完成签名，除了用到 header 信息和 payload 信息外，还需要算法的密钥，也就是 secretKey。加密的算法一般有 2 类：\n\n对称加密：secretKey 指加密密钥，可以生成签名与验签\n非对称加密：secretKey 指私钥，只用来生成签名，不能用来验签（验签用的是公钥）\n\nJWT 的密钥或者密钥对，一般统一称为JSON Web Key，也就是JWK\n5.2.2 JWT 签名算法到目前为止，JWT 的签名算法有三种：\n\nHMAC【哈希消息验证码(对称)】：HS256&#x2F;HS384&#x2F;HS512\nRSASSA【RSA签名算法(非对称)】（RS256&#x2F;RS384&#x2F;RS512）\nECDSA【椭圆曲线数据签名算法(非对称)】（ES256&#x2F;ES384&#x2F;ES512）\n\n5.3 JWEJWS 是去验证数据的，而 JWE（JSON Web Encryption）是保护数据不被第三方的人看到的。通过 JWE，JWT 变得更加安全。\n\nJWE 和 JWS 的公钥私钥方案不相同，JWS 中，私钥持有者加密令牌，公钥持有者验证令牌。而 JWE 中，私钥一方应该是唯一可以解密令牌的一方。\n在 JWE 中，公钥持有可以将新的数据放入 JWT 中，但是 JWS 中，公钥持有者只能验证数据，不能引入新的数据。因此，对于公钥&#x2F;私钥的方案而言，JWS 和JWE 是互补的。\n\n6. 使用6.1 java-jwt导入依赖\n&lt;dependency&gt;\n\t&lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.18.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n6.1.1 对称签名public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; Token的签名密钥\n    private final static String SECRET_KEY &#x3D; &quot;123456&quot;;\n\n\t&#x2F;&#x2F; 根据用户名生成 Token\n    public static String generateToken(String username)&#123;\n        Algorithm algorithm &#x3D; Algorithm.HMAC256(SECRET_KEY);\n        JWTCreator.Builder jwt &#x3D; JWT.create();\n\n        HashMap&lt;String, Object&gt; header &#x3D; new HashMap&lt;&gt;();\n        header.put(&quot;alg&quot;, &quot;HS256&quot;);\n        header.put(&quot;type&quot;, &quot;jwt&quot;);\n\n        &#x2F;&#x2F; jwt.withHeader(header)\n        &#x2F;&#x2F; JWT 的 header 部分,该 map 可以是空的,因为有默认值&#123;&quot;alg&quot;:HS256,&quot;typ&quot;:&quot;JWT&quot;&#125;\n        String token &#x3D; jwt.withHeader(new HashMap&lt;&gt;())\n                .withClaim(&quot;userId&quot;, 7)  &#x2F;&#x2F; Payload\n                .withClaim(&quot;username&quot;, username)\n                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN)) &#x2F;&#x2F; 过期时间\n                .sign(algorithm);&#x2F;&#x2F; 签名用的 secret\n\n        System.out.println(&quot;生成的 Token：&quot; + token);\n        return token;\n    &#125;\n\n\t&#x2F;&#x2F; 验证 Token\n    public static DecodedJWT verify(String token)&#123;\n        Algorithm algorithm &#x3D; Algorithm.HMAC256(SECRET_KEY);\n\n        Verification verification &#x3D; JWT.require(algorithm);\n        JWTVerifier jwtVerifier &#x3D; verification.build();\n\n        DecodedJWT decodedJWT &#x3D; jwtVerifier.verify(token); &#x2F;&#x2F; 通过密钥进行验证\n        return decodedJWT;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        DecodedJWT decodedJWT &#x3D; verify(token);\n\n        String header &#x3D; decodedJWT.getHeader();\n        System.out.println(&quot;JWT 头：&quot; + header);\n\n        Map&lt;String, Claim&gt; claims &#x3D; decodedJWT.getClaims();\n        System.out.println(&quot;有效负载：&quot; + claims);\n        Claim username &#x3D; decodedJWT.getClaim(&quot;username&quot;);\n        System.out.println(&quot;用户名：&quot; + username);\n\n        String signature &#x3D; decodedJWT.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n\n        Date expiresAt &#x3D; decodedJWT.getExpiresAt();\n        System.out.println(&quot;过期时间&quot; + expiresAt);\n    &#125;\n&#125;\n\n\n6.1.2 非对称签名public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; 使用 Hutool 构建 RSA，当使用无参构造时，将自动生成随机的公钥私钥密钥对\n    private final static RSA rsa &#x3D; new RSA();\n    &#x2F;&#x2F; private static final String RSA_PRIVATE_KEY &#x3D; &quot;...&quot;; 私钥\n    &#x2F;&#x2F; private static final String RSA_PUBLIC_KEY &#x3D; &quot;...&quot;;  公钥\n\n    &#x2F;&#x2F; 生成 Token\n    public static String generateToken(String username)&#123;\n    \t&#x2F;&#x2F; 获取 RSA 私钥\n        &#x2F;&#x2F; RSA rsa &#x3D; new RSA(RSA_PRIVATE_KEY, null);\n        &#x2F;&#x2F; RSAPrivateKey rsaPrivateKey &#x3D; (RSAPrivateKey) rsa.getPrivateKey();\n        RSAPrivateKey rsaPrivateKey &#x3D; (RSAPrivateKey) rsa.getPrivateKey();\n\n        String token &#x3D; JWT.create().withHeader(new HashMap&lt;&gt;())\n                .withClaim(&quot;username&quot;, username)\n                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n                .sign(Algorithm.RSA256(null, rsaPrivateKey)); &#x2F;&#x2F; 签名时传入私钥\n        return token;\n    &#125;\n\n    &#x2F;&#x2F; 验证 Token\n    public static DecodedJWT verify(String token)&#123;\n    \t&#x2F;&#x2F; 获取 RSA 公钥\n    \t&#x2F;&#x2F; RSA rsa &#x3D; new RSA(null, RSA_PUBLIC_KEY);\n   \t\t&#x2F;&#x2F; RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) rsa.getPublicKey();\n        RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) rsa.getPublicKey();\n      \n        &#x2F;&#x2F; 验签时传入公钥\n        JWTVerifier jwtVerifier &#x3D; JWT.require(Algorithm.RSA256(rsaPublicKey, null)).build();\n\n        DecodedJWT decodedJWT &#x3D; jwtVerifier.verify(token);\n        return decodedJWT;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        DecodedJWT decodedJWT &#x3D; verify(token);\n\n        String header &#x3D; decodedJWT.getHeader();\n        System.out.println(&quot;JWT 头：&quot; + header);\n\n        Map&lt;String, Claim&gt; claims &#x3D; decodedJWT.getClaims();\n        System.out.println(&quot;有效负载：&quot; + claims);\n        Claim username &#x3D; decodedJWT.getClaim(&quot;username&quot;);\n        System.out.println(&quot;用户名：&quot; + username);\n\n        String signature &#x3D; decodedJWT.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n\n        Date expiresAt &#x3D; decodedJWT.getExpiresAt();\n        System.out.println(&quot;过期时间&quot; + expiresAt);\n    &#125;\n&#125;\n\n\n6.2 jjwt导入依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.9.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n6.2.1 对称签名public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; Token的密钥\n    private final static String SECRET_KEY &#x3D; &quot;123456&quot;;\n\n    &#x2F;&#x2F; 根据用户名生成 Token\n    public static String generateToken(String username)&#123;\n        JwtBuilder jwtBuilder &#x3D; Jwts.builder();\n\n        &#x2F;&#x2F; jwtBuilder.setHeader(new HashMap&lt;&gt;());\n        String token &#x3D; jwtBuilder.setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)\n                .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)\n                .setSubject(&quot;user&quot;)\n                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n                .claim(&quot;username&quot;, username)\n                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)\n                .compact();\n\t\tSystem.out.println(&quot;生成的 Token：&quot; + token);\n        return token;\n    &#125;\n\n    &#x2F;&#x2F; 验证 Token，从http请求头中获取 Token 字符串\n    public static Jws&lt;Claims&gt; verify(String token)&#123;\n        JwtParser jwtParser &#x3D; Jwts.parser();\n        Jws&lt;Claims&gt; claimsJws &#x3D; jwtParser.setSigningKey(SECRET_KEY).parseClaimsJws(token);\n        return claimsJws;\n    &#125;\n    public static Jws&lt;Claims&gt; verify(HttpServletRequest request)&#123;\n        String token &#x3D; request.getHeader(&quot;token&quot;);\n        JwtParser jwtParser &#x3D; Jwts.parser();\n        Jws&lt;Claims&gt; claimsJws &#x3D; jwtParser.setSigningKey(SECRET_KEY).parseClaimsJws(token);\n        return claimsJws;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        Jws&lt;Claims&gt; claimsJws &#x3D; verify(token);\n\n        JwsHeader header &#x3D; claimsJws.getHeader();\n        System.out.println(&quot;Header：&quot; + header);\n\n        Claims body &#x3D; claimsJws.getBody();\n        System.out.println(&quot;PayLoad：&quot; + body);\n        String subject &#x3D; body.getSubject();\n        System.out.println(&quot;主题：&quot; + subject);\n\n        String signature &#x3D; claimsJws.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n    &#125;\n&#125;\n\n\n6.2.2 jjwt 的 0.10版本以后pom依赖要引入多个\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.11.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt-impl&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.11.2&lt;&#x2F;version&gt;\n    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jjwt-jackson&lt;&#x2F;artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt;\n    &lt;version&gt;0.11.2&lt;&#x2F;version&gt;\n    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n在 jjwt 0.10 版本之前，没有强制要求，secretKey 长度不满足要求时也可以签名成功。但是 0.10 版本后强制要求 secretKey 满足规范中的长度要求，否则生成 jws 时会抛出异常\n\nHS256：要求至少 256 bits (32 bytes)\nHS384：要求至少384 bits (48 bytes)\nHS512：要求至少512 bits (64 bytes)\nRS256 and PS256：至少2048 bits\nRS384 and PS384：至少3072 bits\nRS512 and PS512：至少4096 bits\nES256：至少256 bits (32 bytes)\nES384：至少384 bits (48 bytes)\nES512：至少512 bits (64 bytes)\n\n之前的签名和验签方法都是传入密钥的字符串，已经过时。最新的方法需要传入 Key 对象\npublic static String generateToken(String username)&#123;\n\tString token &#x3D; Jwts.builder()\n\t\t.setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)\n\t\t.setSubject(&quot;user&quot;)\n\t\t.setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n\t\t.claim(&quot;username&quot;, username)\n\t\t&#x2F;&#x2F; 传入Key对象\n\t\t.signWith(Keys.hmacShaKeyFor(SECRET_KEY.getBytes(StandardCharsets.UTF_8)), SignatureAlgorithm.HS256)\n\t\t.compact();\n\treturn token;\n&#125;\n\n&#x2F;&#x2F; 验证 Token\npublic static Jws&lt;Claims&gt; verify(String token) &#123;\n\t&#x2F;&#x2F; 传入Key对象\n\tJws&lt;Claims&gt; claimsJws &#x3D; Jwts.parserBuilder().setSigningKey(Keys.hmacShaKeyFor(SECRET_KEY.getBytes(StandardCharsets.UTF_8))).build().parseClaimsJws(token);\n\treturn claimsJws;\n&#125;\n\n6.2.3 非对称签名public class TestJWT &#123;\n\n    &#x2F;&#x2F; Token的失效时间\n    private final static long EXPIRATION_TOKEN &#x3D; 60 * 1000;\n\n    &#x2F;&#x2F; 使用 Hutool 构建 RSA\n    private final static RSA rsa &#x3D; new RSA();\n\n    &#x2F;&#x2F; 根据用户名生成 Token\n    public static String generateToken(String username)&#123;\n        &#x2F;&#x2F; 获取 RSA 私钥\n        RSAPrivateKey rsaPrivateKey &#x3D; (RSAPrivateKey) rsa.getPrivateKey();\n\n        &#x2F;&#x2F; jwtBuilder.setHeader(new HashMap&lt;&gt;());\n        String token &#x3D; Jwts.builder().setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)\n                .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)\n                .setSubject(&quot;user&quot;)\n                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TOKEN))\n                .claim(&quot;username&quot;, username)\n                .signWith(rsaPrivateKey, SignatureAlgorithm.RS256)\n                .compact();\n        System.out.println(&quot;生成的 Token：&quot; + token);\n        return token;\n    &#125;\n\n    &#x2F;&#x2F; 验证 Token\n    public static Jws&lt;Claims&gt; verify(String token)&#123;\n        RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) rsa.getPublicKey();\n        Jws&lt;Claims&gt; claimsJws &#x3D; Jwts.parserBuilder().setSigningKey(rsaPublicKey).build().parseClaimsJws(token);\n        return claimsJws;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String token &#x3D; generateToken(&quot;张三&quot;);\n        Jws&lt;Claims&gt; claimsJws &#x3D; verify(token);\n\n        JwsHeader header &#x3D; claimsJws.getHeader();\n        System.out.println(&quot;Header：&quot; + header);\n\n        Claims body &#x3D; claimsJws.getBody();\n        System.out.println(&quot;PayLoad：&quot; + body);\n        String subject &#x3D; body.getSubject();\n        System.out.println(&quot;主题：&quot; + subject);\n\n        String signature &#x3D; claimsJws.getSignature();\n        System.out.println(&quot;签名：&quot; + signature);\n    &#125;\n&#125;\n\n7. 实际应用\n在登录验证通过后，给用户生成一个对应的随机 Token （注意这个 Token 不是指 JWT，可以用 UUID 等算法生成），然后将这个Token 作为 Key 的一部分，用户信息作为 Value 存入 Redis，并设置过期时间，这个过期时间就是登录失效的时间\n第1步中生成的随机 Token 作为 JWT 的 payload 生成 JWT 字符串返回给前端\n前端之后每次请求都在请求头中的 Authorization 字段中携带 JWT 字符串\n后端定义一个拦截器，每次收到前端请求时，都先从请求头中的 Authorization 字段中取出 JWT 字符串并进行验证，验证通过后解析出 payload 中的随机 Token，然后再用这个随机 Token 得到 Key，从 Redis 中获取用户信息，如果能获取到就说明用户已经登录\n\npublic class JWTInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        String JWT &#x3D; request.getHeader(&quot;Authorization&quot;);\n        try &#123;\n            &#x2F;&#x2F; 1.校验JWT字符串\n            DecodedJWT decodedJWT &#x3D; JWTUtils.decode(JWT);\n            &#x2F;&#x2F; 2.取出JWT字符串载荷中的随机token，从Redis中获取用户信息\n            ...\n            return true;\n        &#125;catch (SignatureVerificationException e)&#123;\n            System.out.println(&quot;无效签名&quot;);\n            e.printStackTrace();\n        &#125;catch (TokenExpiredException e)&#123;\n            System.out.println(&quot;token已经过期&quot;);\n            e.printStackTrace();\n        &#125;catch (AlgorithmMismatchException e)&#123;\n            System.out.println(&quot;算法不一致&quot;);\n            e.printStackTrace();\n        &#125;catch (Exception e)&#123;\n            System.out.println(&quot;token无效&quot;);\n            e.printStackTrace();\n        &#125;\n        return false;\n    &#125;\n&#125;\n","slug":"BlogRepository/开发技术及框架/JWT 总结","date":"2022-03-17T03:48:47.000Z","categories_index":"开发技术及框架","tags_index":"JWT","author_index":"凡"},{"id":"e7512e112eb3757deb99ae02ef8d3f9b","title":"Redis 启动报错 QForkMasterInit system error caught error code=0x000005af 解决","content":"1. 问题直接用 redis-server.exe 启动时闪退，用脚本加上配置文件启动也闪退，用命令行启动时，报错：\n[23848] 16 Mar 16:10:32.565 # QForkMasterInit: system error caught. error code&#x3D;0x000005af, message&#x3D;VirtualAllocEx failed.: unknown error\n\n2. 解决方法Redis 的 conf 文件设置参数 maxheap 和 maxmemory\n\nmaxmemory 120MB\nmaxheap 180MB\n\nmaxmemory 和 maxheap 根据自己的电脑配置而定，通常情况下：maxheap  &#x3D; 1.5 * maxmemory\n","slug":"BlogRepository/问题记录/Redis 启动报错 QForkMasterInit_ system error caught. error code=0x000005af 解决","date":"2022-03-16T08:20:49.000Z","categories_index":"问题记录","tags_index":"Redis","author_index":"凡"},{"id":"9bbbfad97b27dd46076156599b323bc3","title":"使用 GitHub Pages 和 Hexo 搭建个人博客","content":"示例站点\n1. GitHub PagesGitHub Pages 是一个静态站点托管服务，直接将个人、组织或项目的页面托管于 GitHub 库或仓库 （repository）中\n新建一个仓库，名为 用户名.github.io\n\n进入 Pages 页面，Choose a Theme 选择一个 GitHub Pages 提供的默认主题，即可通过 用户名.github.io 访问页面\n\n也可以添加自己的域名通过自己的域名进行访问，需要将域名 CNAME 到 用户名.github.io 的地址，添加后等待一段时间，即可通过自己的域名访问页面\n\n2. HexoHexo 是一款基于 Node.js 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 GitHub 或 Gitee 上。同时官网有中文说明，可以直接根据官网说明进行搭建\n2.1 安装 Node.js2.2 安装 Git2.3 安装 Hexo\n在安装上面的两个程序后，即可使用 npm 安装 Hexo\nnpm install -g hexo-cli\n新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站\nhexo init [folder]\nhexo init Blog\n进入创建好的文件夹根目录，以后所有的 Hexo 相关命令操作都在这里进行\ncd &lt;folder&gt;\ncd Blog\n\n\n\n创建一个 source&#x2F;name&#x2F;index.md 文件，source 是存放用户资源的地方\nhexo new page &lt;name&gt;\n清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo clean\n安装 hexo-deployer-git，用于部署\nnpm install hexo-deployer-git --save\n部署网站\nhexo d\n\n一般部署网站，使用 hexo clean 然后再 hexo d 即可。\n3. 使用 Aurora 主题\n在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\nnpm install hexo-theme-aurora --save\n在 node_modules 目录下的 hexo-theme-aurora 主题文件夹中复制 _config.yml 文件到根目录下，并重命名为 _config.aurora.yml\n\n\n\n一共有两个配置文件，一个是 Hexo 自身的配置，一个是主题专用的配置\n\n\n\n\n\n\n\n\n\n. # Hexo 项目根目录.├─ _config.yml # Hexo 配置文件└─ _config.aurora.yml # 主题配置\n\n\n3.1 Hexo配置文件 _config.yml\n设置 url 和 permalinkurl 为自己的博客地址，permalink 参数为 &#x2F;post&#x2F;:title.html# URL\n## Set your site url here. For example, if you use GitHub Page, set url as &#39;https:&#x2F;&#x2F;username.github.io&#x2F;project&#39;\nurl: https:&#x2F;&#x2F;blog.fan223.cn\npermalink: &#x2F;post&#x2F;:title.html\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks\n  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks\n设置代码高亮关闭 Highlight，设置 enable 为 false。使用 prismjs，设置 enable 为 true，将 preprocess 设置为 falsehighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: false\n  line_number: true\n  tab_replace: &#39;&#39;\n设置主题# Extensions\n## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;\n## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;\ntheme: Aurora\n设置部署仓库# Deployment\n## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment\ndeploy:\n  type: git\n  repo: git@github.com:Fan223&#x2F;Fan223.github.io.git\n  branch: main\n\n3.2 主题配置文件 _config.aurora.yml#! ---------------------------------------------------------------\n#! Aurora Theme for Hexo\n#! ---------------------------------------------------------------\n#! Designed &amp; Coded By TriDiamond\n#! ---------------------------------------------------------------\n\n#! ---------------------------------------------------------------\n#! Site Configs\n#！ @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;configuration.html\n#! ---------------------------------------------------------------\nsite:\n  # 博客子标题，页面主标题后面会跟随这个标题内容。\n  subtitle: Fan&#39;s Blog\n  author: 凡\n  # 博客子名字，会在 header 的 logo 下方显示\n  nick: Fan\n  description:\n  link: &#39;&#x2F;&#39;\n  language: cn\n  # 开启博客的多语言支持\n  multi_language: true\n  # Logo 的图片链接 image\n  logo: https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20210313122054101.png\n  # 头像的图片链接 image\n  avatar: https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20210313122054101.png\n  # 备案信息\n  beian:\n    number: &#39;&#39;\n    link: &#39;&#39;\n  police_beian:\n    number: &#39;&#39;\n    link: &#39;&#39;\n\n#! ---------------------------------------------------------------\n#! Authors Configs\n#！ @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;authors.html\n#! ---------------------------------------------------------------\nauthors:\n  ##! example\n  # TriDiamond:\n  #   name: TriDiamond\n  #   avatar: https:&#x2F;&#x2F;up.enterdesk.com&#x2F;edpic_source&#x2F;44&#x2F;ff&#x2F;3d&#x2F;44ff3d6bd2819d524facfcc33205d4cd.jpg\n  #   link: https:&#x2F;&#x2F;github.com&#x2F;TriDiamond\n  #   description: &#39;Think like an artist, code like an artisan.&#39;\n  #   socials:\n  #     github: https:&#x2F;&#x2F;tridiamond.tech\n\n#! ---------------------------------------------------------------\n#! Menu Configs\n#！ @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;menu.html\n#! ---------------------------------------------------------------\nmenu:\n  About: false\n  about: \n    name: &#39;About&#39;\n    i18n:\n      cn: &#39;关于&#39;\n      en: &#39;About&#39;\n    path: &#39;&#x2F;page&#x2F;about&#39;\n  Tags: true\n  Archives: true\n  # 自定义菜单, 外部链接\n  message-board:\n    name: &#39;留言板&#39;\n    i18n:\n      cn: &#39;留言板&#39;\n      en: &#39;Message Board&#39;\n    path: &#39;&#x2F;page&#x2F;message-board&#39;\n  # 多级 projects 菜单配置\n  projects:\n    name: &#39;链接&#39;\n    i18n:\n      cn: &#39;链接&#39;\n      en: &#39;Link&#39;\n    children:\n      Fan:\n        name: &#39;凡&#39;\n        i18n: \n          cn: &#39;凡&#39;\n          en: &#39;Fan&#39;\n        path: &#39;https:&#x2F;&#x2F;github.com&#x2F;Fan223&#x2F;Fan223.github.io&#39;\n      Email:\n        name: &#39;邮件&#39;\n        i18n:\n          cn: &#39;邮件&#39;\n          en: &#39;Mail Me&#39;\n        path: &#39;mailto:fanj.zh@foxmail&#39;\n  my:\n    name: &#39;我的&#39;\n    il8n:\n      cn: &#39;我的&#39;\n      en: &#39;My&#39;\n    path: &#39;&#x2F;page&#x2F;my&#39;\n\n#! ---------------------------------------------------------------\n#! Theme Config\n#! @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;theme.html\n#! ---------------------------------------------------------------\ntheme:\n  # 深色模式 true、false、auto\n  dark_mode: true\n  # 头像形状\n  profile_shape: diamond # support &#96;circle&#96;, &#96;diamond&#96;, &#96;rounded&#96;\n  # 推荐文章\n  feature: true\n  # 渐变颜色\n  gradient:\n    color_1: &#39;#24c6dc&#39;\n    color_2: &#39;#5433ff&#39;\n    color_3: &#39;#ff0099&#39;\n\n#! ---------------------------------------------------------------\n#! Social Configs\n#! @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;social.html\n#! ---------------------------------------------------------------\n\n# 社交链接\nsocials:\n  github: &#39;https:&#x2F;&#x2F;github.com&#x2F;Fan223&#39;\n  twitter: &#39;&#39;\n  stackoverflow: &#39;&#39;\n  weibo: &#39;https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7318914058&#39;\n  zhihu: &#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tridiamond&#39;\n  csdn: &#39;https:&#x2F;&#x2F;blog.csdn.net&#x2F;ACE_U_005A&#39;\n  juejin: &#39;https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;1873223546578589&#39;\n  # 自定义社交连接\n  customs:\n  ##! Example:\n  ##! --- Using SVG\n  bilibili:\n    icon: http:&#x2F;&#x2F;localhost:4000&#x2F;svg&#x2F;bilibili.svg\n    link: https:&#x2F;&#x2F;live.bilibili.com&#x2F;22619211\n\n  ##! --- Using IconFont\n  baidu:\n    icon: iconfont icon-baidu\n    link: https:&#x2F;&#x2F;live.bilibili.com&#x2F;22619211\n\n  ##! --- Using FontAwesome\n  book:\n    icon: far fa-address-book\n    link: https:&#x2F;&#x2F;live.bilibili.com&#x2F;22619211\n\n#! ---------------------------------------------------------------\n#! Site Meta Configs\n#! @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;theme.html\n#! ---------------------------------------------------------------\n\n# 网页META\nsite_meta:\n  cdn: cn\n  favicon:\n  # 对站点的描述\n  description: &#39;Fan&#39;\n  # 网站的关键词\n  keywords: &#39;Java, Blog&#39;\n  # 网站作者\n  author: &#39;凡&#39;\n\n#! ---------------------------------------------------------------\n#! Plugins\n#! @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;plugins.html\n#! ---------------------------------------------------------------\n\n# For local development only!\ngitalk:\n  enable: true\n  autoExpand: true\n  clientID: &#39;2a249d7d9c6b2c8634ef&#39;\n  clientSecret: &#39;31b0f1d47f77f962ed6d5cf1be6aede282293f2d&#39;\n  repo: &#39;blogtalk&#39;\n  owner: &#39;Fan223&#39;\n  admin: [&#39;Fan223&#39;]\n  id: uid\n  language: cn\n  distractionFreeMode: true\n  recentComment: true\n  proxy: &#39;&#39;\n\n# Valine comment plugin (recommended!)\n# see https:&#x2F;&#x2F;valine.js.org&#x2F;quickstart.html\nvaline:\n  enable: false\n  app_id:\n  app_key:\n  avatar: &#39;&#39;\n  placeholder: Leave your thoughts behind~\n  visitor: true\n  lang: en\n  avatarForce: false\n  meta: [&#39;nick&#39;, &#39;mail&#39;]\n  requiredFields: []\n  admin: &#39;TriDiamond&#39;\n  recentComment: true\n\n# Enable Busuanzi statistic plugin\n# see http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;\nbusuanzi:\n  enable: true\n\ncopy_protection:\n  enable: false\n  author:\n    cn: 凡\n    en: Fan\n  link:\n    cn: 本文来自于\n    en: Article is from\n  license:\n    cn: 博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议\n    en: This content is shared under the CC BY-NC-SA 4.0 protocol (Non-Commercial)\n\n#! ---------------------------------------------------------------\n#! Enable Aurora Bot Dia\n#! @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;site-meta.html#custom-meta\n#! ---------------------------------------------------------------\n# 开启 Aurora 机器人 Dia\naurora_bot:\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 设置为 true，你可爱的机器人就会启动。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  enable: false\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 该机器人支持两种语言\n  # -- en: 英语\n  # -- cn: 中文\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  locale: en\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  # 目前只支持使用 Dia，将来会支持 live2d。\n  # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  bot_type: dia\n\n  # 这个技巧是用来对用户交互做出反应的\n  tips:\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 这些是 Dia 每30秒会说的随机消息。\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    messages:\n      - 你好，我是 &lt;span&gt;Dia&lt;&#x2F;span&gt;，好高兴遇见你～\n      - 好久不见，日子过得好快呢……\n      - &#39;&lt;span&gt;大坏蛋！&lt;&#x2F;span&gt;你都多久没理人家了呀，嘤嘤嘤～&#39;\n      - 嗨～快来逗我玩吧！\n      - 拿小拳拳锤你胸口！\n      - 学习使我们快乐，快乐使我们更想学习～\n      - 你知道吗？你可以&lt;span&gt;点击我&lt;&#x2F;span&gt;返回页面顶部哦！～\n      # 这是一个特殊的函数，它将触发 quotes API\n      # 和 Dia 会说出每日引用的信息。\n      - showQuote\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 将在用户打开浏览器控制台时触发。\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    console: 哈哈，你打开了控制台，是想要看看我的小秘密吗？\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 当用户从你的博客上复制内容时触发。\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    copy: 你都复制了些什么呀，转载要记得加上出处哦！\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 这将在用户返回窗口时触发。\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    visibility_change: 老朋友，你怎么才回来呀～\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 欢迎留言，号码是一天中的时间。\n    # -----------------------------------\n    # eg: 24 &#x3D; 00:00 也就是午夜\n    # eg: 17-19 &#x3D; 在下午 5 点到 7 点之间\n    # -----------------------------------\n    # 在一天的这段时间里，Dia 会向你的读者问好\n    # 与相应的消息。\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    welcome:\n      &#39;24&#39;: 你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？\n      &#39;5_7&#39;: 早上好！一日之计在于晨，美好的一天就要开始了。\n      &#39;7_11&#39;: 上午好！工作顺利嘛，不要久坐，多起来走动走动哦！\n      &#39;11_13&#39;: 中午了，工作了一个上午，现在是午餐时间！\n      &#39;13_17&#39;: 午后很容易犯困呢，今天的运动目标完成了吗？\n      &#39;17_19&#39;: 傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红～\n      &#39;19_21&#39;: 晚上好，今天过得怎么样？\n      &#39;21_23&#39;:\n        - 已经这么晚了呀，早点休息吧，晚安～\n        - 深夜时要爱护眼睛呀！\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 当用户来自搜索引擎时使用。\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    referrer:\n      # 用户来自你自己的网站。\n      self: 欢迎来到&lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt;\n      # 用户来自百度搜索引擎。\n      baidu: Hello！来自 百度搜索 的朋友&lt;br&gt;你是搜索 &lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt; 找到的我吗？\n      # 用户来自360搜索引擎。\n      so: Hello！来自 360搜索 的朋友&lt;br&gt;你是搜索 &lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt; 找到的我吗？\n      # 用户来自谷歌搜索引擎。\n      google: Hello！来自 谷歌搜索 的朋友&lt;br&gt;欢迎阅读&lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt;\n      # 用户来自另一个网站。\n      site: Hello！来自 &lt;span&gt;[PLACEHOLDER]&lt;&#x2F;span&gt; 的朋友\n      # 任何其他来源。\n      other: 感谢您阅读： &lt;span&gt;「[PLACEHOLDER]」&lt;&#x2F;span&gt;\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 当你的&#39;鼠标悬停&#39;到特定的HTML标签，Dia将\n    # 给用户留言帮助他们解决问题。\n    # ------------------------------------------------------\n    # selector: 标签选择器(你可以使用任何css选择器)\n    # text: 这是Dia将要传达的信息。(如果你想要的\n    #       Dia从一组信息中随机说出一个，设置它\n    #       数组，否则只是纯文本)\n    #  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    mouseover:\n      # 悬浮在 Dia 上\n      - selector: &#39;#Aurora-Dia&#39;\n        text:\n          - 哇啊啊啊啊啊啊... &lt;span&gt;你想干嘛&lt;&#x2F;span&gt;? O.O\n          - 请您轻一点，我是&lt;span&gt;很昂贵&lt;&#x2F;span&gt;的机器人哦! O.O\n          - &#39;&lt;span&gt;领导，我在呢!&lt;&#x2F;span&gt; 我有什么可以帮到你呢? O.O&#39;\n      # 悬浮在 Home 菜单\n      - selector: &quot;[data-menu&#x3D;&#39;Home&#39;]&quot;\n        text:\n          - 点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\n          - 点它就可以回到首页啦！\n          - 回首页看看吧。\n      # 悬浮在 About 菜单\n      - selector: &quot;[data-menu&#x3D;&#39;About&#39;]&quot;\n        text:\n          - 你想知道我家主人是谁吗？\n          - 这里有一些关于我家主人的秘密哦，要不要看看呢？\n          - 发现主人出没地点！\n      # 悬浮在 Archives 菜单\n      - selector: &quot;[data-menu&#x3D;&#39;Archives&#39;]&quot;\n        text:\n          - 这里存储了主人的所有作品哦！\n          - 想看看主人的图书馆吗？\n      # 悬浮在 Tags 菜单\n      - selector: &quot;[data-menu&#x3D;&#39;Tags&#39;]&quot;\n        text:\n          - 点击就可以看文章的标签啦！\n          - 使用标签可以更好的分类你的文章哦～\n      # 悬浮在 language 菜单\n      - selector: &quot;[data-dia&#x3D;&#39;language&#39;]&quot;\n        text: 主人的博客支持多种语言。\n      # 悬浮在黑白切换按钮上\n      - selector: &quot;[data-dia&#x3D;&#39;light-switch&#39;]&quot;\n        text: 您可以点击这里切换黑白模式哦！\n      # 悬浮在作者简介上\n      - selector: &quot;[data-dia&#x3D;&#39;author&#39;]&quot;\n        text:\n          - 这是我主人的简介。\n          - 点击其中任何一个链接都可以传送到我主人的其他世界。\n      # 悬浮在作跳转评论按钮上\n      - selector: &quot;[data-dia&#x3D;&#39;jump-to-comment&#39;]&quot;\n        text:\n          - 你想看看评论吗?\n          - 点击这里可以帮助你直接跳转到评论部分。\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 当你的&#39;鼠标点击&#39;为特定的HTML标签，Dia将\n    # 给用户留言帮助他们解决问题。\n    # ------------------------------------------------------\n    # 属性与&#39; moveover &#39;事件相同\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    click:\n      # 鼠标点击搜索按钮\n      - selector: &quot;[data-dia&#x3D;&#39;search&#39;]&quot;\n        text:\n          - 没有看到你想要的文章，那么就输入你想搜索的关键词吧～\n          - 可以使用 ctrl&#x2F;cmd + k 快捷键打开搜索哦～\n      # 鼠标点击文章标题\n      - selector: &quot;[data-dia&#x3D;&#39;article-link&#39;]&quot;\n        text:\n          - 希望你会喜欢这篇文章：&lt;span&gt;「&#123;text&#125;」&lt;&#x2F;span&gt;.\n          - 您的选择真的不错哦！好好享受这篇文章吧～\n          - 希望您能从 &lt;span&gt;「&#123;text&#125;」&lt;&#x2F;span&gt;这篇文章中学到点东西。\n      # 鼠标点击跳转评论输入框（Gitalk）\n      - selector: &#39;.gt-header-textarea&#39;\n        text:\n          - 要吐槽些什么呢？\n          - 一定要认真填写喵～\n          - 有什么想说的吗？\n          - 如果觉得文章不错的话，就给博主留个言吧～\n      # 鼠标点击跳转评论输入框（Valine）\n      - selector: &#39;.veditor&#39;\n        text:\n          - 要吐槽些什么呢？\n          - 一定要认真填写喵～\n          - 有什么想说的吗？\n          - 如果觉得文章不错的话，就给博主留个言吧～\n\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    # 在特定的日期，Dia会向你的读者问候。\n    # ------------------------------------------------------\n    # date: 特别活动的日期(格式:月&#x2F;日或月&#x2F;日-月&#x2F;日)\n    # text:\n    # ---只使用一个简单的字符串。\n    # -——消息的随机集合，使用数组配置格式。\n    # &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    events:\n      - date: 01&#x2F;01\n        text: &#39;&lt;span&gt;元旦&lt;&#x2F;span&gt;了呢，新的一年又开始了，今年是&#123;year&#125;年～&#39;\n      - date: 02&#x2F;14\n        text: 又是一年&lt;span&gt;情人节&lt;&#x2F;span&gt;，&#123;year&#125;年找到对象了嘛～\n      - date: 03&#x2F;08\n        text: 今天是&lt;span&gt;国际妇女节&lt;&#x2F;span&gt;！\n      - date: 03&#x2F;12\n        text: 今天是&lt;span&gt;植树节&lt;&#x2F;span&gt;，要保护环境呀！\n      - date: 04&#x2F;01\n        text: 悄悄告诉你一个秘密～&lt;span&gt;今天是愚人节，不要被骗了哦～&lt;&#x2F;span&gt;\n      - date: 05&#x2F;01\n        text: 今天是&lt;span&gt;五一劳动节&lt;&#x2F;span&gt;，计划好假期去哪里了吗～\n      - date: 06&#x2F;01\n        text: &#39;&lt;span&gt;儿童节&lt;&#x2F;span&gt;了呢，快活的时光总是短暂，要是永远长不大该多好啊…&#39;\n      - date: &#39;09&#x2F;03&#39;\n        text: &#39;&lt;span&gt;中国人民抗日战争胜利纪念日&lt;&#x2F;span&gt;，铭记历史、缅怀先烈、珍爱和平、开创未来。&#39;\n      - date: &#39;09&#x2F;10&#39;\n        text: &#39;&lt;span&gt;教师节&lt;&#x2F;span&gt;，在学校要给老师问声好呀～&#39;\n      - date: 10&#x2F;01\n        text: &#39;&lt;span&gt;国庆节&lt;&#x2F;span&gt;到了，为祖国母亲庆生！&#39;\n      - date: 11&#x2F;05-11&#x2F;12\n        text: 今年的&lt;span&gt;双十一&lt;&#x2F;span&gt;是和谁一起过的呢～\n      - date: 12&#x2F;20-12&#x2F;31\n        text: 这几天是&lt;span&gt;圣诞节&lt;&#x2F;span&gt;，主人肯定又去剁手买买买了～\n\n#! ---------------------------------------------------------------\n#! Injections\n#! @docs https:&#x2F;&#x2F;aurora.tridiamond.tech&#x2F;guide&#x2F;site-meta.html#custom-meta\n#! ---------------------------------------------------------------\n\n# 自定义 Meta, 自定义 Script 或 CSS 链接添加到主题中\ninjects:\n  scripts:\n    - &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Fan223&#x2F;live2d-widget@latest&#x2F;autoload.js&quot;&gt;&lt;&#x2F;script&gt;\n  css:\n    - &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;font-awesome&#x2F;css&#x2F;font-awesome.min.css&quot;&gt;\n\n然后执行 hexo clean &amp; hexo d 即可部署到 GitHub 上，然后通过地址访问\n","slug":"BlogRepository/其他实践/使用 GitHub Pages 和 Hexo 以及 Aurora 主题搭建静态个人博客","date":"2022-03-13T10:12:13.000Z","categories_index":"其他实践","tags_index":"Hexo,GitHub Pages","author_index":"凡"},{"id":"fe5ae23beccc6bfdd8c3b06280c3eb7c","title":"Windows 和 Linux 查看和关闭端口常用命令","content":"1. Windows 常用命令\n查看系统当前所有的端口使用情况netstat -ano\n查看端口被哪个应用占用netstat -ano|findstr &quot;端口号&quot;\n查看端口信息tasklist|findstr &quot;端口号&quot;\n关闭端口taskkill &#x2F;pid &quot;端口号&quot; -t -f\n\n2. Linux 常用命令Linux系统查看端口常用命令：lsof 和 netstat\n2.1 lsoflsof （list open files）是一个显示系统当前打开文件的工具。 Linux系统的应用程序都会有自己的文件描述符，通过文件描述符与操作系统进行交互。可用此命令进行系统监控、网络信息查看等\n\n列举当前所有端口连接信息，输出信息列表lsof -i\n\n\n查看 TCP 端口情况查看所有 TCP 端口\nlsof -i tcp\n查看指定 TCP 端口情况\nlsof -i tcp:&quot;指定端口号&quot;\nlsof -i tcp:7001\n查看 UDP 端口情况lsof -i udp\n\n用法与查看 TCP 端口同\n按协议类型查lsof -i 4\nlsof -i 6\n查看指定端口情况lsof -i :22\n按用户查查看 nexus 用户\nlsof -a -u nexus -i\n\n2.2 netstatnetstat 命令用于显示网络状态， 命令参数如下：\n\n\n\n\n\n\n\n\n\n\n-t ： 指明显示TCP端口\n-u ：  指明显示UDP端口\n-l ： 仅显示监听套接字（所谓套接字就是使应用程序能够读写与收发通讯协议（protocol）与资料的程序)\n-p ： 显示进程标识符和程序名称，每一个套接字&#x2F;端口都属于一个程序。\n-n ： 不进行DNS轮询，显示 IP(可以加速操作)\n\n\n查看某一端口netstat -anp|grep &quot;端口号&quot;\nnetstat -anp|grep 3306\n查看 TCP 或 UDP 端口，即加 t 或 unetstat -ntlp\nnetstat -nulp\n查看某一端口的连接数量netstat -pnt|grep :3306 |wc\n\n可根据情况选择对应的命令参数\n2.3 psLinux中的 ps 命令是 Process Status 的缩写。ps 命令用来列出系统中当前运行的那些进程。ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用 top 命令。常用参数如下：\n\n\n\n\n\n\n\n\n\n\na ： 显示所有进程\n-a ： 显示同一终端下的所有程序\n-A ：  显示所有进程\nc ： 显示进程的真实名称\n-N ： 反向选择\n-e ： 等于 “-A”\ne ：  显示环境变量\nf ：  显示程序间的关系\n-H ： 显示树状结构\nr ：  显示当前终端的进程\nT ：  显示当前终端的所有程序\nu ：  指定用户的所有进程\n\n\n查看一个服务有几个端口ps -ef|grep redis\n列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示ps c\n显示现行终端机下的所有程序，包括其他用户的程序ps a\n显示所有程序ps -A\n\n可根据情况选择对应的命令参数\n2.4 杀死进程kill [参数] [进程号]\nkill -9 4394\n","slug":"BlogRepository/开发实践/Windows 和 Linux 查看和关闭端口常用命令","date":"2022-03-11T01:35:48.000Z","categories_index":"开发实践","tags_index":"Windows,Linux","author_index":"凡"},{"id":"cb51a2133d61232dd118d1d3d5ca5ed4","title":"Node.js 多版本安装及 NPM 镜像配置","content":"1. 安装多版本 Node.js1.1 下载首先去官网下载需要的 Node.js 版本，点击其他下载可以下载其他版本的 Node.js\n1.2 安装下载完成后先安装低版本的 Node.js，点击 Next接受，Next可以按需修改安装路径，NextNextNext最后安装完成。会自动添加环境变量，可以打开环境变量查看，假如没有可以手动添加，这里我已经添加了两个通过命令行输入 node -v 可以查看 Node.js 版本安装完后更改 Node.js 的安装目录名字，然后再进行上面的操作安装另一个版本，安装完成后再将名字改回来\n1.3 更换版本通过命令 where node 可以查看本机中所有 Node.js 的版本更换版本时，只需要在环境变量中将需要的 Node.js 版本移到其他版本前面。\n2. 更换 NPM 镜像Node.js 自带了一个包管理器 NPM，但是默认是去国外的服务器地址下载依赖，速度可能会很慢，可以替换为镜像地址，提高下载速度\n打开命令行，输入命令，更换为淘宝镜像\nnpm config set registry https:&#x2F;&#x2F;registry.npmmirror.com\n\n然后重新打开命令行，可以通过命令查看镜像是否更改\nnpm config get registry\n\n\n3. 安装 CNPM虽然更改了镜像，但 NPM 访问的还是国外服务器，只是代理到了镜像地址。阿里巴巴的淘宝团队把 NPM 官网的插件都同步到了在中国的服务器，使用 CNPM 可以从国内服务器下载（一般来说更换镜像地址后使用即可，无需安装 CNPM）\n3.1 安装命令npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npmmirror.com\n\n安装完成后，可以通过命令查看版本\ncnpm -v\n\n\n3.2 卸载命令npm uninstall -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npmmirror.com\n\n\n","slug":"BlogRepository/开发工具及环境/Node.js 多版本安装及 NPM 镜像配置","date":"2022-03-10T12:23:09.000Z","categories_index":"开发工具及环境","tags_index":"NPM,Node.js,前端","author_index":"凡"},{"id":"6ce853e2be25e958aefcb6cbbd6efe7a","title":"OSI七层模型、TCP/IP四层和五层模型的各层作用及对应协议","content":"1. 各模型分层对应关系及协议\n2. 各层作用2.1 物理层主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特\n2.2 数据链路层将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。数据链路层又分为2个子层：\n\n逻辑链路控制子层（LLC）：处理 CSMA&#x2F;CD 算法、数据出错校验、成帧等\n媒体访问控制子层（MAC）：定义了一些字段使上层协议能共享数据链路层，非必需\n\n2.3 网络层本层通过 IP 寻址来建立两个节点之间的连接，为远端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的 IP 层。这一层就是我们经常说的 IP 协议层。IP 协议是 Internet 的基础\n2.4 传输层传输层建立了主机端到端的连接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。常常把这一层数据叫做段\n\nTCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）\nUDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）\n\n2.5会话层会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）\n2.6 表示层表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取\n2.7 应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务\n","slug":"BlogRepository/计算机网络/OSI七层模型、TCP_IP四层和五层模型的各层作用及对应协议","date":"2022-03-10T11:46:56.000Z","categories_index":"计算机网络","tags_index":"TCP/IP,网络协议,网络","author_index":"凡"},{"id":"4e9d049749f532005151e72d3b86b285","title":"Dubbo总结（分布式理论 + 使用）","content":"1. 分布式基础理论1.1 什么是分布式系统？分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。分布式系统（distributed system）是建立在网络之上的软件系统\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进\n1.2 发展演变\n1.3 第一时期（单一应用架构）当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM）是关键问题：\n\n代码不具备可维护性\n容错性差\n当用户访问或某些原因发生异常，用户会直接看到异常信息，有些情况下，该错误可能会导致服务宕机\n\n\n\n\n\n\n\n\n\n\n故障容许度（Fault tolerance），也称容错，容错性，是指系统在部分组件（一个或多个）发生故障时仍能正常运作的能力\n1.3.1 第一时期后阶段解决方案：\n\n分层开发\nMVC 架构（基于Java WEB 应用的设计模式）\n服务器分离部署\n\n特点：\n\nMVC 分层开发（提高了维护性，解决了容错性问题）\n数据库和项目分离部署\n\n问题： 随着用户的访问量持续增加，单台应用服务器以及无法满足需求（高并发问题）解决方案： 集群（集群方案解决）\n1.3.2 会出现的如下问题在互联网项目下，因单个 Tomcat 默认并发量有限制。如果请求量过大，会产生如下问题：\n1.3.2.1 高并发( High Concurrency )是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。高并发相关常用的一些指标有响应时间（Response TIme )、吞吐量 (Throughput )、每秒查询率QPS ( QueryPer Second ) 、并发用户数等\n\n响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要 200ms，这个 200ms 就是系统的响应时间\n吞吐量：单位时间内处理的请求数量\nQPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显\n开发用户数：同时承载正常使用系统功能的用户数量\n\n1.3.2.2 高可用(High Availability )通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性\n(一直都能用 99.9999%)   –&gt;  docker  –&gt;  k8shttps://www.idcbest.com/idcnews/11002927.html\n1.3.2.3 高性能是指服务响应时间快，（CPU &#x2F; 处理器&#x2F;内存）特别是在高并发下响应时间不会急剧增加\n1.3.3 提高系统的并发能力提高系统并发能力的方式，方法论上主要有两种︰垂直扩展(Scale Up )与水平扩展( Scale Out )\n1.3.3.1 垂直扩展（提升单机处理能力）垂直扩展的方式又有两种：\n\n增强单机硬件性能，例如∶增加 CPU 核数如 32 核，升级更好的网卡如万兆，升级更好的硬盘如 SSD，扩充硬盘容量如 2T，扩充系统内存如 128 G\n提升单机架构性能，例如∶使用 Cache 来减少 IO 次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间\n\n在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法\n总结∶不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足∶单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展\n1.3.3.2 水平扩展水平扩展︰只要增加服务器数量，就能线性扩充系统性能。 水平扩展对系统架构设计是有要求的，难点在于：如何在架构各层进行可水平扩展的设计\n1.3.4 集群操作集群：同一个业务，部署在多个服务器上特点： 项目采用集群（多台服务器部署）解决： 支持高并发、支持高可用问题：\n\n（集群）用户的请求该往哪里进行转发？\nSession 如何共享\n\n\n1.3.5 数据库压力变大通过 Nginx + Tomcat 集群方案，支持高并发（应用的性能进行提升访问），但是数据库的负载能力慢慢增加\n问题： 怎么减少数据库层面的访问压力？解决方案：读写分离主从数据库之间进行数据同步，Master 主要负责增删改操作，Slave 负责读（查询）操作。 MySQL 本身就支持 Master + Slave 的功能（主从复制）\n1.3.6 使用搜索引擎缓解数据库的访问压力 + 能力数据库本身对大数据量查询效率慢，对模糊查询支持不是特别优秀，像电商类网站。搜索是非常核心的功能。(即使做了数据库读写分离），很多功能也不能有效解决（分词技术），针对于该问题，有必要引入全文检索服务器功能\n目前市场上主流的搜索引擎技术：Solr、ElasticSearch\n1.3.7 引入缓存机制减轻数据库的访问压力随着访问量的持续增加（数据库的访问压力持续增大，甚至都无法满足需求），虽然做了主从复制，对于热点数据，如果每次都从数据中查询，数据库无法应对，导致无法对外提供服务\n最住解决方案:Redis\n\n读写性能非常好\n提供了丰富的数据类型\n原子性\n\n1.3.8 数据库的表进行水平 &#x2F; 垂直拆分—张表里面有1千条数据，查询的性能很高。如果有100万数据，查询的性能很慢。单个表性能做提升。(能力终归还有限的)\n1.3.8.1 垂直拆分表假设一张表里面用户表（有30个字段）\n\n\n\n\n\n\n\n\n\nid、姓名、年龄、身份证号、身高、体重、性别、手机号、家庭住址、爱好……\n热数据 &#x2F; 冷数据\n\n\n\n\n\n\n\n\n\nuser（id，姓名，身份证号，年龄，性别，手机号）user_info（id，身高，体重）\n1.3.8.2 水平拆分表按需求进行拆分（省份、时间）\n1.3.8.3 分库分表垂直拆分数据库：按照业务将表进行分类，不同的表分布到不同的数据库上水平拆分数据库：将一个表拆分到不同的数据库上采用第三方数据库中间件：Mycat、Sharding-JDBC、DRDS通过设计保证高并发、高可用。（不断对服务器进行扩容）问题：\n\n服务器价钱（忙闲不均匀问题、服务器的维护、人工成本、大量运维工程师）\n可维护性差\n可扩展性差（服务器）\n协同开发不方便（大家都去修改相同业务代码，易发生代码冲突 &#x2F; 错误问题）\n单体架构（随着业务需求的不断增加，应用代码会变得越来越多）导致服务器部署时占用的硬盘也大\n\n1.4 第二时期（垂直应用架构）当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web 框架（MVC）是关键\n1.4.1 水平拆分（横着拆）将一个大的应用拆分成多个小应用。project（controller、service、mapper、pojo……）\n问题1： 现在网站分为前台(给用户使用），后台（给管理员使用），是否需要拆成2个项目独立部署?如果需要拆的话，有一些前后台都需要公用的代码，这些代码怎么办?\n\n\n\n\n\n\n\n\n\n\nparent  pom   ———— 父工程（放所有的 pom.xml）\ncommon.jar ———— 公共库 相关工具类\npojo.jar —————— Java Bean\nmapper.jar ————– 数据持久层\nservice.jar ————— 业务逻辑层\nweb.war —————— web 访问层\nmanager.war ———— 后台管理\n\n解决问题：\n\n模块复用\n减少了服务器内容部署\n\n1.4.2 垂直拆分（竖着拆）按功能拆分将一个大的应用按功能拆分成多个互不相干的小应用。每个应用都是独立的 WEB 应用程序解决问题：\n\n维护性（如果发生需求变更，只需要调整某个应用模块即可）\n功能扩展（随着业务的不断增加，只需要创建新的WEB程序即可）\n协同开发方便(不同的团队修改不同的代码）\n部署内容大小（性能扩展），如果哪台访问量大，只需要对该服务多部署几台即可\n\n问题：\n\n客户对页面的要求会越来越高，（修改频繁）需要重新部署后台应用程序(每一个应用从头到尾都完整的)\n随着业务需求不断增加，需要很多个互不相干应用部署，这些应用之间一定会需要业务交互\n\n1.5 第三时期（分布式服务架构）\n\n\n\n\n\n\n\n\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。\n分布式：将一个业务拆分成多个子业务，部署在不用的服务器上\n问题：\n\n客户对页面的要求会越来越高，（修改频繁）需要重新部署后台应用程序(每一个应用从头到尾都完整的)答：页面 + 业务代码（前后端分离开发  &#x2F; 部署）\n随着业务需求不断增加，需要很多个互不相干应用部署，这些应用之间一定会需要业务交互\n\n分析：以前如果都在一台服务器上（模块之间通过依赖jar完成调用）。现在都是在不同的服务器上做的部署（分布式）。服务和服务之间通过进程间调用。\n解决方案： RPC &#x2F; HTTP &#x2F; HttpClient\n\n\n\n\n\n\n\n\n\nRPC ( Remote Procedure call ) -远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n架构的改变—定会带来—些新的技术和新的问题问题：\n\n分布式事务：两（二）阶段提交\n分布式锁：Redis SetNX（Zookeeper）\n分布式 Session：Redis Spring Session\n分布式日志：ELK\n\n问题：\n\n当服务越来越多，服务和服务之间的调用非常的混乱（不知道你有哪些服务）\n\n\n\n\n\n\n\n\n\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现\n\n例如∶支付管理访问量小，部署了100台服务器。物流管理访问量大，部署了50台服务器\n\n\n1.8 第四时期（流动计算架构）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键\nSOA（面向服务的架构）–&gt; 微服务架构单体应用拆分成多个互不相干的小应用，每一个小的应用称为微服务\n分布式服务治理（解决方案）中间件：Dubbo（底层是 RPC 协议） &#x2F; SpringCloud（底层是 HTTP 协议）基于访问压力实时管理集群容量，提高集群利用率\n\n\n\n\n\n\n\n\n\nSOA ( Service oriented Architecture ) “面向服务的架构”：他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用。微服务架构 &#x3D; 80%的 SOA 服务架构思想＋100% 的组件化架构思想＋80% 的领域建模思想\n以一个公司为例:有基层员工，有管理层，有老板。最初大家都听老板指挥，谁干什么谁干什么，根据需要，你可能今天干A事情，明天干B事情，后来人越来越多了，事情也越来越多了，做事情的效率越来越多，管理也很混乱，就开始做部门划分（服务化），专门部门做专门事情的，IT部门只做研发，人事部门只做招聘﹔这个时候就无法避免的发生跨部门协作（服务器调用），但是你怎么知道有这样一个部门可以做这个事情呢，就要依赖行政部门（注册中心），新成立的部门要在行政哪里做一个备案（服务注册），然后公布一下，让其他部门知道了（服务发布），大家就可以在新的工作秩序里面上班，这个时候依然是在公司的组织架构中运转\n优点：\n\n微服务对服务的拆分变的更细（复用性强），提高开发效率\n可根据需求使用最新的技术（选择新的技术）\n适用于互联网项目（迭代周期短。开发效率快)\n\n缺点：\n\n微服务过多，服务的管理（治理）成本高。\n不利于服务的部署( Docker –&gt; K8S)\n技术难点在增加（分布式事务、锁、Session、日志）\n对程序员的技术要求也高（Dubbo &#x2F; SpringCloud）\n\n2. 使用2.1 服务提供者2.1.1 POM&lt;!-- Dubbo 依赖--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- Dubbo 注解进 Nacos 的依赖--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;dubbo-registry-nacos&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.1.2 YML&#x2F;&#x2F; zookeeper\ndubbo:\n  application:\n    name: user-service-provider\n  registry:\n    address: zookeeper:&#x2F;&#x2F;127.0.0.1:2181\n  protocol:\n    name: dubbo\n    port: 20880\n\n&#x2F;&#x2F; nacos\ndubbo:\n  registry:\n    address: nacos:&#x2F;&#x2F;127.0.0.1:8848\n  protocol:\n    name: dubbo\n    port: 20880\n#  application:\n#    name: user-service-provider\nspring:\n  application:\n    name: user-service-provider # 也可以在 dubbo 里定义 application.name\n\n2.1.3 实现类import org.apache.dubbo.config.annotation.DubboService;\n\n@DubboService\npublic class UserServiceImpl implements UserService &#123;\n    @Override\n    public User getUser() &#123;\n        User user &#x3D; new User(1, &quot;七七&quot;);\n        return user;\n    &#125;\n&#125;\n\n2.1.4 启动类import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;\n\n@SpringBootApplication\n@EnableDubbo\npublic class UserServiceProviderApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(UserServiceProviderApplication.class, args);\n    &#125;\n&#125;\n\n2.2 服务消费者2.2.1 POM&lt;!-- Dubbo 依赖 --&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;3.0.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.2.2 YMLspring:\n  application:\n    name: user-service-consumer\n\n2.2.3 调用&#x2F;&#x2F; 通过 @DubboReference 注入，url 为服务提供者的地址和端口\n@Service\npublic class MeetingServiceImpl implements MeetingService &#123;\n\n    @DubboReference(url &#x3D; &quot;dubbo:&#x2F;&#x2F;127.0.0.1:20880&quot;)\n    private UserService userService;\n\n    @Override\n    public Meeting getMeeting() &#123;\n        User user &#x3D; userService.getUser(); &#x2F;&#x2F; 调用方法\n        Meeting meeting &#x3D; new Meeting(11, &quot;会议&quot;,&quot;Dubbo&quot;,user);\n        return meeting;\n    &#125;\n&#125;\n","slug":"BlogRepository/开发技术及框架/Dubbo总结（分布式理论 + 使用）","date":"2022-03-08T16:24:40.000Z","categories_index":"开发技术及框架","tags_index":"Dubbo,架构,分布式","author_index":"凡"},{"id":"7478131d527adbde00e55d0f806e6ef1","title":"RedisTemplate常用方法总结（参考官方文档2.6.2）","content":"1. 简介RedisTemplate 是 Spring Data Redis 提供给用户的最高级的抽象客户端，用户可直接通过 RedisTemplate进行多种操作\n1.1 类继承关系public class RedisTemplate&lt;K, V&gt; extends RedisAccessor implements RedisOperations&lt;K, V&gt;, BeanClassLoaderAware &#123;\n&#125;\n\n\nRedisAccessor：Base class for RedisTemplate defining common properties. Not intended to be used directly.RedisTemplate 定义通用属性的基类。不打算直接使用\nRedisOperations：Interface that specified a basic set of Redis operations, implemented by RedisTemplate. Not often used but a useful option for extensibility and testability (as it can be easily mocked or stubbed).指定一组基本 Redis 操作的接口，由 RedisTemplate 实现。不经常使用，但对于可扩展性和可测试性来说是一个有用的选项（因为它可以很容易地被模拟或存根）\nBeanClassLoaderAware：Callback that allows a bean to be aware of the bean class loader; that is, the class loader used by the present bean factory to load bean classes. This is mainly intended to be implemented by framework classes which have to pick up application classes by name despite themselves potentially being loaded from a shared class loader.允许 bean 知道 bean 类加载器的回调；也就是当前bean工厂用来加载bean类的类加载器。这主要是由框架类实现的，这些框架类必须按名称选择应用程序类，尽管它们可能是从共享类加载器加载的\n\n1.2 方法&#x2F;&#x2F; 配置默认序列化与反序列化工具类\n1.afterPropertiesSet\n&#x2F;&#x2F; 根据参数执行相关operation操作，例如，事务\n2.execute\n&#x2F;&#x2F; 执行pipelining流水线相关操作\n3.executePipelined\n&#x2F;&#x2F; 执行指定connection连接的相关操作\n4.executeWithStickyConnection\n&#x2F;&#x2F; 执行session内的execute方法\n5.executeSession\n&#x2F;&#x2F; 创建RedisConnection代理类\n6.createRedisConnectionProxy\n&#x2F;&#x2F; connection连接的预处理\n7.preProcessConnection\n&#x2F;&#x2F; 结果的后处理，默认什么都不做\n8.postProcessResult\n&#x2F;&#x2F; 是否向RedisCallback暴露本地连接\n9.isExposeConnection\n&#x2F;&#x2F; 设置是否向RedisCallback暴露本地连接\n10.setExposeConnection\n&#x2F;&#x2F; 12到26都是设置和获取相关序列化工具类\n11.isEnableDefaultSerializer\n12.setEnableDefaultSerializer\n13.getDefaultSerializer\n14.setDefaultSerializer\n15.setKeySerializer\n16.getKeySerializer\n17.setValueSerializer\n18.getValueSerializer\n19.getHashKeySerializer\n20.setHashKeySerializer\n21.getHashValueSerializer\n22.setHashValueSerializer\n23.getStringSerializer\n24.setStringSerializer\n25.setScriptExecutor\n&#x2F;&#x2F; 27到34为私有方法，不对外提供使用\n26.rawKey\n27.rawString\n28.rawValue\n29.rawKeys\n30.deserializeKey\n31.deserializeMixedResults\n32.deserializeSet\n33.convertTupleValues\n&#x2F;&#x2F; 执行事务\n34.exec\n35.execRaw\n&#x2F;&#x2F; 删除操作\n36.delete\n&#x2F;&#x2F; 接触链接\n37.unlink\n&#x2F;&#x2F; 查看是否含有指定key\n38.hasKey\n39.countExistingKeys\n&#x2F;&#x2F; 设置过期时间\n40.expire\n41.expireAt\n&#x2F;&#x2F; 转换成字节流并向channel发送message\n42.convertAndSend\n&#x2F;&#x2F; 获取过期时间\n43.getExpire\n&#x2F;&#x2F; 根据传入的正则表达式返回所有的key\n44.keys\n&#x2F;&#x2F; 取消指定key的过期时间\n45.persist\n&#x2F;&#x2F; 移动指定的key和index到数据库中\n46.move\n&#x2F;&#x2F; 从键空间随机获取一个key\n47.randomKey\n&#x2F;&#x2F; 将指定key改成目标key\n48.rename\n&#x2F;&#x2F; key不存在时，将指定key改成目标key\n49.renameIfAbsent\n&#x2F;&#x2F; 设置存储在指定key的类型\n50.type\n&#x2F;&#x2F; 检索存储在key的值的序列化版本\n51.dump\n&#x2F;&#x2F; 执行Redis的restore的命令\n52.restore\n&#x2F;&#x2F; 标记事务阻塞的开始\n53.multi\n&#x2F;&#x2F; 丢弃所有在multi之后发出的命令\n54.discard\n&#x2F;&#x2F; 观察指定key在事务处理开始即multi之后的修改情况\n55.watch\n&#x2F;&#x2F; 刷新先前观察的所有key\n56.unwatch\n&#x2F;&#x2F; 为key元素排序\n57.sort\n&#x2F;&#x2F; 关闭客户端连接\n58.killClient\n&#x2F;&#x2F; 请求连接客户端的相关信息和统计数据\n59.getClientList\n&#x2F;&#x2F; 更改复制配置到新的master\n60.slaveOf\n&#x2F;&#x2F; 将本机更改为master\n61.slaveOfNoOne\n&#x2F;&#x2F; 64到79都是获取相对应的操作\n62.opsForCluster\n63.opsForGeo\n64.boundGeoOps\n65.boundHashOps\n66.opsForHash\n67.opsForHyperLogLog\n68.opsForList\n69.boundListOps\n70.boundSetOps\n71.opsForSet\n72.opsForStream\n73.boundStreamOps\n74.boundValueOps\n75.opsForValue\n76.boundZSetOps\n77.opsForZSet\n&#x2F;&#x2F; 设置是否支持事务\n78.setEnableTransactionSupport\n&#x2F;&#x2F; 设置bean的类加载器\n79.setBeanClassLoader\n\n1.3 功能介绍spring-data-redis 提供了如下功能：\n\n连接池自动管理，提供了一个高度封装的“RedisTemplate”类\n\n进行了归类封装,将同一类型操作封装为operation接口\n\nValueOperations：简单K-V操作\nSetOperations：set类型数据操作\nZSetOperations：zset类型数据操作\nHashOperations：针对map类型的数据操作\nListOperations：针对list类型的数据操作\n\n\n提供了对 key 的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即 BoundKeyOperations\n\nBoundValueOperations\nBoundSetOperations\nBoundListOperations\nBoundSetOperations\nBoundHashOperations\n\n\n将事务操作封装，有容器控制\n\n针对数据的“序列化&#x2F;反序列化”，提供了多种可选择策略(RedisSerializer)\n\nJdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream&#x2F;ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略\nStringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“newString(bytes,charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略\nJacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂\nOxmSerializer：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。【需要spring-oxm模块的支持】\n\n如果你的数据需要被第三方工具解析，那么数据应该使用 StringRedisSerializer 而不是 JdkSerializationRedisSerializer\n\n\n2. RedisTemplate 顶层方法\n确定给定 key 是否存在，有的话就返回 true，没有就返回 falseredisTemplate.hasKey(K key)\n删除给定的 keyredisTemplate.delete(K key)\n删除给定 key 的集合redisTemplate.delete(Collection&lt;K&gt; keys)\n执行 Redis 转储命令并返回结果，把key值序列化成byte[]类型redisTemplate.dump(K key)\n对传入的key值设置过期时间、将给定 key 的过期时间设置为日期时间戳redisTemplate.expire(K key, long timeout, TimeUnit unit)\nredisTemplate.expireAt(K key, Date date)\n查找与给定模式匹配的所有 key ，返回的是一个没有重复的Set类型redisTemplate.keys(K pattern)\n将 oldKey 重命名为 newKey。redisTemplate.rename(K oldKey, K newKey)\n获取key值的类型redisTemplate.\ttype(K key)\n仅当 newKey 不存在时，才将密钥 oldKey 重命名为 newKey。redisTemplate.renameIfAbsent(K oldKey, K newKey)\n随机从redis中获取一个keyredisTemplate.randomKey()\n获取当前key的剩下的过期时间redisTemplate.getExpire(K key)\n获取剩余的过期时间，同时设置时间单位redisTemplate.\tgetExpire(K key, TimeUnit timeUnit)\n删除 key 的过期时间redisTemplate.\tpersist(K key)\n将给定的 key 移动到带有索引的数据库redisTemplate.\tmove(K key, int dbIndex)\n\n3. RedisTemplate.opsForValue() 方法\n设置 key 跟 value 的值redisTemplate.opsForValue().set(K key, V value)\n获取 key 的值redisTemplate.opsForValue().get(Object key)\n设置key跟value的值，同时设置过期时间redisTemplate.opsForValue().set(K key, V value, Duration timeout)\n在 start 和 end 之间获取键值的子字符串redisTemplate.opsForValue().get(K key, long start, long end)\n设置 key 的值并返回其旧值redisTemplate.opsForValue().getAndSet(K key, V value)\n获取多个 keyredisTemplate.opsForValue().multiGet(Collection&lt;K&gt; keys)\n获取原来的key的值后在后面新增上新的字符串redisTemplate.opsForValue().append(K key, String value)\n增量方式增加double值redisTemplate.opsForValue().increment(K key, double increment)\n通过increment(K key, long delta)方法以增量方式存储long值（正值则自增，负值则自减）redisTemplate.opsForValue().increment(K key, long increment)\n仅当提供的 key 不存在时，才使用集合中提供的键值对将多个 key 设置为多个值。redisTemplate.opsForValue().multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map)\n使用集合中提供的键值对将多个 key 设置为多个值。Map map &#x3D; new HashMap(); map.put(&quot;1&quot;,&quot;1&quot;); map.put(&quot;2&quot;,&quot;2&quot;); \nmap.put(&quot;3&quot;,&quot;3&quot;); \nredisTemplate.opsForValue().multiSet(Map&lt;? extends K,? extends V&gt; map)\n获取指定key的字符串的长度redisTemplate.opsForValue().size(K key)\n用给定值覆盖从指定偏移量开始的 key 的部分。redisTemplate.opsForValue().set(K key, V value, long offset)\n如果 key 不存在，则设置 key 以保存字符串值，存在返回false，否则返回trueredisTemplate.opsForValue().setIfAbsent(key, value)\n重新设置key的值并加入过期时间redisTemplate.opsForValue().set(key, value, timeout, unit)\n将二进制第offset位值变为valueredisTemplate.opsForValue().setBit(K key, long offset, boolean value)\n对key所储存的字符串值，获取指定偏移量上的位(bit)redisTemplate.opsForValue().getBit(K key, long offset)\n\n4. RedisTemplate.opsForHash() 方法\n从 key 处的 hash 中获取给定 hashKey 的值，即 key field（hashKey） valueredisTemplate.opsForHash().get(H key, Object hashKey)\n获取存储在 key 的整个 hash，即获取所有值redisTemplate.opsForHash().entries(H key)\n设置hash hashKey 的值redisTemplate.opsForHash().put(H key, HK hashKey, HV value)\n使用 m 中提供的数据将多个 hash 字段设置为多个值，即使用 map 进行赋值redisTemplate.opsForHash().putAll(H key, Map&lt;? extends HK,? extends HV&gt; m)\n仅当 hashKey 不存在时才设置 hash hashKey 的值。redisTemplate.opsForHash().putIfAbsent(H key, HK hashKey, HV value)\n删除给定的hash hashKeysredisTemplate.opsForHash().delete(H key, Object... hashKeys)\n确定给定的hash hashKey 是否存在redisTemplate.opsForHash().hasKey(H key, Object hashKey)\n通过给定的增量增加hash hashKey 的值redisTemplate.opsForHash().increment(H key, HK hashKey, double increment)\nredisTemplate.opsForHash().increment(H key, HK hashKey, long increment)\n在 key 处获取 hash 的 hashKey 集（字段）redisTemplate.opsForHash().keys(H key)\n获取 key 的 hash 大小。redisTemplate.opsForHash().size(H key)\n在 key 处获取 hash 的值redisTemplate.opsForHash().values(H key)\n查看匹配的键值对redisTemplate.opsForHash().scan(H key, ScanOptions options)\n\n5. RedisTemplate.opsForList() 方法\n从 key 的 list 中获取索引处的元素redisTemplate.opsForList().index(K key, long index)\n从 key 的 list 中获取 start 和 end 之间的元素redisTemplate.opsForList().range(K key, long start, long end)\n为 key 添加值redisTemplate.opsForList().leftPush(K key, V value)\n将值添加到 key 中redisTemplate.opsForList().leftPushAll(K key, Collection&lt;V&gt; values)\n仅当 list 存在时，才将值添加到 key 中redisTemplate.opsForList().leftPushIfPresent(K key, V value)\n在 pivot 之前将值添加到 key 中redisTemplate.opsForList().leftPush(K key, V pivot, V value)\n将值附加到 keyredisTemplate.opsForList().rightPush(K key, V value)\nredisTemplate.opsForList().rightPushAll(K key, Collection&lt;V&gt; values)\n在 pivot 之后将值添加到 key 中redisTemplate.opsForList().rightPush(K key, V pivot, V value)\n在列表元素的索引处设置值redisTemplate.opsForList().set(K key, long index, V value)\n删除并返回存储在 key 的列表中的第一个元素、redisTemplate.opsForList().leftPop(K key)\nredisTemplate.opsForList().leftPop(K key, Duration timeout)\nredisTemplate.opsForList().leftPop(K key, long count)\nredisTemplate.opsForList().leftPop(K key, long timeout, TimeUnit unit)\n删除并返回存储在 key 的列表中的最后一个元素redisTemplate.opsForList().rightPop(K key)\nredisTemplate.opsForList().rightPop(K key, Duration timeout)\nredisTemplate.opsForList().rightPop(K key, long count)\nredisTemplate.opsForList().rightPop(K key, long timeout, TimeUnit unit)\n从 sourceKey 的列表中删除最后一个元素，将其附加到 destinationKey 并返回其值redisTemplate.opsForList().rightPopAndLeftPush(K sourceKey, K destinationKey)\nredisTemplate.opsForList().rightPopAndLeftPush(K sourceKey, K destinationKey, Duration timeout)\n从存储在 key 的列表中删除第一个 count 出现的 valueredisTemplate.opsForList().remove(K key, long count, Object value)\n在 start 和 end 之间的元素的 key 处修剪列表redisTemplate.opsForList().trim(K key, long start, long end)\n获取存储在 key 的列表的大小redisTemplate.opsForList().size(K key)\n\n6. RedisTemplate.opsForSet() 方法\n在 key 的 set 中添加给定值redisTemplate.opsForSet().add(K key, V... values)\n在 key 的 set 中删除给定值并返回已删除元素的数量redisTemplate.opsForSet().remove(K key, Object... values)\n从 key 的 set 中移除并返回一个随机成员redisTemplate.opsForSet().\tpop(K key)\n在 key 处获取集合的大小redisTemplate.opsForSet().size(K key)\n检查在 key 的 set 中是否包含值redisTemplate.opsForSet().isMember(K key, Object o)\n返回在 key 和 otherKeys 处与所有给定 sets 相交的成员redisTemplate.opsForSet().intersect(K key, Collection&lt;K&gt; otherKeys)\n在 key 和 otherKeys 处与所有给定 sets 相交，并将结果存储在 destKey 中redisTemplate.opsForSet().intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey)\n在 key 和 otherKey 处相交所有给定的 sets，并将结果存储在 destKey 中redisTemplate.opsForSet().intersectAndStore(K key, K otherKey, K destKey)\n合并给定 key 和 otherKey 的所有 setsredisTemplate.opsForSet().union(K key, K otherKey)\n将给定 key 和 otherKey 处的所有 set 合并，并将结果存储在 destKey 中redisTemplate.opsForSet().unionAndStore(K key, K otherKey, K destKey)\n获取差集redisTemplate.opsForSet().difference(key, otherKeys)\n获取差集并存储到destKeyredisTemplate.opsForSet().differenceAndStore(key, otherKey, destKey)\n随机获取集合中的一个元素redisTemplate.opsForSet().randomMember(key)\n获取集合中的所有元素redisTemplate.opsForSet().members(key)\n随机获取集合中count个值redisTemplate.opsForSet().randomMembers(key, count)\n随机获取集合中count个值，但是去重redisTemplate.opsForSet().distinctRandomMembers(key, count)\n遍历setredisTemplate.opsForSet().scan(key, options)\n\n7. RedisTemplate.opsForZSet() 方法\n添加元素，从小到大排序redisTemplate.opsForZSet().add(key, value, score)\n删除多个values的值redisTemplate.opsForZSet().remove(key, values)\n增加元素的score值同时返回增加后的值redisTemplate.opsForZSet().incrementScore(key, value, delta)\n返回元素在集合的从小到大排名redisTemplate.opsForZSet().rank(key, value)\n返回元素在集合的由大到小排名redisTemplate.opsForZSet().reverseRank(key, value)\n获取集合中指定区间的元素redisTemplate.opsForZSet().reverseRangeWithScores(key, start,end)\n查询集合中的元素并从小到大排序redisTemplate.opsForZSet().reverseRangeByScore(key, min, max)\nredisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, min, max)\n从高到低的排序，然后获取最小与最大值之间的值redisTemplate.opsForZSet().reverseRangeByScore(key, min, max, start, end)\n根据score值获取元素数量redisTemplate.opsForZSet().incrementScore(key, value, delta)\n获取集合的大小redisTemplate.opsForZSet().size(key)redisTemplate.opsForZSet().zCard(key)\n获取集合中key、value元素的score值redisTemplate.opsForZSet().score(key, value)\n移除指定索引元素redisTemplate.opsForZSet().removeRange(key, start, end)\n移除指定score范围的集合成员redisTemplate.opsForZSet().removeRangeByScore(key, min, max)\n获取key和otherKey的并集并存储在 destKey 中redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey)\n获取key和otherKey的交集并存储在 destKey 中redisTemplate.opsForZSet().intersectAndStore(key, otherKey, destKey)\n\n","slug":"BlogRepository/Redis/RedisTemplate常用方法总结（参考官方文档2.6.2）","date":"2022-02-26T19:40:27.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"凡"},{"id":"56daa6f6e65f7cd942daf401bb41ead5","title":"Redis 6总结（1）","content":"1. NoSQL 数据库简介1.1 技术发展技术的分类：\n\n解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN\n解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis\n解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch\n\n1.1.1 问题\n1.1.2 解决CPU及内存压力使用负载均衡减少服务器压力，但存在登录验证问题\n\n1.1.3 解决IO压力\n1.2 NoSQL 数据库1.2.1 NoSQL 数据库概述NoSQL（NoSQL &#x3D; Not Only SQL ），意即“不仅仅是SQL”，泛指非关系型的数据库\nNoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力\n\n不遵循 SQL 标准。\n不支持 ACID。\n远超于 SQL 的性能。\n\n1.2.2 NoSQL 适用场景\n对数据高并发的读写\n海量数据的读写\n对数据高可扩展性的\n\n1.2.3 NoSQL不适用场景\n需要事务支持\n基于 SQL 的结构化查询存储，处理复杂的关系,需要即时查询\n（用不着 SQL 的和用了 SQL 也不行的情况，请考虑用 NoSQL）\n\n1.2.4 常用的 NoSQL 数据库1.2.4.1 Memcache\n1.2.4.2 Redis\n1.2.4.3 MongoDB\n1.3 行式存储数据库（大数据时代）1.3.1 行式数据库\n1.3.2 列式数据库\n1.3.2.1 HBase\nHBase 是 Hadoop 项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中\nHBase 的目标就是处理数据量非常庞大的表，可以用普通计算机处理超过10亿行数据，还可处理有数百万列元素的数据表\n1.3.2.2 CassandraApache Cassandra 是一款免费的开源 NoSQL 数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集（数据量通常达到PB级别）。在众多显著特性当中，Cassandra 最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程\n计算机存储单位 计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：\n\n位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位\n字节 byte：8个二进制位为一个字节(B)，最常用的单位\n1KB (Kilobyte 千字节)&#x3D;1024B\n1MB (Megabyte 兆字节 简称“兆”)&#x3D;1024KB\n1GB (Gigabyte 吉字节 又称“千兆”)&#x3D;1024MB\n1TB (Trillionbyte 万亿字节 太字节)&#x3D;1024GB，其中1024&#x3D;2^10 ( 2 的10次方)\n1PB（Petabyte 千万亿字节 拍字节）&#x3D;1024TB\n1EB（Exabyte 百亿亿字节 艾字节）&#x3D;1024PB\n1ZB (Zettabyte 十万亿亿字节 泽字节)&#x3D; 1024 EB\n1YB (Jottabyte 一亿亿亿字节 尧字节)&#x3D; 1024 ZB\n1BB (Brontobyte 一千亿亿亿字节)&#x3D; 1024 YB.注：“兆”为百万级数量单位\n\n1.4 图关系型数据库主要应用：社会关系，公共交通网络，地图及网络拓扑（n *（n-1）&#x2F; 2）\n2. Redis 概述安装\nRedis 是一个开源的 key-value 存储系统\n和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string（字符串）、list（链表）、set（集合）、zset（sorted set –有序集合）和 hash（哈希类型）\n这些数据类型都支持 push&#x2F;pop、add&#x2F;remove 以及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的\n在此基础上，Redis 支持各种不同方式的排序\n与 memcached 一样，为了保证效率，数据都是缓存在内存中\n区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件\n并且在此基础上实现了 master-slave（主从）同步\n\n2.1 应用场景2.1.1 配合关系型数据库做高速缓存\n高频次，热门访问的数据，降低数据库IO\n分布式架构，做session共享\n\n2.1.2 多样的数据结构存储持久化数据\n2.2 Redis 安装2.3 Redis 介绍相关知识Redis是单线程+多路IO复用技术\n多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）\n串行   vs   多线程+锁（memcached） vs   单线程+多路IO复用(Redis)\n（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）\n3. 常用五大数据类型String、List、Set、Hash、Zset\n\n   对象 编码 数据结构 \n    string(字符串对象)  int   可以存储 long 类型的整数  \n    embstr   embstr 编码的简单动态字符串  \n    row   简单动态字符串（SDS）  \n    list（列表对象）   ziplist   压缩列表  \n    linkedisk   双端链表  \n    hash（哈希对象）   ziplist   压缩列表  \n    hashtable   字典  \n    set（集合对象）   intset   整数集合  \n    hashtable   字典  \n    zset（有序集合对象）   ziplist   压缩列表  \n    skiplist   字典 + 跳跃表  \n\n\n3.1.\tRedis键(key)\nkeys * ：查看当前库所有 key    (匹配：keys *1)\nexists key ：判断某个 key 是否存在\ntype key ：查看你的 key 是什么类型\ndel key ：删除指定的 key 数据\nunlink key ：根据 value 选择非阻塞删除，仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作\nexpire key 10 ：10秒钟：为给定的 key 设置过期时间\nttl key ：查看还有多少秒过期，-1 表示永不过期，-2 表示已过期\nselect ：命令切换数据库\ndbsize ：查看当前数据库的 key 的数量\nflushdb ：清空当前库\nflushall ：通杀全部库\n\n3.2 Redis字符串（String）3.2.1 简介\nString 是 Redis 最基本的数据类型，可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value\nString 类型是二进制安全的。意味着 Redis 的string 可以包含任何数据。比如 JPG 图片或者序列化的对象\n一个 Redis 中字符串 value 最多可以是 512M\n\n3.2.2 常用命令添加键值对\nset &lt;key&gt; &lt;value&gt; \n\n\n\nNX：当数据库中key不存在时，可以将key-value添加数据库\nXX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥\nEX：key的超时秒数\nPX：key的超时毫秒数，与EX互斥\n\n\n\n\n\n\n\n\n\n\n\nget key查询对应键值\nappend key value将给定的 value 追加到原值的末尾\nstrlen key获得值的长度\nsetnx key value只有在 key 不存在时    设置 key 的值\nincr key将 key 中储存的数字值增1只能对数字值操作，如果为空，新增值为1\ndecr key将 key 中储存的数字值减1只能对数字值操作，如果为空，新增值为-1\nincrby &#x2F; decrby  key 步长将 key 中储存的数字值增减。自定义步长。原子性所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作Redis 单命令的原子性主要得益于 Redis 的单线程\nmset key1 value1 key2 value2 …..同时设置一个或多个 key-value 对\nmget  key1 key2 key3 …..同时获取一个或多个 value\nmsetnx key1 value1 key2 value2 …..同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在原子性，有一个失败则都失败\ngetrange  key 起始位置 结束位置获得值的范围，类似java中的substring，前包，后包\nsetrange  key 起始位置 value用 value 覆写 key 所储存的字符串值，从 起始位置 开始(索引从0开始)\nsetex  key 过期时间 value设置键值的同时，设置过期时间，单位秒\ngetset key value以新换旧，设置了新值同时获得旧值\n\n3.2.3 数据结构String 的数据结构为简单动态字符串（Simple Dynamic String，缩写 SDS）。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList ，采用预分配冗余空间的方式来减少内存的频繁分配内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M\n3.3 Redis 列表（List）3.3.1 简介单键多值\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n它的底层实际是个 双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。即 查询性能较差\n\n\n3.3.2 常用命令\nlpush&#x2F;rpush  key value1 value2 value3 ….从左边 &#x2F; 右边插入一个或多个值\nlpop&#x2F;rpop  key从左边 &#x2F; 右边吐出一个值。值在键在，值光键亡。\nrpoplpush  key1 key2从 key1 列表右边吐出一个值，插到 key2 列表左边。\nlrange key start stop按照索引下标获得元素(从左到右)lrange mylist 0 -10 左边第一个，-1 右边第一个，（0-1表示获取所有）\nlindex key index按照索引下标获得元素(从左到右)\nllen key获得列表长度\nlinsert key before&#x2F;after value newvalue在 value 的前面 &#x2F; 后面插入 newvalue 插入值\nlrem key n value从左边删除 n 个value(从左到右)\nlset key index value将列表 key 下标为 index 的值替换成 value\n\n3.2.3 数据结构List 的数据结构为快速链表 quickList\n\n首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表\n它将所有的元素紧挨着一起存储，分配的是一块连续的内存\n当数据量比较多的时候才会改成 quicklist\n因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如列表里存的只是int类型的数据，结构上还需要两个额外的指针 prev 和 next\n\n\nRedis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余\n3.4 Redis 集合（Set）3.4.1 简介Redis Set 对外提供的功能与 List 类似是一个列表的功能，特殊之处在于 Set 是可以 自动排重 的，当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的\nRedis 的 Se t是 String 类型的 无序集合 。它底层其实是一个 value 为 null 的 hash 表，所以添加，删除，查找的复杂度都是O(1)\n一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变\n3.4.2 常用命令\nsadd key value1 value2 …..将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略\nsmembers key取出该集合的所有值。\nsismember key value判断集合 key 是否为含有该 value 值，有1，没有0\nscard key返回该集合的元素个数。\nsrem key value1 value2 ….删除集合中的某个元素。\nspop key随机从该集合中吐出一个值。\nsrandmember key n随机从该集合中取出n个值。不会从集合中删除 。\nsmove source target value把集合中一个值从一个集合移动到另一个集合\nsinter key1 key2返回两个集合的交集元素。\nsunion key1 key2返回两个集合的并集元素。\nsdiff key1 key2返回两个集合的差集元素（key1中的，不包含key2中的）\n\n3.4.3 数据结构Set 数据结构是 dict 字典，字典是用哈希表实现的\nJava 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。Redis 的 Set 结构也是一样，它的内部也使用 Hash 结构，所有的 value 都指向同一个内部值。\n3.5 Redis哈希（Hash）3.5.1 简介Redis hash 是一个键值对集合。Redis hash 是一个 String 类型的 field 和 value 的映射表，hash **特别适合用于存储对象。类似 Java 里面的 Map&lt;String, Object&gt; \n用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key&#x2F;value 结构来存储，主要有以下2种存储方式：\n3.5.2 常用命令\nhset key field value给 key 集合中的  field 键赋值 value\nhget key1 field从 key1 集合 field 取出 value\nhmset key1 field1 value1 field2 value2…批量设置 hash 的值\nhexists key1 field查看哈希表 key 中，给定域 field 是否存在。\nhkeys key列出该 hash 集合的所有 field\nhvals key列出该 hash 集合的所有 value\nhincrby key field increment为哈希表 key 中的域 field 的值加上增量 1   -1\nhsetnx key field value将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在\n\n3.5.3 数据结构Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable\n3.6 Redis 有序集合 Zset（sorted set）3.6.1 简介Redis 有序集合 Zset 与普通集合 Set 非常相似，是一个 没有重复元素 的字符串集合。不同之处是有序集合的每个成员都关联了一个 评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的\n因为元素是有序的，所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表\n3.6.2 常用命令\nzadd  key score1 value1 score2 value2…将一个或多个 member 元素及其 score 值加入到有序集 key 当中\nzrange key start stop  [WITHSCORES]返回有序集 key 中，下标在 start stop之间的元素带WITHSCORES，可以让分数一起和值返回到结果集\nzrangebyscore key minmax [withscores] [limit offset count]返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列\nzrevrangebyscore key maxmin [withscores] [limit offset count]同上，改为从大到小排列\nzincrby key increment value为元素的score加上增量\nzrem  key value删除该集合下，指定值的元素\nzcount key min max统计该集合，分数区间内的元素个数\nzrank key value返回该值在集合中的排名，从0开始\n\n3.6.3 数据结构SortedSet（Zset）是Redis提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表\nZset 底层使用了两个数据结构\n\nhash，hash的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值\n跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表\n\n3.6.4 跳跃表1、简介有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单\n2、实例对比有序链表和跳跃表，从链表中查询出51\n\n有序链表要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较\n跳跃表\n从第2层开始，1节点比51节点小，向后比较\n21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层\n在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下\n在第0层，51节点为要查找的节点，节点被找到，共查找4次\n\n\n\n从此可以看出跳跃表比有序链表效率要高\n4. Redis 配置文件4.1 ###Units 单位###配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感\n4.2 ###INCLUDES 包含###类似 JSP 中的 include，多实例的情况可以把公用的配置文件提取出来\n4.3\t###NETWORK 网络相关配置###4.3.1 bind默认情况 bind&#x3D;127.0.0.1 只能接受本机的访问请求。不写的情况下，无限制接受任何 ip 地址的访问。生产环境应该要写应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉\n4.3.2 protected-mode将本机访问保护模式设置 no\n4.3.3 Port默认端口为 6379\n4.3.4 tcp-backlog设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和 &#x3D; 未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题\n注意 Linux 内核会将这个值减小到 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 的值（128），所以需要确认增大 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 和 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果\n4.3.5 timeout一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。\n4.3.6 tcp-keepalive对访问客户端的一种心跳检测，每隔 n 秒检测一次。单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60 （默认 300）\n4.4 ###GENERAL 通用###4.4.1 daemonize是否为后台进程，设置为 yes。守护进程，后台启动\n4.4.2 pidfile存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件\n4.4.3 loglevel指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice。四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning\n4.4.4 logfile日志文件名称\n4.4.5 databases 16设定库的数量默认16，默认数据库为 0，可以使用SELECT dbid 命令在连接上指定数据库 id\n4.5 ###SECURITY 安全###4.5.1 设置密码在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。永久设置，需要在配置文件中进行设置。\n4.6 #### CLIENTS 客户端4.6.1 maxclients设置redis同时可以与多少个客户端进行连接。默认情况下为 10000 个客户端。如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出 “max number of clients reached” 以作回应\n4.7 ####MEMORY MANAGEMENT 内存管理####4.7.1 maxmemory建议必须设置，否则，将内存占满，造成服务器宕机。设置 Redis 可以使用的内存量。一旦到达内存使用上限，Redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定\n如果 Redis 无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么 Redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等\n但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。如果你的 Redis 是主 Redis（说明你的 Redis有从 Redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素\n4.7.2 maxmemory-policy\nvolatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；（最近最少使用）\nallkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key\nvolatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键\nallkeys-random：在所有集合 key 中，移除随机的 key\nvolatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key\nnoeviction：不进行移除。针对写操作，只是返回错误信息\n\n\n4.7.3\tmaxmemory-samples\n设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，Redis 默认会检查这么多个 key 并选择其中 LRU 的那个。\n一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。\n\n\n5. Redis的发布和订阅5.1 简介Redis 发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道\n5.2\tRedis的发布和订阅\n客户端订阅频道\n当给这个频道发布消息后，消息就会发送给订阅的客户端\n\n5.3 发布订阅命令行实现1、打开一个客户端订阅 channel1\nsubscribe channel1\n\n2、打开另一个客户端，给 channel1 发布消息 hello\npublish channel1 hello\n\n返回的1是订阅者数量3、打开第一个客户端可以看到发送的消息注：发布的消息没有持久化，如果在订阅的客户端收不到 hello，只能收到订阅后发布的消息\n6. Redis新数据类型6.1 Bitmaps6.1.1 简介现代计算机用二进制（位）作为信息的基础单位，1个字节等于8位， 例如“abc”字符串是由3个字节组成，但实际在计算机存储时将其用二进制表示， “abc”分别对应的 ASCII 码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图合理地使用操作位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：\n\nBitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作\nBitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在 Bitmaps 中叫做偏移量\n\n6.1.2 命令1、setbit\n\n格式setbit key offset value ：设置 Bitmaps 中某个偏移量的值（0或1），offset:偏移量从0开始\n示例每个独立用户是否访问过网站存放在 Bitmaps 中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的 id设置键的第 offset 个位的值（从0算起） ， 假设现在有20个用户，userid&#x3D;1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图users:20220224 表示 2022-02-24 这天独立访问用户的 Bitmaps注：\n很多应用的用户 id 以一个指定数字（例如10000） 开头， 直接将用户 id 和 Bitmaps 的偏移量对应势必会造成一定的浪费， 通常的做法是每次做 setbit 操作时将用户 id 减去这个指定数字\n在第一次初始化 Bitmaps 时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成 Redis 的阻塞\n\n\n\n2、getbit\n\n格式getbit key offset ：获取 Bitmaps 中某个偏移量的值，获取键的第 offset 位的值（从0开始算）\n\n示例获取 id&#x3D;8 的用户是否在 2022-02-24 这天访问过， 返回0说明没有访问过，因为100根本不存在，所以也是返回0\n\n\n\n3、bitcount统计字符串被设置为 1 的 bit 数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含\n\n格式bitcount key [start end] ：统计字符串从start字节到end字节比特值为1的数量\n\n示例计算 2022-02-24 这天的独立访问用户数量start 和 end 代表起始和结束字节数， 下面操作计算用户 id 在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】，四个字节组\n\n\n\n\n\n\n\n\n\nbitcount K1 1 2  ： 统计下标1、2字节组中 bit&#x3D;1 的个数，即 01000000  00000000–》bitcount K1 1 2 　　–》1bitcount K1 1 3  ： 统计下标1、2字节组中 bit&#x3D;1 的个数，即 01000000  00000000 00100001–》bitcount K1 1 3　　–》3bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中 bit&#x3D;1 的个数，即 01000001  01000000  00000000–》bitcount K1 0 -2　　–》3\n注意：Redis 的 setbit 设置或清除的是 bit 位置，而 bitcount 计算的是 byte 位置\n\n\n4、bitop格式：bitop  and(or&#x2F;not&#x2F;xor) destkey [key…]bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中\n6.1.3 Bitmaps 与 Set 对比设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万（大量的僵尸用户），那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps 就不太合适了， 因为基本上大部分位都是0。\n6.2 HyperLogLog6.2.1 简介在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView页面访问量）,可以使用 Redis 的 incr、incrby 轻松实现。但像 UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。解决基数问题有很多种方案：\n\n数据存储在MySQL表中，使用 distinct count 计算不重复个数\n使用Redis提供的 hash、set、bitmaps 等数据结构来处理\n\n以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog。Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素\n什么是基数?\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数\n6.2.2 命令1、pfadd\n\n格式pfadd  key element [element …] ：添加指定元素到 HyperLogLog 中\n示例将所有元素添加到指定 HyperLogLog 数据结构中。如果执行命令后 HLL 估计的近似基数发生变化，则返回1，否则返回0\n\n2、pfcount\n\n格式pfcount key [key …] ：计算 HLL 的近似基数，可以计算多个 HLL，比如用HLL 存储每天的 UV，计算一周的 UV 可以使用7天的 UV 合并计算即可\n示例\n\n3、pfmerge\n\n格式pfmerge destkey sourcekey [sourcekey …] ：将一个或多个 HLL 合并后的结果存储在另一个 HLL 中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得\n示例\n\n6.3 Geospatial6.3.1 简介Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。Redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作\n6.3.2 命令1、geoadd\n\n格式geoadd key longitude latitude member [longitude latitude member…] ：添加地理位置（经度，纬度，名称）\n\n示例\nbash两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的\n\n\n2、geopos\n\n格式geopos  key member [member…] ：获得指定地区的坐标值\n示例\n\n3、geodist\n\n格式geodist key member1 member2 [m|km|ft|mi ] ：获取两个位置之间的直线距离\n\n示例获取两个位置之间的直线距离单位：\n\n\n\n\n\n\n\n\n\nm 表示单位为米[默认值]km 表示单位为千米mi 表示单位为英里ft 表示单位为英尺\n如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位\n\n\n4、georadius\n\n格式georadius key longitude latitude radius m|km|ft|mi ：以给定的经纬度为中心，找出某一半径内的元素\n示例\n\n","slug":"BlogRepository/Redis/Redis 6总结（1）","date":"2022-02-24T01:12:39.000Z","categories_index":"Redis","tags_index":"Redis","author_index":"凡"},{"id":"f5cb41ad6b8fe76e1bcc157a340542d5","title":"服务器安装Redis和配置后台远程连接","content":"1. 官网下载选择对应的版本进行下载下载完成后上传到服务器上解压文件，tar -zxvf redis-6.2.7.tar.gz\n2. 安装2.1 环境安装 Redis 需要 C 语言的编译环境，先测试 gcc 版本，gcc --version没有环境的需要进行安装，yum install gcc-c++\n2.2 编译进入解压好的 Redis 文件夹，执行 make 命令进行编译，make\n假如没有准备好 C 语言编译环境，make 会报错，—Jemalloc/jemalloc.h：没有那个文件准备好环境后需要运行 make distclean 进行清空，然后再次执行 make 命令\n2.3 安装跳过 make test 直接执行 make install，默认安装目录：/usr/local/bin指定安装路径可以使用 make PREFIX=/usr/java/redis/redis-6.2.7 install\n\nredis-benchmark：性能测试工具，可以查看性能\nredis-check-aof：修复有问题的 AOF 文件\nredis-check-dump：修复有问题的 dump.rdb 文件\nredis-sentinel：Redis 集群使用\nredis-server：Redis 服务器启动命令\nredis-cli：客户端，操作入口\n\n3. 修改配置文件（后台远程连接）进入 Redis 解压的目录，编辑 redis.conf 文件\n3.1 后台启动后台启动设置 daemonize，将 no 改成 yes\n3.2 远程连接\n注释， #bind 127.0.0.1 -::1\n将 protected-mode 改为 no\n设置密码，requirepass\n\n然后通过服务器 IP 地址、端口、以及设置的密码进行连接\n3.3 设置日志文件位置在 redis.conf 同级目录下创建 redis-log.log 文件，并在 redis.conf 里配置日志文件的位置，logfile\n4. 启动和关闭4.1 启动进入 Redis 安装目录，执行 ./redis-server /usr/java/redis/redis-6.2.7/redis.conf，通过修改后的配置文件启动，并且会在后台运行可以通过密码用客户端访问，./redis-cli -h IP地址 -p 6379（端口） -a 密码测试验证\n4.2 关闭\n单实例关闭：redis-cli shutdown\n也可以进入客户端后关闭：shutdown\n多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown\n或者直接杀死 Redis 的进程号来关闭，查看进程号：ps -ef | grep redis使用 kill 命令杀死进程：kill -9 进程号\n\n","slug":"BlogRepository/服务器/服务器安装Redis和配置后台远程连接","date":"2022-02-24T00:48:55.000Z","categories_index":"服务器","tags_index":"Redis,服务器","author_index":"凡"},{"id":"5ba2b1d9fbead41813249a5bdde7870e","title":"VSCode下载安装和修改插件下载位置（配置右键菜单）及配置Java环境和更换终端","content":"1. 下载1、 进入官网2、点击 Download 进入下载页面下载需要的版本\n下载 ZIP 免安装版可以省略下面安装和修改插件位置步骤，只需在安装目录中创建 data 文件夹即可，使用过程中的插件及用户数据都会保存到这个文件夹，可以直接进行 3.3 右键菜单的配置\n2. 安装双击打开，同意协议，下一步选择安装路径，下一步下一步根据情况勾选，下一步安装完成\n3. 修改插件位置默认安装在 C盘用户目录下的 .vscode&#x2F;extensions 文件夹中\n3.1 修改启动文件通过安装目录下的 code.exe 启动文件打开时，指定其打开时选择的插件位置在安装目录下打开 CMD，输入下面的命令：code --extensions-dir &quot;自己的插件位置&quot;\ncode --extensions-dir &quot;D:\\DevelopmentTools\\Microsoft VS Code\\extensions&quot;\n\n此时通过启动文件打开可以生效，但通过快捷方式打开，修改的插件位置无法生效。\n3.2 修改快捷方式找到 VSCode 的快捷方式，修改快捷方式目标参数，加上 –extensions-dir  “自己的插件文件路径”\n&quot;D:\\工具\\Microsoft VS Code\\Code.exe&quot; --extensions-dir  &quot;D:\\工具\\Microsoft VS Code\\extensions&quot;\n\n修改生效但这种方式用快捷方式打开生效，用右键菜单打开 vscode，配置并没有生效，搜索不到更改的插件路径下的插件\n3.3 配置右键菜单（可根据选择配置）Win+R，打开运行窗口，输入 regedit，回车确定，打开注册表\n3.3.1 配置右键打开文件依次点开 HKEY_CLASSES_ROOT —&gt; * —&gt; shell —&gt; VSCode —&gt; command，假如没有后面两个文件夹需要新增没有右键菜单选项的需要添加，右键 shell ，新建 —&gt; 项，给创建的文件夹命名为 VSCode默认的数值修改为 用VSCode打开再右键VSCode，新建 —&gt; 可扩充字符串值，名称为 Icon，数值修改为 VSCode 的 exe 文件路径再右键VSCode，新建 —&gt; 项，给创建的文件夹命名为 command，修改 command 的数值，即前面的快捷方式目标参数，按照个人配置来\n&quot;D:\\工具\\Microsoft VS Code\\Code.exe&quot; --extensions-dir  &quot;D:\\工具\\Microsoft VS Code\\extensions&quot; &quot;%1&quot;\n\n\n3.3.2 配置右键打开文件夹依次点开 HKEY_CLASSES_ROOT —&gt; Directory —&gt; shell，操作与上同，修改 command 的数值\n&quot;D:\\工具\\Microsoft VS Code\\Code.exe&quot; --extensions-dir  &quot;D:\\工具\\Microsoft VS Code\\extensions&quot; &quot;%V&quot;\n\n\n3.3.3 配置右键文件夹空白处，打开文件夹依次点开 HKEY_CLASSES_ROOT —&gt; Directory —&gt; Background —&gt; shell，操作与上同，修改 command 的数值\n&quot;D:\\工具\\Microsoft VS Code\\Code.exe&quot; --extensions-dir  &quot;D:\\工具\\Microsoft VS Code\\extensions&quot; &quot;%V&quot;\n\n\n4. 常用插件及配置使用见另一篇博客：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;123975082\n","slug":"BlogRepository/开发工具及环境/VSCode下载安装和修改插件下载位置（配置右键菜单）","date":"2022-02-12T19:28:53.000Z","categories_index":"开发工具及环境","tags_index":"Java,VSCode,编辑器","author_index":"凡"},{"id":"c1bfd81bf358c0811575f4b1b2b672c7","title":"电脑软件有网但访问网址显示未连接问题解决","content":"1. 运行 Windows 网络诊断，查看详情\n2. 打开控制面板点击网络和 Internet\n3. 点击Internet选项\n4. 在连接界面点击局域网设置\n5. 取消勾选 为 LAN 使用代理服务器确定，保存退出。\n","slug":"BlogRepository/问题记录/电脑软件有网但访问网址显示未连接问题解决","date":"2022-02-10T04:45:04.000Z","categories_index":"问题记录","tags_index":"Windows","author_index":"凡"},{"id":"5a21c09ba3fee0fc771792aaefbd27f1","title":"轻量应用服务器部署 SpringBoot 前后端分离项目","content":"部署 Nginx 见：轻量应用服务器使用总结\n1. 前端项目部署1、这里使用的是 vue 项目，运行 npm run build，会生成一个 dist 文件夹2、把文件上传到服务器 Nginx 安装目录的 html 目录下，先压缩成 ZIP 包上传然后再解压，然后重命名为 blog（这里的文件路径与 Nginx 配置文件的路径对应即可）3、修改 Nginx 配置文件，/usr/java/nginx-1.22.0/conf/nginx.conf4、Nginx 没有启动的直接启动 Nginx，已经启动的运行 ./nginx -s reload 更新配置文件，指令见 6.25、在防火墙里放开对应的端口6、通过浏览器地址加端口号即可访问，这里因为还没有后端，所以页面没有数据\n2. 后端项目部署1、上传jar包在 Maven 里点击 package，将项目打包在项目路径下的 target 文件夹中会有一个 jar 文件将该文件上传到服务器2、启动项目进入 jar 包所在文件夹，执行 java -jar FanBlog-0.0.1-SNAPSHOT.jar，启动项目，使用服务器地址加项目中设置的内置 Tomcat 的端口即可访问。端口需要在防火墙里开放。但这种方式关闭终端 Tomcat 就停止了，关闭后项目不能再访问。\n可以使用 nohup java -jar FanBlog-0.0.1-SNAPSHOT.jar 启动，nohup 表示将该程序在后台一直运行，即使退出终端，项目也可以访问。同时会在 jar 包所在目录生成一个 nohup.out 文件，记录运行过程中的信息3、关闭要关闭项目可以使用 ps -ef | grep 进程名称关键字，显示进程相关信息然后使用 kill -9 进程id，关闭进程，项目停止。\n3. 使用 Nginx 反向代理解决跨域修改 Nginx 的配置文件 /usr/java/nginx-1.22.0/conf/nginx.conf ，在前面前端项目 Nginx 配置的基础上，加上一个反向代理的配置当请求路径为 /fanBlog 时，将请求代理到8001端口，即后端运行端口，再刷新 Nginx 配置，访问前端页面即可看到后端返回数据\n4. 配置域名访问先配置域名解析到服务器修改 Nginx 配置文件，将 server_name 修改为域名地址即可通过域名加端口访问，这里设置端口为 80，即可省略端口号，直接通过域名访问\n5. 配置 SSL 证书1、先下载 Nginx 服务器类型证书，上传到服务器2、解压3、移动文件3、在 Nginx 配置文件里配置证书以及修改其他配置\n# 设置 HTTP 请求自动跳转 HTTPS（可选）\nserver &#123;\n\tlisten 80;\n\t# 证书绑定的域名，例如：cloud.tencent.com\n\tserver_name cloud.tencent.com;\n\t# 将 http 的域名请求转成 https\n\treturn 301 https:&#x2F;&#x2F;$host$request_uri;\n&#125;\nserver &#123;\n\t# SSL 端口\n\tlisten 443 ssl;\n\t# 证书绑定的域名，例如：cloud.tencent.com\n\tserver_name  cloud.tencent.com;\n\t      \n\t# 证书文件名称\n\tssl_certificate      ..&#x2F;certificate&#x2F;cloud.tencent.com_bundle.pem;\n\t# 私钥文件名称\n\tssl_certificate_key  ..&#x2F;certificate&#x2F;cloud.tencent.com.key;\n\n\t# 默认配置\n\tssl_session_cache    shared:SSL:1m;\n\tssl_session_timeout  5m;\n\tssl_ciphers  HIGH:!aNULL:!MD5;\n\tssl_prefer_server_ciphers  on;\n\t......\n&#125;\n\n刷新 Nginx 配置，即可通过 HTTPS 访问\n","slug":"BlogRepository/服务器/轻量应用服务器部署 SpringBoot 前后端分离项目","date":"2022-02-09T15:59:34.000Z","categories_index":"服务器","tags_index":"SpringBoot,服务器","author_index":"凡"},{"id":"6307e383010802622c546f5e2b5cd218","title":"Git总结","content":"1. 下载点击https://git-scm.com/downloads，前往下载页面这里选择 Windows，选择对应的位数下载\n2. 安装选择安装组件，NextNext选择在 Git 中使用的编辑器，按自己选择，Next或者选择自定义编辑器\n选择 Git init 命令后分支的初始命名，默认为 master可以选择自定义，目前 GitHub 默认的分支为 main，Next\n修改系统的环境变量，这里我选择第二个，Next选择 SSH，默认，Next选择 SSL 证书，默认，Next配置行尾结束符，默认，Next选择想在 Git Bash 中使用哪个终端模拟器，默认或选择 Windows 默认，Nextpull 时的默认行为，默认选择 Merge，合并分支，Next选择凭证助手，默认，Next额外选项，默认，Next默认不选，Install，进行安装安装完成\n3.  查看配置信息git config --list  查看所有配置项信息\ngit config user.name  查看用户名\ngit config user.email 查看email\n\n\n4. 设置用户信息每次Git提交都会使用该用户信息\ngit config --global user.name &quot;Fan223&quot;    设置用户名\ngit config --global user.email &quot;fanj.zh@foxmail.com&quot;  设置邮箱\n\n5. SSH设置5.1 生成密钥对Git 服务器选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥SSH公钥默认存储在账户的主目录下的 .ssh 目录看是否存在id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux&#x2F;Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：\nssh-keygen -t rsa -C &quot;fanj.zh@foxmail.com&quot; \n私钥以BEGIN OPENSSH PRIVATE KEY开头，以END OPENSSH PRIVATE KEY结尾，Git 可以正常使用，在SpringCloud的配置中心从GitHub上读取配置时，使用该种类型会报错\n使用\nssh-keygen -m PEM -t rsa -b 4096 -C &quot;fanj.zh@foxmail.com&quot; \n私钥以BEGIN RSA PRIVATE KEY开头，以END RSA PRIVATE KEY结尾，在SpringCloud的配置中心从GitHub上读取配置时，使用该种类型可以成功\n\n直接按 Enter 确定，会提示输入密码，可以不输，也可以输，假如输入后，每次进行操作时都将提示：\nEnter passphrase for key &#39;&#x2F;c&#x2F;Users&#x2F;Fan&#x2F;.ssh&#x2F;id_rsa&#39;:\n\n需要输入密码才能操作。假如设置了密码可以通过：\nssh-keygen -p  重新设置密码，直接回车设置为空\n\n完成密码设置之后，密钥对生成完成\nYour identification has been saved in &#x2F;c&#x2F;Users&#x2F;Fan&#x2F;.ssh&#x2F;id_rsa  密钥存放在id_rsa\nYour public key has been saved in &#x2F;c&#x2F;Users&#x2F;Fan&#x2F;.ssh&#x2F;id_rsa.pub  公钥存放在id_rsa.pub\n\n5.2 添加公钥到远程仓库（GitHub、Gitee）1、查看生成的公钥\ncat .ssh&#x2F;id_rsa.pub\n\n2、登录GitHub账号，进入设置3、添加公钥复制上面的公钥内容，粘贴进 Key 里，Title 定义一个名字4、测试是否正常工作\nssh -T git@github.com\n\n看到\nHi Fan223! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n\n即设置成功\n6. 常用命令1、拉取（可以使用 SSH 公钥或 HTTPS）\ngit clone git@github.com:Fan223&#x2F;SpringCloud-Config.git\n\n2、添加\ngit add .\n\n3、提交\ngit commit -m &quot;Initial commit&quot;\n\n4、设置远端仓库\ngit remote add origin &lt;远程仓库url&gt;\n\n5、推送（-f 表示强推，可选）\ngit push\ngit push [-f] --set-upstream origin master\n\n6、初始化 Git，即生成 .git 文件夹\ngit init\n\n7. IDEA使用Git7.1 配置 Git\n7.2 创建本地仓库创建一个新项目，点击 VCS，然后点击 Create Git Repository选择项目目录项目目录下会出现一个隐藏的 .git 文件夹同时在项目里右键会出现 Git 选项，菜单栏右上角也会出现 Git 的操作选项或者我们创建好远程仓库，直接复制远程仓库的地址，把项目 Clone 下来\n7.3 提交代码到远程仓库新建一个 Class 类，会提示是否把文件加到 Git，勾选 Don’t ask again 不再询问，然后点击 Add，添加点击菜单栏的 Git 操作选项，Commit填写 Commit Message，然后点击 Commit提示 Code Analysis 代码分析，这个文件没有错误但有5个警告，是否要回看代码，选择 Commit 提交点击 Commit 提交点击菜单栏的 Git 操作选项，Push第一次提交，需要指定远程仓库的地址输入远程仓库地址，点击 OK可以看到我们提交的记录，点击 Push可以在远程仓库看到我们 Push 的内容，Push 成功可以在 Commit 操作时直接点击 Commit and Push，提交完会自动打开 Push 页面，不需要再手动点击 Push\n7.4 从远程仓库获取更新点击菜单栏的 Git 操作选项，Update Project 更新项目。Merge the incoming changes into the current branch：将传入的更改合并到当前分支中Rebase the current branch on top of the incoming changes：在传入更改的基础上重新建立当前分支选择合并分支，点击 OK项目内容进行了更新\n7.5 回滚操作点击菜单栏的 Git 操作选项，Rollback 回滚操作\n","slug":"BlogRepository/开发工具及环境/Git总结","date":"2022-01-26T15:54:45.000Z","categories_index":"开发技术及框架","tags_index":"Git","author_index":"凡"},{"id":"30348196f3e5c5edf9397c3928f42c56","title":"getResource()获取中文或带空格路径问题报错处理","content":"1. 问题描述当我们使用getResource()获取文件路径时，路径中带有中文或者空格时，获取到的路径含%20字样此时我们用该路径创建文件时报错，找不到该路径我们在资源管理器中复制该路径，发现确实找不到而我们将路径中的%20字样删除，转换为原本的空格，发现可以找到\n2. 解决方案此时我们在getResource()方法后加一个toURL()方法，则不会报错，说明路径已成功找到此时我们输出打印一下，%20字样消失，路径恢复正常，则可正常找到结尾：至此，问题成功解决\n","slug":"BlogRepository/问题记录/getResource()获取中文或带空格路径问题报错处理","date":"2021-09-07T04:33:42.000Z","categories_index":"问题记录","tags_index":"Spring","author_index":"凡"},{"id":"7f0c37f8ba3bd417fe76addb2027285e","title":"数据库事务隔离级别实例详解","content":"1. 名词概念1.1 脏读：一个事务，读取到另一个事务中没有提交的数据1.2 不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样1.3 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，第一个事务查询不到自己的修改\n2. 隔离级别分类2.1 read uncommitted：读未提交\n\n\n\n\n\n\n\n\n问题：脏读、不可重复读、幻读\n2.2 read committed：读已提交（Oracle默认）\n\n\n\n\n\n\n\n\n问题：不可重复读、幻读\n2.3 repeatable read：可重复读（MySQL默认）\n\n\n\n\n\n\n\n\n问题：幻读\n2.4 serializable：串行化\n\n\n\n\n\n\n\n\n可以解决所有问题\n3. 解析3.1 设置read uncommitted时当张三借钱给李四，设双方账号各有1000元，转账后张三变为500，李四变为1500\n事务1：\t\t\t\t\t\t事务2：\n\tstart transaction;\t\t\t\tstart transaction;\n\t张三：1000，李四：1000\t\t\t        张三：1000，李四：1000\n转账后：\n\t张三：500，李四：1500\n\n而张三进行转账操作时，开启事务，执行转账后，并未提交（commit）。由于设置了read uncommitted，李四可以查询到未提交的数据（脏读），看到账户余额为1500元，给张三打下500元借条。这时张三进行回滚（rollback），账户余额重新变为1000，李四再去看时账户余额已变为1000元（不可重复读）\n事务1：\t\t\t\t\t\t\t\t\t事务2：\n转账后：\n\t张三：500，李四：1500 （此时并未提交）   张三：500，李四：1500（其他事务未提交但能查看修改数据）\n\trollback;\n\t（张三：1000，李四：1000）\t\t\t\t张三：1000，李四：1000\n\n此时张三一分钱没少，反而李四欠张三500元，这就出问题了\n3.2 设置read committed时此时不会发生3.1 所述问题，当张三转账完，执行 commit 提交后，张三账户余额为500元，李四账户余额为1500元\n事务1：\t\t\t\t\t\t\t事务2：\n转账后：\n\t张三：500，李四：1500（未提交）\t\t张三：1000，李四：1000（其他事务未提交不能查看修改数据）\n\tcommit;\n\t（张三：500，李四：1500）\t\t\t张三：500，李四：1500（其他事务已提交可以查看修改数据）\n\n对于李四来说，第一次查看账户余额为1000元，第二次查看账户余额为1500元。在同一个事务中，两次读取到的数据不一样（不可重复读）\n李四：1000\n李四：1500\n\n从操作层面来说很合理，但是有些情况需要在同一个事务中读取到的数据都一样。例如做一个利率年增长查询，你查看到的是25%，而当你报告给你的上级说是25%时，你的上级一查看到的却是24.6%，同一个事务中查到的数据不一样。这时候就显得你工作有问题。此时我们需要定义repeatable read（可重复读）\n3.3 设置repeatable read此时我们开启一个事务，无论其他事务做了什么修改，只要我们本事务不提交（commit），即不重新开启事务，查询到的结果都是一样，不会改变。只有当我们提交事务后，再次开启事务，查询到的才是这次事务现在的数据\n事务1：\t\t\t\t\t事务2：\n\tstart transaction;\t\t\tstart transaction;\n\t张三：1000,李四：1000\t\t\t张三：1000，李四：1000\n转账后：\n\t张三：500，李四：1500\t\t\t张三：1000，李四：1000\n\tcommit;\n\t（张三：500，李四：1500）\t\t张三：1000，李四：1000（其他事务已提交，但查询结果不变）\n\t\t\t\t\t\t\t\t\tcommit;\n\t\t\t\t\t\t\t\t\tstart transaction;\n\t\t\t\t\t\t\t\t\t张三：500，李四：1500（重新开启事务查询）\n\n但此时又有一个问题，当一个事务进行修改后，另一个事务中查询不到修改的记录（幻读）\n3.4 设置serializableserializable相当于锁的概念，即一个事务在操作一个表的数据时，其他事务是不可以操作这张表的。只有当这个事务结束后，其他事务才可以操作\n事务1：\t\t\t\t\t事务2：\n\tstart transaction;\t\t\tstart transaction；\n\t张三：1000,李四：1000\t\t\t等待\n转账后：\n\t张三：500，李四：1500\t\t\t等待\n\tcommit;\n\t（张三：500，李四：1500）\t\t张三：500，李四：1500（查询到）\n\n由此可见，事务隔离级别越高，效率也越低\n","slug":"BlogRepository/数据库/数据库事务隔离级别实例详解","date":"2021-09-05T06:31:33.000Z","categories_index":"数据库","tags_index":"数据库,MySQL","author_index":"凡"},{"id":"379bfe9e543db8b5badb42fb328dcff4","title":"数据库三大范式详解实例图文教程","content":"需要用到的例表：\n1. 名词概念1.1 函数依赖A –&gt; B，如果通过A属性（属性组）的值，可以确定唯一属性B的值，则称属性B依赖于A\n如：学号 --&gt; 姓名 （学号唯一确定姓名）                      1001 --&gt; 张三\n（学号，课程名称）--&gt; 分数 （学号和课程名称唯一确定分数） （1001，Java) --&gt; 89\n\n1.2 完全函数依赖A –&gt; B，如果A是一个属性组，则B属性确定需要依赖于A属性组中的所有属性值\n\n\n\n\n\n\n\n\n\n如：（学号，课程名称）–&gt; 分数 （分数需要完全依赖于学号和课程才能得出）\n1.3 部分函数依赖A – &gt; B，如果A是一个属性组，那么B属性只需要依赖A属性组中的一些值即可\n\n\n\n\n\n\n\n\n\n如：（学号，课程名称）–&gt; 姓名\n1.4 传递函数依赖A –&gt; B，B –&gt; C，则A –&gt; C。通过A属性（属性组）的值，可以确定唯一B属性的值，通过B属性的值，可以确定唯一的C属性的值，则称 C 传递依赖于 A\n\n\n\n\n\n\n\n\n\n如：学号 –&gt; 系名，系名 –&gt; 系主任，则学号 –&gt; 系主任（通过学号，可以确定唯一的系主任）\n1.5 码在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码\n\n\n\n\n\n\n\n\n\n如：该表的码为：(学号，课程名称）其中，姓名，系名，系主任，都完全依赖于学号，而分数则完全依赖于（学号，课程名称)。（学号，课程名称）被其他所有属性所完全依赖，即为该表的码\n2. 三大范式概念简述第一范式（1NF）：每一列都是不可分割的原子数据项第二范式（2NF）：在满足第一范式的前提下，表中的每一个字段都完全依赖于主键。即在1NF的基础上，消除非主属性对主码的部分函数依赖，非码属性必须完全依赖于码属性第三范式（3NF）：在满足第二范式的前提下，表中的每一列都直接依赖于主键，而不是通过其他的列来间接依赖主键。即不得传递依赖于主键，在2NF基础上，消除传递依赖\n3. 具体实现存在问题：\n\n数据冗余：姓名，系名，系主任\n添加新系时，数据不合法。\n删除张三同学的数据时，系也删除了\n\n3.1 转换为2NF，消除部分函数依赖，全为完全函数依赖\n\n\n\n\n\n\n\n\n由前面所说：姓名，系名，系主任都完全依赖于学号，而分数完全依赖于学号和课程名称，将其分为两个表\n化简：现存问题：1. 数据冗余，姓名，系名，系主任2. 添加新系时，数据不合法。3. 删除张三同学的数据时，系也删除了\n3.2 转换为3NF，消除传递函数依赖\n\n\n\n\n\n\n\n\n由前面所说，学号 –&gt; 系名，系名 –&gt; 系主任，再将其分为两个表，一共三个表\n现存问题：1. 数据冗余，姓名，系名，系主任2. 添加新系时，数据不合法。3. 删除张三同学的数据时，系也删除了\n结尾：由此，问题全部解决，同时也由1NF转换为2NF，再转换为3NF\n","slug":"BlogRepository/数据库/数据库三大范式详解实例图文教程","date":"2021-09-04T12:29:31.000Z","categories_index":"数据库","tags_index":"数据库,MySQL","author_index":"凡"},{"id":"14ee149aa3c84bbd442554199e8c600d","title":"IDEA创建子模块及 Web 项目与 Tomcat + Servlet 配置（包括 Servlet 路径模板配置）超详细图文教程","content":"1. 创建子模块（Module）1、在创建的项目中右键 New –&gt; Module2、可根据自己需求创建，这里默认选择 Java 项目，直接点击 Next3、给子模块命名，输入名字后点击 Finish4、可以看到已经在原有的项目下多了一个你所创建的子模块\n2. 配置Web项目1、在你创建的子模块右键点击 Add Framework Support\n2、选中 Web Application ，点击 OK3、可以看到在刚刚创建的子模块下多了一个web文件夹4、在 WEB-INF 目录下创建 lib 文件夹和 classes 文件夹，右键点击 New –&gt; Directory 创建文件夹5、输入 lib ，然后重复上面的的步骤创建再一个 classes 文件夹6、创建完之后可以得到如下目录\n7、右键点击刚刚创建的子模块，点击Open Module Settings8、也可以 File –&gt; Project Structure\n9、在 Modules 选择刚刚创建的子模块，点击 Path ，选择 Use module compile output path ，然后把路径修改为刚刚创建的 classes 文件夹10、点击 Dependencies ，右侧的 + 号，选择第一个 JARs or directories11、选择我们刚刚创建的 lib 文件夹，点击 OK12、选择 Jar Directory ，点击 OK\n13、可以看到多出一个选项，点击 Apply ，然后点击 OK ，保存确定\n3. 配置Tomcat1、点击 Run –&gt; Edit Configuration\n2、点击 + 号，选择 Tomcat Server –&gt; Local3、点击 Configure4、在 Tomcat Home 选择你 Tomcat 的路径，点击 OK5、可以看到下方有一个警告提示 Warning: No artifacts marked for deployment ，直接点击右边的 Fix6、会跳转到 Deployment 面板，我们将这里的默认路径 &#x2F;chapter12_war_exploded ，改为 &#x2F;chapter12 ，chapter12 为你自己创建的项目名，即把项目名后面的多余部分删掉，这样我们在浏览器中输入路径的时候只需要输入 localhost:8080&#x2F;chapter12&#x2F;文件名  就可以访问你要打开的文件 ，比较方便其实这里的路径就是你访问这个文件的映射路径。假如不改，就为默认的 &#x2F;chapter12_war_exploded ，那么访问路径为 localhost:8080&#x2F;chapter12_war_exploded&#x2F;文件名。但后面一串写起来麻烦，所以去掉，只留项目名便于输入习惯同样的，假如改为 &#x2F; ，那么访问路径就为 localhost:8080&#x2F;文件名 ，更简单，但是项目多之后不利于查看文件具体位置\n7、点击 Server 回到 Server 面板，把 After launch 选项取消，不然每次启动 Tomcat 会自动以默认浏览器打开一个默认的 index.jsp 界面，然后把下面的 On ‘Update’ action 和 On frame deactivation 选项都改为 Update classes and resource（热部署） ，点击 Apply ，然后点击 OK ，保存确定8、注意，我们每次创建一个 Web 项目，都要来这里进行部署，不然新建的 Web 项目是无法运行的，路径报错。来到 Deployment 面板，点击 + 号，选择第一个 Artifact ，会自动将你创建的 Web 项目添加进来，同样的按 3.6 把路径多余部分删掉，改为项目名，然后点击 OK ，保存确定即可。\n4. Servlet 配置1、右键点击刚刚创建的子模块，点击Open Module Setting\n2、也可以 File –&gt; Project Structure\n3、在Module选择刚刚创建的子模块，点击 Dependencies ，然后点击右侧的 + 号，选择第一个 JARs or directories4、在 Tomcat 路径中的 lib 文件夹下找到 servlet-api.jar 文件，点击 OK\n5、可以看到多出一个选项，点击 Apply ，然后点击 OK ，保存确定\n5. 配置 Servlet 路径模板1、点击 File –&gt; Setting\n2、点击 Editor –&gt; File and Code Templates3、点击 Other –&gt; Web –&gt; Java code templates –&gt; Servlet Annotated Class.java4、将这句代码修改为如下：\n@javax.servlet.annotation.WebServlet(name &#x3D; &quot;$&#123;Entity_Name&#125;&quot;,urlPatterns&#x3D;&quot;&#x2F;$&#123;Entity_Name&#125;&quot;)\n\n点击 Apply ，然后点击 OK ，保存确定结尾：至此，IDEA 子模块及有关 Web 项目相关的一系列配置已完全结束，可以开始编写 Web 项目了\n","slug":"BlogRepository/开发实践/IDEA创建子模块及 Web 项目与 Tomcat + Servlet 配置（包括 Servlet 路径模板配置）超详细图文教程","date":"2021-04-10T11:09:15.000Z","categories_index":"开发实践","tags_index":"Java,IDEA,Web","author_index":"凡"},{"id":"eff30bb7d086b3412ad27d9c98560636","title":"IntelliJ IDEA 下载安装及配置超详细图文教程","content":"1. IDEA 下载1、打开浏览器输入https://www.jetbrains.com/，进入 Jetbrains官网，点击 Developer Tools，再点击 Intellij IDEA2、点击中间的 Download，进入IDEA下载界面3、选择左边的 Ultimate 版本进行下载安装。Ultimate 版本为旗舰版，需要付费，包括完整的功能Community 版本为社区版，免费，只支持部分功能。这里我们选择左边 Ultimate 版本进行下载，然后进行激活\n2. IDEA 安装1、下载完后在本地找到该文件，双击运行 idea 安装程序2、点击 Next\n3、选择安装路径，Next4、按需求选择，点击 Next5、默认，不用改，直接点 Install，安装\n6、安装完成后，点击 Finish，也可勾选Run Intellij IDEA 再点击 Finish，会自动打开安装好的 IDEA\n3. IDEA 使用1、打开 IDEA，Don’t Send\n2、点击 Start trial点击开始试用3、点击 New Project，新建一个项目4、可以选择不同的项目类型，输入项目名，选择项目创建路径，Create5、进入 IDEA 的主界面，进行项目编写\n4. 配置见：https://blog.csdn.net/ACE_U_005A&#x2F;article&#x2F;details&#x2F;125552411\n","slug":"BlogRepository/开发工具及环境/IntelliJ IDEA 下载安装及配置使用超详细图文教程","date":"2021-03-18T10:20:48.000Z","categories_index":"开发工具及环境","tags_index":"Java,IDEA","author_index":"凡"},{"id":"6d85ccd1149a1b677fbaa270c9512e58","title":"Java JDK下载安装及环境配置超详细图文教程","content":"1. JDK下载（点击可跳过下面步骤直接进入下载界面）1、打开浏览器输入网址 https://www.oracle.com/index.html，进入Oracle官网2、在官网首页菜单栏，点击Products，在Software中找到Java，单击该选项会进入如下界面3、在界面中往下滑，可以看到如下选项，在该选项中选择Java SE，找到Oracle JDK，点击进入JDK下载界面4、在该界面可以找到各种版本的JDK，选择自己需要的版本进行下载即可。在这里本人选择JDK1.8的 X64 版本进行下载安装5、假如不确定电脑类型，可按win+r打开运行，输入msinfo32，回车确定后即可查看电脑配置信息6、确定好之后选择对应的exe文件格式，点击进行下载，点击后会弹出一个通知，同意接受，点击安装，未登录的用户可能会弹出登录界面，假如没有Oracle账号创建账号进行登录后即可下载安装\n2. JDK安装1、下载完JDK到本地后，找到该文件，双击运行JDK安装程序\n2、等待一会，进入JDK安装界面，点击下一步3、可以直接默认目录，点击下一步。也可以自定义路径，先创建一个文件夹名为 Java，再在该文件夹下创建一个文件夹为 JDK 安装目录，同时创建一个文件夹为 JRE 安装目录\n4、然后回到JDK安装界面，更改安装路径，为上述所创建的 JDK 路径，点击下一步（这里由于第一项开发工具中已经自带了 JRE，则第三项的公共 JRE 可以取消独立安装，上述创建的 JRE 文件夹也不需要了）。无其他需求，取消安装 JRE 即可5、等待一会，会进入 JRE 的安装界面，同样的更改路径，为上述所创建的 JRE 路径，更改完之后点击下一步（在上一步取消公共 JRE 安装的则不会出现下面的界面，直接到 2.6 安装完成）6、至此JDK已经安装完毕，点击关闭7、若想验证是否安装成功，可按 Win+R，输入 cmd 进入命令提示符（可参照前面的查看电脑配置信息操作），在命令提示符界面输入 java，出现如下界面即表示安装成功（未选择上面公共 JRE 独立安装的则不会有下面的显示，而为\n\n\n\n\n\n\n\n\n\n’java‘ 不是内部或外部命令，也不是可运行的程序或批处理文件\n需配置环境变量即可有下面的界面）\n3. 环境配置1、右键单击此电脑，点击属性，会出现以下设置选项，点击高级系统设置，打开Win10Win112、点击环境变量3、点击新建，变量名为 JAVA_HOME,变量值为刚刚JDK安装的路径，点击确定4、双击 path，进入界面后，点击编辑文本5、在变量值的最开头输入 %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;。不要对其他数值进行修改（由于我已经进行了配置，所以显示在了中间，第一次输入在最开头即可），假如不小心修改了其他数值，取消重新进入即可。（在前面取消安装了公共 JRE 的则只需要在变量值的最开头输入：%JAVA_HOME%\\bin; 即可）6、点击确定，全部确定退出后，依旧按 Win+R，输入 cmd 进入命令提示符界面，输入 javac，假如出现如下界面则配置成功。（这时再输入 java，则会出现 2.7 所示界面）结尾：至此，Java JDK下载安装及环境配置已完全成功\n","slug":"BlogRepository/开发工具及环境/Java JDK下载安装及环境配置超详细图文教程","date":"2021-03-15T10:51:22.000Z","categories_index":"开发工具及环境","tags_index":"Java,IDEA","author_index":"凡"}]